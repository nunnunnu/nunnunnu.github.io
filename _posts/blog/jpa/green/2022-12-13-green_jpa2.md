---
생성일: 2022-12-13
하위태그:
  - 수업과정
last_modified_at: 2023-01-20
상위태그:
  - 수업과정
title: "[국비교육학원-수업내용정리] JPA2"
category: JPA
tags:
  - jpa
  - 국비교육
  - spring
  - ORM
---
— API명세서 작성
![images](/assets/images/green/IMG-20240908151546.png)

- 회원 정보 조회시 비밀번호 빼고 조회하는 법

```java
package com.green.jpa_test.member.entity;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity(name = "member_info")
@JsonIgnoreProperties(
    value = {"pwd"}, allowSetters = true, allowGetters = false //setter는 권한허용, getter는 권한비허용. 
    //불러올때는 비번안나온다는소리
)
public class MemberInfoVO {
    //jpa가 _는 제대로 인식을 못함
    //mi_seq;mi_id;mi_pwd;mi_name;mi_nickname;mi_reg_dt;mi_status
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) //MYSQL의 AUTO_INCREMENT
    @Column(name="mi_seq") //기본키의 이름이 mi_seq임
    private Long seq; 
    
    @Column(name="mi_id")
    private String id;
    // @JsonIgnore //json형식으로 내보낼때 빠져서 나오나 입력할때도 빼고입력해야해서 적절하지않음
    @JsonProperty("pwd")
    @Column(name="mi_pwd")
    private String pwd;
    @Column(name="mi_name")
    private String name;
    @Column(name="mi_nickname")
    private String nickname;
    @Column(name="mi_reg_dt")
    private Date regDt;
    @Column(name="mi_status")
    private Integer status;
}
```

- 제품등록
    
    ```java
    package com.green.jpa_test.entity;
    
    import java.util.Date;
    
    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Entity(name="product_info")
    public class ProductInfoVo {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name="pi_seq")
        private Integer seq;
    
        @Column(name="pi_name")
        private String name;
        @Column(name="pi_price")
        private Integer price;
        @Column(name="pi_discount")
        private Double discount;
        @Column(name="pi_reg_dt")
        private Date regDt;
        @Column(name="pi_status")
        private Integer stauts;
        @Column(name="pi_stock")
        private Integer stock;
    }
    ```
    
    ```java
    package com.green.jpa_test.repository;
    
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    import com.green.jpa_test.entity.ProductInfoVo;
    
    @Repository
    public interface ProductRepository extends JpaRepository<ProductInfoVo, Long> {
        // public Long countByName(String name);
    }
    ```
    
    ```java
    @Test
    	@Transactional
    	public void productAdd(){
    		ProductInfoVo p = new ProductInfoVo();
    		p.setName("제품명");
    		p.setPrice(15000);
    		p.setDiscount(0.0);
    		p.setRegDt(new Date());
    		p.setStauts(1);
    		p.setStock(100);
    		prodRepo.save(p);
    	}
    	// @Test
    	// public void nameDupChkTest(){
    	// 	Long cnt = prodRepo.countByName("제품명");
    	// 	assertEquals(cnt, 1);
    	// } //제품이름은 동일할수도있음
    ```
    
    ```java
    package com.green.jpa_test.api;
    
    import java.util.LinkedHashMap;
    import java.util.Map;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PutMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    
    import com.green.jpa_test.entity.ProductInfoVo;
    import com.green.jpa_test.repository.ProductRepository;
    
    @RestController
    @RequestMapping("/api/product")
    public class ProductAPICountroller {
    
        @Autowired ProductRepository prodRepo;
    
        @PutMapping("/")
        public ResponseEntity<Object> addProduct(@RequestBody ProductInfoVo data){
            Map<String, Object> map = new LinkedHashMap<>();
            // if(prodRepo.countByName(data.getName())==1){
            //     map.put("status", false);
            //     map.put("message", data.getName()+"가 이미 등록되었습니다.");
            //     return new ResponseEntity<>(map, HttpStatus.NOT_ACCEPTABLE);
            // }
            prodRepo.save(data);
            map.put("status", true);
            map.put("message", "제품이 등록되었습니다.");
            return new ResponseEntity<>(map, HttpStatus.OK);
        }
    }
    ```
    
    ![images](/assets/images/green/IMG-20240908151546-1.png)]]
    
- 페이지기능
    
    ```java
    package com.green.jpa_test.repository;
    
    import java.util.List;
    
    import org.springframework.data.domain.Page;
    import org.springframework.data.domain.Pageable;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    import com.green.jpa_test.entity.ProductInfoVo;
    
    @Repository
    public interface ProductRepository extends JpaRepository<ProductInfoVo, Long> {
        // public Long countByName(String name);
        // public List<ProductInfoVo> findAll(); //DB안의 데이터 모두 조회 가능
        public Page<ProductInfoVo> findAll(Pageable pageable);
    }
    ```
    
    ```java
    @GetMapping("/list")
        public ResponseEntity<Object> getProductList(Pageable pageable){
            Map<String, Object> map = new LinkedHashMap<>();
            
            map.put("list", prodRepo.findAll(pageable));
    
            return new ResponseEntity<>(map, HttpStatus.OK);
        }
    ```
    
    ![images](/assets/images/green/IMG-20240908151546-2.png)
    
    [http://localhost:8999/api/product/list?page=0&size=10&sort=seq,desc](http://localhost:8999/api/product/list?page=0&size=10&sort=seq,desc)
    
    1페이지 10개, 최신등록순 정렬
    
- 로그인
    
    ```java
    package com.green.jpa_test.member.vo;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public class LoginVO {
        private String id;
        private String pwd;
    }
    ```
    
    ```java
    package com.green.jpa_test.member.repository;
    
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    import com.green.jpa_test.member.entity.MemberInfoVO;
    
    @Repository
    public interface MemberRepository extends JpaRepository<MemberInfoVO, Long> { //repository의 기본키 값이 Long이라 Long을 넣음
        // MemberInfoVO findById(String id);
        public Long countById(String id); //select count(*) from member_info where mi_id = ""; 자동생성해줌. 
        //이미 만들어진것은 커스텀하기까다로움
        public MemberInfoVO findByIdAndPwd(String id, String pwd); //0아니면 1로 값이 나옴.
        //member_info db의 id, pwd를 조회함. findByMi_IdAndMi_Pwd를 spring이 인식하기 못하기때문에 MemberInfo에서 이름지정을 해줌
    }
    ```
    
    ```java
    @PostMapping("/login")
        public ResponseEntity<Object> userLogin(@RequestBody LoginVO data){
            Map<String, Object> map = new LinkedHashMap<String, Object>();
            MemberInfoVO loginUser = repo.findByIdAndPwd(data.getId(),data.getPwd());
            if(loginUser ==null){
                map.put("status", false);
                map.put("message", "아이디 또는 비밀번호 오류입니다.");
                return new ResponseEntity<>(map, HttpStatus.UNAUTHORIZED);
            }
            map.put("status", true);
            map.put("message", "로그인 되었습니다.");
            return new ResponseEntity<>(map, HttpStatus.CREATED);
        }
    ```
    
    ```java
    package com.green.jpa_test.member.entity;
    
    import java.util.Date;
    
    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    
    import com.fasterxml.jackson.annotation.JsonIgnore;
    import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
    import com.fasterxml.jackson.annotation.JsonProperty;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Entity(name = "member_info")
    @JsonIgnoreProperties(
        value = {"pwd"}, allowSetters = true, allowGetters = false //setter는 권한허용, getter는 권한비허용. 
        //불러올때는 비번안나온다는소리
    )
    public class MemberInfoVO {
        //jpa가 _는 제대로 인식을 못함
        //mi_seq;mi_id;mi_pwd;mi_name;mi_nickname;mi_reg_dt;mi_status
        @Id @GeneratedValue(strategy=GenerationType.IDENTITY) //MYSQL의 AUTO_INCREMENT
        @Column(name="mi_seq") //기본키의 이름이 mi_seq임
        private Long seq; 
        
        @Column(name="mi_id")
        private String id;
        // @JsonIgnore //json형식으로 내보낼때 빠져서 나오나 입력할때도 빼고입력해야해서 적절하지않음
        @JsonProperty("pwd")
        @Column(name="mi_pwd")
        private String pwd;
        @Column(name="mi_name")
        private String name;
        @Column(name="mi_nickname")
        private String nickname;
        @Column(name="mi_reg_dt")
        private Date regDt;
        @Column(name="mi_status")
        private Integer status;
    }
    ```
    
- 한개 조회
    
    ```java
    @GetMapping("/detail")
        public ResponseEntity<Object> getProductDetail(@RequestParam Integer prodNo){
            Map<String, Object> map = new LinkedHashMap<String, Object>();
            map.put("detail", prodRepo.findBySeq(prodNo));
            return new ResponseEntity<>(map, HttpStatus.CREATED);
        }
    ```
    
    ```java
    @Repository
    public interface ProductRepository extends JpaRepository<ProductInfoVo, Long> {
        // public Long countByName(String name);
        // public List<ProductInfoVo> findAll(); //DB안의 데이터 모두 조회 가능
        public Page<ProductInfoVo> findAll(Pageable pageable);
        public ProductInfoVo findBySeq(Integer seq);
    }
    ```
    
- default 지정
    
    ```java
    		@Column(name="pi_name")
        private String name;
        @Column(name="pi_price")
        private Integer price=0;
        @Column(name="pi_discount")
        private Double discount=0.0;
        @Column(name="pi_reg_dt")
        private Date regDt= new Date();
        @Column(name="pi_status")
        private Integer stauts=1;
        @Column(name="pi_stock")
        private Integer stock=0;
    ```
    
    가장 간단한 방법
    
    ```java
    package com.green.jpa_test.product.entity;
    
    import java.util.Date;
    
    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    
    import org.hibernate.annotations.DynamicInsert;
    import org.hibernate.annotations.DynamicUpdate;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Entity(name="product_info")
    @DynamicInsert
    @DynamicUpdate
    public class ProductInfoVo {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name="pi_seq")
        private Integer seq;
    
        @Column(name="pi_name")
        private String name;
        @Column(name="pi_price")
        private Integer price;//=0;
        @Column(name="pi_discount")
        private Double discount;//=0.0;
        @Column(name="pi_reg_dt")
        private Date regDt;//= new Date();
        @Column(name="pi_status")
        private Integer stauts;//=1;
        @Column(name="pi_stock")
        private Integer stock;//=0;
    }
    ```
    
    확실한 방법
    
- 제품 삭제
    
    ```java
    package com.green.jpa_test.product.repository;
    
    import java.util.List;
    
    import org.springframework.data.domain.Page;
    import org.springframework.data.domain.Pageable;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    import com.green.jpa_test.product.entity.ProductInfoVo;
    
    @Repository
    public interface ProductRepository extends JpaRepository<ProductInfoVo, Long> {
        // public Long countByName(String name);
        // public List<ProductInfoVo> findAll(); //DB안의 데이터 모두 조회 가능
        public Page<ProductInfoVo> findAll(Pageable pageable);
        public ProductInfoVo findBySeq(Integer seq);
        public void deleteBySeq(Integer seq);
    }
    ```
    
    ```java
    @DeleteMapping("")
        @Transactional  //sql실행시 오류가 발생한다면 실행이전으로 되돌림
        public ResponseEntity<Object> deleteProduct(@RequestParam Integer prodNo){
            Map<String, Object> map = new LinkedHashMap<String, Object>();
            prodRepo.deleteBySeq(prodNo); //delete from product_info where pi_seq="";
            map.put("status", true);
            map.put("message", "제품 정보를 삭제했습니다.");
            return new ResponseEntity<>(map, HttpStatus.CREATED);
    	  }
    ```
    
- 제품 수정
    
    ```java
    package com.green.jpa_test.product.entity;
    
    import java.util.Date;
    
    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    
    import org.hibernate.annotations.DynamicInsert;
    import org.hibernate.annotations.DynamicUpdate;
    
    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Entity(name="product_info")
    @DynamicInsert
    @DynamicUpdate
    @Builder
    public class ProductInfoVo {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name="pi_seq")
        private Integer seq;
    
        @Column(name="pi_name")
        private String name;
        @Column(name="pi_price")
        private Integer price;//=0;
        @Column(name="pi_discount")
        private Double discount;//=0.0;
        @Column(name="pi_reg_dt")
        private Date regDt;//= new Date();
        @Column(name="pi_status")
        private Integer stauts;//=1;
        @Column(name="pi_stock")
        private Integer stock;//=0;
    }
    ```
    
    Builder 추가
    
    save시 기본값이 없이 세팅되면 insert, 기본값이 있으면 update
    
    ```java
    @PatchMapping("/update/{type}")
        @Transactional  //sql실행시 오류가 발생한다면 실행이전으로 되돌림
        public ResponseEntity<Object> updateProduct(
            @RequestParam Integer prodNo, 
            @PathVariable String type,
            @RequestParam String value    
        ){
            Map<String, Object> map = new LinkedHashMap<String, Object>();
            ProductInfoVo data = prodRepo.findBySeq(prodNo);
            if(data==null){
                map.put("status", false);
                map.put("message", "해당 제품이 존재하지 않습니다. 제품번호를 확인해주세요.");
                return new ResponseEntity<>(map, HttpStatus.BAD_REQUEST);
            }
            if(type.equals("name")){ 
                data.setName(value);
            }else if(type.equals("price")){
                data.setPrice(Integer.parseInt(value));
            }else if(type.equals("discount")){
                data.setDiscount(Double.parseDouble(value));
            }else if(type.equals("regDt")){
                SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmss");
                try{data.setRegDt(format.parse(value));}
                catch(Exception e){e.printStackTrace();}
                
            }else if(type.equals("status")){
                data.setStauts(Integer.parseInt(value));
                
            }else if(type.equals("stock")){
                data.setStock(Integer.parseInt(value));
                
            }else{
                map.put("status", false);
                map.put("message", "타입이 잘못되었습니다. {name, price, discount, regDt}");
                return new ResponseEntity<>(map, HttpStatus.BAD_REQUEST);
            }
            prodRepo.save(data);
            map.put("status", true);
            map.put("message", "제품 정보를 수정했습니다.");
            return new ResponseEntity<>(map, HttpStatus.CREATED);
        }
    ```
    
    [http://localhost:8999/api/product/update/stock?prodNo=44&value=100](http://localhost:8999/api/product/update/stock?prodNo=44&value=100)
    
    주소예시
    
      
    

---

### todolist

— rest client 사용법

![images](/assets/images/green/IMG-20240908151546-3.png)

파일 생성 후

![images](/assets/images/green/IMG-20240908151547.png)

작성 후 send Request 또는 ctrl+alt+R 누르면

![images](/assets/images/green/IMG-20240908151547-1.png)

이런식으로 뜸

— 파일

파일 저장 경로(꼭 이렇게해야하는건아니나 이걸 추천)

![images](/assets/images/green/IMG-20240908151547-2.png)

application.properties에서 관리함.

![images](/assets/images/green/IMG-20240908151547-3.png)

파일 경로 지정. 사용자 정의 설정값(여기 주석 #이라서 사진 그대로 쓰면 안됨;;. 주소치고 띄어쓰기해도 오류남.)

- 파일 업로드 메소드

```java
package com.jh_project.todo.todoList.file.api;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileAPIController {
    // 파일 업로드, 다운로드는 어느 프로젝프든 거의 동일함. 복붙추천
    @Value("${file.image.todo}") String todo_img_path; //springframework.beans임
    @Value("${file.image.member}") String member_img_path; 
    //이것도 DI임. 이미지 파일의 경로가 바뀌어도 application.properties만 고쳐주면 됨

    @PutMapping("/{type}/upload") //todo이미지를 올릴것인지 file이미지를 올릴것인지
    public ResponseEntity<Object> putImageUpload(
        @PathVariable String type,
        @RequestPart MultipartFile file //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함
        ){
            Map<String, Object> map = new LinkedHashMap<>();
            System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력
            //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스
            Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.
            if(type.equals("todo")){
                folderLocation = Paths.get(todo_img_path);
                
            }else if(type.equals("member")){
                folderLocation = Paths.get(member_img_path);
            }else{
                map.put("status", false);
                map.put("message", "타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload");
                return new ResponseEntity<>(map, HttpStatus.BAD_REQUEST);
            }
            Path targerFile = folderLocation.resolve(file.getOriginalFilename()); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성
            try{
                //Files는 파일 처리에 대한 유틸리티 클래스
                //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비
                //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.
                Files.copy(file.getInputStream(), targerFile, StandardCopyOption.REPLACE_EXISTING); 
            }catch(Exception e){e.printStackTrace();}
            return new ResponseEntity<>(map, HttpStatus.OK);
        } //파일 업로드 메소드
```

postman에서 key File로 만들고 file이라고 파라미터 적어주고(메소드의 파라미터 변수명과 동일하게 작성) value에 파일을 첨부

![](/assets/images/green/IMG-20240908151547.mp4)
<video controls width="640" height="360"> <source src="/assets/images/green/IMG-20240908151547.mp4" type="video/mp4"></video>

send하면 위에 지정해둔 폴더에 파일이 저장된걸 확인할 수 있음

- 파일 업로드 수정버전
    
    ```java
    @PutMapping("/{type}/upload") //todo이미지를 올릴것인지 file이미지를 올릴것인지
        public ResponseEntity<Object> putImageUpload(
            @PathVariable String type,
            @RequestPart MultipartFile file, //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함
            @RequestParam Long seq 
            ){
                Map<String, Object> map = new LinkedHashMap<>();
                System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력
                //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스
                Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.
                if(type.equals("todo")){
                    folderLocation = Paths.get(todo_img_path);
                    
                }else if(type.equals("member")){
                    folderLocation = Paths.get(member_img_path);
                }else{
                    map.put("status", false);
                    map.put("message", "타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload");
                    return new ResponseEntity<>(map, HttpStatus.BAD_REQUEST);
                }
    
                String originFileName = file.getOriginalFilename();
                String[] split = originFileName.split(("\\.")); //.을 기준으로 나눔
                String ext = split[split.length-1]; //확장자
                String fileName = null;
                for(int i=0;i<split.length-1;i++){
                    fileName += split[i]; //원래 split[i]+"." 이렇게 해줘야함
                }
                String saveFileName = type+"_"; //보통 원본 이름을 저장하는것이아니라 시간대를 입력함
                Calendar c = Calendar.getInstance();
                saveFileName+=c.getTimeInMillis()+"."+ext; // todo_161310135.png 이런식으로 저장됨
    
    
                Path targerFile = folderLocation.resolve(saveFileName); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성
                try{
                    //Files는 파일 처리에 대한 유틸리티 클래스
                    //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비
                    //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.
                    Files.copy(file.getInputStream(), targerFile, StandardCopyOption.REPLACE_EXISTING); 
                }catch(Exception e){e.printStackTrace();}
                return new ResponseEntity<>(map, HttpStatus.OK);
            } //파일 업로드 메소드
    ```

	![images](/assets/images/green/20240908151956.png)   
    파일이름 member_1671076931157으로 저장됨
    
- url접속시 파일다운 메소드

```java
@GetMapping("/image/{filename}")
        public ResponseEntity<Resource> putImageUpload( //core.io.Resource import해야함
        @PathVariable String filename, HttpServletRequest request
        ){
            //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스
            Path folderLocation = Paths.get(todo_img_path); //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.
            Path targerFile = folderLocation.resolve(filename); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성
            //다운로드 가능한 형태로 변환하기 위해 Resource객체 생성함
            Resource r = null; 
            try{
                //일반파일 -> Url로 첨부 가능한 형태로 변환
                r = new UrlResource(targerFile.toUri());
            }catch(Exception e){e.printStackTrace();} //fileNotFoundException이 많이 나옴
            //첨부된 파일의 타입을 저장하기 위한 변수 생성
            String contentType = null;
            try{
                //첨부할 파일의 타입정보 산출
                contentType =  request.getServletContext().getMimeType(r.getFile().getAbsolutePath()); 
                if(contentType == null){ //산출한 파일의 타입이 null이면 
                    //일반 파일로 처리
                    contentType = "application/octet-stream"; //파일종류에따라서 동작이 다름. 만약 contentType이 안들어오면 그냥 다운로드함.
                }
            }catch(Exception e){e.printStackTrace();}
            return ResponseEntity.ok() // 200 OK가 나옴
                .contentType(MediaType.parseMediaType(contentType)) //산출한 타입을 응답에 맞는 형태로 변환
                //내보낼 내용의 타입을 설정(파일), 
                // attachment; filename*=\""+r.getFilename()+"\" - 요청한 쪽에서 다운로드한 파일의 이름을 결정(원본 파일 이름 그대로 결정)
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename*=\""+r.getFilename()+"\"")
                .body(r); //변환된 파일을 ResponseEntity에 추가
        }
```

[http://localhost:9988/image/Fj8pPNYaAAAoWja.jpg](http://localhost:9988/image/Fj8pPNYaAAAoWja.jpg) 아래 주소로 가면 파일 다운됨. 파일이름을 확장자까지 정확하게 써줘야함.

- 멤버
    
    ```java
    package com.jh_project.todo.member.entity;
    
    import java.util.Date;
    
    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    
    import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
    import com.fasterxml.jackson.annotation.JsonProperty;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Entity(name = "member_info")
    @JsonIgnoreProperties(
        value = {"pwd"}, allowGetters = false, allowSetters = true
    )
    public class MemberInfoEntity {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name="mi_seq")    private Long seq;
    
        @Column(name="mi_email")  private String email;
        @JsonProperty("pwd")
        @Column(name="mi_pwd")    private String pwd;
        @Column(name="mi_name")   private String name;
        @Column(name="mi_birth")  private Date birth;
        @Column(name="mi_reg_dt") private Date regDt;
    }
    ```
    
    ```java
    package com.jh_project.todo.member.repository;
    
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    import com.jh_project.todo.member.entity.MemberInfoEntity;
    @Repository
    public interface memberRepository extends JpaRepository<MemberInfoEntity, Long> {
        public Integer countByEmail(String email);
        public MemberInfoEntity findByEmailAndPwd(String email, String pwd);
        
    }
    ```
    
    ```java
    package com.jh_project.todo.member.data;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public class LoginVO {
        private String email;
        private String pwd;    
    }
    ```
    
    ```java
    package com.jh_project.todo.member.service;
    
    import java.util.LinkedHashMap;
    import java.util.Map;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.stereotype.Service;
    
    import com.jh_project.todo.member.data.LoginVO;
    import com.jh_project.todo.member.entity.MemberInfoEntity;
    import com.jh_project.todo.member.repository.memberRepository;
    import com.jh_project.todo.utils.AESAlgorith;
    
    @Service
    public class MemberService {
        @Autowired memberRepository m_repo;
        
        public Map<String, Object> addMember(MemberInfoEntity data){
            Map<String, Object> resultMap = new LinkedHashMap<String, Object>();
            if(m_repo.countByEmail(data.getEmail())==1){
                resultMap.put("status", false);
                resultMap.put("message", data.getEmail()+"은/는 이미 가입된 이메일입니다.");
                resultMap.put("code", HttpStatus.BAD_REQUEST);
            }else{
                try{
                    String encPwd = AESAlgorith.Encrypt(data.getPwd());
                    data.setPwd(encPwd);
                }catch(Exception e){e.printStackTrace();}
    
                resultMap.put("status", true);
                resultMap.put("message", "회원이 등록되었습니다.");
                resultMap.put("code", HttpStatus.CREATED);
                m_repo.save(data);
            }
            return resultMap;
        }
        public Map<String, Object> loginMember(LoginVO data){
            Map<String, Object> resultMap = new LinkedHashMap<String, Object>();
            MemberInfoEntity loginUser = null;
            try{
                loginUser = m_repo.findByEmailAndPwd(data.getEmail(), AESAlgorith.Encrypt(data.getPwd()));
            }catch(Exception e){e.printStackTrace();}
            if(loginUser==null){
                resultMap.put("status", false);
                resultMap.put("message", "로그인 실패. 이메일 또는 비밀번호를 확인해주세요.");
                resultMap.put("code", HttpStatus.BAD_REQUEST);
            }else{
                resultMap.put("status", true);
                resultMap.put("message", "로그인 성공");
                resultMap.put("code", HttpStatus.ACCEPTED);
                resultMap.put("loginUser", loginUser);
            }
            return resultMap;
        }
    }
    ```
    
    ```java
    package com.jh_project.todo.member.api;
    
    import java.util.Map;
    
    import javax.servlet.http.HttpSession;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.PutMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    
    import com.jh_project.todo.member.data.LoginVO;
    import com.jh_project.todo.member.entity.MemberInfoEntity;
    import com.jh_project.todo.member.service.MemberService;
    
    @RestController
    @RequestMapping("/api/member")
    public class MemberAPIController {
        @Autowired MemberService mService;
        @PutMapping("/join")
        public ResponseEntity<Object> memberJoin(@RequestBody MemberInfoEntity data){
            Map<String, Object> resultMap = mService.addMember(data);
            return new ResponseEntity<Object>(resultMap, (HttpStatus)resultMap.get("code"));
        }
        @PostMapping("/login")
        public ResponseEntity<Object> memberLogin(@RequestBody LoginVO data, HttpSession session){
            Map<String, Object> resultMap = mService.loginMember(data);
            session.setAttribute("loginUser", resultMap.get("loginUser")); 
            //실패하면 null이라 로그인 안됨.session의 값이 채워지면 로그인상태임. 모든 코드에서 사용가능(Html도 마찬가지임)
            //프론트에서는 사용못함!!
            return new ResponseEntity<>(resultMap, (HttpStatus)resultMap.get("code"));
        }
    }
    ```
    
- 투두
    
    ```java
    package com.jh_project.todo.todoList.entity;
    
    import java.util.Date;
    
    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data@AllArgsConstructor@NoArgsConstructor
    @Entity(name = "todo_info")
    public class TodoInfoEntity {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = "ti_seq") private Long seq;
        @Column(name = "ti_mi_seq") private Long miSeq;
        @Column(name = "ti_content") private String content;
        @Column(name = "ti_status") private Integer status;
        @Column(name = "ti_start_dt") private Date startDt;
        @Column(name = "ti_end_dt") private Date endDt;
    
        
    }
    ```
    
    ```java
    package com.jh_project.todo.todoList.repository;
    
    import java.util.Date;
    import java.util.List;
    
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    import com.jh_project.todo.todoList.entity.TodoInfoEntity;
    @Repository
    public interface TodoRepository extends JpaRepository<TodoInfoEntity, Long> {
        public List<TodoInfoEntity> findAllByMiSeq(Long miSeq);
        public TodoInfoEntity findBySeq(Long seq);
        public void deleteBySeqAndMiSeq(Long seq, Long miSeq);
        public TodoInfoEntity findBySeqAndMiSeq(Long seq, Long miSeq);
        //select * from todo_info where ti_end_dt between [start] and [end] and ti_mi_seq=[miSeq]
        public List<TodoInfoEntity> findByEndDtBetweenAndMiSeq(Date start, Date end, Long miSeq);
    }
    ```
    
    ```java
    package com.jh_project.todo.todoList.service;
    
    import java.text.SimpleDateFormat;
    import java.util.Date;
    import java.util.LinkedHashMap;
    import java.util.List;
    import java.util.Map;
    
    import javax.servlet.http.HttpSession;
    import javax.transaction.Transactional;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.stereotype.Service;
    
    import com.jh_project.todo.member.entity.MemberInfoEntity;
    import com.jh_project.todo.todoList.entity.TodoInfoEntity;
    import com.jh_project.todo.todoList.repository.TodoRepository;
    
    @Service
    public class TodoInfoService {
        @Autowired TodoRepository t_repo;
    
        public Map<String, Object> addTodoList(TodoInfoEntity data, HttpSession session){
            Map<String, Object> map = new LinkedHashMap<String, Object>();
            MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute("loginUser");
            if(loginUser==null){
                map.put("status", false);
                map.put("message", "로그인이 필요합니다.");
                map.put("code", HttpStatus.FORBIDDEN);
            }else{
                data.setMiSeq(loginUser.getSeq());
                t_repo.save(data);
                map.put("status", true);
                map.put("message", "일정이 추가되었습니다.");
                map.put("code", HttpStatus.CREATED);
            }
            return map;
        }
        public Map<String, Object> getTodoList(HttpSession session){
            Map<String, Object> map = new LinkedHashMap<>();
            MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute("loginUser");
            if(loginUser==null){
                map.put("status", false);
                map.put("message", "로그인이 필요합니다.");
                map.put("code", HttpStatus.FORBIDDEN);
            }else{
                map.put("list", t_repo.findAllByMiSeq(loginUser.getSeq()));
                map.put("status", true);
                map.put("message", "조회하였습니다.");
                map.put("code", HttpStatus.OK);
                
            }
            return map;
        }
        public Map<String, Object> updateTodoStatus(Integer status, Long seq){
            Map<String, Object> map = new LinkedHashMap<>();
            TodoInfoEntity todo = t_repo.findBySeq(seq);
            if(todo==null){
                map.put("status", false);
                map.put("message", "잘못된 todo번호입니다.");
                map.put("code", HttpStatus.FORBIDDEN);
            }else{
                todo.setStatus(status);
                t_repo.save(todo);
                map.put("status", true);
                map.put("message", "todo 상태가 변경되었습니다.");
                map.put("code", HttpStatus.OK);
            }
            
            return map;
        }
        public Map<String, Object> updateTodoContent(String content, Long seq){
            Map<String, Object> map = new LinkedHashMap<>();
            TodoInfoEntity todo = t_repo.findBySeq(seq);
            if(todo==null){
                map.put("status", false);
                map.put("message", "잘못된 todo번호입니다.");
                map.put("code", HttpStatus.FORBIDDEN);
            }else{
                todo.setContent(content);
                t_repo.save(todo);
                map.put("status", true);
                map.put("message", "todo 상태가 변경되었습니다.");
                map.put("code", HttpStatus.OK);
            }
            return map;
        }
        @Transactional
        public Map<String, Object> deleteTodo(Long seq, HttpSession session){
            Map<String, Object> map = new LinkedHashMap<>();
            MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute("loginUser");
            if(loginUser==null){
                map.put("status", false);
                map.put("message", "로그인 후 사용가능한 기능입니다.");
                map.put("code", HttpStatus.FORBIDDEN);
                return map;
            }
            TodoInfoEntity todo = t_repo.findBySeqAndMiSeq(seq, loginUser.getSeq());
            if(todo==null){
                map.put("status", false);
                map.put("message", "잘못된 Todo 번호입니다..");
                map.put("code", HttpStatus.FORBIDDEN);
            }else{
                t_repo.deleteBySeqAndMiSeq(seq, loginUser.getSeq());
                map.put("status", true);
                map.put("message", "todo가 삭제되었습니다.");
                map.put("code", HttpStatus.OK);
            }
            return map;
        }
        public Map<String, Object> selectTodoListByTrem(HttpSession session, String start, String end){
            Map<String, Object> map = new LinkedHashMap<>();
            MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute("loginUser");
            if(loginUser==null){
                map.put("status", false);
                map.put("message", "로그인 후 사용가능한 기능입니다.");
                map.put("code", HttpStatus.FORBIDDEN);
                return map;
            }
            SimpleDateFormat format = new SimpleDateFormat("yyMMdd");
            Date startDt=null;
            Date endDt=null;
            try{
                startDt = format.parse(start);
                endDt = format.parse(end);
            }catch(Exception e){
                map.put("status", false);
                map.put("message", "날짜 형식을 확인해주세요(yyMMdd ex:221214)");
                map.put("code", HttpStatus.BAD_REQUEST);
                return map;
                
            }
            List<TodoInfoEntity> list = t_repo.findByEndDtBetweenAndMiSeq(startDt, endDt, loginUser.getSeq());
            if(list.size()==0){
                map.put("status", false);
                map.put("message", "일치하는 Todo가 없습니다. 날짜를 확인해주세요");
                map.put("code", HttpStatus.FORBIDDEN);
            }else{
                map.put("list", list);
                map.put("status", true);
                map.put("message", "조회완료되었습니다.");
                map.put("code", HttpStatus.OK);
            }
            return map;
        }
    }
    ```
    
    ```java
    package com.jh_project.todo.todoList.api;
    
    import java.text.SimpleDateFormat;
    import java.util.LinkedHashMap;
    import java.util.Map;
    
    import javax.servlet.http.HttpSession;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.DeleteMapping;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PatchMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.PutMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    
    import com.jh_project.todo.todoList.entity.TodoInfoEntity;
    import com.jh_project.todo.todoList.service.TodoInfoService;
    
    import net.bytebuddy.agent.builder.AgentBuilder.FallbackStrategy.Simple;
    
    @RestController
    @RequestMapping("/api/todo")
    public class TodoAPIController {
        @Autowired TodoInfoService tService;
        @PutMapping("/add")
        public ResponseEntity<Object> addTodo(@RequestBody TodoInfoEntity data, HttpSession session){
            Map<String, Object> map = tService.addTodoList(data, session);
            
            return new ResponseEntity<>(map, (HttpStatus)map.get("code"));
        }
        @GetMapping("/list")
        public ResponseEntity<Object> getTodoList(HttpSession session){
            Map<String, Object> map = tService.getTodoList(session);
            return new ResponseEntity<>(map, (HttpStatus)map.get("code"));
        }
        @PatchMapping("/update/{type}")
        public ResponseEntity<Object> updateTodo(
            @RequestParam Long seq,
            @PathVariable String type,
            @RequestParam String value
        ){
            if(type.equals("status")){
                Map<String, Object> map = tService.updateTodoStatus(Integer.parseInt(value), seq);
                return new ResponseEntity<>(map, (HttpStatus)map.get("code"));
            }else if(type.equals("content")){
                Map<String, Object> map = tService.updateTodoContent(value, seq);
                return new ResponseEntity<>(map, (HttpStatus)map.get("code"));
            }else{
                Map<String, Object> map = new LinkedHashMap<>();
                map.put("stauts", false);
                map.put("message", "type은 status, content 둘 중 한가지만 가능합니다");
                return new ResponseEntity<>(map, HttpStatus.BAD_REQUEST);
                
            }
        }
        // @DeleteMapping("/delete")
        // @Transactional
        // public ResponseEntity<Object> deleteTodo(@RequestParam Long seq, @RequestParam Long miSeq){
        //     Map<String, Object> map = tService.deleteTodo(seq, miSeq);
        //     return new ResponseEntity<>(map, (HttpStatus)map.get("code"));
        // }
        @DeleteMapping("/delete")
        public ResponseEntity<Object> deleteTodo(@RequestParam Long seq, HttpSession session){
            Map<String, Object> map = tService.deleteTodo(seq, session);
            return new ResponseEntity<>(map, (HttpStatus)map.get("code"));
        }
        @GetMapping("/list/term")
        public ResponseEntity<Object> getDetailTodoList(HttpSession session, String start, String end){
            Map<String, Object> map = tService.selectTodoListByTrem(session, start, end);
            return new ResponseEntity<>(map, (HttpStatus)map.get("code"));
        }
        
    }
    ```
    
    ```HTML
    ###제품 추가
    PUT http://localhost:9988/api/member/join HTTP/1.1
    content-type : application/json
    
    {
        "email" : "user002@service.com",
        "pwd" : "1234",
        "name" : "사용자2",
        "birth" : "2022-12-14T00:00:00",
        "regDt" : "2022-12-14T00:00:00"
    }
    ###로그인
    POST http://localhost:9988/api/member/login HTTP/1.1
    content-type : application/json
    
    {
        "email" : "user001@service.com",
        "pwd" : "1234"
    }
    
    ##\#Todo 등록
    PUT http://localhost:9988/api/todo/add HTTP/1.1
    content-type : application/json
    
    {
        "content" : "Todo5",
        "status" : 1,
        "startDt" : "2022-12-30T00:00:00",
        "endDt" : "2022-12-30T00:00:00"
    }
    ###내 TodoList 조회
    GET http://localhost:9988/api/todo/list HTTP/1.1
    
    ##\#Todo 내용 수정
    PATCH  http://localhost:9988/api/todo/update/content?&value=sssss&seq=1 HTTP/1.1
    ##\#Todo 상태 변경
    PATCH  http://localhost:9988/api/todo/update/status?&value=2&seq=1 HTTP/1.1
    ##\#Todo 삭제
    DELETE http://localhost:9988/api/todo/delete?seq=3 HTTP/1.1
    ##\#Todo 날짜범위 조회
    GET http://localhost:9988/api/todo/list/term?start=221226&end=221230 HTTP/1.1
    ```
    
    restClient 사용 링크
    
- 파일관리
    
    ```java
    package com.jh_project.todo.todoList.entity;
    
    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Entity(name = "todo_images_info")
    public class TodoImageEntity {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = "tii_seq")       private Long seq;
        @Column(name = "tii_ti_seq")    private Long tiSeq;
        @Column(name = "tii_file_name") private String fileName;
        @Column(name = "tii_uri")       private String uri;
    }
    ```
    
    ```java
    package com.jh_project.todo.member.entity;
    
    import javax.persistence.Column;
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Entity(name = "member_images_info")
    public class MemberImageEntity {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = "mii_seq")       private Long seq;
        @Column(name = "mii_mi_seq")    private Long miSeq;
        @Column(name = "mii_file_name") private String fileName;
        @Column(name = "mii_uri")       private String uri;
    }
    ```
    
    ```java
    package com.jh_project.todo.member.repository;
    
    import java.util.List;
    
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    import com.jh_project.todo.member.entity.MemberImageEntity;
    
    @Repository
    public interface MemberImageRepository extends JpaRepository<MemberImageEntity, Long> {
        public List<MemberImageEntity> findByMiSeq(Long miSeq);
        //select * from todo_image_info where tii_uri = uri order by tii_seq desc limit 1;
        //가장 나중에 입력된 이미지를 가져옴.
        public List<MemberImageEntity> findTopByUriOrderBySeqDesc(String uri);
        
    }
    ```
    
    ```java
    package com.jh_project.todo.todoList.repository;
    
    import java.util.List;
    
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    import com.jh_project.todo.todoList.entity.TodoImageEntity;
    
    @Repository
    public interface TodoImageRepository extends JpaRepository<TodoImageEntity, Long> {
        public List<TodoImageEntity> findByTiSeq(Long tiSeq);
        //select * from todo_image_info where tii_uri = uri order by tii_seq desc limit 1;
        //가장 나중에 입력된 이미지를 가져옴.
        public List<TodoImageEntity> findTopByUriOrderBySeqDesc(String uri);
    }
    ```
    
    ```java
    @Autowired TodoImageRepository tiRepo;
    
        public Map<String, Object>  addTodoImage(TodoImageEntity data, Long tiSeq){
            Map<String, Object> map = new LinkedHashMap<String, Object>();
            data.setTiSeq(tiSeq);
            tiRepo.save(data);
            map.put("status", true);
            map.put("message", "이미지가 저장되었습니다.");
            map.put("code", HttpStatus.OK);
            return map;
        }
    ```
    
    ```java
    @Autowired MemberImageRepository mi_repo;
        
        public Map<String, Object>  addMemberImage(MemberImageEntity data, Long miSeq){
            Map<String, Object> map = new LinkedHashMap<String, Object>();
            data.setMiSeq(miSeq);
            mi_repo.save(data);
            map.put("status", true);
            map.put("message", "이미지가 저장되었습니다.");
            map.put("code", HttpStatus.OK);
            return map;
        }
        public String getFileNameByUri(String uri){
            List<MemberImageEntity> data = mi_repo.findTopByUriOrderBySeqDesc(uri);
            return data.get(0).getFileName();
        }
    ```
    
    ```java
    package com.jh_project.todo.todoList.file.api;
    
    import java.net.URLEncoder;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.StandardCopyOption;
    import java.util.Calendar;
    import java.util.LinkedHashMap;
    import java.util.Map;
    
    import javax.servlet.http.HttpServletRequest;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.core.io.Resource;
    import org.springframework.core.io.UrlResource;
    import org.springframework.http.HttpHeaders;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.MediaType;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.PutMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RequestPart;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.multipart.MultipartFile;
    
    import com.jh_project.todo.member.entity.MemberImageEntity;
    import com.jh_project.todo.member.service.MemberService;
    import com.jh_project.todo.todoList.entity.TodoImageEntity;
    import com.jh_project.todo.todoList.service.TodoInfoService;
    
    @RestController
    public class FileAPIController {
        // 파일 업로드, 다운로드는 어느 프로젝프든 거의 동일함. 복붙추천
        @Value("${file.image.todo}") String todo_img_path; //springframework.beans임
        @Value("${file.image.member}") String member_img_path;
        //이것도 DI임. 이미지 파일의 경로가 바뀌어도 application.properties만 고쳐주면 됨
        @Autowired TodoInfoService tService;
        @Autowired MemberService mService;
    
        @PutMapping("/{type}/upload") //todo이미지를 올릴것인지 file이미지를 올릴것인지
        public ResponseEntity < Object > putImageUpload(
            @PathVariable String type,
            @RequestPart MultipartFile file, //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함
            @RequestParam Long seq
        ) {
            Map < String, Object > map = new LinkedHashMap < > ();
            System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력
            //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스
            Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.
            if (type.equals("todo")) {
                folderLocation = Paths.get(todo_img_path);
    
            } else if (type.equals("member")) {
                folderLocation = Paths.get(member_img_path);
            } else {
                map.put("status", false);
                map.put("message", "타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload");
                return new ResponseEntity < > (map, HttpStatus.BAD_REQUEST);
            }
            String originFileName = file.getOriginalFilename();
            String[] split = originFileName.split(("\\.")); //.을 기준으로 나눔
            String ext = split[split.length - 1]; //확장자
            String fileName = "";
            for (int i = 0; i < split.length - 1; i++) {
                fileName += split[i]; //원래 split[i]+"." 이렇게 해줘야함
            }
            String saveFileName = type + "_"; //보통 원본 이름을 저장하는것이아니라 시간대를 입력함
            Calendar c = Calendar.getInstance();
            saveFileName += c.getTimeInMillis() + "." + ext; // todo_161310135.png 이런식으로 저장됨
    
            Path targetFile = folderLocation.resolve(saveFileName); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성
            try {
                //Files는 파일 처리에 대한 유틸리티 클래스
                //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비
                //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.
                Files.copy(file.getInputStream(), targetFile, StandardCopyOption.REPLACE_EXISTING);
            } catch (Exception e) {
                e.printStackTrace();
            }
            if (type.equals("todo")) {
                TodoImageEntity data = new TodoImageEntity();
                data.setFileName(saveFileName);
                data.setUri(fileName);
                tService.addTodoImage(data, seq);
            } else if (type.equals("member")) {
                MemberImageEntity data = new MemberImageEntity();
                data.setFileName(saveFileName);
                data.setUri(fileName);
                mService.addMemberImage(data, seq);
    
            }
            return new ResponseEntity < > (map, HttpStatus.OK);
        } //파일 업로드 메소드
    
        @GetMapping("/images/{type}/{uri}")
        public ResponseEntity getImage(
            @PathVariable String uri, HttpServletRequest request,
            @PathVariable String type
        ) throws Exception {
            // todo_img_path 문자열로부터 실제 폴더 경로를 가져온다. 
            Path folderLocation = null;
            if (type.equals("todo")) {
                folderLocation = Paths.get(todo_img_path);
            } else if (type.equals("member")) {
                folderLocation = Paths.get(member_img_path);
            }
            String filename = null;
            if (type.equals("todo")) {
                filename = tService.getFileNameByUri(uri);
            } else if (type.equals("member")) {
                filename = mService.getFileNameByUri(uri);
            }
            String[] split = filename.split("\\.");
            String ext = split[split.length - 1];
            String exportName = uri + "." + ext;
            // 내보낼 파일의 이름을 만든다. 
            // 폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로를 만든다. 
            Path targetFile = folderLocation.resolve(filename);
            // 다운로드 가능한 형태로 변환하기 위한 Resource 객체 생성 
            Resource r = null;
            try {
                // 일반파일 -> Url로 첨부 가능한 형태로 변환 
                r = new UrlResource(targetFile.toUri());
            } catch (Exception e) {
                e.printStackTrace();
            }
            // 첨부된 파일의 타입을 저장하기위한 변수 생성 
            String contentType = null;
            try {
                // 첨부할 파일의 타입 정보 산출 
                contentType = request.getServletContext().getMimeType(r.getFile().getAbsolutePath());
                // 산출한 파일의 타입이 null 이라면 
                if (contentType == null) {
                    // 일반 파일로 처리한다. 
                    contentType = "application/octet-stream";
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            return ResponseEntity.ok()
                // 응답의 코드를 200 OK로 설정하고 
                // 산출한 타입을 응답에 맞는 형태로 변환 
                .contentType(MediaType.parseMediaType(contentType))
                // 내보낼 내용의 타입을 설정 (파일), 
                // attachment; filename*=\""+r.getFilename()+"\" 요청한 쪽에서 다운로드 한 
                // 파일의 이름을 결정 
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + URLEncoder.encode(exportName, "UTF-8") + "\"")
                .body(r);
            // 변환된 파일을 ResponseEntity에 추가 }
    
    
    
        }
    }
    ```