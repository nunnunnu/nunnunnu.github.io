---
생성일: 2022-12-25
하위태그:
  - 김영한 자바 ORM 표준 JPA
last_modified_at: 2023-09-03
상위태그:
  - 김영한의 스프링부트/JPA 실무 로드맵
category: JPA
tags:
  - 김영한자바ORM표준JPA
  - jpa
  - ORM
title: "[김영한 자바 ORM 표준 JPA] 영속성 관리"
layout:
---
### 영속성 컨텍스트

- JPA를 이해하는데 가장 중요한 용어
- “엔티티를 영구 저장하는 환경”
- EntityManager.persist(entity) - DB에 저장하는 것이 아니라 영속성 컨텍스트에 저장함
- 논리적인 개념(눈에보이지 않음)
- 엔티티 메니저를 통해서 영속성 컨텍스트에 접근
- 엔티티의 생명주기
    - 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 - em.persist 하기 전 entity
    - 영속(managed) : 영속성 컨텍스트에 관리되는 상태 - em.persist 한 상태 or em.find한 상(DB저장상태아님. 1차 캐시에 저장된상태)
    - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태. 영속성 컨텍스트가 제공하는 기능을 사용하지 못함.(더이상 JPA가 관리하지 않음.)
        - em.detach(entity) : 특정 엔티티만 준영속 상태로 전환.
        - em.clear() : 영속성 컨텍스트를 완전히 초기화
        - em.close() : 영속성 컨텍스트를 종
    - 삭제(removed) : 삭제된 상태 - em.remove(entity)

→ em.persist단계에서 entity가 1차캐시에 저장됨. 이후 조회할때 DB접근 필요없이 1차캐시만 조회하면 되서 효율적임. 그러나 1차캐시에서 찾지못한다면 DB를 조회해서 1차캐시를 재로딩?함

이렇게 1차캐시에서 조회해오기때문에 각 두 변수에 같은 조건으로 조회를 한다면 동일성 비교를 했을때 true가 나옴

em.persist(entity)를 하면 1차 캐시에 entity가 저장되고 insert SQL이 쓰기지연 저장소에 저장됨 → 이 후 transaction.commit()을 하면 DB에 쓰기지연 저장소에 저장되어있던 SQL문이 flush됨

![images](/assets/images/김영한ORM/IMG-20240908184828.png)

위 처럼 수정해주면 변경 값을 DB에 자동으로 수정해줌. 변경감지기능이 있어서 따로 DB를 수정해줄 필요가 없음!!! 1차 캐시에서 entity의 초기값을 스냅샷으로 저장해뒀다가 스냅샷과 entity를 비교해서 다른게 있다면 DB를 수정함. 삭제도 마찬가지로 1차캐시에서 지워지면 DB도 지워짐

- 플러시 : 영속성 컨텍스트의 변경내용(쓰기지연 저장소)을 데이터베이스에 반영(DB 바로 반영)
    - em.flush() - 직접 호출
    - 트랜잭션 커밋 - 플러시 자동 호출
    - JPQL 쿼리 실행 - 플러시 자동 호출(DB반영 안된상태에서 SQL문을 날리면 오류발생가능성있음)
    - 영속성 컨텍스트를 비우지는 않음
    - 영속성 컨텍스트의 변경내용을 DB에 동기화
    - 트랜잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화하면

❗1차캐시는 고객이 10명이 접속하면 10개가 생김. 성능상 이점이 그렇게 크지는 않