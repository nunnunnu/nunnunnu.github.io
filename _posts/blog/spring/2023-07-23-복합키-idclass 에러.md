---
title: Spring boot 2.x의 IdClass의 복합키 연관관계 에러 해결
category: Spring
tags:
  - spring
  - jpa
  - 복합키
  - 에러해결
last_modified_at: 2023-08-15
---
### 구조
- Parent

```java
package com.example.demo.test;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

import javax.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@AllArgsConstructor
@NoArgsConstructor
@Data
@Table(name="parent")
public class Parent {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "p_seq")
	private Long pSeq;

	@Column(name = "p_column")
	private String pColumn;
}
```

- Child

```java
package com.example.demo.test;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.ConstraintMode;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.ForeignKey;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;

import javax.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@Entity
@IdClass(Child.ChildId.class)
@AllArgsConstructor
@NoArgsConstructor
@Data
@Table(name="child")
@Builder
public class Child {
	@Id
	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "p_seq", foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT))
	private Parent parent;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "c_seq")
	private Long cSeq;

	@Column(name = "c_column")
	private String cColumn;

	@AllArgsConstructor
	@NoArgsConstructor
	@Data
	@EqualsAndHashCode
	public static class ChildId implements Serializable {
		@ManyToOne
		@JoinColumn(name = "p_seq")
		private Parent parent;
		@Column(name = "c_seq")
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		private Long cSeq;
	}
}
```

- GrandChild

```java
package com.example.demo.test;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.ConstraintMode;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.ForeignKey;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ManyToOne;

import javax.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@IdClass(GrandChild.GrandChildId.class)
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Data
@Table(name="grandChild")
public class GrandChild {
	@Id
	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumns(value = {
		@JoinColumn(name = "c_seq"),
		@JoinColumn(name = "p_seq")
	}, foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT))
	private Child child;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "gc_seq")
	private Long gcSeq;

	@AllArgsConstructor
	@NoArgsConstructor
	@Data
	@EqualsAndHashCode
	public static class GrandChildId implements Serializable {
		@ManyToOne(fetch = FetchType.LAZY)
		@JoinColumns(value = {
			@JoinColumn(name = "c_seq"),
			@JoinColumn(name = "p_seq")
		})
		private Child child;
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		private Long gcSeq;
	}
}
```

- 최종 테스트 코드

```java
@Test
	@Transactional
	void test() {
		Parent p = new Parent(null, "ss");
		pRepo.save(p);

		Child c = new Child(p, null, "d");
		cRepo.save(c);

		GrandChild gc = new GrandChild(c, null);
		gcRepo.save(gc);
	}
```

### 발단

insert 테스트를 했는데

`Caused by: java.lang.IllegalStateException: Cannot convert value of type 'java.lang.Long' to required type 'com.example.demo.test.Parent' for property 'parent': no matching editors or conversion strategy found`

와 같은 에러가 나타남

업무 프로젝트에서 복합키 구조를 처음 사용해봐서 미리 연습을했을때는 insert 테스트가 잘 되었는데

동일한 구조로 생성한 업무 프로젝트에서 왜 갑자기 이런 에러가 나는지 이해가 되지않아 

프로젝트의 코드를 잘 작동했던 연습용 프로젝트로 옮겨서 작업을 했더니 잘 작동하는것을 확인했음..

회사 프로젝트랑 데모 프로젝트의 차이점을 찾아 본 결과 **스프링 부트의 버전문제**………였음

아무생각없이 연습용 프로젝트를 스프링부트 버전 3으로 만들어서 테스트를 했는데 
회사 프로젝트는 스프링부트 버전이 2였던..

회사 프로젝트의 기본키 채번방식이 결정되지않아 테스트없이 코드를 작성하다가 뒤늦게 문제를 발견한것이었음

회사 프로젝트의 스프링부트 버전 변경이 불가능한 상황이라 방법을 찾아야했음

### 해결 방법
#### idClass의 매핑을 EntityId클래스로 변경+ 생성자 생성+FetchType을 EAGER로 변경

- 장점 : X
- 단점 : <mark class="hltr-cyan">즉시로딩(EAGER)로 사용한다는거 자체가 문제</mark>
	자식 entity를 조회할때 연관관계 매핑된 부모 entity를 무조건 join해서 조회하기 때문에 n+1 문제가 발생함
	
#### 복합키를 보유한 entity를 연관관계로 매핑해야할 경우에만 해당 entity를 단일키로 구조 변경

- 장점: 복합키를 사용하며 생기는 단점을 모두 회피가능(일반적으로 JPA는 단일키를 권장)
	- FK를 맺을 때 복합키를 모두 컬럼으로 보유하거나 연결용 테이블을 생성해야함
	- 성능에 불리함. 인덱스에 좋은 영향을 끼치지 못함
	- 유니크 조건변경 시, PK전체를 수정
- 단점
	- 프로젝트의 entity 구조를 변경해야함
	- 유니크 키를 추가해야함

그러나 프로젝트 특성 상 복합키 구조를 유지해야해서 현재는 사용할 수 없는 방법임

#### entity 연관관계에 update=false, insert=false설정을 추가(최종 사용)

- Parent(원래 구조와 동일)

```java
package com.example.demo.test;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

import javax.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@AllArgsConstructor
@NoArgsConstructor
@Data
@Table(name="parent")
public class Parent {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "p_seq")
	private Long pSeq;

	@Column(name = "p_column")
	private String pColumn;
}
```

- Child

```java
package com.example.demo.test;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.ConstraintMode;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.ForeignKey;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;

import javax.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@Entity
@IdClass(Child.ChildId.class)
@AllArgsConstructor
@NoArgsConstructor
@Data
@Table(name="child")
@Builder
public class Child {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "c_seq")
	private Long cSeq;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "p_seq")
	private Long pSeq;

	@ManyToOne(fetch = FetchType.LAZY, optional = false)
	@JoinColumn(name = "p_seq", updatable = false, insertable = false, foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT))
	private Parent parent;

	@Column(name = "c_column")
	private String cColumn;

	@AllArgsConstructor
	@NoArgsConstructor
	@Data
	@EqualsAndHashCode
	public static class ChildId implements Serializable {
		@Column(name = "p_seq")
		private Long pSeq;
		@Column(name = "c_seq")
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		private Long cSeq;
	}
}
```

- GrandChild

```java
package com.example.demo.test;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.ConstraintMode;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.ForeignKey;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ManyToOne;

import javax.persistence.Table;

import org.hibernate.sql.Update;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@IdClass(GrandChild.GrandChildId.class)
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Data
@Table(name="grandChild")
public class GrandChild {
	@Id
	@Column(name = "p_seq")
	private Long pSeq;

	@Id
	@Column(name = "c_seq")
	private Long cSeq;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "gc_seq")
	private Long gcSeq;

	@ManyToOne(fetch = FetchType.EAGER, optional = false)
	@JoinColumns(value = {
		@JoinColumn(name = "c_seq", updatable = false, insertable = false),
		@JoinColumn(name = "p_seq", updatable = false, insertable = false)
	}, foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT))
	private Child child;
	@AllArgsConstructor
	@NoArgsConstructor
	@Data
	@EqualsAndHashCode
	public static class GrandChildId implements Serializable {
		@Column(name = "c_seq")
		private Long cSeq;

		@Column(name = "p_seq")
		private Long pSeq;

		@GeneratedValue(strategy = GenerationType.IDENTITY)
		@Column(name = "gc_seq")
		private Long gcSeq;

	}
}
```

기존의 pk에 설정한 연관관계를 제거하고, update와 insert가 불가능한 기본키와 관계없는 조회용 연관관계 entity를 추가해주었음

특정 칼럼을 두번 선언해주었으나 update와 insert를 불가능하도록 설정해두었기때문에 문제없이 동작함

- 장점 (단일키 구조에서도 적용되는 장점임)
	- 자식객체 사용 시 부모객체의 **기본키**만 사용할 때 불필요한 join/select 쿼리를 방지할 수 있음
		
		ex) 파라미터로 받은 부모 객체의 ID로 자식객체를 조회할때 불필요하게 부모객체를 먼저 조회할 필요없음
	- 불필요한 쿼리를 줄이면서 연관관계를 사용가능(fetch join 등 기능 사용 가능)
- 단점
	- jpa의 더티 체킹(dirty checking) 기능 사용 불가
	- (2023/08/15 단점 추가) 기본키 생성 전략을 IDENTITY로 설정한다면 DB저장 전에 해당 객체의 기본키를 알수없음.
	
		한 트랜젝션 내에서 
		1. Parent 객체 저장
		2. Child 객체 저장
		3. GrandChild 객체 저장 
		
		로직을 순서대로 실행한다면 
		1번에서 저장한 Parent 객체의 기본키를 Child와 GrandChild의 연관관계 매핑된 child와 GrandChild의 FK에서는 알 수 없음
		
		물론 @ManyToOne 어노테이션을 사용한 단일 매핑 객체에서는 기본키를 알 수 있으나 
		insertable, updateable을 false로 지정해두었기때문에 사용할 수 없는 것이 문제임.
		
		따라서 저장 전에 FK를 미리 set해주어야하는 코드가 필요함
		
		물론 기본키 생성 전략으로 IDENTITY를 사용하지않으면 해당 문제는 발생하지않음.
		아직 업무 프로젝트의 기본키 생성전략이 결정되지 않아 해당 구조를 유지하기로 결정함