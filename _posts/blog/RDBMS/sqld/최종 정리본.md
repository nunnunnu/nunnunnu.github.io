---
상태: Invalid date
---
- 성능 데이터모델링 : 분석 및 설계단계부터 성능과 관련한 데이터모델링을 수행함(정규화/반정규화, 테이블분할/병합/추가, 칼럼추가, PK/FK조정, 슈퍼타입/서브타입 조정 등)
    - 데이터 증가가 빠를수록 성능개선비용 증가 → 테이블분할을 하게되는경우 할일이 많아짐
    - 성능을 튜닝하면서 변경되는 특징이 있음
    - 분석/설계단계에서 하면 비용을 최소화할수있음
    - 고려사항
        - 용량산정은 성능데이터모델링시 트랜잭션의 유형과 양을 파악가능해서 중요한 작업임
        - 물리적 데이터 모델링시, PK/FK의 칼럼의 순서조정, FK인덱스 생성 등은 성능 향상을 위한 데이터 모델링 작업에 중요한 요소
        - 이력데이터는 반복발생 → 다량데이터일 확률이 높음 ⇒ 특별히 성능을 고려해 칼럼 등을 추가하도록 설계
- 트랜잭션
    - 항상 전체를 대상으로 일괄처리 → 전체를 하나의 테이블로 구성(Rollup) (테이블을 서브타입별로 개별유지하면 Union연산에 의해 성능저하 가능성 있음)
    - 항상 서브타입을 개별로 처리 → 서브타입을 개별 테이블로 구성(Rolldown) (테이블을 하나로 통합시 불필요하게 많은 데이터 집적으로 성능저하)
    - 슈퍼+서브타입을 공동초리 → 슈퍼타입 + 서브타입 테이블로 구성(Identity) (개별유지시 조인에의해 성능저하)

— 1:M관계일때 부모테이블에 인덱스가 있더라도 상속받은 테이블도 인덱스가 필요함  
마찬가지로 FK생성 여부와는 별개로 상속받은 테이블에도 인덱스 생성이 필요함  

### 테이블 삭제

- TRUNCATE : 테이블 초기상태로, 재사용 가능함. 행만 삭제하는 것. 디스크 초기화. Auto commit
- DROP : 완전 삭제. 테이블 자체를 삭제함. Auto commit
- DELETE : 로그 남음. 데이터 삭제. 사용자 commit

### 내장함수

- 1:M관계의 테이블조인시 M쪽에 단일행, 다중행 함수 사용가능
- 입력행수에따라 단일행 함수와 다중행 함수로 구분
    - 단일행 함수
        - 추출되는 각 행마다 작업을 수행
        - 각 행마다 하나의 결과를 반환
        - 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET절에 사용 가능
        - 데이터타입 변경가능
        - 중첩사용 가능
    - 다중행 함수
        - 여러개의 인수가 입력되어도 단일값만을 반환
        - 그룹집계함수 (SUM, AVG, MAX, MIN…)

### 순위

- top n with ties : 동일데이터 모두 출력
- rank() over() : 1 1 3 4 4 6
- row_number() over : 같은순위 다른순위로 나타냄
- dense_rank() over : 1 1 2 3 3 4

### 순수관계연산자

- SELECT(가로)
- JOIN
- DIVIDE
- PROJECTION(세로)

### USING절

: 왼쪽 테이블이 각 열이 오른쪽 테이블에 있는 동일이름의 열과 비교되는 결합조건

**USING** (PROJNO, ACTNO)

= **ON** CORPDATA.PROJACT.PROJNO = CORPDATA.EMPPROJACT.PROJNO  
  
**AND** CORPDATA.PROJACT.ACTNO = CORPDATA.EMPPROJACT.ACTNO

같은거임

### 집합연산자

||sql|oracle|
|---|---|---|
|교집합||INTERSECT|
|차집합|EXCEPT|MINUS|
|합집합||UNION|

### 계층형 질의

- sql에서는 CTE를 재귀호출함으로써 계층구조를 전개
- sql에서는 앵커멤버를 실행해서 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행
- oracle의 where절은 모든 전개를 진행한 후 필터 조건으로서 조건을 만족하는 데이터만 추출
- oracle의 PRIOR키워드는 CONNECT BY, SELECT, WHERE절에서 사용가능

### 서브쿼리

- 단일 행 또는 복수행 비교연산자와 사용가능
- SELECT절, FROM절, HAVING절, ORDER BY절 등에서 사용 가능
- 단일행 결과를 반환하는 경우 ‘=’, ’≥’, ’≤’등의 연산자와 사용 가능
- 다중 행 비교연산자는 IN, ALL 등이있다
- 다중행 서브쿼리 비교연산자는 단일 행 서브쿼리의 비교연산자로도 사용가능
- 연관(Correlated) 서브쿼리: 서브쿼리가 메인쿼리칼럼을 포함하고 있는 형태의 서브쿼리, 메인쿼리에서 값을 제공받음
- Oracle은 다중칼럼 서브쿼리를 지원하지만 SQL은 지원하지않음
- 스칼라 서브쿼리 : JOIN으로 동일한 결과 추출가능
- 동적 뷰 : SQL 문장 중 테이블명이 올 수 있는 곳에 사용가능

### 뷰(view)

- 필요한 정보를 테이블로 추출하는 SQL만을 저장함
- 데이터 구조 단순화
- 단지 정의만 가지고 있으며 실행시점에 질의를 재작성하여 수행
- 복잡한 SQL문장을 단순히 저장.
- 테이블구조 변경에 의한 영향으로부터 응용프로그램을 분리
- 보안목적으로도 사용가능
- 실제 데이터를 저장하고있는 뷰를 생성하는 기능을 지원하는 DBMS도 있음
- user에게 단순한 인터페이스 제공

## 그룹함수

결과건수가 줄어든다

### ROLLUP

- ROLLUP(A,B) : A,B그룹바이기준으로 해서 (A,B), A를 그룹바이 기준으로 해서 (A,null), 아무기준없이 전체를 기준으로 (null,null) 총 세가지의 값을 모두 조회
- 칼럼의 순서에 따라 다른결과가 출력되는 것

### GROUPING SETS

- 칼럼의 순서가 중요하지 않음.
- 각 함수의 인자로 주어진 칼럼 중 집계기준이 되는 칼럼 이외의 칼럼은 NULL값이 반환
- 각각의 합계를 출력

### CUBE

- 각 함수의 인자로 주어진 칼럼 중 집계기준이 되는 칼럼 이외의 칼럼은 NULL값이 반환
- 인자로 주어진 칼럼의 결합가능한 모든 조합에 대해 집계 → 다른 그룹함수에 비해 부하가 큼
- 모든 경우의 수에 대해 소계화 합계를 출력

### Grouping

- 해당 칼럼이 그룹화되어있다면 1, 아니면 0을 반환. CASE와 함께 씀

### 윈도우 함수

- 적용범위가 partition을 넘을 수 없음
- 그룹함수가 먼저 실행된 후 윈도우 함수가 실행.
- range

RANGE between 1000 PERCECDING and 1000 FOLLOWING → -1000~+1000 사이에 존재하는 ~의 개수

### lag(), lead()

- lag() : 앞의 값 찾기
- lead() : 뒤의 값 찾기

## PL/SQL

- 변수와 상수 등을 사용해서 일반 SQL문장을 실행시 WHERE절 조건으로 대입 가능
- procedure, User defined function, Trigger객체 생성가능 → 트랜잭션 분할 가능. 각 트랜잭션 별로 프로시저, UDF를 호출 가능
- Procedure내부에 작성된 절차적코드 처리 (일반적인 SQL문장은 SQL실행기가 처리해줌)

— EXECUTE IMMEDIATE ‘TRUNCATE TABLE 테이블명’ → 테이블의 모든 데이터를 롤백이 불가능하도록 삭제

- 절차형 SQL모듈
    - logic과 함께 데이터베이스에 저장한 명령문의 집합. CREATE PROCEDURE명령을 사용해서 생성
    - 사용자함수는 다른 SQL문을 통해 호출되고 그 결과를 리턴. SQL의 보조적인 역할 - CREATE FUNCTION명령을 사용해서 생성
    - Trigger
        - DML문이 수행되면 데이터베이스에서 자동으로 동작하도록 작성된 프로그램.
        - 데이터의 무결성과 일관성 유지가능
        - CREATE TRIGGER 명령을 사용해서 생성.
        - 데이터베이스에 로그인하는 작업에도 정의 가능
        - 롤백안됨
        - 테이블, 뷰에만 트리거를 작성(데이터베이스에선 안됨)

## JOIN

- 인라인뷰 안에서 뷰 바깥의 테이블과 Join불가
- PK와 FK값의 연관성에 의해 성립된다.
- DBMS절의 옵티마이저는 from절에 나열된 테이블들을 임의로 2개씩 묶어서 Join처리함
- Equi join은 join에 관여하는 테이블간의 칼럼값들이 정확하게 일치하는 경우에 사용하는 방법
- EQUI JOIN은 ‘=’연산자에 의해서만 수행되며, 그 이외의 비교연산자를 사용하는 경우에는 모두 Non EQUI JOIN임
- 설계상의 이유로 Non EQUI JOIN이 불가능한 경우도 있음
- 테이블사이에 JOIN조건이 없는 경우 카타시안 곱 발생
- NATURAL JOIN에서 OWNER 명을 사용하면 에러 발생

### CROSS JOIN

: 한쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 조인. → 최종 결과개수 = 두 테이블의 행의 개수를 곱한개수

⇒ FROM EMP,DEPT = FROM EMP CROSS JOIN DEPT

### self join

- 한 테이블 내에서 두 칼럼이 연관 관계에 있을때 사용

### Nested Loops Join

중첩for문같은느낌 - 인덱스구성전략이 매우 중요, 대량테이블에는 비효율적

- 조인 칼럼에 적당한 인덱스가 있어서 자연조인(Natural join)이 효율적일때 유리.
- Driving테이블의 조인 데이터양이 큰 영향을 줌
- 유니크 인덱스를 활용하여 수행시간이 적게걸리는 소량테이블을 온라인조회할때 유용
- 조인조건의 인덱스 유무에 영향을 많이 받음
- 선택도가 낮은(결과 행의 수가 적은)테이블이 선행테이블로 선택되는것이 유리

### Sort Merge Join

- 조인 칼럼에 적당한 인덱스가 없어서 자연조인이 비효율적일때 사용
- Driving테이블의 영향을 받지 않음
- 조인조건의 인덱스 유무에 영향받지않음
- equal join이 아니라 범위조인할때 효율적

### Hash Join

대용량테이블에쓰면 좋음. key컬럼에 중복이없을수록 유리. hash영역에 올라가는 테이블의 크기가 작아야함

- 해싱기법을 이용해 조인을 함
- DW등 데이터집계업무에서 많이 사용
- EQUI(=) 조인조건에서만 동작한다.
- 한쪽 테이블이 주 작고 해시 키 속성에 중복값이 적을 때 효과적
- 조인 칼럼에 적당한 인덱스가 없어서 자연조인이 비효율적일때 사용
- 자연조인시 드라이빙 집합쪽으로 조인 엑세스 량이 많아 랜덤 엑세스 부하가 심할때 사용
- 소트머지조인을 하기에는 두 테이블이 너무 커서 소트부하가 심할때 사용
    - 동등조인(Euqi Join)에서만 사용가능 → 제약존재
- 작은테이블을 먼저 읽으면 부하가 심해짐

  

— EXISTS(긍정) → SEMI JOIN

— NOT EXISTS(부정) → ANTI JOIN

## 옵티마이저

실행계획을 만들어주는 역할

- 실행계획 : SQL처리를 위한 실행절차와 방법을 표현. 시각적으로 표현해줌
    - 알수있는 정보
        - 엑세스 기법
        - 질의 처리 예상비용
        - 조인방법, 순서
    - 실행순서 : 안에서 밖으로, 위에서 아래로
    - 동일 SQL문에대해 실행계획이 다르면 Performance가 달라질수있음
    - Oracle의 실행계획에 나타나는 기본적인 join기법에는 NL Join, Hash Join, Sort Merge Join등이 있음

### CBO

: 비용기반 실행계획, SQL문 실행시 소요될 처리시간, CPU, I/O 자원량 등을 계산하여 가장 효율적일 것으로 예상되는 실행계획을 선택하는 옵티마이저. 단계별 예상 비용 및 건수 표시

- 객체의 통계정보를 사용하여 실행계획 수립 → 통계정보 변경 시 SQL의 실행계획이 달라질수도 있음

### RBO

: 규칙기반 실행계획.

- 제일 높은 우선순위는 행에대한 고유주소 사용하는 방법임
- 인덱스 스캔이 항상 유리함, 적절한 인덱스가 있다면 무조건 사용하려함
- Single row by rowid엑세스 기법이 가장 우선순위가 높음

### 인덱스

- B-Tree - 관계형 데이터베이스의 주요 인덱스 구조. 일반적으로 OLTP시스템 환경에서 가장 많이 사용. 일치 및 범위검색에 적절한 구조임
    - branch block : 분기를 목적
    - leaf block : 인덱스 구성하는 칼럼의 값으로 정렬
- CLUSTERED : 인덱스의 leaf페이지가 곧 데이터 페이지, 모든 데이터는 인덱스 키 칼럼순으로 물리적으로 정렬
- BUTMAP : 시스템에서 사용될 질의를 시스템 구현시에 모두 알 수 없는 경우인 DW 및 AD-HOC질의 환경을 위해 설계, 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조
- 인덱스 범위 스캔 시 결과가 없으면 한 건도 반환하지않을 수도 있음
- 인덱스 조건 중 ‘=’가 사용된 칼럼이 앞쪽에 위치하는것이 효율적임
- SQL의 클러스터형 인덱스틑 ORACLE의 IOT와 매우 유사함

  

SELECT - 스칼라 서브쿼리

FROM - 인라인뷰

WHERE - 서브쿼리(자유롭게 사용못함)

  

CHARACTER :고정길이 문자열, S만큼 최대길이(그보다 작을시 공백으로 채운다.), 서로 길이가 달라도 같은 내용으로 판단

  

1 PRECEDING / 1 FOLLOWING - 현재행을 기준으로 이전행+현재+다음행 합계를 표시

  

인덱스 생성구문 - create

  

ANY (다수의 비교값 중 하나라도 만족하면 TRUE)

  

- 트랜잭션 특징
    
    원자성 일관성 고립성 지속성
    
- 순위 1 2 3 3 4 5
    
    DENSE_RANK
    
- 부모삭제시 자식도 삭제
    
    CASCADE
    
- 계층쿼리에서 형제노드간의 정렬을 지정
    
    ORDER SIBLINGS BY
    
- 엔터티의 일반 속성간에는 서로 종속되지 않음
    
    제 3정규형
    
- 관계의 표기법에 표현되는 개념 3가지
    
    관계명, 관계차수(1:M:), 관계선택사양
    
- SUMMER 테이블 이름 FALL로 변경
    
    RENAME SUMMER TO FALL;
    
- 카타시안곱
    
    CROSS JOIN
    
- 이름같은 칼럼 기준 EQUIJON
    
    NATURAL JOIN
    
- SELECT SIGN(-77) FROM DUAL;
    
    -1. 음수면 -1, 0이면 0, 양수면 1
    
- 날짜 문자열로 변환
    
    TO_CHAR