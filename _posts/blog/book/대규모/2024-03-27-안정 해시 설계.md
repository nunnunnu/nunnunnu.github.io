---
title: "[책] 가상 면접 사례로 배우는 대규모 시스템 설계 기초 - 5장 안정 해시 설계"
publish_date: 2024-03-27T17:23:00
last_modified_at: 2024-03-27
category: 프로그래밍 방법
tags:
  - 설계
---
[책정보](https://m.yes24.com/Goods/Detail/102819435)
![images](/assets/images/대규모/IMG-20240910172136.png)

### 해시 키 재배치 문제
N개의 캐시서버가 있다고 가정, 이 서버들의 부하를 나누려면
<mark style="background: #ABF7F7A6;">serverindex = hash(key)%N(N이 서버의 개수)</mark>
위 계산공식으로

| 키    | 해시       | 해시%4(서버인덱스)[실제값아님!귀찮아서 대충함] |
| ---- | -------- | --------------------------- |
| key0 | 13414213 | 1                           |
| key1 | 131231   | 0                           |
| key2 | 23123    | 2                           |
| key3 | 12312    | 0                           |
| key4 | 34253    | 1                           |
| key5 | 4363     | 3                           |
| key6 | 6243     | 2                           |
| key7 | 432234   | 3                           |

위와같이 있다고 가정했을때

| 서버인덱스 | 0            | 1            | 2            | 3            |
| ----- | ------------ | ------------ | ------------ | ------------ |
| 서버    | server0      | server1      | server2      | server3      |
| 키     | key1<br>key3 | key0<br>key4 | key2<br>key6 | key5<br>key7 |

이렇게 배치될거임
이상태에서
1번서버가 장애를 일으켰을때 계산공식에서 사용한 서버의 개수가 4에서 3으로 변경됨. 그렇다면 서버에 키가 다시 재배치가 되는데
결과적으로 이때 <mark style="background: #ABF7F7A6;">죽은 server1의 키만 재배치되는게아니라 모든 키가 재배치됨</mark>
**결국 캐시 클라이언트는 데이터가없는 엉뚱한 서버에 접속하게될 가능성이 있음**
#### 안정 해시

^cabc4d

위의 문제에서(해시테이블의 크기가 조정될때) 평균적으로 오직 k(key개수)/n(slot개수)개의 키만 재배치하는 기술
- 해시 공간과 해시 링
	해시 함수 f로는 SHA-1을 사용한다고 가정, 출력범위는 x0~xn
	SHA-1의 공간 범위는 0~2^160-1
	따라서 x0은 0, xn은 2^160-1
	이것을 직사각형모양의 n개로 나누어진 공간을 해시공간이라 말하고
	이 해시공간을 양쪽을 잡아 구부려 접으면 해시링이라고 한다
![images](/assets/images/대규모/IMG-20240910173709.png)
여기서 함수 f를 사용하려 서버 ip나 이름을 이 링 위 어느 위치에 대응가능함 이를 **해시서버**라고 함
![images](/assets/images/대규모/IMG-20240910173709-1.png)
여기서 사용된 해시함수는 아까 본 해시키 재배치문제에서 사용한 함수와는 다름
캐시할 키도 링위에 배치 가능
![images](/assets/images/대규모/IMG-20240910173710.png)
여기서 키가 저장된 서버는 해당 키로부터 시계방향으로 링을 탐색해가며 만나는 첫번째 서버임.
여기서 서버가 추가된다면 키 가운데 일부만 재배치해주면됨
![images](/assets/images/대규모/IMG-20240910173710-1.png)
이렇게하면 서버가 추가되거나 삭제되었을때 영향을 받지않는 해시키는 재배치되는것을 막을 수 있음

이 과정에서도 문제점이 있는데
- 파티션의 크기가 균등하지않음 -> 어떤서버는 작은 해시공간을, 어떤서버는 큰 해시공간을 할당받음
- 키의 군등분포를 당설하기 어려움 -> 대부분의 키가 한 서버에 보관될 가능성이있음
##### 가상 노드
위의 문제를 해결하기위해 나온 방법
실제노드 또는 서버를 가르키는 노드인데 하나의 서버는 링위에 여러개의 가상 노드를 가질 수 있음
![images](/assets/images/대규모/IMG-20240910173710-2.png)
key0이 가상노드 서버1_1을 만나 서버1에 저장됨
가상 노드의 개수를 늘리면 늘릴 수록 키의 분포가 점점 균등질것임. 표준편차가 작아져 데이터가 고르게 분포되는것.
그러나 가상노드 데이터를 저장할 공간이 필요하게되니 타협적 결정이 필요함
- 서버가 추가/제거되면 데이터 일부는 재배치해야하는데 어느 범위의 키가 재배치되는가?
	- ![images](/assets/images/대규모/IMG-20240910173710-1.png)
		여기서는 서버 4가 추가되면서 s4(새로추가된서버)~s3까지임
		즉 s3부터 s4사이에있는 키를 재배치해야함
		마찬가지로 만약 서버4가 다시 삭제된다면 s3~s0까지임
	