---
title: "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 10장 알림 시스템 & 뉴스 피드 시스템 & 채팅 시스템"
category: 프로그래밍 방법
tags:
  - 설계
  - 가상면접사례로배우는대규모시스템설계기초
---

[책정보](https://m.yes24.com/Goods/Detail/102819435)
![images](/assets/images/대규모/IMG-20240910172136.png)

## 알림 시스템 설계

- iOS 푸시알람
	- 알림 제공자 : 알림요청을 만들어 애플 푸시알림서비스로 보내는 주체
		- 단말토큰 : 알림 요청을 보내는 데 필요한 고유 식별자
		- 페이로드 : 알림내용을 담은 JSON딕셔너리
		- APNS: 애플이 제공하는 원격 서비스. 푸시알람을 IOS장치로 보냄
- 안드로이드 푸시알람
	- FCM : 푸시알람을 안드로이드장치로 보냄
- SMS 메세지
	- 트윌리오, 넥스모 같은 상용서비스를 사용해 메세지를 보냄(유료)
- 이메일 지원 알림 시스템
	- 센드그리드, 메일침프 등 상용 이메일 서비스 사용.

1. 연락처 수집 : 알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 등의 정보를 계정 등록시 DB에 저장
2. 알림 전송 및 수신
	![images](/assets/images/대규모/2024-03-30.18.26.04.png)
	하나 이상의 메세지 큐를 사용하여 알람 병렬처리 가능
	- 안정성
		- 데이터 손실 방지 : 알림은 지연되거나 순서가 틀려도 괜찮지만 사라지면 곤란함. 알림 시스템은 알림 데이터를 DB에 보관하고 재시도 메커니즘을 구현해야함
	- 알림 중복 전송 방지
		- 분산시스템의 경우 중복전송되기도함. 그러나 완전히 막는 것은 불가능함. 빈도를 줄이기 위해서는 알림의 이벤트 ID를 검사해 중복 이벤트라면 버리고, 아니면 알림을 발송함
3. 추가 고려 사항
	- 알림 템플릿 : 사전에 형식을 지정해서 알림을 보냄. 일관성 유지, 오류 가능성 감소, 알림 작성 시간 감소 등의 장점
	- 알림 설정 : 사용자가 알림을 상세히 조정할 수 있어야함
	- 전송률 제한 : 한 사용자에게 너무 많은 알림을 보내지 않도록. 너무 많은 알림이 가면 사용자가 알림을 꺼버림
	- 재시도 : 알림 전송에 실패하면 해당알림은 재시도 전용 큐에 넣어 시도. 계속 실패하면 개발자에게 alert
	- 푸시 알림/보관 : iOS와 안드로이드는 알림전송 API로 appKey와 appSecret을 사용해 보한을 유자하기때문에 인증/승인된 라이언트만 해당 api를 사용할 수 있음
	- 큐 모니터링 : 큐에 쌓인 알림이 너무 크면 서버들이 이벤트 처리를 빠르게못하고있다는 뜻. 서버 증설이 바람직함
	- 이벤트 추적 : 알람 확인률, 클릭율, 실제 앱사용 비율 등 이벤트 추적이 필요. 데이터분석서비스는 보통 이벤트 추적도 같이 제공함. 

## 뉴스 피드 시스템 설계

- 포스팅 전송(팬아웃) 서비스 : 특정 사용자의 새 포스팅을 그 사용자의 친구에게 모두 전달하는 과정. 쓰기시점/읽기시점으로 나뉨
	- 쓰기시점에 팬아웃 : 새로운 포스팅을 기록하는 시점에 뉴스피드를 갱신. 
		- 읽는 데 드는 시간이 짧아지고 뉴스피드가 실시간 갱신, 즉시전송됨
		- 핫키 문제 : 친구가 많은 사용자의 경우 목록에있는 사용자 모드의 뉴스피드를 갱신하는데 많은 시간이 소요됨.
		- 서비스를 자주 이용하지않는 사용자의 피드도 갱신해야함
	- 읽기 시점에 팬아웃
		- 비활성or거의 사용하지않는 사용자의 경우 유리. 핫키문제도 생기지않음
		- 뉴스피드를 읽는데 많은 시간이 소요될수도있음
1. 그래프 데이터베이스(친구관계/친구추천을 관리하기 좋음)에서 친구 ID목록 조회
2. 사용자 정보 캐시에서 친구 정보 조회(사용자 설정에따라 일부 걸러냄-mute). 
3. 친구 목록/새스토리의 포스팅 ID를 메세지 큐에 넣음
4. 팬아웃 작업 서버가 메세지 큐에서 데이터를 꺼내 뉴스 피드 데이터를 뉴스피드 캐시에 넣음(<포스팅ID, 사용자ID>의 순서쌍으로 보관)
5. 사용자가 피드 읽기 요청을 보냄
6. 로드밸런서가 웹 서버 중 하나로 요청을 전달
7. 웹 서버가 피드 조회를 위해 뉴스 피드 서비스 호출
8. 뉴스 피드 서비스가 캐시에서 포스팅 목록 ID목록 조회
9. 뉴스피드에 표시할 사용자 이름/사진/포스팅컨텐츠/이미지 등은 사용자 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드를 생성
10. 생성된 뉴스피드를 클라이언트에게 전송

| 캐시구조           |        |        |     |
| -------------- | ------ | ------ | --- |
| 뉴스 피드(뉴스피드의ID) | 뉴스피드   |        |     |
| 콘텐츠            | 인기 콘텐츠 | 일반 콘텐츠 |     |
| 소셜 그래프         | 팔로어    | 팔로잉    |     |
| 행동             | 좋아요    | 답글     | 기타  |
| 횟수             | 좋아요횟수  | 답글횟수   | 기타  |

## 채팅 시스템 설계
- 제공 기능
	- 클라이언트로부터 메세지 수신
	- 메세지 수신자 결정 및 전달
	- 수신자가 접속 상태가 아닐경우 접속할때까지 메세지 보관

메세지 송신은 HTTP프로토콜을 사용하는것이 효율적. 그러나 수신시에는 여러 기법이 제안되어있음(HTTP 프로토콜은 서버에서 클라이언트로 임의시점에 메세지를 보내는데 사용하기 어려움)
### 메세지 수신 기법
- 폴링
	클라가 주기적으로 서버에 새 메세지가 있는지 물어보는 방식
	답해줄 새 메세지가 없는 경우에도 서버에 메세지가있냐고 물어보기때문에 서버자원이 불필요하게 낭비됨. 폴링비용은 폴링을 자주할수록 높아짐
- 롱폴링
  폴링을 보완한 기법. 클라이언트가 새 메세지여부를 서버에 물으면서 생긴 연결을 새 메세지를 받을때까지 계속 유지함. 받으면 연결 종료. 만약 오래동안 새 메세지가 오지않으면 연결을 타임아웃시킴 ^9c87fd
  - 그러나 수신/전송 클라이언트가 같은 채팅서버에 접속하지않았을수도 있음. HTTP서버들은 보통 무상태 서버기때문에 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우 *메세지를 받은서버 != 메세지를 수신할 클라이언트가 접속한 서버* 일수도 있음
  - 서버에서는 클라이언트의 연결유무를 알수없음
  - 비효율적. 메세지를 많이받지않는 클라이언트도 타임아웃이 날때마다 주기적으로 서버에 다시 접속할것임
- 웹 소켓
	서버가 클라이언트에게 비동기 메세지를 보낼때 가장 널리사용하는 기술.
	![images](/assets/images/대규모/2024-03-31.11.32.13.png)
	- 연결은 쿨라이언트가 시작. 한번 맺어진 연경은 항구적&양방향
	- 처음엔 HTTP연결 -> 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드됨. 웹 소켓은 80이나 443처럼 HTTP or HTTPS가 사용하는 기본포트번호를 사용해 방화벽이있는 환경에서도 잘 동작함
	- 웹 소켓이 메세지를 양방향 전송해주기때문에 굳이 메세지 송신시에도 HTTP프로토콜을 사용하지않아도됨
	
##### 설계안
- 무상태 서비스 : 로드밸런서 뒤에 위치
- 상태유지 서비스 : 채팅서비스는 상태유지가 필요함. 각 클라이언트가 채팅 서버와 독립적 네트워크 연결을 유지해야함(클라이언트는 서버가 살아있는 한 서버를 변경하지않음. 한서버에 몰리지않도록 관리해야함)
- 제 3자 서비스 연동 : 알림서비스. 앱이 실행중이아니라도 알람이 가야함
- 규모확장성
- 저장소 : 채팅이력 데이터의 양은 엄청남 + 대체로 최근 메세지를 사용함 + 그러나 검색기능/언급기능으로 무작위적데이터접근/특정메세지로 점프가 일어남
  => 키/값 저장소가 효율적
	- 1:1 채팅을 위한 테이블
	- 그룹채팅을 위한 테이블
	- 메세지 ID -> RDMS라면 auto_increment가 대안이나 noSql에서는 스노플레이크 or 지역적 순서번호 생성기(ID의 유일성은 같은 그룹 내에서만 적용함)를 사용하면 좋음
###### 기능
- 1:1 채팅
![images](/assets/images/대규모/2024-03-31.12.11.25.png)
- 그룹 채팅
	- 소규모 채팅 : A가보낸 메세지를 B와 C의 메세지 동기화 큐에 전송
	- 대규모 채팅 : 하나의 메세지 동기화 큐가 여러 사용자의 메세지를 수신할 수 있음
- 접속상태
	- 사용자 로그인/로그아웃으로 접속상태 서버를 거쳐 접속상태 판단. 
	- 인터넷 연결 장애 발생 시
		- 박동검사 : 주기적으로 박동 이벤트를 접속상태 서버로 보내고 마지막 이벤트를 받은지 x초 이내에 또 다른 박동 이벤트를 받으면 접속상태 유지. 못받으면 오프라인 변환
	- 접속상태정보 전송
		- 소규모 환경 : 각각의 친구관계별로 서버생성.
		- 대규모환경 : 사용자가 그룹 채팅에 입장하는 순간에만 상태정보를 읽게함/친구리스트의 접속상태를 갱신하고싶으면 수동갱신하도록 유도

- 추가 고려 사항
	- 미디어 지원. 미디어는 용량이 크니 압축/클라우드저장소/섬네일 생성등을 논의해야함
	- 종단 간 암호화 : 메세지 발신인/수신인 외 아무도 못보게 암호화
	- 캐시 : 이미읽은 메세지 캐시
	- 로딩속도 개선 : 슬랙은 사용자 데이터/체널 등을 지역적으로 분산하는 네트워크를 구축하여 개선함
	- 오류처리
	- 메세지 재전송 : 재시도나 큐는 메세지 안정전송 보장을 위해 보편적으로 사용됨
	