---
title: "[기술 면접 대비 CS전공 핵심 요약집] 운영체제 1"
category: CS
tags:
  - cs
  - 운영체제
  - 책요약
---
![image](https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791140706129.jpg)

# 운영체제란
하드웨어 위에 설치되어 하드웨어 계층과 다른 소프트웨어 계층을 연결하는 소프트웨어 계층
CPU, 메모리같은 제한된 컴퓨터 시스템 자원 관리, 사용자가 컴퓨터를 사용할 수 있는 환경 제공.
사용자와 컴퓨터 간의 인터페이스를 제공해 편리하게 사용가능
윈도우, 맥, 리눅스, 유닉스 등

## 운영체제의 목적
- 처리능력 향상: OS는 자원관리를 통해 일정시간 내 시스템이 처리하는 일의 양을 향상시킴
- 반환시간 단축: OS는 사용자가 시스템에 요청한 작업을 완료할때까지 소요되는 시간 단축
- 사용 가능도 향상: 시스템 자원을 얼마나 빨리 제공할 수 있는가를 의미. OS는 사용자가 컴퓨터를 사용해야할때 자원을 즉시 사용
- 신뢰도 향상: 주어진 문제를 시스템이 얼마나 정확하게 푸는가? 입력값에 대한 정확한 결과 값을 줄수있도록 신뢰도를 향상해야함

## CPU와 메모리 구조
- CPU
	'컴퓨터의 뇌' 역할을 하며 컴퓨터에서 프로그램을 실행하는 데 필요한 연산을 처리하고 수행한다
	다른말로 **프로세서**라고도 한다
- 메모리
	데이터를 저장하기위한 기억장치. 휘발성 메모리인 주 기억장치와 비휘발성 메모리인 보조기억 장치가 있다
	- 주 기억장치: 메인메모리. 일반적으로 RAM을 가르킴
	- 보조 기억장치: SSD, HDD 등
	- 메모리 계층 구조
		![image](/assets/images/cs/IMG-20250520205524.png)
		- 레지스터: CPU가 사용자의 요청을 처리하는데 필요한 데이터를 임시로 저장하는 기억장치. CPU내부에 존재해 접근속도가 빠름
		- 캐시메모리: CPU와 RAM속도 차이를 해결하기 위한 기억장치. CPU내부에 위치해 레지스터 다음으로 빠름
		- RAM: 컴퓨터에서 프로그램을 실행할때 필요한 정보 저장. CPU에서 하드디스크보다 접근속도가 빠르고 휘발성 기억장치. 보통 메모리라고 말할때 RAM을 의미함
		- 하드디스크: 사용자가 필요한 데이터, 프로그램을 저장하는 비휘발성 기억장치
	프로그램을 실행하면 OS가 디스크에있는 프로그램을 메모리로 로드하고 메모리에 로드한 프로그램을 **프로세스**라고 하며 CPU가 처리한다
	CPU는 하나의 프로세스만 처리할 수 있어 멀티프로세스 환경에서 OS가 스케줄링을 통해 CPU에 프로세스를 할당한다

## <mark class="hltr-cyan">커널과 시스템 콜</mark>
- 커널: OS의 핵심 요소로 컴퓨터 하드워어와 프로세스의 보안, 자원관리, 하드웨어 추상화 같은 중요역할 수행. 특히 자원 관리를 위해 CPU 스케줄링, 메모리 관리, 파일 시스템 등 관리 
	![image](/assets/images/cs/IMG-20250520205525.png)
	운영체제는 커널에서 관리하는 중요자원에 쉽게접근하지 못하도록 커널모드와 사용자 모드로 모드를 나눔
	커널 모드에서는 하트웨어에 직접 접근해 메모리, CPU같은 자원을 사용 가능
	<mark class="hltr-cyan">사용자 모드에서 실행된 프로세스가 자원에 접근하려면 시스템콜을 호출해 커널에 요청을 해야함</mark>.
- 시스템 콜
	사용자 모드에서 커널모드에 접근해 필요한 기능을 수행할 수 있게하는 시스템 함수
	커널은 시스템 콜로 받은 요청을 처리한 후 다시 시스템 콜로 결과값을 반환함
	
	![image](/assets/images/cs/IMG-20250520205525-1.png)
	프로세스 제어, 파일 조작, 장치관리, 데이터 유지보수, 통신, 보호를 할수있음.
	대표적인 예로는 프로세스를 생성하는 fork(), 부모 프로세스가 자식 프로세스의 수행을 기다리는 wait()등이 있다
	
- 시스템콜에서 커널에 매개변수 전달하는 법
	1. 매개변수를 CPU 레지스터에 직접 전달. 단, 매개변수의 개수가 레지스터보다 많은경우 문제가될수있어 권장하지 않음	
	2. 매개변수를 메모리에 저장한 후 메모리의 주소 값을 레지스터에 저장
	3. 매개변수를 프로그램 스택에 push하고 OS에서 pop해 매개변수를 전달

---
# <mark class="hltr-cyan">프로세스</mark>
컴퓨터에서 실행중인 하나의 프로그램. 
프로그램은 특정 작업을 수행하기 위한 명령어의 집합으로 OS는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드
OS로부터 독립된 메모리 영역을 할당받아 다른 프로세스의 메모리 영역에 접근할 수 없다
![image](/assets/images/cs/IMG-20250520205525-2.png)
- 스택: 지역변수, 함수의 매개변수, 반환되는 주소값이 저장됨. LIFO(후입선출). 높은 주소값에서 낮은 주소값으로 메모리 할당
- 힙: 사용자에 의해 동적 메모리 할당이 일어나는 영역. C언어에서 amlloc()으로 할당되는 영역. 낮은 주소값에서 높은 주소값으로 메모리가 할당되며 영역 크기는 런타임에 결정됨. FIFO(선입선출)
- 데이터: 전역변수, 정적변수, 배열, 구조체 등이 저장됨.
	- BSS 영역: 초기화하지않은 변수 저장
	- 데이터 영역: 초기화한 변수 저장
	- 
- 코드: 실행할 코드가 기계어로 컴파일되어 저장하는 영역. 텍스트영역이라고도 함
스택과 힙은 동적 메모리 할당이 가능해 두 영역사이에 빈 메모리 공간이 있음.
하지만 메모리 영역을 공유하기때문에 서로의 영역을 침범하기도하는데 이런경우를 
스택이 힙 영역을 침범하면 **스택 오버플로**, 힙 영역이 스택 영역을 침범하면 **힙 오버플로**라고 한다

## 스레드
<mark class="hltr-cyan">프로세스에서 실제로 실행되는 흐름의 단위</mark>. 프로세스는 한개 이상의 스래드를 가짐
프로세스안에 존재하므로 프로세스의 메모리 공간을 이용하고 지역 변수를 저장하는 스택 영역을 할당 받음. 그리고 전역변수를 저장, 힙 영역은 다른 스레드와 공유
![image](/assets/images/cs/IMG-20250520205525-3.png)
- 사용자 레벨 스레드와 커널 레벌 스레드
	커널처럼 스레드도 관리하는 주체에 따라 구분된다
	- 사용자레벨 스레드
		사용자가 라이브러리를 이용해 생성 및 관리
	 - 커널 레벨 스레드
		커널이 스레드를 생성 및 관리
	멀티 스레드 환경에서 사용자 레벨 스레드와 커널 레벨 스레드는 다음과 같이 3가지 관계를 맺을 수 있음
	1. 다대일 모델
		사용자레벨 스레드 N개, 커널 레벨 스레드 1개가 매핑되어 사용자 레벨에서 스레드를 관리
		하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 나머지 사용자 레벨 스레드는 커널레벨에 접근 불가.
		따라서 멀티코어의 병렬성 이용 불가
	2. 일대일 모델
		사용자 레벨 스레드 1개에 커널 레벨 스레드 1개가 매핑됨.
		다대일모델의 단점을 해결하지만 
		사용자레벨 스레드 수만큼 커널 레벨 스레드가 생성되므로 성능저하 위험
	3. 다대다 모델
		사용자 레벨 스레드 N개에 서컬레벨 스레드 M개가 매핑(N > M).
		다대일모델과 일대일 모델의 장점을 포함하지만
		구현이어렵다는 단점 존재
	![image](/assets/images/cs/IMG-20250520205525-4.png)


## PCB
<mark class="hltr-cyan">프로세스를 제어하기위해 프로세스 정보를 저장</mark>
- PCB 저장 정보
	- 프로세스의 현재 상태
	- 프로세스를 나타내는 고유의 PID
	- 부모 프로세스의 PID
	- 자식 프로세스의 PID
	- 다음 실행할 명령어의 주소인 PC(프로그램 카운터)
	- 프로세스의 우선순위
	- 메모리 제한
	- 포인터
	- 레지스터
	- 열린파일목록
	- ...

## <mark class="hltr-cyan">프로세스의 생성</mark>
새로운 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성된다. fork()함수는 함수를 호출한 프로세스를 복사하는 기능이 있음
이때 기존 프로세스를 부모 프로세스, 복사된 프로세스를 자식 프로세스라고 지칭.
fork()함수 실행 시 부모프로세스는 자식 프로세스의 PID값을, 자식 프로세스는 0을 반환함

![image](/assets/images/cs/IMG-20250520205526.png)
- 운영체제가 프로세스를 종료하는 경우
	- 프로세스가 운영체제의 종료서비스(exit())를 호출하는 경우 - 정상종료
	- 프로세스의 실행시간, 특정 이벤트 발생을 기다리는 시간이 제한시간 초과
	- 프로세스가 파일검색/입출력에 실패
	- 오류발생/메모리부족 발생
- 부모프로세스가 자식 프로세스를 종료시키는 경우
	- 자식프로세스가 할당된 자원을 초과사용
	- 자식프로세스에 할당된 작업없음

- fork()함수의 반환값
	![image](/assets/images/cs/IMG-20250520205526-1.png)
	start는 부모프로세스에 의해 출력 -> 부모프로세스가 fork()호출 -> fork()의 반환값은 자식프로세스의 pid -> else문 실행 -> 생성된 자식프로세스가 첫번째 조건문 해당

	다만 책에서는 자식프로세스가 fork()에서 생성되기때문에 윗줄인 start는 실행되지않아 1번만 찍힌다고 나오는데 나는 2번찍혔다..
	gpt의 설명에따르면
	- 복제된 자식 프로세스는 그 시점의 메모리 상태를 그대로 이어받음.
	- 따라서 `printf()`가 `fork()`보다 먼저 호출되었고, 버퍼가 flush되지 않았다면 `"start!"`가 두 번 출력될 수 있음
	이라고한다
	![image](/assets/images/cs/IMG-20250520205526-2.png)
	부모와 자식이 같은 출력버퍼를 공유하고있기때문에 start 아래에 출력버퍼를 비워주면 해결된다고..

## 프로세스 상태도

>![용어 정리]
>- 승인(admit): CPU를 제외한 다른 자원이 준비되어 해당 프로세스가 준비상태가 될 수 있도록 OS가 허락
>- 디스패치(dispatch): 프로세스에 CPU자원을 할당해 해당 프로세스가 준비상태에서 실행상태가 되는 것을 의미


모든 프로세스는 CPU에 의해 생성/소멸을 반복하는데, 이때 프로세스는 5가지 상태를 가진다
- 프로세스의 5가지 상태
	- 생성(new): 프로세스가 PCB를 가지고있지만 OS로부터 승인(admit)받기 전.
	- 준비(ready): OS에게 승인받은 후 준비 큐에서 CPU할당을 기다림
	- 실행(running): 프로세스가 CPU를 할당받아 실행함
	- 대기(waiting): 프로세스가 입출력이나 이벤트 발생을 기다려야해서 CPU사용을 멈추고 기다림
	- 종료(terminated): 프로세스 실행 종료
![image](/assets/images/cs/IMG-20250520205526-3.png)
- 프로세스의 상태 변환
	- 생성->준비: 생성 상태의 프로세스가 OS로부터 승인을 받아 준비 상태의 프로세스가 모여있는 자료구조인 준비 큐(ready queue)에 추가됨
	- 준비->실행: 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치되어 실행
	- 실행->준비: CPU독점 방지를 위해 타임아웃 되어 준비상태로 변경
	- 실행->대기: 입출력 또는 이벤트 때문에 대기상태로 변경
	- 대기->준비: 입출력 또는 이벤트가 완료되어 준비상태로 변경
	- 실행->종료: 실행중인 프로세스가 정상적으로 끝나서 종료상태로 변경

## 멀티 프로세스와 멀티 스레드
- 동시성(concurrency)
	<mark class="hltr-cyan">하나의 코어(싱글 코어)에서 여러작업을 번갈아가며 처리하는 방식</mark>. 
	CPU는 한번에 하나의 작업만 처리가능해서 여러작업을 돌아가며 처리함.
	이렇게 하나의 CPU에서 여러작업을 번갈아가며 처리하기위해 처리중인 작업을 교체하는 것을 **콘텍스트 스위칭**이라 함
- 병렬성(parallelism)
	<mark class="hltr-cyan">CPU가 여러개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리</mark>하는 방식
	즉, 물리적인 시간 관점에서 동시에 여러작업이 처리된다
![image](/assets/images/cs/IMG-20250520205526-4.png)

### 멀티 프로세스
응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미
멀티프로세스 환경에서는 한 프로세스가 죽어도 다른 프로세스에 영향을 주지않음.
=> <mark class="hltr-cyan">응용프로그램을 하나로 구성하는 것보다 여러개로 구성하는 것이 안정적.</mark>
하지만 <mark class="hltr-cyan">시간과 메모리 공간을 많이 차지하기하는 단점</mark>이 있다

그래서 여러 프로세스를 처리하려면 CPU에서 처리중인 프로세스를 교체하는 콘텍스트 스위칭 작업이 이루어져야한다
이때 CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체되면서 시간과 메모리가 필요한데, 이를 **오버헤드**라고 한다
또한 프로세스는 독립적인 메모리를 할당받는데 프로세스 간의 공유할 자원이있다면 IPC를 통해 자원을 공유해야해서 공유할 메모리를 직접 참조하는것보다 비효율적이다
![image](/assets/images/Pastedimage20250520210602.png)
### 멀티 스레드 
스레드를 여러개 생성해 스레드들이 각자 다른 작업을 처리하는것.
멀티 스레드는 스레드 간에 힙, 데이터, 코드영역을 공유함.
따라서 콘텍스트 스위칭 시 오버헤드가 적게 발생하고, IPC를 사용하지않아서 멀티프로세스의 단점을 보완함
따라서 독립적인 메모리공간을 가지는 프로세스를 여러개 생성하는것보다 스레드를 여러개 생성하는 것이 자원을 효율적으로 사용 가능하다
스레드간 자원공유 방식도 프로세스보다 효율적이라 시스템처리비용이 적고 응답시간도 단축됨

하지만 스택영역을 다른 스레드와 함께 사용하므로 공유자원에 대한 동기화가 필수
또한 스레드에 문제가생기면 프로세스 내 다른 스레드에도 영향을 끼친다
![image](/assets/images/cs/IMG-20250520205527-1.png)

## 콘텍스트 스위칭
- 인터럽트
	<mark class="hltr-cyan">CPU에서 프로세스를 처리하다가 입출력관련 이벤트가 발생하거나 예외 상황이 발생할때 이에 대응할 수 있게 CPU에 처리를 요청함</mark>. 입출력이 발생할때, CPU시간이 만료되었을대, 자식 프로세스를 생성할 때 발생함

CPU는 하나의 프로세스만 처리 가능해서 멀티 프로세스를 처리하려면 CPU 스케줄러에 의해 언터럽트가 발생하면 콘텍스트 스위칭이 이뤄진다

- 콘텍스트: CPU가 처리하는 프로세스의 정보
- 콘텍스트 스위칭: <mark class="hltr-cyan">멀티 프로세스 환경에서 CPU가 처리중인 프로세스의 정보를 바꾸는 것</mark>.
![image](/assets/images/cs/IMG-20250520205527-2.png)
처리중이던 프로세스를 P1. 다음에 처리해야할 프로세스를 P2라고 가정했을 때
1. CPU가 P1을 처리하던 중 운영체제에 의해 인터럽트가 발생	
2. P1이 유후 상태로 변경
3. 스케줄러는 레지스터에 있는 처리중인 작업정보를 P1의 PCB에 저장
4. P2의 PCB에 저장된 정보를 레지스터에 로드 -> CPU는 작업 정지(이렇게 어떤 처리를 하는데 간접적인 처리시간과 메모리가 소요될 경우 '오버헤드가 발생한다 라고 함')

멀티 스레드를 처리할때도 콘텍스트 스위칭이 일어나지만(스택을 제외한 힙, 데이터, 코드영역을 공유하기때문에) 시간과 메모리를 적게 소모한다

CPU에서 처리중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유는 PCB에 프로그램 카운터와 스택 포인터 값이 저장되어있기때문임.
- 프로그램 카운터: <mark class="hltr-cyan">프로세스가 이어서 처리해야하는 명령어의 주소 값</mark>
- 스택 포인터: <mark class="hltr-cyan">스택 영역에서 데이터가 채워진 가장 높은 주소 값</mark>. 데이터가 스택에 어디까지 채워져있는지를 알수있음

