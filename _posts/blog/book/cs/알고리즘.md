# 정렬 알고리즘
## 비교 기반 알고리즘
### 버블 정렬
- <mark class="hltr-cyan">양옆에 위치한 두 값을 비교하면서 크기순으로 정렬</mark>
- 연속 인덱스 a, b가 있을때 b>a면 정렬되었다고 봄. 작으면 a, b의 위치를 교환
- 배열의 n번째요소를 정렬하는데 n-1번 비교 -> n(n-1)/2만큼 연산 수행
- O(n<sup>2</sup>)
- 비교적 느린편이지만 별도의 메모리공간이 필요하지않음
### 선택 정렬
- <mark class="hltr-cyan">배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값을 선택해 위치</mark>시킴
- 오름차순이라면 배열의 첫번째에 최솟감. 두번째에는 최소값 다음으로 작은 값 위치

|     |     |     |       |       |
| --- | --- | --- | ----- | ----- |
| 5   | 3   | 8   | ==1== | 2     |
| 1   | 3   | 8   | 5     | ==2== |
| 1   | 2   | 8   | 5     | ==3== |
| 1   | 2   | 3   | ==5== | 8     |
| 1   | 2   | 3   | 5     | ==8== |
- 위의 표처럼 배열을 순회하며 각 인덱스에 최솟값을 위치시킴.
- 배열의 크기가 n일때 i에 들어갈 숫자를 찾기위해 n-1개의 값을 비교 = n(n-1)/2
- O(n<sup>2</sup>)
### 삽입 정렬
- 배열을 앞에서부터 순회하며 정렬된 부분의 적절한 위치에 값을 삽입
- 인덱스 i의 a를 정렬할때 i-1은 정렬된 상태임. 정렬부분에서 a보다 작거나 같은수와 a보다 큰수사이에 a를 삽입

|     |       |       |       |       |
| --- | ----- | ----- | ----- | ----- |
| 5   | ==3== | 8     | 1     | 2     |
| 3   | 5     | ==8== | 1     | 2     |
| 3   | 5     | 8     | ==1== | 2     |
| 1   | 3     | 5     | 8     | ==2== |
| 1   | 2     | 3     | 5     | 8     |

- i의 적절한 위치에 삽입하기위해 n-1번 탐색 = n(n-1)/2
- O(n<sup>2</sup>)
### 합병 정렬
- 재귀를 이용
- 분할 정복 알고리즘
- <mark class="hltr-cyan">분할은 배열을 쪼개는것. 정복은 분할한 배열을 정렬하며 하나로 합병</mark>
- 정렬하려는 배열을 크기가 0 or 1이될때까지 절반씩 분할, 하나의 배열로 합하며 정렬
- O(n long n)
### 퀵 정렬
- 분할정복 알고리즘
- 피봇이라는 특정 값을 선택해 피봇보다 작은값, 큰값으로 배열을 분할해 정렬함
- <mark class="hltr-cyan">분할은 배열의 크기가 1이하가 될때까지 반복수행.</mark>
- 만약 피봇으로 배열의 가장 큰수 or 작은수를 선택하면 배열분할에 실해함. => O(n<sup>2</sup>)
- <mark class="hltr-cyan">피봇값이 무엇이냐에따라 퀵 정렬의 성능이 좌우됨</mark>
### 힙 정렬
- <mark class="hltr-cyan">최대 힙이나 최소 힙 자료구조를 이용해 정렬</mark>
- 최대힙으로 오름차순, 최소힙으로 내림차순 정렬을 함
- 과정 : 배열 -> 힙 변경(힙생성알고리즘) -> 힙 요소 정렬 
	- 힙생성 알고리즘: 특정 노드의 두 자식 노드 중 우선순위가 더 높은 자식의 노드와 위치를 교환
- O(n log n). 힙 생성 알고리즘이 O(log n), 전체 정렬에 O(n log n)
## 비교하지않는 정렬 알고리즘으로 나뉨
### 기수 정렬
- <mark class="hltr-cyan">낮은 자리수부터 정렬 수행</mark>
- 숫자별로 버킷이라는 큐를 생성 -> 각 자리수에 해당하는 숫자를 버킷에 넣고 자릿수만큼 반복
	- 73, 21, 56, 13 .. 등의 수가있을때,
	  0~에서 9까지의 버킷을 생성, 1의자리수별로 버킷에 분류 배분 -> 버킷의 숫자를 배열에 넣음
	  -> 버킷을 십의자리수 기준으로 다시 생성 -> 분류 배분 -> 배열에 넣음
- 데이터 개수 n, 최대 자리수 d. O(dn)
### 계수 정렬
- <mark class="hltr-cyan">데이터의 개수를 세서 정렬</mark>
- 데이터범위를 인덱스로 갖는 빈 배열을 생성(데이터 범위가 0~99라면 크기가 100) -> 정렬하려는 배열을 순회해 데이터에 해당하는 인덱스 값 1씩 증가
- 데이터 개수 n, 최대값 k. O(n+k)
- 최대값이 무한이라면 무한대로 수렴함.
- 데이터범위만한 배열을 생성해야하니 추가 메모리공간 사용

# 최소 신장 트리
- 신장트리: 모든 정점을 포함하는 트리
- 최소 신장 트리: <mark class="hltr-cyan">가중치가 있는 그래프에서 간선의 가중치 총합이 가장 작은 신장트리</mark>

## 프림 알고리즘
- 그리디 알도리즘(탐욕 알고리즘): 각 단계에서 최선의 선택이 모여 전역으로 최적의 해결방안을 찾음.
	  - 앞에서 선택한 결과가 나중 선택에 영향을 주면안됨
	  - 지역적인 문제에대한 최선의 해석이 전역적 문제에서도 최선의 해석이어야함
  - 수행과정
	  ![[Pasted image 20250514161152.png]]
	  1. 최소신장트리를 찾을 그래프로, 시작정점이 S
	  2. 정점 S에서 탐색 가능한 정점은 A, B, C. 각 정점은 각각 가중치 3, 6, 13인 간선과 연결됨. 가장 작은 가중치인 3인 간선에 연결된 정점 A를 트리에 추가
	  3. 정점 S와 A에서 탐색가능한 정점은 B,C,D. 각 정점과 연결된 간선의 최소 가중치는 13, 4, 18. 가장 작은 가중치인 5인 간선으로 연결된 정점 C를 트리에 추가
	  ... 반복

## 크루스칼 알고리즘
- <mark class="hltr-cyan">간선을 오름차순으로 정렬, 가중치가 낮은 간선을 선택하며 최소 신장 트리를 생성</mark>
- 특정 간선을 선택했을 때 사이클이 생성된다면 해당 간선은 선택하지않고 다음으로 가중치가 낮은 간선을 선택
- 가중치의 오름차순으로 간선을 연결하는 알고리즘과 사이클의 생성을 판단하는 유니온 파인드 알고리즘을 함께 사용
	- 유니온 파인드 알고리즘
		- 2개의 원소(노드)가 같은 집합(그래프)에 속하는지 판단.  루트노드가 없어 대표 노드를 설정해 그래프를 구분.
		- 유니온: 두 노드를 하나의 그래프로 합치는 연산
		- 파인트: 특정도느가 속한 그래프의 대표노드를 찾는 연산
- 수행과정
	1. 전체에서 가중치가 가장작고 D-C를 잇는 간선 선택
	2. 가중치가 그다음으로 작은 3선택. A-S
	3. 가중치가 그 다음으로 작은 5 선택. A-C
	4. 가중지가 그다음으로 작은 6을 선택해야하나 이것을 선택하면 S-A-C사이 사이클이 형성됨.
	   -> 다음으로 작은 7을 선택
	5. 9를 선택 => 모든 정점이 연결되었으니 종료

## 최단거리 알고리즘
- 정점간 최단거리를 구하기위한 알고리즘.
### 다익스트라 알고리즘
- <mark class="hltr-cyan">간선의 가중치가 음수가 아닌경우 특정정점에서 다른 정점까지의 최단거리를 구함</mark>
- 시작정점 설정+방문가능하며 비용이 가장적게드는 정점에 방문
- 각 정점의 비용에 우선순위 큐를 사용해 시간복잡도 효율
- 작동 방식
	1. 초기에 시작정점에서 방문 가능한 정점에대한 비용 갱신, 나머지 정점에 대한 비용은 무한대로 설정
	2. 방문하지않은 정점중 가장 비용이 적게드는 정점 방문. 해당정점과 연결된 다른 정점의 비용 갱신 필요여부 확인 ->  기존보다 적다면 비용 갱신
	3. 모든 정점 방문까지 정점방문기용을 갱신하며 모든 정점 방문시 종료
	![[Pasted image 20250514162613.png]]
		1. S에서 시작, 3 선택.
		2. S에서 다음으로 작은 비용인 13. 도착한 D에서 B로가는비용 10 => S->B= 13, S->D->B=13 비용갱신 필요없음
		   그러나 S->C=15, S->D->C=9. 비용갱신 필요, 
		   또한 S->D->E = 11. 무한대보다 적음. 비용갱신 필요
		3. 방문하지않은 접점중 가장 작은 비용인 A로 이동. 같은 방식으로 계산

### 벨만-포드 알고리즘
- 특정 정점에서 다른정점까지 최단거리를 구함
- <mark class="hltr-cyan">가중치가 음수라도 적용</mark>됨
- <mark class="hltr-cyan">음의 사이클이있으면 최소비용이 무한하게 줄어들어 알고리즘 적용 불가</mark>
- 그래프 정점 수가 n일때. 전체 간선을 n-1번 순회해 최단거리 갱신.
- 만약 n개이상의 간선을 사용했을때 최단거리가 갱신된다면 음의 사이클이있다는 의미라 사용할 수 없음
- 수행과정
	![[Pasted image 20250514164529.png]]
	1. 시작정점 S. 나머지 정점에대한 거리는 무한대
	2. 첫 순회. S기점으로 각각 최단거리 계산
	3. 첫 순회. D-A, D-E 탐색. S->A=11, S->B->D->A=6. 비용 갱신. S->E는 갱신안함
	4. 두번째 순회. S->A, S->B탐색
	5. 두번째 순회. S->B->D->A가 6이니까 A->E는 3. 그럼 S->B->D->A->E는 9로 갱신
	   S->B->D->A->E->C는 7이니까 갱신.
	6. (정점 수 - 1) 만큼 반복해야하니 5번까지 순회한다 - 해당예에서는 두번째이후로 비용이 갱신되지는않음
1. 