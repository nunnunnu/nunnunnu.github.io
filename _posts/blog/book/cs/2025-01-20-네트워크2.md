---
title: "[기술 면접 대비 CS전공 핵심 요약집] 네트워크 2"
category: CS
tags:
  - cs
  - 네트워크
  - 책요약
---
![image](https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791140706129.jpg)

## UDP
- TCP와 마찬가지로 전송계층에 해당하는 네트워크 프로토콜.
- <mark class="hltr-cyan">송신부와 수신부 간 연결을 지원x, 데이터그램 형태의 통신을 지원</mark>
- 별도의 과정없이 패킷을 바로 송수신 -> <mark class="hltr-cyan">신뢰성이 낮지만 속도는 빠름</mark>
- 특징
	- 송/수신부의 연결이 보장되지않는 비연결형 서비스
	- 패킷이 서로 다른 회선으로 교환될 수도 있음
	- 송신부에서 전달한 패킷 순서와 수신부에서 받은 패킷 순서가 다를 수 있음
	- 패킷 수신여부 확인 x
	- 1:1, 1:N, N:N 모두 가능
	- 데이터 신뢰성 낮음
	- 데이터 전송 속도 빠름

| 구분       | TCP      | UDP           |
| -------- | -------- | ------------- |
| 연결 방식    | 연결형 서비스  | 비연결형 서비스      |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식      |
| 전송 순서    | 순서 보장    | 순서 보장x        |
| 수신 여부    | 확인       | 확인안함          |
| 통신 방식    | 1:1 통신   | 1:1, 1:N, N:N |
| 신뢰성      | 높음       | 낮음            |
| 속도       | 느림       | 빠름            |

### 오류 검출
- 최소한의 신뢰성 보장을 위해 체크섬 방식으로 오류를 검출함.
- 체크섬
	- 데이터 무결성을 보장하는 간단한 방식
	- 체크섬을 만들기위한 데이터를 모두 더함 -> 캐리(2진수 덧셈 연산 시 오버플로(자리수 넘어감)) 발생 시 해당 캐리를 떼서 데이터에 다시 더함 -> 1의 보수를 취해 체크섬 생성
		![image](/assets/images/cs/IMG-20250520211222-3.png)
	- UDP 통신부가 UDP의 헤더, IP 헤더의 일부정보(발신 IP 주소, 수신 IP주소, 프로토콜 ID 등)와 데이터로 체크섬 값을 생성. 생성한 체크섬 값을 UDP헤더의 체크섬 영역에 넣어 수신부에 전송 -> 수신부가 체크섬의 모든값을 더해 비트가 모두 1인지(송신부와 동일한 체크섬 값이 나오는지) 확인
	- 100프로 오류 검출은 불가능. 값을 더하는 방식이라 순서가 바뀌거나 오류가 발생해도 체크섬이 같을 수 있음
	- 선택사항이라 송신부에서 0 으로 보내면 수신부는 검사하지않음

---
# HTTP
- 데이터 전송하기위한 프로토콜. TCP/IP 4계층에서 응용계층.
- 특징
	- 비연결성
		- <mark class="hltr-cyan">클라이언트에서 요청을 보낸 후 서버로부터 요청을 받으면 연결을 끊음</mark>
		- 불특정 다수를 대상으로 하는 서비스에 유리(자원을 아낄수 있기때문)
		- 서버가 클라이언트를 기억할 수 없음
		- 동일 클라이언트에서 연속 요청이 오면 연결/연결 해제 과저을 반복해 자원이 낭비됨 
		  => HTTP Keep Alive(HTTP연결시 일정시간동안 요청을 유지하는 HTTP헤더의 일종. 클라이언트에서 요청을 보낼때 연결 헤더에 keep Alive를 추가하면 서버에서 연결을 유지할 시간을 Keep Alive 헤더에 추가해 응답)를 사용해 동일 클라이언트로 요청이 오면 연결과정을 생략해 단점 보완
	- 무상태
		- <mark class="hltr-cyan">서버에서클라이언트 상태를 저장하지 않음</mark>
		- 클라이언트에서 요청에 필요한 모든 데이터를 가지고있어야함(쿠키, 세션에 저장)
		- 서버 확장성이 높음. 요청에 응답하는 서버가 달라져도 문제없음.
- HTTP 메세지
	- 클라이언트와 서버의 통신을 위해 정형화된 데이터인 HTTP 메세지를 주고받음
	- 구조
		- 요청 라인(request line):요청 URI, 요청 방법, HTTP 버전 등을 포함
		- 응답 라인(response line)/상태 라인(status line): 요청에 대한 HTTP 상태코드, HTTP 버전 포함
		- 헤더(header): 키-값으로 구성된 다수의 헤더 항목으로 구성
		- 빈 줄(blank line): 헤더의 끝을 나타내는 빈 줄로, 헤더와 바디를 구분
		- 바디(body): 요청할 때는 POST인 경우에만 바디가있고 나머지는 비운채로 전달된다
- HTTP상태코드
	- 1XX: 요청받아서 처리중
	- 2XX: 성공
	- 3XX: 요청 처리를 위해 추가 처리 필요
	- 4XX: 클라이언트 오류
	- 5XX: 서버오류

## HTTPS
- <mark class="hltr-cyan">보안계층인 SSL/TLS를 이용해 HTTP의 보안을 강화한 웹 통신 프로토콜</mark>
- HTTP는 데이터 암호화를 거치지 않고 전송하기때문에 보안에 취약함 -> 이를 보완한 HTTPS 등장
- HTTPS에서 통용되는 방식은 TLS지만, SSL이라는 명칭이 사라지지 않아서 SSL 또는 SSL/TLS라고 부름
	- 암호화
		- SSL: 넷스케이프에서 개발한 암호화 프로토콜인데 출시당시 몇가지 문제점이 있었음
		- TLS: SSL를 보완해 개발한 새로운 암호화 포로토콜
- 계층
	- HTTP
		- 응용계층 - HTTP
		- 전송계층 - TCP
		- 인터넷 계층 - IP
		- 네트워크 인터페이스 계층 - 네트워크 인터페이스
	- HTTPS
		- 응용계층 - HTTP
		- 보안계층 - SSL/TLS
		- 전송계층 - TCP
		- 인터넷 계층 - IP
		- 네트워크 인터페이스 계층 - 네트워크 인터페이스
- 동작방식
	- 데이터 송신 시 응용 계층에서 보안계층의 SSL/TLS로 데이터를 보냄 -> 데이터를 암호화 해 전송 계층으로 전달 -> 데이터 수신 시 전송계층에서 보낸 데이터를 보안계층에서 받아 복호화
		- SSL/TLS 암호화 방식
			- 대칭 키 암호화
				- 암호화/복호화에 같은키인 대칭키를 이용.
				- 수신자가 가진 키를 송신자에게 전송(수신자가 같아도 송신자가 다르면 키는 다름) -> 송신자가 받은 키로 데이터를 암호화 해 전송 -> 수신자가 동일 키로 복호화 
				- 유출 위험 있음
			- 공개 키 암호화
				- 데이터의 암호화와 복호화를 다른키로 함.
				- 암호화할때는 공개키를, 복호화할때는 비밀키 사용
				- 수신자가 공개키를 송신자에게 전송(수신자가 누구든 같은 키) -> 송신자가 수신자에게 받은 키로 암호화 해 데이터 전송 -> 수신자가 비밀키로 복호화
				- 비밀키가 있어야한 복호화가 가능해서 유출위험 없음

## 웹 페이지 접속 과정
1. 사용자가 URL을 웹 브라우저에 입력
2. 웹 브라우저는 입력한 URL을 바탕으로 DNS 서버에 연결할 IP를 요청
3. DNS서버가 IP주소를 웹 브라우저에 응답으로 제공
4. 웹 브라우저가 DNS서버에서 받은 IP를 통해 웹 서버와 TCP/IP를 연결, HTTP 요청
5. 웹 서버가 받은 요청에 응답.(웹 페이지, 필요 리소스 포함)
6. 웹 브라우저가 받은 응답을 바탕으로 페이지 로딩

---
# REST(Representational State Transfer)

- 용어 정리
	- URI: 인터넷에 있는 자원을 나타내는 주소. 인터넷에서 요구하는 기본조건으로 인터넷 프로토콜에 항상 붙어다님. 하위개념으로 URL, URN이 있음
	- URL: 인터넷에서 자원의 위치를 알 수 있는 규약. 웹사이트 주소와 인터넷의 모든 자원을 나타낼수있음
	- URN: 자원의 위치정보가 아닌 실제자원을 특정
- HTTP 통신을 활용하기 위해 고안된 아키텍처
- 자원을 명시해 연산을 수행하고 상태를 주고받음
- Representational: 인터넷상 자원을 URI로 나타낼 수 있음. 클라이언트는 URI로 표현된 자원을 HTTP 메서드를 이용해 CRUD 연산을 할 수 있음
- State Transfer: 자원의 상태를 주고받는것.
- 특징
	- 일괄된 인터페이스: 자원을 나타내는 URI를 HTTP 메서드로 조작하는 일괄된 인터페이스를 사용, HTTP를 따르는 모든 플랫폼에서 REST 사용 가능
	- 클라이언트 - 서버 구조: 클라이언트와 서버 간의 요청-응답의 독립적 구조를 가진다. 클라이언트는 서버에 요청을 보내고 응답을 대기. 서버는 자원을 가지고있으며 클라이언트의 요청에 응답
	- 무상태성: 서버에서는 클라이언트의 요청을 저장/관리하지 않음. 요청에 대한 처리와 응답만 함. 인증/로그인 정보는 클라이언트에서 직접 관리
	- 캐싱 가능: HTTP 표준을 사용하므로 클라이언트는 전에 서버로 받은 응답을 저장/재사용하는 캐싱을 할 수 있음. -> 서버 부하를 줄이고 클라이언트는 비교적 빨리 응답 가능
	- 자체 표현 구조: REST API는 자원, 행위, 표현으로 구성되어 REST API 메시지를 보고 어떤 요청을 하는지 알 수 있다
	- 계층형 구조: REST 서버는 다중 계층으로 구성될 수 있어서 보안, 암호화 같은 계층을 추가해 서버에 대한 기능을 유연하게 확장 가능
- HTTP를 기반으로 해 별도의 인프라를 구축할 필요X
- HTTP메서드를 사용해 자원에대한 연산을 처리하므로 동작이 한정적임

## REST API
- REST를 기반으로 한 API.
- API: 다른 소프트웨어에 서비스를 제공하기 위한 소프트웨어 인터페이스
- <mark class="hltr-cyan">REST API는 REST를 기반으로 한 인터페이스</mark>
- 구성
	- 자원 - URI
	- 행위 - HTTP 메서드
	- 표현 - JSON, XML 등
- 작동방식
	![image](/assets/images/cs/IMG-20250520211223.png)
		1. 클라이언트가 URI로 식별한 자원에 HTTP 메서드를 사용해 REST API로 요청
		2. REST API가 HTTP 요청메세지에 실려 서버로 전달
		3. 서버에서 수신한 HTTP 요청 메세지를 바탕으로 요청 사항을 확인, 처리, HTTP 응답 반환(처리성공여부, 정보 포함하여 응답)
		4. 응답 메세지는 자원에 대한 정보를 JSON or XML 등의 형태로 포함. 클라이언트는 해당 정보를 수신
- RESTful
	- REST규칙을 지키며 API를 제공하는 서비스.
	- 규칙
		- 자원에대한 행위는 HTTP 메서드로 나타냄. HTTP 메서드나 행위에 대한 표현이 URI에 들어가면 안됨
		- HTTP 메서드는 명시적이여야함. 요청하려는 목적에 맞게 HTTP 메서드를 사용
		  POST로 Create 뿐만 아니라 Update 같은 연산을 하면 명시적이지 않음
		- URI 경로는 /로 계층관계 표현, URI 마지막에 슬래시가 들어가면 안됨
		- URI 경로에 _ 사용 X, 소문자 사용 지양
