---
title: "[개발자를 위한 코딩테스트] 기술면접 2"
category: CS
tags:
  - cs
  - 책요약
last_modified_at: 2024-10-23
---

#### 장애 처리
>![문제8]
>
>지원자가 해온 업무 중 가장 어려웠던 상황이나 큰 성장을 한 상황

##### DB 개선

**인덱스**

인덱스가 제대로 최적화 되지않으면 쿼리실행 속도가 느려지고 애플리케이션 로드에 지연이 발생할 수 밖에없다
보통은 어떤 컬럼 조건이 자주 조회되는지를 확인해 인덱스를 추가하고 쿼리 실행계획으로 비효율적인 인덱스 설정을 모니터링해 올바르게 인덱스를 수행한다

즉, 테이블 스캔은 db가 테이블의 모든 블록과 페이지를 읽어야함으로 디스크 I/O가 많이 발생하는데 인덱스를 사용하면 인덱스가 저장된 데이터 구조를 이용해 데이터를 검색함으로 디스크 I/O가 적게발생한다

또한 데이터를 빠르게 찾아올수있어 시스템 리소스를 효율적으로 사용가능하다

다만 과도한인덱스(자주검색되어야 하며 카디널리티가 높아야하는데 고려되지않음)는 DML시 오버헤드가 발생할 수 있다

또한 조회조건이 지나치게 많다면 인덱스 부여시 성능감소의 원인이되기도하며 단일 인덱스를 여러개 만드는 것 보단 다중 칼럼으로 좁은 인덱스를 구성하는게 낫다

- 인덱스를 타지않는 케이스
	- 인덱스 칼럼을 변경하는 조건절
		- where substring(cloum1) = value
		- where concat(colum1, ',', colum2)
	- 부정형 비교를 사용한 경우: Not In, !=, >, <(간혹 타기도하니 실행계획 참조)
	- 와일드카드 like문장의 전체범위 지정: where column like '%2023'
	- 인덱스 컬럼의 형변환

**실행 계획**

SELECT 쿼리 앞에 EXPLAIN 구문을 통해 검증 중요한곳은 <font color="#c00000">EXPLAIN Join Types</font>다
- select type

| select type 명                        | 설명                                                          |
| ------------------------------------ | ----------------------------------------------------------- |
| <font color="#4bacc6">SIMPLE         | 가장 일반적인 select</font> 문. 복잡한 UNION이나 서브쿼리가 없는 경우.<br>가장 빠르다 |
| <font color="#4bacc6">PRIMARY</font> | 복잡한 쿼리에서 최상위 쿼리문인경우                                         |
| SUBQUERY                             | select문 안에서 서브쿼리를 사용                                        |
| DEPENDENT SUBQUERY                   | 서브쿼리가 외부 쿼리로부터 값을 참조하여 실행                                   |
| <font color="#4bacc6">DERIVED</font> | FROM절에서 쓰인 서브쿼리(인라인뷰)                                       |
| UNION                                | UNION또는 UNION ALL 사용                                        |
| DEPENDENT UNION                      | UNION의 서브쿼리가 외부 쿼리로부터 값을 참조하여 실행                            |
| UNION RESULT                         | UNION의 결과로 생성된 임시테이블에 대한 SELECT문을 실행                        |

DEPENDENT UNION과 UNION RESULT는 쿼리가 독립적으로 실행되지 못하고 메인테이블로부터 값을 공급받는 구조이기때문에 성능적으로 좋지않아 튜닝대상이다

UNION ALL을 사용하거나 인덱스 사용을 확인하고 서브쿼리 최적화를 통해 대상의 크기를 줄여야하며 JOIN을 사용할 수 있다면 JOIN을 고려해야함

type은 테이블이 행을 조회하는 방식을 나타내기에 접근방식이 효율적인지 판단하는 근거가된다
ALL, INDEX는 성능상 문제가 가능성이 높은 항목이다

- join type

| type명                               | 설명                                                                            |
| ----------------------------------- | ----------------------------------------------------------------------------- |
| <font color="#4bacc6">system</font> | 테이블에 단 한개의 행만 있는경우                                                            |
| <font color="#4bacc6">const</font>  | 테이블의 Unique Key 혹은 Primary Key를 상수로 조회하는 경우(한건만 존재)                           |
| <font color="#4bacc6">eq_ref</font> | 다른 테이블과 join시 Primary Key를 이용(한건 조회)                                          |
| ref                                 | 다른 테이블과 조인시 인덱시에 설정된 모든 칼럼을 조회조건으로 사용<br>(사용되는 키 조건이 몇개의 행에 일치하는경우. 최소 두개 이상) |
| fulltext                            | 풀텍스트 인덱스를 사용하여 수행                                                             |
| ref_or_null                         | ref와 동일하지만 null값이 포함됨. MySQL에서는 NULL에 대해서도 인덱스를 활용할 수 있고 이때 null은 가장 앞쪽에 정렬됨  |
| index_merge                         | 단일 테이블의 여러 범위의 행을 스캔한 결과를 하나로 병합                                              |
| unique_subquery                     | In절의 서브쿼리에 eq_ref를 적용                                                         |
| index_subquery                      | In절의 서브쿼리에 PK가 아닌 인덱스 적용                                                      |
| range                               | 인덱스의 지정 범위 안의 행을 검색(BETWEEN, LIKE, In, <, >, <=, >= ...등)                     |
| index                               | 단일 인덱스의 일부만 충족할 경우(테이블 풀 스캔보다는 유리하지만). 물리적인 인덱스 블록을 처음부터 끝까지 탐색               |
| all                                 | 테이블 풀 스캔. 테이블의 처음부터 끝까지 탐색. 전체테이블 중 10~20프로 정도를 조회할때는 오히려 유리할때도 있음            |

- 실제 실행계획 열 설명
  
	![image](/assets/images/note/IMG-20250521152701-2.png)
	
	- possible_keys: 옵티마이저가 SQL 튜닝을 위한 후보 인덱스를 보여줌(실제 사용한거 아님)
	- key: SQL문에서 사용한 인덱스 키를 의미. 어떤 인덱스를 사용했는지 확인하고 다른 인덱스를 유도하거나 사용되지 않았다면 인덱스를 선택하도록 튜닝 가능
	- key_len: 인덱스의 바이트를 의미. int의 경우 4바이트, varchar의 경우 단위당 3바이트
	- ref: 테이블 조인을 수행할 때 어떤 조건으로 해당 테이블에 조인할건지 알려줌
	- rows: SQL문이 접근한 모든 데이터 행수를 예측해서 나타내는 정보
	- filtered: SQL을 통해 가져온 대상 데이터가 필터 조건을 통해 어드정도 제거되었는지 퍼센트 단위로 알려줌
	- extra: SQL문을 어떻기 수행할 것인지를 나타냄. 보통 Using temporary, Using filesort 정도가 튜닝대상으로 알려져있음

- extra 타입 종류

| Extra 명                                                  | 설명                                                                                                                                                                                                 |
| -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <font color="#4bacc6">Using index</font>                 | 인덱스를 사용해 쿼리를 처리. 일반적으로 인덱스를 사용하는게 좋지만 일부는 사용하지 않는게 더 효율적일 수도 있다.<br>ex. 인덱스를 사용하는데도 대량의 데이터를 검색할때 -> 테이블 스캔을 피하기위해 인덱스 조정<br>물리적으로 인덱스의 사이즈가 작고 정렬이 되어있다면 성능상으로 효율적임                               |
| Using index for group-by                                 | Group by나 Distinct 구문으로 그룹화 작업이 수행될 때, 인덱스를 사용하는 것. 그룹화 작업을 취적화하거나 인덱스를 활용해 성능을 개선할 수 있는지 확인                                                                                                       |
| Using where Using index condition                        | 쿼리에서 WHERE절을 처리하는 방식을 나타내며 필요한 경우 WHERE절 조건 항목들을 최적화하여 인덱스를 효과적으로 사용하도록 변경하거나 불필요한 조건을 줄이는 작업을 고려                                                                                                  |
| Using sort_union()                                       | 병합 작업에서 정렬을 수행하는 것. 성능상 문제가 될 여지가 있다면 정렬을 최적화하여 성능을 향상시킨다                                                                                                                                          |
| Using join buffer(Block Nested Loop, Batched Key Access) | 조인 수행 중 중간 데이터 결과를 저장하는 조인 버퍼를 사용한다는 의미. 성능을 개선하기 위해 조인 버퍼 크기를 조정하거나 인덱스를 사용해 조인버퍼 크기를 최적화해야할수도있음                                                                                                  |
| Using join buffer(Block Nested Loop)                     | 조인 수행 . 중중간 데이터 결과를 저장하는 조인 버퍼를 사용. 성능을 향상시키기 위해 조인 버퍼의 크기나 조인방식을 조정해야할 수도 있음                                                                                                                      |
| Using temporary                                          | 데이터 중간결과를 저장하고자 임시테이블을 사용. 임시테이블은 메모리나 디스크에 생성되어 쿼리 결과를 저장하는 용도로 사용된다. 임시 테이블을 사용하는 것은 성능에 영향을 줄 수 있어 쿼리를 재작성하거나 인덱스를 추가하여 임시테이블의 필요성을 줄일 수 있다<br>보통 Distinct, Group by Order by 구문 등이 포함 된 경우 출력됨 |
| Using fileSort                                           | 정렬 작업을 위해 파일 정렬을 수행하는 것. 이미 정렬된 인덱스를 사용하면 추가적인 정렬작업이 필요없지만, 인덱스를 사용하지 못할 경우, 정렬을 위해 메모리에 올리므로 성능에 부담이 갈수도 있음. 정렬이 필요한경우 인덱스를 올바르게 사용(or 이미 정렬된 인덱스를 생성)하거나 정렬을 애플리케이션에서 최적화하는 등의 방법을 고려            |

 ![image](/assets/images/note/IMG-20250521155343-1.png)
 
이 실행계획을 예시로 보면
- t 테이블
	- **`ALL`**: `t` 테이블에 대해 **풀 테이블 스캔**이 발생(`PRIMARY` 키가 명시돼 있지만 **실제로는 인덱스를 사용하지 않고 전체 테이블을 읽는 중**)
	- **`Using where`**: 조건절(`WHERE`)이 적용되어 필터링을 하고 있음을 의미
	- **`Start temporary`**: **임시 테이블의 생성을 시작**했음을 뜻()
	=> 성능 개선 여지가 있는 부분: `t`의 `WHERE`절에 맞는 인덱스가 없는지 확인. 인덱스를 잘 잡아주면 `ALL` 대신 `range`나 `ref`로 변경될 수 있음
- pc 테이블
	- **`ref`**: 인덱스를 사용하여 해당 키 값과 일치하는 레코드를 찾는 방식
	- **`Using index` 없음**: `Extra`에 아무런 인덱스 관련 정보가 없지만, `ref` 타입이라면 일단 **해당 FK 인덱스는 사용되고 있음**(`t.tag_seq` 값을 통해 외래키(FK) 인덱스를 사용)
	- `Extra`에 추가 메시지가 없다는 것은 불필요한 정렬이나 임시 테이블 없이 처리된다는 뜻으로 **상대적으로 성능에 문제 없음**.
- u 테이블
	- **`ALL`**: `u` 테이블 **풀 테이블 스캔 중**
	- **`Using where`**: 조건 필터링 적용 중
	- **`End temporary`**: 임시 테이블 사용이 **종료되었음**을 의미
	- **`Using join buffer (hash join)`**:
		- 조인 작업 중 **해시 조인** 방식으로 조인 버퍼를 사용한다는 의미
		- 인덱스를 이용한 조인이 아닌 경우 사용되며, 일반적으로 성능이 나쁠 수 있음
		- **조인 조건이 인덱스를 활용할 수 없다**는 것을 암시

DB는 테스트시 비슷한 사양의 DB를 사용하면 비용부담이 크기때문에 사양비 비슷한 스테이지 장비에 데이터 덤프 등을 활용해 성능테스트 전용 DB를 만드는 것을 추천.

힘들다면 개발용 장비에 더미 데이터를 생성한 후 인덱스 실행계획과 쿼리 수행속도를 점검

실습을 해보고싶다면 다양한 예제가 있는 [업무에서 바로 쓰는 SQL 튜닝](https://product.kyobobook.co.kr/detail/S000001810409) 책을 추천

**커넥션 사이즈 조절**

커텍션을 얻기위한 대기시간 증가를 막기 위해서 쿼리튜닝과 성능 테스트를 반복해 커넥션의 적정한 사이즈를 확보해야함

초당 요청 쿼리 수 산정 -> 애플리케이션의 최대 피크 시간을 감안한 사이즈를 설정(성능테스트로 가능가능, DB성능 감안)

**중복 쿼리 제거**

가장 간단하면서 큰 효과를 볼 수 있는 방법으로. 애플리케이션에서 DB에 접근하는 횟수를 줄이고 인덱스 Hint을 등을 통해 응답시간을 개선

그렇기에 중복쿼리를 제거하고 캐싱을 도입하면 성능을 끌어올릴 수 있음

로직 레벨에서 처리할 수 있는것들은 최대한 로직에서 처리한다

join 구문이 많고 depth가 깊다면 애플리케이션에서 이 조인관계를 풀어주고 따로 호출한다

그 후 각 데이터를 머지하거나 대상 테이블을 로직단위에서 추리고 2차로 db를 호출해 건수를 줄일 수 있다

조인관계를 풀어내는 것은 MSA 설계시 레거시 테이블을 분리하는 전략으로 유용하게 사용되는 기법 중 하나이므로 반드시 기억해두자

**캐싱**

데이터 사이즈는 크지만 잘 변경되지않는 경우. 코드 성 테이블은 캐싱 솔루션을 도입해 성능 향상을 꾀할 수 있음
별도로 redis를 구축하거나 Ehcache나 멤캐시드 같은 인메모리 캐싱을 통해 API콜이나 DB데이터 검색 횟수를 줄이는 방식.

- reids: db보다 빠르고 서버측의 부담을 줄여주지만 별도 장비를 구축해야하고 커넥션을 맺는 과정에서 네트워크 비용을 고려해야한다
- Ehcache: 멤캐시드에 비해 고급기능이많고 단순하고 가벼워 분산환경에서 많이쓴다. 

수용자가 수백, 수천만을 대상으로하는 서비스는 아키텍처가 다름. 분산 처리할 대상 서비스도 늘어나고 서버를 용도에 맞게 분리하기도 하고 db복제 기능을 필수로 마련함. RDBMS가 아닌 다른 용도의 DB형 솔루션을 추가하거나 비동기로 처리해야하는 포인트도 늘어남

**대용량 테이블의 처리 기법**
- Write, Read 분리/복제
	가장 많이 사용하는 기법. 대부분의 db는 리플리케이션(복제)를 자체적으로 지원하기 때문에, 몇가지 설정만으소 쉽게 적용가능함. 리플리케이션은 보통 원본 데이터를 복사하여 리얼 타임에 근접하게 다른 물리 db에 자동으로 적재해 가용성과 안정성을 확보하기 위해 쓰인다
	
	주용도는 백업/복구인데 대량데이터 처리를 위해 사용가능하다
	
	보통 리플리케이션은 Read/Write를 수행하는 마스터 DB와 이 데이터를 복제하는 역할인 읽기전용 슬래이브 db장비들로 구성됨.
	
	대용량 테이블을 조인해 수행하는 데이터 분석이나 사이즈가 큰 데이터들을 조회해 큐와 같은 별도의 애플리케이션에서 전송해야할 때, 트랜잭션이 일어나고있는 마스터 DB에 접근하면 DB성능 저하가 우려된다. 실제 서비스는 마스터 DB를 바라보고있으므로 장애부담이 있을 수 있다
	
	![image](/assets/images/note/IMG-20250521152701-4.png)
	
	이럴때 읽기 전용으로 구축한 슬레이브 db에서 조회 위주의 작업을 수행하게함으로 마스터의 사용 리소스를 분담가능하다
	
	db는 애플리케이션 서버와 다르게 운영중에 스케일업이 어려움. 따라서 리플리케이션을 확장해 가상 IP로 묶어 HA(High Availability)로 구축하는 것이 일반적임
	
	슬레이브 장비들을 스케일 아웃으로 구성해 운영하는것도 하나의 확장방식임. 단, 슬레이브  사양이 낮으면 실시간 복제 시 복제 지연이 발생할 가능성이 높고, 대량 데이터 처리 시 버퍼 오버플로가 발생할 수 있음
	HA는 새로 네트워크가 변경되어 슬레이브가 마스터 역할을 하기까지 시간차로 발생하는 네트워크 단절(순단)이 발생하고 이 순단시점에는 데이터 소실이 있을 수 있음
	
	따라서 마스터-슬레이브의 사양차이를 최소화해야한다
- 파티셔닝
	하나의 테이블을 여러개의 작은 단위로 분할에 제약조건에 따라 저장/보관
	물리적으로 분할하는것이 아닌 논리적으로 분할. 다만 실제데이터들은 여러개의 물리파일로 분리되어 보관됨
	
	성능관리 효율을 향상하고 쿼리조건을 기반으로 데이터를 분리하면 슬로우 쿼리 해결에 도움이됨
	
	테이터 사이즈가 시간에 비례해 늘어난다거나 데이터가 큰 테이블에 select, insert, update가 빈번하게 일어나서 인덱스 역시 영향을 받을거라 예상된다면, 파티셔닝을 통해 인덱스를 분할하는 효과도 기대가능
	
	- 수직 분할: 테이블 칼럼을 기준으로 나눔
	- 수평 분할: 데이터개수를 기준으로 나누고 이를 통해 인덱스 성능을 끌어올림
	  
	단, 테이블간의 비용 증가, 애플리케이션 복잡도 증가가 유발되므로 어떤 전략을 선택할지 따져봐야함
	
	```sql
	CREATE TABLE tablename(
		id INT NOT NULL AUTO_INCREMENT,
		data DATE NOT NULL,
		value INT NUL NULL,
		PRIMARY KEY(id)
	) PARTITION BY RANGE(value) (
		PARTITION t0 VALUES LESS THAN (10000),
		PARTITION t0 VALUES LESS THAN (50000),
		PARTITION t0 VALUES LESS THAN (100000),
		PARTITION t0 VALUES LESS THAN MAXVALUE
	)
	```

- 샤딩
	아무리 조회조건을 잘걸고 인덱스를 태우고 파티셔닝까지 해도 물리적인 데이터 그기가 방대하면 해결이 안될수도있다
	
	이럴때 사용하는 방법으로 DB증설과 샤딩이있다
	
	데이터를 분할하여 저장하는 방식으로 동일 DB에서 테이블을 논리적으로 분리하는 파티셔닝과 다르게 샤팅은 서로 다른 물리DB에 분할하여 저장한다
	
	큰 사이즈의 테이블을 여러개의 DB로 분할하여 각각의 데이터베이스에서 처리할 수 있는 양의 효율화를 추구, 성능 및 확장성의 향상을 목표로 함
	
	- 모듈러 샤딩: 데이터베이스를 균등하게 분할하기위해 키의 모듈러 연산을 통해 결정
	- 레인지 샤딩: 키의 범위로 데이터베이스를 분할
	  
	DBMS에서 지원되는 스펙이 아니라 애플리케이션 레벨에서 구현해주어야함
	
	보통은 테이블을 분석해 샤딩 키를 기준으로 범위를 나누어 테이블 PK와 같은 키값 베이스로 데이터를 저장하거나 해시로 변환해 균등 분산저장하는 방식으로 개발한다. 진행시 기존 데이터는 대상데이터에 맞게 마이그레이션 한다
	
	마이그레이션이 끝나고 샤딩데이터를 사용할 수 있게되면 원본 DB, 샤딩 DB 양쪽에 저장한다.
	애플리케이션에서 분할 저장이 안정화되면 양쪽에 저장하는 부분을 제거한다
