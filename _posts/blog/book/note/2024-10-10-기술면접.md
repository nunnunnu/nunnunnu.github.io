---
title: "[개발자를 위한 코딩테스트] 기술면접"
last_modified_at: 2024-10-14
category: CS
tags:
  - cs
  - 책요약
---

- 추천 가능한 연습
	- MySql 쿼리로 수십~수백만 데이터를 생성한 후 데이터 전송 테스트
	- 수백만건의 미가공 데이터를 .sql파일로 만들어 서버 기동시 .sql파일을 읽어와 MQ로 전송하는 애플리케이션
	- Consumer를 통해 해당 메세지를 추출해 DB에 삽입
  => 데이터가 많아질때 문제점. Consumer에 데이터를 100프로 전송하기위한 처리방식. 데이터가 서로맞지않을때 sync방법
- 자기소개 전 고민할 것들
	- 부각 시키고 싶은 프로젝트나 기술/경험을 소개하거나 소개방식의 전략
	- 자신의 커리어가 회사에 어떤 영역에 기여가능한지
	- 서류가 왜 통과되었는가?
		- 해당 부서와 기술 베이스의 적합성과 역량이라면 -> 커뮤니케이션 방식 중요(태도, 열정, 협업능력) => 핵심 위주로 대화하듯이 타인에게 설명하는 연습 필요
	- 관심있거나 자신있는 분야에 흥미를 가지고 질문할수있도록 자기소개로 유도
		- 본격적인 기술면접에서는 지원자와 면접관이 기술적 흥미와 관심사에 대해 토론하는 자리로 만들어야함
		- 의도파악이 안되거나 궁금한점이 생기면 질문하고 재확인해 능동적으로 참여
- Q&A에서 고민할 것들
	- 입사하게된다면 어떤업무?
	- 어떤 기술사용중인지?
	- 어떤 역할을 해야하는지?
	- 일하는 방식/사용 툴
	- 운영중인 업무의 수치 데이터
	- 사용자는?
	- 올해잡은 목표?
- 기술면접에서 물어보는 영역 분류
	- CS, 알고리즘, 자료구조
	- CPU, 메모리
	- 데이터베이스, 트랜젝션
	- 네트워크와 인프라
	- 시스템 디자인, 엔티티설계
	- OOP와 대표적인 디자인 패턴
	- 소프트웨어 공학
	- 문제해결
	- 개발언어
	- 프레임워크
	- 애플리케이션 장애 트레킹과 문제해결, 성능향상 튜닝
	- 비동기 아키텍처에 대한 이해
	- 마이크로 서비스 아키텍쳐(MSA)
- 자주나오는 질문
	- 프로세스와 스레드
	- 동시성과 병렬성
	- 데드락, 트랜잭션, 격리레벨, 트랜잭션 락
	- DROP과 TRUNCATE의 차이
	- JPA 1차/2차 캐, OSIV, N+1문제
	- JPQL과 QueryDsl
	- 브라우저에서 도메인 호출 후 페이지 랜딩되기까지 아키택처/흐름
	- Map, Set, List
	- 스택, 큐
	- 트리/ 힙
	- 해시 맵/ 해시 테이블
	- HTTP/HTTPS
	- CORS
	- 기본키, 외래키, 복합키
	- 테이블, 인덱스, 인덱스 활용
	- Mutable, Immutable
	- 세션, 쿠키, 세션스토리지
	- IoC, DI
	- 필터, 인터셉터
	- 프레임워크, 라이브러리
	- RESTful 아키텍처
	- 프록시/리버스 프록시
	- SQL 인젝션, XSS
	- OAuth, JWT, Token
	- 마이크로서비스 아키텍처
	단순 개념 암기를 넘어 동작 방식을 이해하고 어떤 상황에서 써야하는지를 설명하는것이 중요

[저자의 깃허브 링크](https://github.com/haru-note/tech-interview)

[저자의 깃허브 링크2](https://github.com/haru-note/spring-amqp-sample)

연차기준으로 이력서의 특이사항을 포착해 높은 수준의 질문 -> 답변이 꼬이면 점점 낮은 단계의 질문으로 내려감
만약 기대이상의 답변이온다면 높은 단계의 질문 -> 폭넓은 유관 지식을 물어봄

5년차 미만의 주니어에게 아키텍처 설계나 도메인 설계를 깊에 물어보는 경우는 본인이 적어놓지않은 이상 거의 없을것

---
>[문제1]
>
>'나의 구매목록 조회' 시 초반에는 데이터가 적어 페이지 로딩이 빨랐지만 시간이 지나 억단위의 데이터가 생성되면서 조회할때마다 페이지 로딩이 느려질때, 로딩시간 개선을 위해 해야할 것은?


  - 책 설명
	주니어 레벨에서 접근 가능한것은 기간별 데이터 파티셔닝으로 구조를 개선하는 법.
	쿼리 최적화나 인덱스 적용은 문제의 본질을 해결하지못함
	
	억단위의 데이터가 생겼다는것은 데이터가 더 증가할수있다는 의미라 쿼리개선이나 인덱스 적용은 일시적인 해결책에 불과함. 근본적인 구조 개선+비지니스 로직에서 연도/월별 검색을 위한 테이블 파티셔닝 필요
	
	결론적으로 면접관이 물은 것은
	
	<mark class="hltr-cyan">테이블 파티셔닝에 대해 설명해주세요.</mark> 일 확률이 높다!
	
	<mark class="hltr-red">개념 질문을 잘 하지않고 하더라도 개념간의 차이를 구분해서 적용가능한지를 판단하려하지 단순개념을 물어본다면 다음 질문을 위한 사전질문일 확률이 높음</mark>!
	
	지식을 연계해서 설명가능해야함.
	
	그 개념을 어디에 적용가능한지, 어떤 효과를 기대하는지, 어떤 문제를 해결할수있는지를 파악하고자함
	기준에 맞게(문제에선 기간) 파티셔닝 -> 인덱스를 구조에맞게 재생성 -> 쿼리 튜닝 -> 테스트
	<mark class="hltr-cyan">기존 테이블과 병행 운영하다 페이드아웃하는 전략</mark>도 설명가능함
	
	그래도 안되면 API와 로직 튜닝을 통해 효율적인 호출방식 고려, 테이블 엑세스 횟수 감소 방식 고려필요
	
---
>[문제2]
>
>블로킹과 논블로킹, 동기와 비동기의 차이를 설명하고 개념을 적용할 수 있는 구체적인 사례를 설명해보세요
		  
- 블로킹: 호출된 함수가 작업을 마칠때까지 제어권을 가지고있고, 호출한 함수는 대기중
- 논블로킹: 호출된 함수가 제어권을 바로 리턴하고, 콜백할때까지 호출된 함수가 다른 일을 수행
- 동기: 호출되는 함수의 작업 완료 여부를 호출한 함수가 체크
- 비동기: 호출되는 함수의 작업 완료 여부를 호출한 함수가 체크하지않음. (별도의 스레드로 빼서 실행/완료하면 호출하는 측에 알림)
  
![image](/assets/images/note/IMG-20250521152443.png)


이제 실무에서 어떻게 쓰이는지를 알아야한다

MSA환경으로 대형 서비스들이 체질 개선을 하면서 자바진영의 HTTP client 모듈도 RestTemplate(멀티 스레드, 블로킹)에서 WebClient로(싱글 쓰레드: 코어당 1개, 동기/비동기 둘다 지원, 논블로킹)방식의 기술로 대체되어가며, RestTemplate는 스프링 5.0부터 ddeprecated되어 WebClient의 사용이 권장됨

또한 하나의 서비스가 여러 서비스를 호출하는 MSA기반의 API호출로 바뀌다보니 네트워크 지연에 민감해지고 호출결과의 응답시간에 부담이 증가(MSA나 분산환경을 적용한 아키텍처는 시스템이 무겁고 데이터가 많다는 것을 전제하기 때문에, 속도 측면의 성능 관리가 중요)

=> 기본적인 로직만 처리한 후 나머지 부분은 비동기로 전환해 큐를 발급하거나 별도의 처리를 해주되, 뒷단에서의 처리와 상관없이 클라이언트에 응답을 바로 내려주는 형태로 개발방식도 변화함. 그런 뒤 화면 별로 뿌려야 할 영역별로 api 호출을 나눠 먼저보여지는 영역은 클라이언트 화면에 로드해온다면 더 늦게 로드되는 페이지도 기다림없이 순차적으로 전환될것

개념과 차이, 어떤 기술에 적용되는지 숙지해야 제대로 된 설명이 가능.
단순 개념을 묻는 게 아니라는걸 기억할것!

---
#### 성능 개선
>[문제3]
>
> 동시성과 병렬성에 대해 설명하고 각각의 구현이 적합한 프로세스나 상황에 대해 설명해주세요

>[문제4]
>
>현재 서비스하고있는 DB의 테이블을 비정규화해서 분리하기로했다고 가정, 대량의 데이터 중 요건에 부합하는 테이블과 일부 데이터를 가공하여 배치를 통해 이관하고자 함. 이관 실행 시간을 계산할 때, 충분한 기간을 확보하지 못한다면 어떤 방식으로 처리해야 속도가 빨라지겠는가?

문제3은 문제 1과 비슷한 개념의 질문, 문제4는 문제 3의 확장 질문임
데이터 덤프나 복제관리나 백업 질문이 아닌
<mark class="hltr-cyan">데이터 처리량을 늘리기 위해 어떤 프로그래밍 방식을 사용할지</mark>를 묻는 것.

동시성보다는 병렬성의 질문이고, 운영 레벨에서 트래픽이 몰리지않는 시간대에 배치를 통해 점진적 이관/효율적 작업 시간(처리)에 대한 지원자의 지식과 노하우에 대한 질문

- 동시성
	독립적이고 작업시간이 비교적 짧은 경우 유용함.
	
	논리적 개념이기에 단일 스레드에서 사용 가능.
	
	초기 멀티태스킹은 동시성 개념을 통해 여러 프로세스가 동시에 수행되는것 같은 결과물을 만들 수 있음
	수많은 요청에 빠르게 응답해주어야할때, 네트워크 응답이나 DB자원 반환과 같은 작업을 각 클라이언트 별 요청에 대한 별도의 스레드처리로 빠르게 처리 가능
	
	웹 서버의 경우, 여러 클라이언트로부터 요청을 받아 처리해야하고, 각 요청이 독립적으로 수행되어야하기때문에 동시성 고려필요
	- 수행 속도
	  
	  동시성은 스레드 풀을 사용해 작업을 분산시키므로, 여러 작업이 동시에 실행될 수 있음.
	  
	  하지만 실제로 동시에 실행되는 스레드는 CPU코어에 수에 제한됨
	  
	  스레드 수가 적을때는 상대적으로 수행속도가 느릴 수도 있음
	  
	- 처리 자원
	  
	  동시성은 스레드 풀을 사용해 작업을 처리함으로 적은 수의 스레드로 많은 작업을 동시에 처리 가능. 
	  이로인해 메모리와 CPU자원을 효율적으로 사용가능.
	  
	  하지만 스레드 컨텍스트 스위층이 발생할 수 있으며 추가적인 오버헤드가 발생할 수 있음
	  
		- 스레드 컨텍스트 스위칭
			- **CPU/코어에서 실행중이던 스레드가 다른 스레드로 교체**되는 것
			- 이 때 두 스레드는 같은 프로세스에 속할수도, 다른 프로세스에 속할 수도 있다.
			- 여러 프로세스/스레드를 동시에 실행시키기 위해 필요하다.
- 병렬성
  
	동시성과 다르게 실제로 동시에 여러 작업을 연산하는 것을 말한다
	
	단일 스레드에서는 사용이 불가능하고 다중 스레드가 필요하다
	
	사용방법에 따라 데이터 병렬성과 작업 병렬성으로 나눌 수 있다
	
	- 데이터 병렬성: 단일 작업을 여러개로 쪼개어 연산 -> 하나의 작업에 대한 빠른 처리결과
	- 작업 병렬성: 독립적인 작업을 각 스레드에서 담당하여 연산 -> 단일 스레드에 단일 작업을 하는것과 동일한 결과
	  
	대량의 데이터를 동시에 처리하여 빠르게 결과를 얻고자할때 유용함.
	
	예를들면, 배치로 대량의 데이터를 마이그레이션할때 병렬로 CPU코어를 최대한 활용해 처리시간을 단축할 수 있음.
	
	연산이나 대량의 처리에 적합해 SQL의 처리, 이미지 프로세싱 등에 유리할것.
	
	- 수행속도: 자바에서 병렬성은 포크-조인 프레임워크를 사용하여 작업을 병렬로 분할해 CPU코어를 최대한 활용하는 상황에 적합. 병렬처리를 위해 여러 스레드 또는 프로세스를 사용하므로, 코어의 수에 따라 선형적으로 수행속도 증가
	- 처리자원: 여러개의 스레드/프로세스를 동시에 실행하기에 동시성에비해 더 많은 CPU자원을 요구한다. CPU코어의 수에 맞게 스레드나 프로세스를 관리하므로 자원할당과 관리에 주의

작업의 수가 많고 병렬적으로 처리할수 있음 -> 병렬성이 빠르고 효율적일 가능성 높음

작업의 수가 적거나 스레드나 프로세스 생성에 부가적 오버헤드가 발생함 -> 동시성 고려


![image](/assets/images/note/IMG-20250521152454.png)


---
>![문제5]
>
>예상했던 양보다 훨씬 많은 데이터가 테이블에 쌓이면? 어떤 문제가 발생하나?
>그리고 어떻게 해결하나?

문제1과 동일한 맥락이다

- 고려대상
	- 파티셔닝 전략: 테스트 방향에대한 고려도 있다면 좋음. 파티셔능을 통한 속도 개선을 단순 구조변화만 고려하는것이 아니라 추가적인 필요조치를 같이 설명
		- 인덱스 설계
		- 파티셔닝 전략
		- 정규화/비정규화(역정규화)
		- 쿼리 최적화
		- 캐싱
		- 백업/복구
		- 데이터 마이그레이션 테스트
		- 기타 스케일 아웃(수직, 수평)에 대한 아키텍쳐 이해
	- 키 전략
	- 데이터의 이전
	- 인덱스의 재생성으로 인한 효율적 처리

레거시 시스템의 문제점+ 해결책 + 어떤 솔루션을 적용할 수 있는지 경험이나 지식을 묻는 것.

하나의 정답이 아닌 여러 해결법이 존재함

튜닝, 조회, 구조의 관점에서 여러가지 개선사항을 적용가능함

최소한 데이터가 쌓일때의 문제점+해결책 등을 고민해봐야한다는 뜻

---
#### 웹 환경 아케텍처
>![문제6]
>
>1. 다양한 클라이언트 디바이스(웹, 모바일, 태블릿)에서 서버를 호출할때 일반적인 3 tier환경에서 동작하는 전반적인 프로세스에대해 설명해주세요
>2. 그중 특정한 디바이스 or 메뉴에서 트래픽이 월등히 증가해 서버의 부하가 걸린다면 어떤방식으로 아키텍처를 구성/변경할까요?

1. 일반적인 3 tier 환경: 클라이언트가 HTTP 호출 -> 애플리케이션 서버 -> DB 엑세스(+DNS나 L7의 역할, LB 등의 역할) (+방화벽, CDN, DB의 리플리케이션 정도를 설명한다면 만족스러운 답변이됨)
2. 부하분산에대해 고민해보았는지, 비슷한 문제를 경험했는지, 해결책을 제시할수있는지를 묻는것
	점진적인 구조적 개선을 고민해보았는지, 데이터 및 트래픽 부하 분산에 알고있는지를 알아보기위한 질문

##### - 점진적 고도화와 대량 트래픽 처리 방법과 개념

웹 페이지와 서버 프로그램의 개발이 한영역에 가까웠던 과거와 달리 REST API가 대두된 후 프론트엔드와 백엔드로 분리됨.

REST활성화 이후 ESB나 SOAP같은 복잡한 웹서비스를 대체할 수 있게됨

REST기반 스킬셋으로도 복잡한 웹 환경 지원, Server to Server 환경 통신, 역할을 나눠 결합도 낮추고, 응집도 높이기 가능(다양한 디바이스 별 프론트 화면 개발 분리)

- REST API: URL을 통해 HTTP 요청을 전송/ 서버에서 처리한 결과를 HTTP 응답으로 받는 인터페이스. Client Server, Server to Server 둘다 가능

![image](IMG-20250521163501.png)

view 페이지가 존재한다면 별도의 프론트 서버를 통해 렌더링할수도있고, 서버측에 URL을 호출해 응답객체를 받아 담을수도있다

모던 아키텍쳐들이 MSA나 클라우드 환경으로 이식되며 웹 서버와 애플리케이션 서버들은 스케일아웃이 용이한 구조여야한다

또한 프론트단에는 라우팅이나 방화벽같은 네트워크 요소들이 존재할것이다

그밖의 I/O 처리를 줄이기 위해 애플리케이션에서 메모리 캐시를 쓴다거나 별도의 부하분산을 위해 레디스나 메세지 큐를 활용해 캐싱, 처리성능 향상과 비동기 처리를 지향하는 구조로 확장 가능

최근엔 서버 디스크 성능이 좋아져 I/O 비용의 획기적인 절감은 힘들지만 코드개선이나 아키텍처 개선에 중점을 두고 접근해야함

과거에는 모놀리식 방식의 구조가 대부분이었는데 서비스 스케일이 커지며 장점보다는 단점이 부각되었다(서버 빌드 시간 오래걸림, 재사용모듈 파악 힘듦, 중복코드 증가, 하나의 장애로 모두 먹통-> 스케일아웃 힘듦 등)

=> REST API로 서버단위로 트래픽 분산

![image](/assets/images/note/IMG-20250521152701-1.png)

업무를 도메인별로 쪼개기 어려운 구조라면 적절한 모듈 단위로 서버를 나누고 해당 모듈에 종속된 적합한 데이터 셋을 구성해주면 훨씬 분산시키기 쉬워진다

하루걸려 장애가 발생한다거나 기존방식으론 감당이안될것같다는 판단이 선다면 모듈단위의 서버분산과 데이터 분산을 고려해 위와같은 구조도 가능하다

- 읽기 전용 API와 업무에따라 특정 메뉴에서 조회해오는 클릭수가 많다면, 해당 API만 별도의 장비로 분리해 서비스할수도있다. 
  즉, 부분적 스케일 아웃이나 스케일 업이 가능하다
  하지만 이렇게되면 로그인이나 인증, 인가같은 권한 문제 발생가능성이 있다(감수할지 결정해야함)

웹 서버는 엔드포인트를 통일하고 라우팅하는 역할을 한다. 앱 푸시나 메일 전송 등 비동기로 호출해도될만한 성격의 API라면 MQ에 연결된 별도의 장비로 서비스가 가능해진다

DB는 DML명령어는 Master에 커넥션을, Read는 실시간 복제하는 Slave에 연결함으로 부하를 줄일 수 있다

하지만 데이터 처리량이 증가하면 서버도 터지지만 DB자체도 리플리케이션이 밀리는 상황이 발생할수있다 그래서 비동기처리를 적용하기도하고 NoSql과 같은 솔루션을 적용해 데이터 성격에 맞는 처리방식을 적용하기도 한다

데이터 처리가 많아져 실시간 복제가 느려질때, 애플리케이션에서 삽입 후 바로 데이터를 조회하여 Slave에서 데이터 복제 시간이 1~5초 정도 밀리기 시작한다. 이때 Slave 노드에서 SELECT 쿼리를 날리는 시점에 데이터가 존재하지않아 에러가 발생하는 경우도 더러 경험할 수 있다

이런경우가 운영경험없이 알수없는 대용량 트래픽을 받는 서비스를 운영하며 겪을 수 있는 트러블 슈팅이다

비동기를 위한 전용 장비까지 필요없다면 DB에 update, select 등의 데이터 처리까지 끝난 뒤에 다시 비즈니스 레이어까지 내려와 비동기로 메세지 큐를 발행할 수도 있다

아니면 서드파티에 연동해 데이터를 넘겨주거나 내부의 아키텍처가 MSA처럼 분산서비스일 경우 별도의 서비스에 넘겨주고 또 다른 처리를 요청할 수도 있다

---
>![문제7]
>
>새 프로젝트 오픈을 앞두고 성능 테스트를 하려한다.
>1. 성능테스트를 하는 이유
>2. 어떤 화면을 대상으로 해야하는지
>3. 테스트를 통해 확인해야할 서비스의 성능 지표

성능 테스트는 필수 절차는 아니나 견고한 서비스를 위해서는 하는것이 좋음

1. 병목지점과 비지니스 로직 상 무거운 로드를 식별해 사용자의 응답시간을 단축하고 서버 자원을 최적화 하기 위해서, 장애감지를 위한 임계치를 설정하는것. API한두개나 슬로우 쿼리 하나때문에 전체 서버가 터지는 경우 방지(대부분의 장애가 성능 테스트와 연관이있음)
	- 성능 테스트 툴: 특정 스크립트 언어로 동적을 정의해 주어진 조건에 따라 서버 호출(ex. 초당 사용자 100명 증가)
		- JMeter, <mark class="hltr-cyan">nGrinder</mark>(naver)가 부하테스트 툴로 많이 쓰임
	- 모니터링 툴: 애플리케이션 서버와 DB서버의 CPU메모리와 같은 리소스, 트래픽, 응답시간 측정, 로그 수집 등을 통해 서버 성능 지표 제공
		- 제니퍼, 와탭과 같은 APM, 데이터 독 등이 유명함. 유료 버전 도입이 어렵다면 <mark class="hltr-cyan">핀포인트</mark>, 스카우터 등의 적용을 고려
		- JConsole, 비주얼VM 같은 프로파일링 도구도 있으나 시각적인부분이나 기능적 이점은 APM을 따라오기 힘듬
	- 테스트 장비: 프로덕션 환경과 동일한 스펙의 전용 서버가 준비된 상태에서 외부 트래픽은 차단. 준비하기 어렵다면 서비스의 병목 지점 튜능, 슬로우쿼리 등을 확인하고 개선하는 정도로 쓸수있음
	- 작가는 nGrinder, 핀포인트 조합을 추천한다고 함
2. 사용자가 로그인 하고 난 뒤 첫번째로 진입하는 화면/ 여러 API를 묶어 결과물을 표현하는 페이지, 주요기능을 수행하는 API 기준
	- 첫번째로 진입하는 화면을 먼저 측정
	- 대시보드로 여러 데이터를 끌어와 보여주는 화면
	- 자체적으로 저리하는 API나 DB연동 등은 부하를 주며 테스트하는데 무리는없지만 회사 외부 연동의 경우 트래픽을 감장하기 어려울 수 있고 실제 외부 연동 애플리케이션 전용으로 Perf Zone을 구축하기는 어려움 -> 슬립을 주고 모의 데이터를 반환하도록 변경하는 형태로 테스트 필요
3. 트래픽이 몰리는 피크 뷰 페이지를 상정해 최대 유저 증가 수를 도출하기까지 시스템이 버티는지, 확장이나 개선이 필요한 부분을 측정하는 용도로 환경을 구축해야함
   Performance Test Zone 구성은 프로덕션 장비와 동일한 수준으로 구성해야함 성능이 다르면 식별하기 어려워짐
	- 요청에 대한 응답 시간 추이 분석
	- 최대 요청 임계치 분석
	- 개선 포인트 식별
	튜닝 전 기본설정을 기준으로 성능테스트를 돌린 후 N차수까지 반복하며 테스트 초기의 수지, 테스트 후 개선 한 수치 리포트를 관련 부서에 공유하면 1차 성능테스트는 성공한 것.
	이 시점에서는 최대 TPS 산정, 평균 응답시간, 최대 응답시간 등의 응답 분포도, 자원 사용량이 들어가야함
	만약 개선하고도 목표수치까지 도달하지 못한다면 시스템 사양 조정+캐싱+아키텍처 개선 등의 작업을 고려해야한다
	- 로그분석/성능테스트 모니터링으로 도출
		- 응답 시간 분포도
		- 최대 TPS산정
		- 커넥션 풀 산정
		- 최대 요청 임계치 분석/산정
		- 개선 포인트 식별
		- 외부 호출 API 전체 목록 도출
	- 개선 포인트
		- 슬로우 쿼리
		- 응답 대기 시간 증가 의심 구간 식별
		- 쿼리 튜닝
		- 테이블 관계 구조 개선/인덱스 변경
		- 중복 쿼리 제거, 불필요 로직 제거, 로직 튜닝
		- 커넥션 풀 사이즈 조정
		- 평균 응답 시간/최대 응답 시간
		- 시스템 사양 조정 필요 항목

여러번 반복하여 원하는 수준의 튜닝을 이루어야한다. 기준에 미달하면

캐싱/테이블 연관관계(구조) 개선, 비동기, 부하분산을 위한 아키텍처 검토 -> 서버 스케일 조정
을 진행한다

따라서 결론을 얻기위한 수치화 도출 항목은
- 서버 스펙
	- OS 및 DB 버전
	- 테스트 도구 및 방법
	- 네트워크 정보
	- 하드웨어 정보
- VUser 증가 추이 : 분당/조건당 순증 가상유저 기록
- 응답 시간: 평균 응답, 최소응답, 최대응답 기록
- QPS(초당 쿼리 수), TPS
- 예외, 오류 건수
- 자원 사용량: 모니터링 평균치, 최대치에 대한 수치
- 최대 응답 API 목록
- 슬로우 쿼리 목록
- 커넥션 풀 사이즈
- 네트워크 지연 측정
- 개선활동 상세 기록: 기본테스트 이후 개선 수치, 병목구간 위치, 응답시간 분포 수준 개선 수치
