[
  
  {
    "title": "[사이드프로젝트 aws배포] DNS발급/연결 & HTTPS 설정",
    "url": "/posts/domain_https/",
    "categories": "AWS",
    "tags": "aws, https, 배포",
    "date": "2024-04-20 00:00:00 +0900",
    





    
    "snippet": "도메인 발급사이드 프로젝트의 비용절감을 위해 무료로 도메인을 발급받을 수 있는 내도메인한국에서 도메인을 발급받음등록하기로 뜨는 test-domain.kro.kr 이 등록가능한 도메인임등록하기를 누르면 보안코드를 입력하고 도메인 관리에 선택한 도메인이 들어온걸 확인가능함EC2의 퍼플릭 IP를 이미 발급받은 상태이기때문에 IP연결에 예시로 로컬IP가 적힌...",
    "content": "도메인 발급사이드 프로젝트의 비용절감을 위해 무료로 도메인을 발급받을 수 있는 내도메인한국에서 도메인을 발급받음등록하기로 뜨는 test-domain.kro.kr 이 등록가능한 도메인임등록하기를 누르면 보안코드를 입력하고 도메인 관리에 선택한 도메인이 들어온걸 확인가능함EC2의 퍼플릭 IP를 이미 발급받은 상태이기때문에 IP연결에 예시로 로컬IP가 적힌 쪽에 퍼블릭 IP를 입력하고 저장해줌.이까지만해줘도 도메인으로 접속하면 api호출이 가능하나 http로 접속이된다는 문제가있음aws 사용 (최종 사용하지 않았음)인증서 발급AWS Certificate Manager에서 인증서 먼저 발급(단 클라우드 프론트(CDN)는 https를 적용하려면 미국 동부 버지니아\u001c북부에서 발급받아야함)도메인 이름에 발급받은 무료 도메인을 지정한 후 생성함route53에서 해당 도메인으로 생성하려했는데 aws에서 받은 도메인이 아니라그런지 생성이 안됨..그러나 인증서 요청 상세에서 저 route53에서 레코드 생성으로 생성하면 일단 생성이 가능함.또한 저기에있는 CNAME값으로 내도메인 한국의 CNAME에 값을 지정해주려고했으나실패함알고보니 내가 cname의 값을 무지성으로 복붙했는데 .은 떼고해야하는거였음^^..인증서 상태가 발급됨으로 바뀌었다면!이제 ec2로 가서 대상그룹 생성기본구성은 인스턴스로그리고 고급 상태검사 설정 -&gt; 재정의까지 해준 후 대상등록에서 인스턴스 선택 -&gt; 아래에보류중인것으로 포함 -&gt; 생성HTTPS 인증로드밸런서 생성아래와같이 선택한 후 네트워크매핑에서 매핑(2개이상은 해야한다고함)그리고 프로젝트에서 사용하는 보안그룹 선택리스너는 http와 https둘다 설정인증서 선택. 만약안뜨면 다시 발급받아야함route 53에서 생성한 도메인 클릭, 레코드 생성에서 www 레코드 생성해치웠나??????????/???????????????알고보니 path가 /인 api가 있어야 가능한것이었음getMapping으로 /가 path인 api를 생성하니 성공함!nignx/Let’s Encrypt 사용내도메인한국이 3개월단위로 새로운 도메인을 발급받아야한다고 함만료일전에 연장하면 1년사용가능하다는데 혹시모르니..그러나 사이드 프로젝트 정식 배포 후 백엔드 도메인을 정식으로 발급받게된다면 aws에서 인증서를 받아 다시 설정하게될수도있으나 지금은 해당 방법으로 배포를 진행하였다      nignx 설치    sudo apt-get install -y nginx nginx-common nginx-full        포트 포워딩    sudo iptables -t nat -L --line-numbers 으로 포트 포워딩 관련 정책 번호를 확인    num target prot opt source destination 형식으로 조회가 될텐데 첫번째 num의 위치에있는것이 포워딩 관련 정책번호임    sudo iptables -t nat -D PREROUTING {포트 포워딩 관련 정책 번호} 으로 정책을 제거        포워딩 코드 작성    sudo vi /etc/nginx/nginx.conf 으로 nginx.conf를 열어 아래코드를 작성함     user www-data;  worker_processes auto;  pid /run/nginx.pid;  include /etc/nginx/modules-enabled/*.conf;  events {}  http {      upstream app {          server 127.0.0.1:8080;      }      server {          # 80번으로 요청이 오면 8080번 포트로 변경하여 연결         listen 80; \t\t\t         location / {              proxy_pass http://app;          }      }  }            nginx 재시작    sudo service nginx restart        무료 인증서 발급                  apt-get update -y                    apt-get install software-properties-common -y                    apt-get install certbot -y                    sudo certbot certonly -d {\bdomain.com} --manual --preferred-challenges dns        순서대로 명령어 실행        그럼 이메일을 입력하라고 뜰건데 본인 이메일을 입력까지하면        이후로 약관이나 메일수신 등의 약관을 작성하면됨        그럼         Please deploy a DNS TXT record under the name      {hostName}.{domain} with the following value: {key} Before continuing, verify the record is deployed.  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - Press Enter to Continue                라고 뜰텐데        여기서 중요한것은 {hostName}과 {key}        내도메인 한국으로 돌아가서  ec2에 접속한 콘솔에서 축하메세지가 뜬다면 성공한것!                  포워딩 코드 수정    sudo vi /etc/nginx/nginx.conf     user www-data;  worker_processes auto;  pid /run/nginx.pid;  include /etc/nginx/modules-enabled/*.conf;  events {}  http {      upstream app {          server 127.0.0.1:8080;      }      server {          # 80번으로 요청이 오면 8080번 포트로 변경하여 연결         listen 80;           return 301 https://$host$request_uri;      } \t\t     server {          listen 443 ssl;          ssl_certificate /etc/letsencrypt/live/{도메인 URL}/fullchain.pem;          ssl_certificate_key /etc/letsencrypt/live/{도메인 URL}/privkey.pem;          ssl_protocols TLSv1 TLSv1.1 TLSv1.2;          ssl_prefer_server_ciphers on; ssl_ciphers ECDH+AESGCM:ECDH+AES256:ECDH+AES128:DH+3DES:!ADH:!AECDH:!MD5; \t\t\t         add_header Strict-Transport-Security \"max-age=31536000\" always;          ssl_session_cache shared:SSL:10m;         ssl_session_timeout 10m; \t\t\t          location / {              proxy_pass http://app;          }      }  }        그리고 인스턴스의 보안그룹-인바운드 규칙에서 HTTPS의 포트번호 443을 열어주어야함    이까지하면 http.domain.com 으로 접속하여도 https.domain.com으로 변경되는것을 확인할 수 있음  만약 도메인이 만료되어 갱신하여야한다면5-4와 6번 포워딩 코드의 {domain URL} 만 수정하면될것같다참고한 블로그  https://steady-coding.tistory.com/629"
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 15장 구글드라이브 설계",
    "url": "/posts/%EA%B5%AC%EA%B8%80%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EC%84%A4%EA%B3%84/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-30 00:00:00 +0900",
    





    
    "snippet": "책정보필요한 api는 단순업로드/이어올리기(네트워크중단가능성높음)/다운로드/갱신 임  블록저장소 서버 : 파일블록을 클라우드 저장소에 저장하는 서버. 파일을 여러 블록으로 나누고 각 블록에 고유 해시값이 할당됨.          최적화 방법                  델타 동기화 : 파일 수정시 전체파일이아닌 수정된 블록만 동기화          ...",
    "content": "책정보필요한 api는 단순업로드/이어올리기(네트워크중단가능성높음)/다운로드/갱신 임  블록저장소 서버 : 파일블록을 클라우드 저장소에 저장하는 서버. 파일을 여러 블록으로 나누고 각 블록에 고유 해시값이 할당됨.          최적화 방법                  델타 동기화 : 파일 수정시 전체파일이아닌 수정된 블록만 동기화          압축 : 블룩단위로 압축해두면 데이터크기를 줄일 수 있음                    flowchart TD파일--&gt;블록1--&gt;압축1--&gt;암호화1--&gt;클라우드저장소;파일--&gt;블록2--&gt;압축2--&gt;암호화2--&gt;클라우드저장소;파일--&gt;블록3--&gt;압축3--&gt;암호화3--&gt;클라우드저장소;  아카이빙 저장소 : 오랫동안 사용되지않은 비활성 데이터 저장  메타데이터 데이터베이스 : 사용자, 파일, 블록, 비전 등의 정보 관리. 실제파일은 저장소에있음  알림서비스 : 파일 추가/삭제 등 최신상태 확인용  오프라인 사용자 백업 큐 : 접속중이아니라 최신상태를 알수없을때 이 큐에 젛어 나중에 클라이언트가 접속했을때 동기화함    높은 일관성    RDBMS는 ACID를 보장해서 일관성보장이 쉬우나 NoSql은 프로그램안에 동기화로직을 넣어야함          RDBMS 테이블      유저      디바이스 : 단말정보 보관, 모바일 푸시알람여부도 여기에      루트디렉터리 정보      파일 : 최신정보가 보관됨      파일버전 : 파일 갱신이력이 보관됨      블록 : 특정버전의 파일은 블록은 올바른순서로 조립하면 복원가능함        업로드          메타데이터                  파일 메타데이터 업로드 요청          새파일의 메타데이터를 DB에저장, 업로드 상태를 대기중으로 변경          새파일 추가를 알림서비스에 통지          알림을 클라이언트에게 전송                    클라우드 저장소                  파일 업로드 요청          블록저장소 서버가 파일을 블록단위로 쪼갬-&gt;압축-&gt;암호화-&gt;클라우드저장소에 전송          업로드 완료시 클라우드스토리지가 완료 콜백 호출 -&gt; 콜백 호출이 api서버에 전송          메타데이터에 기록된 해당파일의 상태를 완료로 변경          알림서비스에 파일업로드 완료 통지          알림을 클라이언트에게 전송                      다운로드          알림서비스가 클라2에게 다른사용자의 파일변경알림      알림을 확인한 클라2가 새로운 메타데이터 요청      api서버가 db에 새메타데이터 요청, 클라2에게 반환      클라2가 즉시 블록 다운로드 요청 전송      블록저장소 서버가 클라우드저장소에서 블록 다운요청 -&gt; 클라2에게 반환      클라2는 반환된 블록으로 파일 재구성        [!NOTE]해당 서비스는 알람 서비스와 양방향 통신이 필요하지않기때문에 롱폴딩기법을 사용하는 것이 더 효율적임  저장소 절약          중복제거      지능적 백업 전략 도입                  한도설정(상한도달시 오래된버전 버림)          중요버전만 저장          자주쓰이지않는 데이터는 아카이빙저장소로 이동(ex. s3-&gt;s3글래시어)                      장애처리          로드밸런서 장애 : 부 로드밸런서가 트래픽을 이어받아야함. 로드밸런서끼리는 박동신호로 서로의 상태를 모니터링함      블록저장소 장애 : 다른서버가 미완료상태 작업을 이어받아야함      클라우드저장소 장애 : s3버킷은 여러지역에 다중화가 가능하니 다른지역에서 가져옴      api장애 : 로드밸런서가 해당 트래픽을 장애서버로 보내지않음      메타데이터 캐시 장애 : 캐시서버도 다중화      메타데이터 데이터베이스 장애 : 부or주데이터베이스로 교체      알림서비스 장애 : 모든 사용자와 하나씩 연결을 가지고있기때문에 하나의 서버에 장애발생시 모든 그 서버의 모든 사용자의 연결을 다시만들어야해서 복구가 느림      오프라인 사용자 백업 큐 장애 : 다중화해두어야함,      "
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 13장 검색어 자동완성 시스템&유투브 설계",
    "url": "/posts/%EA%B2%80%EC%83%89%EC%96%B4-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EC%8B%9C%EC%8A%A4%ED%85%9C&%EC%9C%A0%ED%88%AC%EB%B8%8C%EC%84%A4%EA%B3%84/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-30 00:00:00 +0900",
    





    
    "snippet": "책정보검색어 자동완성  기능          속도      연관성      정렬(인기순)      규모확장성      고가용성쿼리와 사용빈도를 저장하는 빈도테이블 생성하여 사용자가 입력한 검색어에 like문을 사용하여 빈도순으로 리턴하면되나 데이터가많아지면 병목가능성이있음        트라이 자료 구조        문자열을 간략하게 저장가능한 트리형태...",
    "content": "책정보검색어 자동완성  기능          속도      연관성      정렬(인기순)      규모확장성      고가용성쿼리와 사용빈도를 저장하는 빈도테이블 생성하여 사용자가 입력한 검색어에 like문을 사용하여 빈도순으로 리턴하면되나 데이터가많아지면 병목가능성이있음        트라이 자료 구조        문자열을 간략하게 저장가능한 트리형태의 구조              빈 문자열 - 빈노드로 표현  각 노드는 글자를 하나 저장. 26개의 자식노드를 가질 수 있음  노드는 하나의 단어or접두어 문자열을 나타냄flowchart TDroot--&gt;t--&gt;tr--&gt;tre--&gt;tree:10;tr--&gt;tru--&gt;true:35;tr--&gt;try:29;t--&gt;to--&gt;toy:14;root--&gt;w--&gt;wi--&gt;wis--&gt;wish:25;wi--&gt;win:50;사용자가 tr을 검색했을때 먼저 tr노드를 먼저 찾고 자식노드 중 유효 노드인 tree:10, true:35, try:29를 찾음.여기서 빈도로 정렬해여true, try, tree 순으로 검색어가 조회될것임성능 저하를 피하기 위해서는 접두어의 길이를 제한(검색기능 특성상 짧아도괜찮음)하거나 각 노드에 인기검색어를 캐시하는 것이 좋음. 캐시는 검색어별로 캐시를 하는것인데 저장공간이 많이소요됨. 그러나 속도가중요하다면 필수임검색 빈도수 업데이트는 로그를 활용하면 좋음데이터분석서비스 로그 -&gt; 로그취합서버 -&gt; 취합데이터 -&gt; 작업서버 -&gt; 트라이 데이터베이스(매주갱신) -&gt; 트라이캐시(매주 데이터베이스의 상태를 스냅샷)  갱신 주기: 해당 서비스의 성격에맞게 조절이필요하나 일반적으로 일주일이면 충분(실시간 서비스는 더 짧게)  작업 서버: 비동기적 작업(job)을 실행하는 서버집합.  트라이 데이터베이스 : 문서저장소(몽고DB), 키-값 저장소를 활용하면 좋음추가 성능 개선(최적화)  AJAX요청 : 페이지 새로고침x  브라우저캐싱 : 자동완성은 보통 짧은시간내에 자주바뀌지않음. -&gt; 브아루저 캐시에 넣어두고 해당 캐시에서 바로 사용(구글검색엔진 사용방법)  데이터 샘플링 : N개 요청 중 1개만 로깅트라이연산트라이 갱신에는 매주한번씩, 트라이의 각 노드별로 개별갱신(성능이안좋음) 2가지방법이있음  검색어 삭제 : 트라이캐시앞에 필터계층을 추가해 부적절한 데이터는 반환되지않도록 제거. 필터계층이있으면 검색결과를 필터규칙에따라 자유롭게 변경가능하다는 장점이있음저장소 규모 확장      데이터 샤딩 : 첫글자별로 샤딩. 최대 26개로 제한되는데 이 이상으로 서버를 늘리려면 샤딩을 계층적으로 해야함 -&gt; 샤딩한 서버별로 균등하게 데이터저장하는것이 불가능 -&gt; 샤딩 기준을 잘 잡아야함(1번서버는 A로 샤딩, 2번서버는 x~z로 샤딩 등)        추가 논의사항          샤딩을 통해 작업대상 데이터 양 줄이기      순위모델을 바꾸어 최근검색어에 가중치      데이터가 스트림형태로 올수도있음      유투브클라우드 CDN을 이용하여 비디오를 서비스할경우 CDN에서 나가는 데이터양에따라 과금이되는데 비용이 엄청날것으로 예상됨.   트랜스코딩(인코딩) 서버 : 비디오 포맷 변환 절차. 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공  트랜트코딩비디오 저장소 : BLOB저장소  CDN: 비디오스트리밍은 CDN을통해 이루어짐위 과정이 이루어지면서 병렬적으로 단말이 메타데이터 갱신요청을 api서버에 보냄. 요청에 포함된 파일이름/크기/포맷등의 정보로 캐시와 데이터베이스를 업데이트함  비디오 트랜스코딩(인코딩)          저장공간을 줄이기위한작업      하나의 비디오를 여러 포맷으로 인코딩해 호환성문제 해결                  컨테이너 : avi, mov, mp4          코덱 : H.264, VP9, HEVC                    사용자에게 끊김없는 비디오 호출을 위해 화질별 인코딩      네트워크상황에따라 화질자동변경/수동변경할수있도록 함        유향 비순한 그래프(DAG) 모델flowchart TD원본비디오--&gt;오디오--&gt;오디오인코딩--&gt;병합;원본비디오--&gt;비디오;원본비디오--&gt;메타데이터;비디오--&gt;검사/인코딩/섬네일추출/워터마크--&gt;병합;  검사 : 좋은품질의 비디오인지/손상여부 확인  인코딩 : 360p, 480p, 720p, 1080p, 4K 등  섬네일  워터마크 : 식별정보를 오버레이형태로 띄움    비디오 트랜스코딩 아키텍쳐  flowchart TD전처리기--&gt;DAG스케줄러--&gt;자원관리자--&gt;작업실행서버--&gt;인코딩된비디오;전처리기--&gt;임시저장소;작업실행서버--&gt;임시저장소;  전처리기          비디오 분할 : 비디오 스트림 GOP로불리는 단위로 쪼갬. 하나의 GOP는 독립적으로 재생가능하며 보통 몇초정도의 길이를 가짐(오래된단말은 지원안해서 전처리기가 대신함)      DAG생성      데이터 캐시 : GOP와 메타데이터를 임시보관소에 보관함. 만약 인코딩실해파면 임시보관소에서 꺼내서 재시도함        DAG스케쥴러 : DAG그래프를 몇단계로 분할해 그 각각을 자원관리자의 작업 큐에 집어넣음flowchart TD원본비디오--&gt;비디오추출--&gt;비디오인코딩;비디오추출--&gt;섬네일;원본비디오--&gt;오디오추출--&gt;오디오인코딩;원본비디오--&gt;메타데이터추출;  자원관리자          작업 큐 : 실행할 작업이 보관된 우선순위 큐.      작업서버큐 : 작업서버의 가용상태정보가 보관된 우선순위 큐      실행 큐: 현재실행중인 작업이 보관된 큐      작업 스케쥴러 : 최적의 작업/서버를 선택해 작업수행지시. 선택한 후 실행큐에 넣어서 실행을 지시함. 완료되면 실행큐에서 제거        작업서버 : DAG에 정의된 작업 수행    시스템 최적화    속도 최적화          비디오 병렬 업로드 : GOP를 분할해 병렬적으로 업로드하면 실패해도 빠르게 재시도가능      업로드센터를 사용자 근거리에 지정      모든 절차를 병렬화        안전성 최적화          미리 사인된 업로드 URL(아마존 S3에서 쓰이는 용어)                  클라이언트는 HTTP 서버에 POST요청을 하여 미리 사인된 URL을 받음. 해당 URL이 가르키는 객체에대한 접근권한은 이미 주어져있음          api서버는 미리사인된 URL을 돌려줌          클라이언트가 해당 위치에 비디오를 업로드                    비디오 보호                  DRM          AES암호화          워터마크                      비용최적화          인기있는 비디오는 CDN을 통해 재생, 다른 비디오는 디비오서버를 이용      인기없는 비디오는 인코딩이 필요없을수도있으며 짧은 비디오는 필요시 인코딩해도된다      특정비디오는 특정지역에서만 인기있음. 다른지역에 옮길필요x      CDN직접구축/인터넷서비스제공자와 제휴        오류 최적화              회복가능오류  회복불가능오류"
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 10장 알림 시스템 & 뉴스 피드 시스템 & 채팅 시스템",
    "url": "/posts/%EC%95%8C%EB%A6%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C&%EB%89%B4%EC%8A%A4-%ED%94%BC%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C&%EC%B1%84%ED%8C%85-%EC%8B%9C%EC%8A%A4%ED%85%9C/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-29 00:00:00 +0900",
    





    
    "snippet": "책정보알림 시스템 설계  iOS 푸시알람          알림 제공자 : 알림요청을 만들어 애플 푸시알림서비스로 보내는 주체                  단말토큰 : 알림 요청을 보내는 데 필요한 고유 식별자          페이로드 : 알림내용을 담은 JSON딕셔너리          APNS: 애플이 제공하는 원격 서비스. 푸시알람을 IOS장치로 ...",
    "content": "책정보알림 시스템 설계  iOS 푸시알람          알림 제공자 : 알림요청을 만들어 애플 푸시알림서비스로 보내는 주체                  단말토큰 : 알림 요청을 보내는 데 필요한 고유 식별자          페이로드 : 알림내용을 담은 JSON딕셔너리          APNS: 애플이 제공하는 원격 서비스. 푸시알람을 IOS장치로 보냄                      안드로이드 푸시알람          FCM : 푸시알람을 안드로이드장치로 보냄        SMS 메세지          트윌리오, 넥스모 같은 상용서비스를 사용해 메세지를 보냄(유료)        이메일 지원 알림 시스템          센드그리드, 메일침프 등 상용 이메일 서비스 사용.        연락처 수집 : 알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 등의 정보를 계정 등록시 DB에 저장  알림 전송 및 수신  하나 이상의 메세지 큐를 사용하여 알람 병렬처리 가능          안정성                  데이터 손실 방지 : 알림은 지연되거나 순서가 틀려도 괜찮지만 사라지면 곤란함. 알림 시스템은 알림 데이터를 DB에 보관하고 재시도 메커니즘을 구현해야함                    알림 중복 전송 방지                  분산시스템의 경우 중복전송되기도함. 그러나 완전히 막는 것은 불가능함. 빈도를 줄이기 위해서는 알림의 이벤트 ID를 검사해 중복 이벤트라면 버리고, 아니면 알림을 발송함                      추가 고려 사항          알림 템플릿 : 사전에 형식을 지정해서 알림을 보냄. 일관성 유지, 오류 가능성 감소, 알림 작성 시간 감소 등의 장점      알림 설정 : 사용자가 알림을 상세히 조정할 수 있어야함      전송률 제한 : 한 사용자에게 너무 많은 알림을 보내지 않도록. 너무 많은 알림이 가면 사용자가 알림을 꺼버림      재시도 : 알림 전송에 실패하면 해당알림은 재시도 전용 큐에 넣어 시도. 계속 실패하면 개발자에게 alert      푸시 알림/보관 : iOS와 안드로이드는 알림전송 API로 appKey와 appSecret을 사용해 보한을 유자하기때문에 인증/승인된 라이언트만 해당 api를 사용할 수 있음      큐 모니터링 : 큐에 쌓인 알림이 너무 크면 서버들이 이벤트 처리를 빠르게못하고있다는 뜻. 서버 증설이 바람직함      이벤트 추적 : 알람 확인률, 클릭율, 실제 앱사용 비율 등 이벤트 추적이 필요. 데이터분석서비스는 보통 이벤트 추적도 같이 제공함.      뉴스 피드 시스템 설계  포스팅 전송(팬아웃) 서비스 : 특정 사용자의 새 포스팅을 그 사용자의 친구에게 모두 전달하는 과정. 쓰기시점/읽기시점으로 나뉨          쓰기시점에 팬아웃 : 새로운 포스팅을 기록하는 시점에 뉴스피드를 갱신.                  읽는 데 드는 시간이 짧아지고 뉴스피드가 실시간 갱신, 즉시전송됨          핫키 문제 : 친구가 많은 사용자의 경우 목록에있는 사용자 모드의 뉴스피드를 갱신하는데 많은 시간이 소요됨.          서비스를 자주 이용하지않는 사용자의 피드도 갱신해야함                    읽기 시점에 팬아웃                  비활성or거의 사용하지않는 사용자의 경우 유리. 핫키문제도 생기지않음          뉴스피드를 읽는데 많은 시간이 소요될수도있음                          그래프 데이터베이스(친구관계/친구추천을 관리하기 좋음)에서 친구 ID목록 조회              사용자 정보 캐시에서 친구 정보 조회(사용자 설정에따라 일부 걸러냄-mute).              친구 목록/새스토리의 포스팅 ID를 메세지 큐에 넣음              팬아웃 작업 서버가 메세지 큐에서 데이터를 꺼내 뉴스 피드 데이터를 뉴스피드 캐시에 넣음(&lt;포스팅ID, 사용자ID&gt;의 순서쌍으로 보관)              사용자가 피드 읽기 요청을 보냄              로드밸런서가 웹 서버 중 하나로 요청을 전달              웹 서버가 피드 조회를 위해 뉴스 피드 서비스 호출              뉴스 피드 서비스가 캐시에서 포스팅 목록 ID목록 조회              뉴스피드에 표시할 사용자 이름/사진/포스팅컨텐츠/이미지 등은 사용자 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드를 생성              생성된 뉴스피드를 클라이언트에게 전송                                                      캐시구조                                       뉴스 피드(뉴스피드의ID)      뉴스피드                            콘텐츠      인기 콘텐츠      일반 콘텐츠                     소셜 그래프      팔로어      팔로잉                     행동      좋아요      답글      기타              횟수      좋아요횟수      답글횟수      기타      채팅 시스템 설계  제공 기능          클라이언트로부터 메세지 수신      메세지 수신자 결정 및 전달      수신자가 접속 상태가 아닐경우 접속할때까지 메세지 보관      메세지 송신은 HTTP프로토콜을 사용하는것이 효율적. 그러나 수신시에는 여러 기법이 제안되어있음(HTTP 프로토콜은 서버에서 클라이언트로 임의시점에 메세지를 보내는데 사용하기 어려움)메세지 수신 기법  폴링  클라가 주기적으로 서버에 새 메세지가 있는지 물어보는 방식  답해줄 새 메세지가 없는 경우에도 서버에 메세지가있냐고 물어보기때문에 서버자원이 불필요하게 낭비됨. 폴링비용은 폴링을 자주할수록 높아짐  롱폴링폴링을 보완한 기법. 클라이언트가 새 메세지여부를 서버에 물으면서 생긴 연결을 새 메세지를 받을때까지 계속 유지함. 받으면 연결 종료. 만약 오래동안 새 메세지가 오지않으면 연결을 타임아웃시킴 ^9c87fd          그러나 수신/전송 클라이언트가 같은 채팅서버에 접속하지않았을수도 있음. HTTP서버들은 보통 무상태 서버기때문에 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우 메세지를 받은서버 != 메세지를 수신할 클라이언트가 접속한 서버 일수도 있음      서버에서는 클라이언트의 연결유무를 알수없음      비효율적. 메세지를 많이받지않는 클라이언트도 타임아웃이 날때마다 주기적으로 서버에 다시 접속할것임        웹 소켓  서버가 클라이언트에게 비동기 메세지를 보낼때 가장 널리사용하는 기술.            연결은 쿨라이언트가 시작. 한번 맺어진 연경은 항구적&amp;양방향      처음엔 HTTP연결 -&gt; 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드됨. 웹 소켓은 80이나 443처럼 HTTP or HTTPS가 사용하는 기본포트번호를 사용해 방화벽이있는 환경에서도 잘 동작함      웹 소켓이 메세지를 양방향 전송해주기때문에 굳이 메세지 송신시에도 HTTP프로토콜을 사용하지않아도됨      설계안  무상태 서비스 : 로드밸런서 뒤에 위치  상태유지 서비스 : 채팅서비스는 상태유지가 필요함. 각 클라이언트가 채팅 서버와 독립적 네트워크 연결을 유지해야함(클라이언트는 서버가 살아있는 한 서버를 변경하지않음. 한서버에 몰리지않도록 관리해야함)  제 3자 서비스 연동 : 알림서비스. 앱이 실행중이아니라도 알람이 가야함  규모확장성  \u001f저장소 : 채팅이력 데이터의 양은 엄청남 + 대체로 최근 메세지를 사용함 + 그러나 검색기능/언급기능으로 무작위적데이터접근/특정메세지로 점프가 일어남=&gt; 키/값 저장소가 효율적          1:1 채팅을 위한 테이블      그룹채팅을 위한 테이블      메세지 ID -&gt; RDMS라면 auto_increment가 대안이나 noSql에서는 스노플레이크 or 지역적 순서번호 생성기(ID의 유일성은 같은 그룹 내에서만 적용함)를 사용하면 좋음        기능              1:1 채팅  그룹 채팅          소규모 채팅 : A가보낸 메세지를 B와 C의 메세지 동기화 큐에 전송      대규모 채팅 : 하나의 메세지 동기화 큐가 여러 사용자의 메세지를 수신할 수 있음        접속상태          사용자 로그인/로그아웃으로 접속상태 서버를 거쳐 접속상태 판단.      인터넷 연결 장애 발생 시                  박동검사 : 주기적으로 박동 이벤트를 접속상태 서버로 보내고 마지막 이벤트를 받은지 x초 이내에 또 다른 박동 이벤트를 받으면 접속상태 유지. 못받으면 오프라인 변환                    접속상태정보 전송                  소규모 환경 : 각각의 친구관계별로 서버생성.          대규모환경 : 사용자가 그룹 채팅에 입장하는 순간에만 상태정보를 읽게함/친구리스트의 접속상태를 갱신하고싶으면 수동갱신하도록 유도                      추가 고려 사항          미디어 지원. 미디어는 용량이 크니 압축/클라우드저장소/섬네일 생성등을 논의해야함      종단 간 암호화 : 메세지 발신인/수신인 외 아무도 못보게 암호화      캐시 : 이미읽은 메세지 캐시      로딩속도 개선 : 슬랙은 사용자 데이터/체널 등을 지역적으로 분산하는 네트워크를 구축하여 개선함      오류처리      메세지 재전송 : 재시도나 큐는 메세지 안정전송 보장을 위해 보편적으로 사용됨      "
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 9장 웹 크롤러 설계",
    "url": "/posts/%EC%9B%B9-%ED%81%AC%EB%A1%A4%EB%9F%AC-%EC%84%A4%EA%B3%84/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-28 00:00:00 +0900",
    





    
    "snippet": "책정보  웹크롤러(로봇, 스파이더라고도 불림) 이용 방법          검색 엔진 인덱싱(search engine indexing) : 크롤러의 가장 보편적인 용례로 웹 페이지를 모아 검색 엔진을 위한 로컬 인덱스를 만든다. googlebot은 구글검색엔진이 사용하는 웹 크롤러임      웹 아카이빙(web archiving) : 나중에 사용할 목적...",
    "content": "책정보  웹크롤러(로봇, 스파이더라고도 불림) 이용 방법          검색 엔진 인덱싱(search engine indexing) : 크롤러의 가장 보편적인 용례로 웹 페이지를 모아 검색 엔진을 위한 로컬 인덱스를 만든다. googlebot은 구글검색엔진이 사용하는 웹 크롤러임      웹 아카이빙(web archiving) : 나중에 사용할 목적으로 장기보관하기 위해 웹 정보를 모으는 절차. 대표적으로 미국 국회 도서관, EU웹아카이브가 있음      웹 마이닝(web mining) : 인터넷의 유용한 지식을 도출해낼수있음. 유명 금융기업에서는 크롤러를 사용해 주주총회 자료나 연차보고서를 다운받아 기업의 핵심사업방향을 알아내기도함      웹 모니터링(web monitoring) : 인터넷의 저작권/상표권 침해 사례를 모니터링 가능. 디지마크사는 웹크롤러를 사용해 해적판 저작물을 찾아 보고함        기본 알고리즘          URL이 집합으로 주어지면 해당 URL이 가르키는 모든 웹 페이지를 다운      다운받은 웹페이지에서 URL 추출      추출된 URL들을 다운할 목록에 추가, 위의 과정을 처음부터 반복        웹 크롤러 만족 속성          규모확장성 : 뱡행성을 활용하면 더 효과적으로 크롤링 가능      안정성 : 잘못작성된 HTML, 반응이없는 서버, 장애, 악성코드 등 비정상적 입력/환경에 대응가능해야함      예절 : 수집대상이되는 웹 사이트에 짧은 시간동안 너무 많은 요청을 날리면 안됨      확장성 : 새로운 형태의 콘텐츠를 지원하기 쉬워야함. (이미지를 추가 크롤링해야할때 전체시스템을 새로설계하는 일이 없도록 구현)        작업 흐름flowchart TD시작URL집합--&gt;미수집URL저장소--&gt;HTML다운로더--&gt;컨텐츠파서--&gt;중복컨텐츠?--&gt;URL추출기--&gt;URL필터--&gt;이미방문한URL?--&gt;URL저장소;HTML다운로더--&gt;도메인이름변환기;컨텐츠저장소--&gt;중복컨텐츠?;이미방문한URL?--&gt;미수집URL저장소;  시작 URL 집합(정답은 없음) 수집대상이되는 도메인이이름이 붙은 URL을 전부 시작URL집합으로 사용. 전체 웹이 대상인경우에는 전체 URL공간을 작은 부분집합으로 나누는 전략을 사용함     -&gt; 쇼핑, 스포츠 등 주제별로 세분화해 다른 시작 url을 사용하는 것  미수집 URL 저장소 크롤링 상태는 2가지로 나뉜다          크롤링상태를 다운할 URL -&gt; 저장 관리하는 컴포넌트를 미수집 URL저장소(URL frontier)라고 부름. FIFO 큐라고 생각하면 편함      다운로드된 URL        HTML다운로더 : 미수집URL저장소가 다운로드할 페이지의 URL제공  도메인 이름 변환기 : URL을 IP주소로 변환  콘턴츠 파서 : 다운한 웹페이지는 파싱, 검증 절차를 거쳐야함. 크롤링 서버안에 구현하면 크롤링 과정이 느려질수있어 책에서는 독립 컴포넌트로 분리  중복컨텐츠 : 가장간단한건 두 페이지의 문자열 비교지만 비교대상 모수가 많으면 비효율적이라 해시로 비교하는것이 좋음. 해시나 체크섬을 사용하면 쉽게 탐지 가능  콘텐츠 저장소 : HTML문서 보관 시스템. 저장데이터 유형, 크기, 저장소접근 빈도, 데이터 유효기간 등으로 종합적으로 고려 후 선택해야함  URL추출기 : HTML페이지를 파싱하여 링크를 골라내는 역할.  URL필터 : 특정 콘텐츠나 파일 확장자를 갖는 URL, 오류발생URL, 접근 제외목록에 포함된 URL을 크롤링대상에서 제외  이미 방문한 URL : 같은 URL을 여러번 처리하는일 방지. 블룸필터나 해시테이블이 널리쓰임.  URL저장소 : 이미 방문한 URL을 저장  구현기술 : 웹 페이지는 노드, 하이퍼링크는 에지라고 보면됨. DFS, BFS중에선 BFS(넓이우선방식)이 적합함, 큐를 사용하는 알고리즘인데 웹페이지의 깊이가 얼마나 깊은지 파악하기 힘들기때문임.          한 페이지에서 나온 링크는 대부분 내부링크임 -&gt; 병렬로 처리하면 해당 서버에 너무 많은 요청을 날림  =&gt; 미수집 URL 저장소로 해결 가능. 동일한 웹사이트에서는 한번에 한 페이지만 요청할수있도록 구현해야함.(예의바른 크롤러)  웹사이트의 호스트명과 작업스레드 사이의 관계를 유지하여 스레드를 별도 큐에 저장하는것.              URL에 우선순위를 두지않음. 하지만 순위, 트래픽양, 업데이트 빈도에 따라 우선순위를 구분하는것이 효율적임=&gt; 순위결정장치 사용. URL의 우선순위별로 큐가 하나씩 할당. 큐 선택기가 우선순위가 높은 큐에서 더 자주꺼내도록 구현함.                          전면 큐 : 우선순위 결정과정 처리          후면 큐 : 크롤러가 예의바르게 동작하도록 보증                    신선도 : 웹페이지가 업데이트될수도있어 이미 저장한 페이지라도 갱신해주어야함. 그러나 모든 페이지를 갱신하면 많은 시간과 자원이 소모됨-&gt; 변경이력 + 우선순위 사용으로 해결      HTML다운로더                  로봇제외 프로토콜(Robots.txt) : 웹사이트가 크롤러와 소통. 이 파일에 수집해도되는 페이지의 목록이있음. 거푸다운로드를 피하기위해 주기적으로 다운받아 캐시에 보관함.          성능 최적화                          분산크롤링 : 여러 서버에 분산. URL공간은 작은 단위로 분할해 각 서버는 그 중 일부의 다운로드를 담당              도메인이름 변환 결과 캐시 : 도메인변환기가 크롤러의 병목중 하나인데 DNS요청 전송/수신작업의 동기적 특성때문임.(수신전까지 다음작업 못함) 따라서 DNS조회 결과로 얻어진 도메인 이름과 IP 사이의 관계를 캐시에 보관해  크론잡을 통해 주기적으로 갱신하여 성능향상가능              지역성 : 크롤링 서버를 지역별로 분산              짧은 타임아웃 : 웹 서버가 응답이없을때를 대비해 일정기간동안 응답이없으면 다음페이지로 넘어감                                안정성                          안정해시 : 서버 쉽게 추가/삭제 가능              크롤링 상태 및 수집 데이터 저장 : 장애에도 쉽게 복구가능하도록 크롤링 상태, 수집데이터를 지속적 저장장치에 기록                                예외처리          데이터검증          확장성  PNG다운로더(PNG 다운로드 플러그인), 웹모니터(웹을 모니터링해서 저작권/상표권 침해를 막음), URL추출기는 확장모듈임                    flowchart TD시작URL집합--&gt;미수집URL저장소--&gt;HTML다운로더--&gt;컨텐츠파서--&gt;중복컨텐츠?--&gt;URL추출기--&gt;URL필터--&gt;이미방문한URL?--&gt;URL저장소;중복컨텐츠?--&gt;PNG다운로더;중복컨텐츠?--&gt;웹모니터;HTML다운로더--&gt;도메인이름변환기;컨텐츠저장소--&gt;중복컨텐츠?;이미방문한URL?--&gt;미수집URL저장소;  거미 덫 : 크롤러를 무한 루프에 빠뜨리도록 설계한 웹 페이지(무한히 깊은 디렉터리구조를 포함). URL의 최대 길이를 제한하면 회피할수있지만 만능 해결책은 아님. 사람이 수작업으로 덫을 확인하고 찾아낸 후 탐색대상에서 제외하는것도 방법임  데이터 노이즈 : 광고, 스크립트 코드, 스팸 등 가치없는 컨텐츠  서버 측 랜더링 : 많은 웹사이트가 자바스크립트, AJAX기술을 사용해 링크를 즉석에서 만들어내기때문에 웹페이지를 그대로 받아서 파싱하면 동적생성링크는 발견하지못함. 페이지 파싱전에 서버 측 렌더링(동적 렌더링)을 적용하면 해결됨  원치않는 페이지 필터링 : 크팸방지 컴포넌트를 두어 품질이 조약하거나 스팸성인 페이지를 걸러냄  DB 다중화/샤딩  수평적 규모 확장성 : 대규모 크롤링을 위해 필요할수도있음. 무상태(서버가 상태정보를 유지하지않음)를 유지하는것이 중요  데이터 분석 솔루션 : 데이터와 분석결과가 필수임"
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 7장 분산 시스템을 위한 유일 ID 생성기 설계",
    "url": "/posts/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9C%A0%EC%9D%BC-ID-%EC%83%9D%EC%84%B1%EA%B8%B0-%EC%84%A4%EA%B3%84/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-28 00:00:00 +0900",
    





    
    "snippet": "책정보  [!NOTE]auto_increment 속성이 설정된 관계형데이터베이스의 기본키를 쓰면 되지않나? -&gt; 데이터베이스 서버 여러대일때는 불가능함선택지로는 다중마스터 복제, UUID, 티켓 서버, 트위터 스노플레이크 접근법 등이 있음다중 마스터 복제(multi-master replication)DB의 auto_increment 기능을 활용하...",
    "content": "책정보  [!NOTE]auto_increment 속성이 설정된 관계형데이터베이스의 기본키를 쓰면 되지않나? -&gt; 데이터베이스 서버 여러대일때는 불가능함선택지로는 다중마스터 복제, UUID, 티켓 서버, 트위터 스노플레이크 접근법 등이 있음다중 마스터 복제(multi-master replication)DB의 auto_increment 기능을 활용하나 다음 ID의 값을 구할때 +1하는것이 아니라 현재 사용중인 데이터베이스 서버의 수만큼 증가시키는 방법규모확장성 문제를 어느정도 해결가능하며 데이터베이스의 수가 늘어나면 초당 생산가능한 ID수도 늘어나지만 여러 데이터센터에 걸쳐 규모를 늘리기 어렵다는 점과 시간흐름에 맞춰 ID가 커짐을 보장할 수 없고 서버 추가/삭제 시에 잘 동작하게 만들기 어렵다는 단점이있음UUID웹 서버에서 UUID를 생성하는 방법으로 간단하며 서버사이 조율이 필요없어 동기화이슈도 없고 규모확장에도 유리하나 ID가 길다는것과 시간순 정렬이 불가능하다는점, ID에 숫자아닌값이 저장될 수 있다는 문제가 있음중복UUID문제는 지극히 낮음티켓 서버유일성이 보장되는 ID를 만들어내는 데이터베이스 서버를 하나 만드는 것.유일성이보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있고 구현하기 쉬우며 중소 어플리케이션에 적합하다.그러나 티켓서버가 SPOF이 되며 이를 피하기위해 티켓서버를 여러대 준비하면 동기화 문제가 발생함트위터 스노플레이크 접근법각개 격파 전략 : 생성해야 하는 ID의 구조를 여러절로 분할  ex. 타임스탬프 + 데이터센터ID + 서버ID + 일련번호          데이터센터ID와 서버ID는 시스템운영중에 바뀌지않음(만약 바꾼다고해도 충돌가능성이 커서 아주 신중해야함)      타임스탬프 - 타임스탬프로 표현 가능한 시간은 69년. 기원전을 현재시간에 가깝게맞추면 오버플로우 발생 시점을 늦출 수 있음. 69년이 지나면 기원시간을 바꾸거나 ID체계를 다른것으로 마이그레이션해야함      일련번호 - 어떤 서버가 같은 밀리초동안 하나이상의 ID를 만들어낸 경우에만 0보다 큰 값을 가짐      "
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 8장 URL 단축키 설계",
    "url": "/posts/URL-%EB%8B%A8%EC%B6%95%EA%B8%B0-%EC%84%A4%EA%B3%84/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-28 00:00:00 +0900",
    





    
    "snippet": "책정보https://www.webservice.com/q-chatsystem&amp;c-loggedin&amp;v=v3&amp;l=long 같은 URL을 https://tinyurl.com/y7kes-eos이런식으로 단축하는 것을 뜻함  조건 + 추정          매일 1억개의 단축 url생성가능      초당 쓰기연산 : 1억/24/3,600 =...",
    "content": "책정보https://www.webservice.com/q-chatsystem&amp;c-loggedin&amp;v=v3&amp;l=long 같은 URL을 https://tinyurl.com/y7kes-eos이런식으로 단축하는 것을 뜻함  조건 + 추정          매일 1억개의 단축 url생성가능      초당 쓰기연산 : 1억/24/3,600 = 1,160      읽기연산 : 읽기, 쓰기연산 비율은 10:1이라 가정. -&gt; 11,600      url단축 서비스를 10년간 운영한다 가정. 1억 * 365 * 10 = 365,000,000,000      축약 전 url의 평균 길이는 100      10년동안 필요한 저장 용량은 365,000,000,000 * 100바이트 = 36.5TB      API 엔드포인트URL단축키는 기본적으로 두개의 엔드포인트를 필요로함  URL 단축용 엔드포인트 : 새 단축 URL을 생성하고자 하는 클라이언트는 엔드포인트에 단축할 URL을 인자로 실어서 POST요청          인자 : {longUrl: longUrlString}      반환 : 단축된 URL        URL 리디렉션용 엔드포인트 : 단축 URL에 대해 HTTP요청이 오면 원래 URL로 보내주기위한 용도의 GetMapping 엔드포인트          반환 : HTTP리디렉션 목적지가 될 원래 URL단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어 301 응답의 Location 헤더에 넣어 반환.        301응답과 302응답의 차이      301 Permanently Moved : 이 응답은 해당 URL에 대한 HTTP요청의 처리 책임이 영구적으로 Location헤더에 반환된 URL로 이전되었다는 응답. 브라우저는 이 응답을 캐시함. -&gt; 추후 단축 URL에 요청을 보낼 필요가있으면 캐시된 원래 URL로 요청을 보냄          302 Found : 주어진 URL로의 요청이 일시적으로 Location헤더가 지정하는 URL에 의해 처리되어야한다는 응답. 요청은 언제나 단축 URL서버에 먼저 보내진 후 원래 URL로 리디렉션되어야함      서버 부하를 줄여야한다면 301을, 트래픽 분석이 중요하다면 302를 사용하는것이 유리. 301은 첫번째요청만 서버를 거치기때문임      단축 URL이 www.tinyurl.com/{hashValue} 의 형태라고 가정. 중요한것은 hashValue를 어떻게 찾을 것이냐가 될것임. 입력으로 주어지는 긴 URL이 다른값이면 해시도 다른값이 나와야하며 계산된 해시값은 원래 입력으로 주어진 긴 URL로 복원가능해야함  데이터 모델 : &lt;단축URL, 원래 URL&gt;의 순서쌍을 관계형 데이터베이스에 저장하는것이 좋음해시함수  해시 값 길이 : 0-9, A-Z, a-z로 이루어짐 -&gt; 총 사용가능한 문자는 62개  해당 시스템은 3,650억개의 url을 만들어야하니 7자리(62^7은 총 3.5조개 생성가능)로 hash Value지정해시충돌 해소 방법  유명한 해시 함수인 CRC32, MD5, SHA-1을 사용가능하나 모두 7자리보다 긴 결과가 나옴-&gt; 앞의 7자리만 잘라서 사용. 그러나 충돌 가능성 증가  flowchart TD     시작--&gt;입력:longURL--&gt;해시함수;      해시함수--&gt;shortURL;         shortURL--&gt;DB유무확인;   DB유무확인--&gt;없음;DB유무확인--&gt;있음;없음--&gt;DB에저장;있음--&gt;longURL뒤에사전에정한문자열추가;longURL뒤에사전에정한문자열추가--&gt;입력:longURL;DB에저장--&gt; 종료  충돌이 해소될때까지 위의 로직을 반복함.생성할때마다 한번 이상의 쿼리를 날려야함. 오버헤드가 큼대신 블룸필터를 사용하면 성능을 높일 수 있음base-62변환진법 변환은 URL단축기를 구현할때 흔히사용하는 방법임해시키에서 사용할 수 있는 문자 개수가 62개라서 62진법을 사용10진수의 ID를 62진수로 변환하는방법            해시 후 충돌 해소 전략      base-62 변환                  단축 후 URL길이가 고정됨      단축 후 URL 길이가 가변적. ID값이 커지면 같이 길어짐              유일성이 보장되는 ID생성기가 필요치 않음      유일성 보장 ID생성기가 필요              충돌이 가능해서 해소 전략이 필요      ID유일성이 보장된 후에 적용하기 때문에 충돌은 아예 불가능              ID로부터 단축 URL을 계산하는 방식이 아니라 다음에 쓸수있는 URL을 알아내는기는 불가능      ID가 1씩 증가하는 값이라고 가정하면 다음에 쓸수있는 단축 URL이 뭔지 알아낼수있어 보안상 문제가 있음      flowchart TD1.입력:longURL--&gt;2.입력된URL이ID가있나?--&gt;예--&gt;3.DB에서찾은단축URL반환;2.입력된URL이ID가있나?--&gt;아니오--&gt;4.새로운ID생성--&gt;5.생성된ID를단축URL로변환-62진법변환사용--&gt;ID,단축URL,원래URL을DB에저장;"
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 6장 키-값 저장소 설계",
    "url": "/posts/%ED%82%A4_%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%84%A4%EA%B3%84/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-27 00:00:00 +0900",
    





    
    "snippet": "책정보키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스. 성능상의 이유로 키는 짧을 수록 좋음값 저장소 중 유명한 것으로는 아마존 다이나모, memcached, redis 등이 있음서버가 한대 일 경우 구현은 간단함. 그러나 모든 데이터를 메모리안에 두는 것이 불가능할수도 있다는 약점을 가짐 -&gt; 데이터 압축 or 자주쓰는 데이터만 메모리에...",
    "content": "책정보키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스. 성능상의 이유로 키는 짧을 수록 좋음값 저장소 중 유명한 것으로는 아마존 다이나모, memcached, redis 등이 있음서버가 한대 일 경우 구현은 간단함. 그러나 모든 데이터를 메모리안에 두는 것이 불가능할수도 있다는 약점을 가짐 -&gt; 데이터 압축 or 자주쓰는 데이터만 메모리에 저장 or 분산 키-값 저장소 생성분산 키-값 저장소분산 해시 테이블이라고도 불림CAP정리  데이터 일관성(consistency) : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게되어야함  가용성(availability) : 분산시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있어야함  파티션 감내(partition tolerance) : 두 노드 사이에 통신 장애가 발생하였음을 의미. 네트워크에 파티션이 생기더라도 시스템은 계속 동작해야함이들 가운데 어떤 두가지를 충족시키면 다른 하나는 반드시 희생되어야함  CP 시스템 : 일관성과 파티션감내를 지원하나 가용성을 희생함  AP 시스템 : 가용성과 파티션감내를 지원하나 데이터 일관성을 희생함  CA 시스템 : 일관성과 가용성을 지원하나 파티션감내를 희생함. 그러나 통상 네트워크장애는 피할 수 없는 일로 여겨지기때문에 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야한다. =&gt; 실세계에 CA 시스템은 존재하지않음이상적 환경에서 네트워크가 파티션되는 상황은 절대로 일어나지않음. n1에 기록된 데이터는 자동으로 n2, n3에 복제됨. 일관성, 가용성을 만족함그러나 분산 시스템은 파티션 문제를 피할 수 없음. 파티션 문제 발생 시 일관성과 가용성 중 하나를 선택해야함n3에 장애가 발생하여 n1, n2와 통신할 수 없는 상황에서 클라이언트가 n1, n2에 기록한 데이터는 n3에 전달되지않으며 n3에 기록되었으나 n1, n2에 전달되지않은 데이터는 알 수 없음-&gt; 가용성 대신 일관성 선택 시(CP)\t세 서버 사이 생길수 있는 데이터 불일치를 피하기 위해 n3의 장애 발생 시 n1, n2의 쓰기연산을 중단. 보통 은행권 시스템은 절대 일관성을 포기할 수 없어 선택함-&gt; 일관성 대신 가용성 선택(AP)\t파티션 문제가 해결 된 후에 노드간 데이터 동기화를 진행함시스템 컴포넌트키-값 저장소 구현에 사용될 핵심 컴포넌트들 및 기술  데이터 파티션  대규모 어플리케이션은 전체 데이터를 한대의 서버에 욱여넣는것이 불가능함. 데이터를 작은 파티션들로 분할해 여러 서버들에 저장하는것이 가장 단순한 해결책임. 그러나          데이터를 여러 서버에 고르게 분산 가능?      노드 추가/삭제될때 데이터이동 최소화 가능?  위 2가지 문제를 해결하기 위해 안정 해시(consistent hash)를 사용 가능함  안정해시를 사용해 데이터를 파티션하면      규모 확장 자동화 : 시스템부하에따라 서버가 자동 추가/삭제      다양성 : 각 서버의 용량에 맞게 가상 노드의 수를 조정 가능. == 고성능 서버는 더 많은 가상 노드를 갖도록 설정가능함        데이터 다중화  높은 가용성, 안정성 확보를 위해 데이터를 N개(튜닝 가능한 값)의 서버에 비동기적으로 다중화할 필요가있음  어떤 키를 해시 링 위에 배치한 후 그 지점으로부터 시계방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 복사  가상 노드를 사용한다면 N개의 노드가 대응될 실제 물리서버의 서버의 개수보다 작아질 수도 있음  =&gt; 노드 선택 시 같은 물리 서버를 중복 선택하지않도록 해야함.  데이터 일관성  여러 노드의 데이터는 적절히 동기화되어야함  정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장 가능.      - N = 사본갯수      - W = 쓰기 연산에 대한 정족수. 쓰기연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기연산이 성공했다는 응답을 받아야함      - R = 읽기 연산에 대한 정족수. 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야함            w=1 은 쓰기연산이 성공했다고 판단하기 위해 중재자는 최소 한대의 서버로부터 쓰기성공응답을 받아야한다는 뜻 == s0으로부터 쓰기 성공 응답을 받았다면 s1, s2의 응답은 받을 필요없음      여기서 중재자는 클라이언트와 노드 사이의 프록시 역할을 함      w=1 or r=1은 중재자가 한대의 서버에서만 응답을 받으면 되니 응답속도는 빠르겠으나 일관성은 보장하기 힘들다는 단점이 있음      - R=1, W=N : 빠른 읽기 연산 최적화      - W=1, R=N : 빠른 쓰기 연산 최적화      - W+R &gt; N : 강한 일관성 보장(보통 N=3, W=R=2)      - W+R &lt;= N : 강한 일관성이 보장되지않음      요구되는 일관성의 수준에 따라 적절히 조정하면됨  일관성 모델 : 데이터 일관성의 수준을 결정함.          강한 일관성 : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환. == 클라이언트는 절대 낡은 데이터를 보지못함. 일반적으로 모든 사본에 현재쓰기연산의 결과가 반영될때까지 해당 데이터에대한 읽기/쓰기를 금지함(고 가용성 시스템에서는 부적합. 새요청 처리가 중단됨)      약한 일관성 : 읽기연산은 가장 최근에 갱신된 결과를 반환하지 못할수도 있음      최종 일관성 : 약한 일관성의 한 형태로 갱신 결과가 결국 모든 사본에 반영(동기화)되는 모델. 다이나모 또는 카산드라가 택하고있는 모델.     쓰기연산이 병렬적으로 발생하며 시스템에 저장된 값의 일관성이 깨질수도 있음. 이 문제는 클라이언트가 해결해야함(데이터의 버전 정보를 활용해 일관성이 깨진 데이터를 읽지않도록 함)        비일관성 해소 기법 : 데이터 버저닝          데이터를 생성할때마다 해당 데이터의 새로운 버전을 만드는것. 각 버전의 데이터는 변경이 불가능하다      백터시계 : 버전 사이 충돌을 해소히가 위해 보편적으로 사용하는 기술. [서버, 버전] 의 순서 쌍을 데이터에 매단 것.                  D([S1, v1], [S2, v2], …, [Sn, vn])와 같이 표현됨.          D - 데이터, S - 서버번호, v - 버전 카운터                          데이터 D를 서버 s1에 기록    -&gt; 있으면? vi 증가    -&gt; 없으면? 새항목[Si, 1] 생성                                  클라이언트가 D1시스템에 기록. S1이 쓰기 연산 처리   -&gt; D1([S1, 1]) 생성                  다른 클라이언트가 D1을 읽고 D2로 업데이트. S1이 쓰기 연산처리(기존 데이터 D1을 덮어씀)   -&gt;D2([S1, 2]) 생성                  다른 클라이언트가 D2를 읽어 D3로 갱신, S2이 쓰기연산                                          동시에 또 다른 클라이언트가 D2를 읽고 D4로 갱신, S3가 쓰기연산 처리 -&gt; D3([S1, 2], [S2, 1]), D4([S1, 2], [S3, 1]) =&gt; 충돌 발생                                                        클라이언트가 D3과 D4를 읽으며 충돌 확인, 충돌된 데이터를 클라이언트가 해소 후 서버에 저장. 충돌 해소된 데이터를 S1이 기록 -&gt; D5([S1, 3], [S2, 1], [S3, 1])  =&gt; 서버별 버전 중 어느 버전이 최신인지 확인하려면 버전의 합을 비교하면된다. 높은쪽이 최신버전. 만약 서버별 버전이 동일하다면 충돌한것.  그러나 클라이언트에 버전 충돌 감지, 해소 로직이 들어가야해서 클라이언트 구현이 복잡해지며 서버:버전의 개수가 빨리늘어난다는것이 문제임. 해결하려면 길이에 임계치를 설정하고 길이가 길어지면 오래된 순서쌍을 백테시계에서 제거하는 로직을 추가해야하나 충돌해소과정의 효율성이 낮아짐.   그러나 아마존은 실제 서비스에서 해당문제가 발생한적이 없다고함. 일반적인 상황에서는 큰 문제요소는 아닌듯                                                                          장애 처리          장애 감지                  멀티캐스팅 : 장애감지하기 가장 쉬운 방법이나 서버가 많을수록 비효율적          분산형 장애 감지 - 가십 프로토콜                          각 노드는 멤버십 목록을 유지(각 멤버 Id와 박동카운터 쌍의 목록)              각 노드는 주기적으로 자신의 박동 카운터를 증가              각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보냄              박동 카운터 목록을 받은 노드는 멤버십 목록을 최신값으로 갱신              특정 멤버의 박동 카운터 값이 지정시간동안 갱신되지않으면 장애상태로 간주                                          일시적 장애 처리 : 가십프로토콜로 장애를 감지하면 가용성보장을 위해 조치를 취함                  엄격한 정족수 : 읽기와 연산 금지          느슨한 정족수 : 조건을 완화하여 가용성을 높임. W개의 건강한 서버와 읽기연산을 수행할 건강한 서버 R개를 해시링에서 고름(장애서버 무시) -&gt; 장애 서버로 가는 요청을 건강한 서버가 잠시 대신 처리함. 장애서버 복구 시 일괄 반영일괄 반영을 위해 임시로 대신 요청을 수행한 서버는 단서(hint)를 남기는데 이런 방안을 단서 후 임시 위탁(hinted handoff)기법 이라 부름                    영구 장애 처리                  반-엔트로피 프로토콜을 구현하여 사본을 동기화, 사본들을 비교하여 최신버전으로 갱신하는 과정 포함. 사본간의 일관성이 망가진 상태를 탐지, 전송 데이터의 양을 줄이기위해서는 머클 트리 사용                          머클트리(Merkle, 해시트리): 각 노드에 그 자식 노드들에 보관된 값의 해시 or 자식노드들의 레이블로부터 계산된 해시값을 레이블로 붙여두는 트리키 공간이 1~12일때 머클트리는                                     1단계 : 키 공단을 버킷으로 나눔                  2단계 : 버킷이 포함된 각각의 키에 균등 분호 해시 함수를 적용 햐 해시값 계산                  3단계 : 버킷별로 해시값 계산, 해당 해시 값을 레이블로 갖는 노드 생성                  4단계 : 자식 노드의 레이블로부터 새로운 해시값을 계산하여 이진트리를 상향식 구성   일관성이 깨진데이터 상자는 색깔로 표기함   루트 노드의 해시값을 비교하는 것으로 머클트리의 비교를 시작. 루트노드의 해시값이 일치 == 두 서버는 같은 데이터를 갖음   실제로 쓰이는 시스템의경우 버킷 하나의 크기가 꽤 크다                                                                          데이터 센터 장애 처리 : 정전, 네트워크 장애, 자연재해 등 다양한 이유로 발생가능. 데이터 센터 다중화 필요  시스템 아키텍처 다이어그램          클라이언트 :  키-값 저장소가 제공하는 두 가지 단순한 api, 즉 get(key) 및 put(key, value)와 통신      중재자 : 클라이언트에게 키-값 저장소에 프록시 역할을 하는 노드      노드는 안정해시의 해시링 위에 분포      노드를 자동추가, 삭제할수있으며 시스템은 완전히 분산됨      데이터는 여러 노드에 다중화      모든 노드가 같은 책임을 지므로 SPOF(Single Point Of Failure)는 존재하지않음      완전히 분산된 설계이므로 모든 노드는 아래 기능을 전부 지원                  클라이언트 API          장애 감지          데이터 충돌 해소          장애 복구 메커니즘          다중화          저장소 엔진          그 외 기능                      쓰기 경로 : 쓰기 요청이 특정 노드에 전달된다면?            쓰기 요청이 커밋로그 파일에 기록      데이터가 메모리 캐시에 기록      메모리캐시가 가득 차거나 사전에 정의한 임계치에 도달하면 데이터는 디스크에있는 SSTABLE(Sorted-String Table. &lt;key, value&gt;의 순서 쌍을 정렬된 리스트형태로 관리하는 테이블)에 기록됨        읽기 경로 : 요청을 받은 노드가 메모리에 데이터가있는지 확인 -&gt; 있으면 클라로 바로 반환, 없으면 SSTable들 중 어디에 키가 있는지 찾아야함 -&gt; 보통 블룸필터가 사용됨          블룸필터(Bloom filter)                    메모리캐시에 데이터 유무 확인          없으면 블룸필터 검사 -&gt; 어떤 SSTable에 있는지 알아냄          SSTable에서 데이터 가져옴          클라이언트에 반환                    "
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 4장 처리율 제한 장치의 설계",
    "url": "/posts/%EC%B2%98%EB%A6%AC%EC%9C%A8-%EC%A0%9C%ED%95%9C-%EC%9E%A5%EC%B9%98%EC%9D%98-%EC%84%A4%EA%B3%84/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-27 00:00:00 +0900",
    





    
    "snippet": "책정보처리율 제한 장치클라이언트나 서비스가 보내는 트래픽의 처리율을 제어하기위한장치. HTTP를 예로들면 특정 기간 내 전송되는 클라이언트의 요청횟수를 제한함. api의 요청횟수가 임계치를 넘어서면 추가로 도달한 모든 호출은 block됨  토큰 버킷          지정된 용량을 갖는 컨테이너. 이 버킷에 사전 설정된 양의 토큰이 주기적으로 채워짐. ...",
    "content": "책정보처리율 제한 장치클라이언트나 서비스가 보내는 트래픽의 처리율을 제어하기위한장치. HTTP를 예로들면 특정 기간 내 전송되는 클라이언트의 요청횟수를 제한함. api의 요청횟수가 임계치를 넘어서면 추가로 도달한 모든 호출은 block됨  토큰 버킷          지정된 용량을 갖는 컨테이너. 이 버킷에 사전 설정된 양의 토큰이 주기적으로 채워짐. 꽉차면 더 이상 추가는 안됨. 용량이 꽉찬 시점에서 추가된 토큰은 버려짐      요청이 처리될때마다 하나의 토큰을 사용      요청 처리를 위한 토큰이 없다면? -&gt; 요청 자체를 버림. 토큰이 다시 차도 버린 요청을 처리하지않음      2개의 인자를 받음                  버킷 크기 : 버킷에 담을 수 있는 토큰의 최대 개수          토큰 공급률 : 초당 몇개의 토큰이 버킷에 공급되는가?                    장점                  구현이 쉬움          메모리 사용측면에서 효율적          짧은 시간에 집중되는 트래픽도 처리 가능                    단점                  버킷크기와 토큰공급률이라는 두개의 인자를 적절하게 튜닝하는것이 어려움                      누출 버킷          토큰 버킷과 비슷하나 요청 처리율이 고정되어있음. 보통 FIFO(선입선출)로 구현함      요청이 도착하면 큐가 가득차있는지 확인. 빈자리가 있으면 큐에 요청 추가      큐가 가득 차면 새 요청은 버림      지정된 시간마다 큐에서 요청을 꺼내 처리      2개의 인자를 받음                  버킷크기 : 큐사이즈와 같은 값.          처리율 : 지정된 시간동안 몇개의 항목을 처리할건지 지정하는 값                    전자 상거래 기업 쇼피파이(shopify)가 사용중인 방법      장점                  큐의 크기가 제한되어있어 메모리 사용량 측면에서 효율적          고정된 처리율을 가지고있어 안정적 출력이 필요한경우 적합                    단점                  단시간에 많은 트래픽이 몰리는 경우 큐에는 오래된 요청들이 쌓이게되고 요청을 처리하지못하면 최신요청은 모두 버려짐          2개의인자를 튜닝하기 까다로움                      고정 윈도 카운터          타임라인을 고정된 간격의 윈도로 나누고 각 윈도마다 카운터를 붙임      요청이 접수될때마다 카운터의 값이 1씩 증가      카운터값이 사전에설정한 임계치를 넘어서면 새로운 요청 윈도가 열릴때까지 버려짐      예시                  타임라인을 1초로 잡고, 임계치를 3으로 설정. == 시스템은 1초동안 3개의 요청만 처리함          매초마다 4번째 요청부터는 모두 버려짐                    장점                  메모리의 효율이 좋음          이해하기 쉬움          윈도가 닫히는 시점에 카운터를 초기화하는 방식이라 특정한 트래픽패턴을 처리하기 적합                    단점 : 윈도의 경계 부근에 순간적으로 많은 트래픽이 몰리는경우 임계치보다 더 많은 양이 처리될수도있음!!                  예시)                          분당 임계치가 3개일경우              2:00:00~2:00:30 1개의 요청              2:00:30~2:01:00 2개의요청              2:01:00~2:01:30 2개의 요청              2:01:30~2:02:00 1개의 요청                                위 예시에서보면 2:00:00~2:01:00까지는 분당 임계치 3개 내로 처리가됨. 그러나 2:00:30~2:01:30을 기준으로 보게되면 4개가 처리됨!! 1분동안 3개를 허용했는데 시간을 어떻게 나누냐에따라 임계치를 넘게 처리되기도함을 알수있음                                이동 윈도 로그          고정윈도카운터의 문제를 해결하기위해 요청의 타임스탬프를 추적하는 방법      타임스탬프 터는 보통 레디스의 정렬집합같은 캐시에 보관함      새요청이 오면 만료된 타임스탬프는 제거, 만료된 타임 스탬프는 그 값이 현재 윈도 시작 시점보다 오래된 타임 스탬프를 말함      새 요청의 타임스탬프를 로그에 추가      로그의 크기가 허용치보다 크거나 같으면 요청을 시스템에 전달, 아니면 거부      장점 : 매우 정료한 메커니즘으로 요청의 갯수가 시스템 한도를 넘지 않음      거부된 요청의 타임스탬프도 보관하기때문에 다량의 메모리를 사용      예시)                  [!NOTE]          분당 2분의 요청만 허용          \t1. 1:00:01 요청\t2. 1:00:30 요청&gt; \t\t   \t3. 1:00:50 요청 =&gt; 거절된 요청\t4. 1:01:40 요청위와 같이 4번의 요청이 들어왔을때, 요청이 들어온 시간(리눅스 타임스탬프)을 기록함.1, 2번 요청은 첫 요청이라 처리 가능. 3번 요청이 들어왔을때 요청 들어온 시간부터 1분전까지(해당요청이 1:00:50이니 0:59:50까지 조회할거임)몇번의 요청이 들어왔는지 확인, 해당 문제에서는 2번을 처리했기때문에 요청 거부.4번요청은 1:00:40~:1:01:40까지의 요청을 조회했을때 조회되는 로그는 3번이있으나 요청 처리된 건이 아니라 무시함! =&gt; 4번요청 성공따라서 위의 4번의 요청중 처리거부된 요청은 3번뿐임                                이동 윈도 카운터          고정윈도 카운터 알고리즘 + 이동윈도로그 알고리즘      두가지 접근법이있으나 책에서는 하나만 소개함      분당 7개의 요청처리가능할때, 직전 1분에 5개, 현재 1분에 3개 요청이 들어왔다 가정. 현재 1분의 30%지점에서 도착한 새 요청의 경우 현재 윈도에 몇개의 요청이왔는가?-&gt; 현재 1분간 요청 수 + 직전 1분간 요청 수 * 이동윈도와 직전 1분이 겹치는 비율    3 + 5 * 70% = 6.5 (올림, 내림은 상황에따라 다르나 이번 예제에서는 내림으로 계산함)    이번 1분동안 총 6개의 요청을 처리했으니 이번 요청도 처리가능(단 같은 시간대로 한번 더 요청이 들어오면 처리거부)      장점                  이전 시간대의 평균 처리율에 따라 현재 윈도상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응          메모리 효율이 좋음                    단점                  직전 시간대에 도착한 요청이 균등하게 분포되어있다고 가정한 상태에서 추정치를 계산하기때문에 다소 느슨함.그러나 그리 심각한 문제는 아님! 클라우드플레어가 실시한 실험에 따르면 40억개의 요청 중 시스템의 실제상태와 맞지않게 허용되거나 버려진 요청은 0.003%였음            개략적인 아키텍처            처리율 제한 알고리즘에서 얼마나 많은 요청이 접수되었는지 추적할수있는 카운터를 추적대상별로(사용자별/IP주소별/API엔드포인트별/서비스단위)두는데 이때 카운터는 어디에 보관할것인가?메모리상에서 동작하는 캐시가 바람직할것인데 대표적으로 redis는 처리율 제한 장치를 구현할때 자주사용되는 메모리 기반 저장장치로서, INCR와 EXPIRE 두가지 명령어를 지원함                                INCR : 메모리에 저장된 카운터의 값을 1만큼 증가  EXPIRE : 카운터에 타임아웃 값을 설정. 설정 시간이 지나면 카운터는 자동 삭제          클라이언트가 처리율 제한 미들웨어에게 요청을 보냄      처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와 한도 도달여부 검사              도달했다면 요청 거부      도달하지않았다면 API서버로 요청 전송                  미들웨어는 카운터의 값을 증가 시킨 후 다시 레디스에 저장=&gt; 그렇다면 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?  리프트(Lyft)는 처리율제한에 오픈소스를 사용함=&gt; 처리가 제한된 요청은 어떻게 처리되는가?  한도제한이 걸리면 429응답을 클라에게 보냄                    처리율 제한장치가 사용하는 HTTP헤더분산 환경에서의 처리율 제한 장치의 구현분산환경에서는 여러대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것이 또다른 문제임  경쟁조건(race confition)          처리율 제한 장치의 동작법                  레디스에서 카운터의 값을 읽음          카운터 + 1이 임계치를 넘는지 확인 -&gt; 문제발생 지점          넘지않는다면 레디스의 보관된 카운터의 값을 1만큼 증가                    A요청과 B요청이 연속으로 들어왔을때, A요청의 3번이 처리되지않은상태에서 B요청의 1번이 실행된다면? A요청과 B요청의 1번 작업결과는 동일함      \b해결방법                  LOCK: 가장 대표적인 방법이나 시스템성능을 상당히 떨어뜨린다는 문제가 있음          루아 스크립트          정렬집합(레디스 자료구조)                      동기화(synchronization)          처리율 제한장치가 2개라면? 둘 사이의 동기화가 제대로 이루어지지 않는다면 올바르게 처리율 제한을 할 수 없을것임      해결방법                  고정세션(sticky session): 같은 클라이언트로부터 들어온 요청은 항상 같은 처리율제한장치로 보낼수있도록 하는것이나 확장불가, 유연하지못함으로 추천하지않음.          중앙집중형 데이터 저장소 사용 : 대표적으로 레디스. 처리율 제한장치가 카운터를 읽어올때 레디스에서 읽어온다면 문제가 해결됨            성능 최적화            여러 데이터 센터를 지원하면서 멀리떨어진 사용자를 지원하려하면 지연시간이 증가함.제한장치간의 데이터를 동기화할때 최종 일관성모델을 사용. -&gt; 6장 키-값 저장소 설계의 데이터 일관성 항목 참조                                모니터링          처리율 제한장치 설계 후 효과적으로 동작(채택한 처리율제한 알고리즘/규칙이 효과적?)하는지 확인해보기위해 사용      깜짝세일같은 이벤트때문에 트래픽이 급증할때 처리율제한장치가 비효율적이라면 트래픽패턴을 파악해 잘 처리할 수 있도록 알고리즘을 바꾸는 것을 고려        [!NOTE]추가적으로 확인하면 좋은 내용  - 경성 또는 연성 처리율 제한\t- 경성(hard)처리율 제한 : 요청 개수는 임계치를 절대 넘을 수 없음\t- 연성(soft)처리율 제한 : 요청 개수가 임계치를 잠시동안은 넘을 수 있음- 다양한 계층에서의 처리율 제한\t- 책에서는 애플리케이션계층(HTTP: OSI 네트워크 계층도 기준으로 7번)에서의 처리율 제한만 설명했으나 다른계층에서의 제한도 가능함\t- 예를들어 Iptables를 사용한다면 IP(3번계층)주소에서 처리율 제한도 가능- 처리율 제한 회피\t- 클라이언트 측 캐시를 사용해 api호출횟수 감소\t- 처리율 제한 임계치를 이해하고 너무 짧은시간동안 너무 많은 메세지를 보내지 말것\t- 예외나 에러를 처리하는 코드를 도입해 클라이언트가 예외적 상황으로 우아하게(gracefully) 복구되도록할것\t- 재시도 로직을 구현할때는 충분한 백오프(back-off)시간을 두기  "
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 5장 안정 해시 설계",
    "url": "/posts/%EC%95%88%EC%A0%95-%ED%95%B4%EC%8B%9C-%EC%84%A4%EA%B3%84/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-27 00:00:00 +0900",
    





    
    "snippet": "책정보해시 키 재배치 문제N개의 캐시서버가 있다고 가정, 이 서버들의 부하를 나누려면serverindex = hash(key)%N(N이 서버의 개수)위 계산공식으로            키      해시      해시%4(서버인덱스)[실제값아님!귀찮아서 대충함]                  key0      13414213      1         ...",
    "content": "책정보해시 키 재배치 문제N개의 캐시서버가 있다고 가정, 이 서버들의 부하를 나누려면serverindex = hash(key)%N(N이 서버의 개수)위 계산공식으로            키      해시      해시%4(서버인덱스)[실제값아님!귀찮아서 대충함]                  key0      13414213      1              key1      131231      0              key2      23123      2              key3      12312      0              key4      34253      1              key5      4363      3              key6      6243      2              key7      432234      3      위와같이 있다고 가정했을때            서버인덱스      0      1      2      3                  서버      server0      server1      server2      server3              키      key1key3      key0key4      key2key6      key5key7      이렇게 배치될거임이상태에서1번서버가 장애를 일으켰을때 계산공식에서 사용한 서버의 개수가 4에서 3으로 변경됨. 그렇다면 서버에 키가 다시 재배치가 되는데결과적으로 이때 죽은 server1의 키만 재배치되는게아니라 모든 키가 재배치됨결국 캐시 클라이언트는 데이터가없는 엉뚱한 서버에 접속하게될 가능성이 있음안정 해시위의 문제에서(해시테이블의 크기가 조정될때) 평균적으로 오직 k(key개수)/n(slot개수)개의 키만 재배치하는 기술  해시 공간과 해시 링  해시 함수 f로는 SHA-1을 사용한다고 가정, 출력범위는 x0~xn  SHA-1의 공간 범위는 0~2^160-1  따라서 x0은 0, xn은 2^160-1  이것을 직사각형모양의 n개로 나누어진 공간을 해시공간이라 말하고  이 해시공간을 양쪽을 잡아 구부려 접으면 해시링이라고 한다여기서 함수 f를 사용하려 서버 ip나 이름을 이 링 위 어느 위치에 대응가능함 이를 해시서버라고 함여기서 사용된 해시함수는 아까 본 해시키 재배치문제에서 사용한 함수와는 다름캐시할 키도 링위에 배치 가능여기서 키가 저장된 서버는 해당 키로부터 시계방향으로 링을 탐색해가며 만나는 첫번째 서버임.여기서 서버가 추가된다면 키 가운데 일부만 재배치해주면됨이렇게하면 서버가 추가되거나 삭제되었을때 영향을 받지않는 해시키는 재배치되는것을 막을 수 있음이 과정에서도 문제점이 있는데  파티션의 크기가 균등하지않음 -&gt; 어떤서버는 작은 해시공간을, 어떤서버는 큰 해시공간을 할당받음  키의 군등분포를 당설하기 어려움 -&gt; 대부분의 키가 한 서버에 보관될 가능성이있음    가상 노드    위의 문제를 해결하기위해 나온 방법실제노드 또는 서버를 가르키는 노드인데 하나의 서버는 링위에 여러개의 가상 노드를 가질 수 있음key0이 가상노드 서버1_1을 만나 서버1에 저장됨가상 노드의 개수를 늘리면 늘릴 수록 키의 분포가 점점 균등질것임. 표준편차가 작아져 데이터가 고르게 분포되는것.그러나 가상노드 데이터를 저장할 공간이 필요하게되니 타협적 결정이 필요함    서버가 추가/제거되면 데이터 일부는 재배치해야하는데 어느 범위의 키가 재배치되는가?            여기서는 서버 4가 추가되면서 s4(새로추가된서버)~s3까지임  즉 s3부터 s4사이에있는 키를 재배치해야함  마찬가지로 만약 서버4가 다시 삭제된다면 s3~s0까지임      "
  },
  
  {
    "title": "[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 1장 사용자 수에 따른 규모 확장성",
    "url": "/posts/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B7%9C%EB%AA%A8-%ED%99%95%EC%9E%A5%EC%84%B1/",
    "categories": "프로그래밍 방법",
    "tags": "설계, 가상면접사례로배우는대규모시스템설계기초",
    "date": "2024-03-17 00:00:00 +0900",
    





    
    "snippet": "책정보웹 계층과 데이터 계층웹 서버와 데이터베이스의 서버가 각각 1개씩인 구조여기서 서버를 확장(스케일업)한다는 것은 수직적 규모 확장, 수평적 규모 확장 2가지로 나뉜다  수직적 규모 확장(vertical scaling) : 고사향자원을 추가하는 행위          한계가 있음. 한대의 서버에 CPU나 메모리를 무한대로 증설할 수는 없음      ...",
    "content": "책정보웹 계층과 데이터 계층웹 서버와 데이터베이스의 서버가 각각 1개씩인 구조여기서 서버를 확장(스케일업)한다는 것은 수직적 규모 확장, 수평적 규모 확장 2가지로 나뉜다  수직적 규모 확장(vertical scaling) : 고사향자원을 추가하는 행위          한계가 있음. 한대의 서버에 CPU나 메모리를 무한대로 증설할 수는 없음      장애에대한 자동복구(failover) 방안이나 다중화(re-dundancy) 방안을 제시하지 않음 -&gt; 서버 장애 시 웹사이트/앱이 완전 중단        수평적 규모 확장(scale out) : 서버를 추가해 성능을 개선하는 행위            대규모 애플리케이션을 지원할때 적절한 방법      로드밸런서                  분산 집합에 속한 웹 서버들에게 트레픽 부하를 올바르게 분산                          사용자가 공개 IP주소로 접근              로드밸런서가 사설IP주소(같은 네트워크에 속한 서버사이의 통신에만 쓰이기때문에 인터넷을 통해 접속 불가)로 웹 서버 접속                                서버 1이 다운돼면 모든 트래픽이 서버 2로 전송          트래픽 증기 시 서버 추가로 대처 가능                    부하분산기      데이터베이스 다중화                  보통 서버사이에 주(master) - 부(slave) 관계를 설정해 원본은 주 서버에, 사본은 부서버에 저장하는 방식          쓰기연산은 master, slave는 읽기연산만          디비 서버 분산의로 병렬로 처리될 수 있는 쿼리가 늘어나 성능 향상          db서버 중 하나가 파괴되어도 다중화된 디비로 데이터 보존 가능          여러지역에 데이터를 복제하여 하나의 서버에 장애가 발생해도 다른 서버의 db사용가능                          부 데이터베이스가 한개인데 서버 다운 -&gt; 읽기 연산이 한시적으로 주 db로 몰렸다가 새로운 부 데이터베이스 생성 시 대체됨              주 데이터베이스가 다운 -&gt; 부 데이터베이스 중 1개가 주 데이터베이스로 변경, 필요 시 부 데이터베이스 이후 생성프로덕션 환경에서는 부 서버에 보관된 데이터가 최신 상태가 아닐 수 있어 없는 데이터는 복구 스크립트를 돌려 추가함. 다중 마스터나 원형 다중화 방식을 도입하면 도움이 되나 너무 복잡하여 책에서는 다루지않음                                          응답시간캐시캐시에 값이 있으면 캐시를 반환, 없으면 DB에서 조회하는 전략을 주도형 캐시 전략이라고 한다단 캐시를 사용하게된다면 고려해야할 사항이 많다  데이터 갱신이 자주 일어나지않지만 참조가 많이발생한다면 고려  영구보관할 데이터는 캐시가 아닌 지속적 저장소에 저장해야함  만료방법, 만료시간 지정(지정하지않으면 캐시에 데이터가 계속 남음 + 만료시간이 너무 짧으면 db를 자주읽어서 효과가 떨어짐)  일관성 유지방법. db와 캐시의 사본이 다를경우. 원본 데이터 갱신 시 캐시도 갱신해야함(단일트랜젝션으로 묶여야함)  장애 대처 방법 : 서버와 db서버를 다중화 해도 캐시 서버가 단일서버라면 캐시서버가 단일장애지점(Single Point Of Failure : SPOF, 특정 지점의 장애가 전체 시스템의 동작을 중단시킬수도 있음)이 되어버릴수도있음  캐시메모리는 얼마나 크게잡을것인가? 캐시가 저장될 메모리가 작다면 데이터가 너무 자주 캐시에서 밀려나가게됨  데이터 방출정책 : 캐시 메모리가 꽉찼을경우 기존 데이터는 어떤기준으로 삭제할것인가?          LRU : 가장오래 사용하지않은 데이터 삭제      LFU : 사용빈도가 가장 적은 데이터 삭제      FIFO : 선입선출        CDN        정적 콘텐츠를 전송하는데 쓰이는 지리적으로 분산된 서버의 네트워크. 이미지, 비디오, css, javaScript 파일 등을 캐시요청경로, query string, 쿠키, 요청헤더 등의 정보로 HTML콘텐츠를 캐시하는 방법사용자에게 가장 가까운 CDN서버에서 정적 콘텐츠를 가져옴(없으면 원본서버에서[웹orS3])CDN서버로부터 멀면 멀수록 느림응답 http 헤더에는 파일이 얼마나 오래 캐시될수있는지를 설명하는 TTL(Time To Live)값이 들어있는데 해당 시간이 끝날때까지 캐시된다              비용 : 보통 제 3사업자에 의해 운영되며 CDN으로 들어가고 나가는 데이터 전송량에따라 비용을 지불함. 이득이 크지않다면 사용하지않아도 무방함  만료시한 : 시의성이 중요한 콘텐츠일 경우 만료시점을 잘 정의해야함. 너무 길지도, 짧지도 않아야하는데 너무길면 콘텐츠의 신선도가 떨어지고 짧으면 원본서버에 너무 빈번히 접속하게됨  CDN 장애 대처 : CDN이 죽었을때 웹/어플리케이션이 어떻게 동작해야하는지? 원본서버에서 직접 가져오도록 구성하는것이 필요할수도있음  콘텐츠 무효화 : 아직 만료되자않았어도 무효화          CDN 사업자가 제공하는 API      콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝을 이용(url마지막 인자에 버전정보를 인자로 줌)      무상태 웹 계층웹 계층에서 제거하고 상태정보(사용자 세션 데이터 등)를 제거하고 RDBMS나 NoSQL에 저장하는방법서버가 여러개다보니 상태정보를 웹서버에 저장하게되면 A서버에있는 상태정보가 B서버에 없어서 생기는 문제임사용자 A의 요청은 전부 A서버로 전송되어야하는데 로드밸런서가 이를 지원하기위해 고정 세션이라는 기능을 제공하고있기는 하지만 로드밸런서에 부담을 줄 수 있고 로드밸런서 뒷단에 서버를 추가하거나 제거하기도 까다로워짐편의상 NoSQL로 적었는데 관계형데이터베이스, redis 등도 가능하다데이터 센터장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내됨. 이 절차를 통산 지리적라우팅이라고 부름만약 데이터센터 중 하나가 장애가 발생하면 모든 트래픽이 다른 데이터서버로 전송됨  트래픽 우회 : 올바른 데이터 센터로 트래필을 보내는 효과적인 방법을 찾아야함. GeoDNS는 가장 가까운 데이터 센터로 트래픽을 보낼 수 있어야함  데이터 동기화 : 데이터 센터마다 데이터베이스의 정보가 다를때 한 데이터센터가 장애가 발생하여 우회한다고해도 해당 데이터센터에 찾는 데이터가 없을수도있음보편적으로 데이터를 여러 데이터센터에 걸쳐 다중화함  메세지 큐          무손실을 보장하는 비동기 통신 지원 컴포넌트      메세지의 버퍼역할을 함      생산자/발행자라 불리는 입력서비스가 메세지를 만들어 메세지큐에 발행, 큐에는 소비자/구독자의 서비스/서버가 연결되어있는데 메세지를 받아 그에 맞는 동작을 수행함      서비스, 서버간의 결합이 느슨해져서 규모확장성이 보장되어야하는 안정적인 애플리케이션을 구성하기 좋음      사진보정애플리케이션의 보정작업은 시간이 걸릴수도있는 프로세스이기때문에 비동기를 활용하면 좋음        로그, 메트릭 그리고 자동화        로그        에러 모니터링을 위해 사용        메트릭        사업현황에 유용한 정보를 얻을 수 있음              호스트 단위 메트릭 : CPU, 메모리, 디스트I/O에 관한 메트릭이 여기 해당  종합 메트릭 : 데이터베이스 계층의 성능, 캐시계층의 성능  핵심 비즈니스 메트릭 : 일별 능동 사용자, 수익, 재방문같은 것이 여기 해당    자동화    지속적 통합을 도와주는 도구를 사용하면 개발자가 만드는 코드가 어떤 검증절차를 자동으로 거치도록 할수있어 문제감지에 용이함    데이터 베이스의 수평적 확장(샤딩)    서버를 추가해서 성능을 확장시키는 방법데이터베이스를 샤드라고 부르는 작은 단위로 분할같은 스키마를 쓰지만 샤드에 보관되는 데이터사이에 중복은 없음어느 샤드에 데이터를 저장할지는 PK에 따라 정함가장중요한것은 샤딩 키를 어떻게 정하느냐임    데이터 재 샤딩 : 데이터가 많아져 하나의 샤드로 감당불가할때 or 샤드간 데이터 분포 불균등(샤드소진)5장의 안정 해시방법으로 해결가능  유명인사 문제 : 한 샤드에 많이조회되는 key가 몰려있어 한 샤드에 접속이 집중됨  조인, 비정규화 : 하나의 db를 여러 사드로 쪼개면 조인이 불가능해지는 문제발생 -&gt; 데이터베이스 비정규화"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 프록시 기술과 한계",
    "url": "/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EA%B8%B0%EC%88%A0%EA%B3%BC%ED%95%9C%EA%B3%84/",
    "categories": "Spring",
    "tags": "프록시, spring, 김영한스프링핵심원리-고급",
    "date": "2024-03-02 00:00:00 +0900",
    





    
    "snippet": "JDK 동적 프록시의 한계      타입캐스팅    인터페이스 기반으로 프록시를 생성하기때문에 구체클래스로 타입캐스팅이 불가능하다는 한계가 있음      package hello.aop.proxys;      import org.junit.jupiter.api.Assertions;  import org.junit.jupiter.api.Test;  im...",
    "content": "JDK 동적 프록시의 한계      타입캐스팅    인터페이스 기반으로 프록시를 생성하기때문에 구체클래스로 타입캐스팅이 불가능하다는 한계가 있음      package hello.aop.proxys;      import org.junit.jupiter.api.Assertions;  import org.junit.jupiter.api.Test;  import org.springframework.aop.framework.ProxyFactory;      import hello.aop.member.MemberService;  import hello.aop.member.MemberServiceImpl;  import lombok.extern.slf4j.Slf4j;      @Slf4j  public class ProxyCastingTest {  \t@Test  \tvoid jdkProxy() {  \t\tMemberServiceImpl target = new MemberServiceImpl();  \t\tProxyFactory proxyFactory = new ProxyFactory(target);  \t\t//jdk동적 프록시 사용  \t\tproxyFactory.setProxyTargetClass(false);      \t\t//프록시를 인터페이스로 캐스팅 성공  \t\tMemberService memberServiceProxy = (MemberService) proxyFactory.getProxy();      \t\t//JDK동적 프록시를 구현 클래스로 캐스팅 시도 실패 (예외발생)  \t\t//class jdk.proxy3.$Proxy12 cannot be cast to class hello.aop.member.MemberServiceImpl  \t\t// MemberServiceImpl castingMemberServiceImpl = (MemberServiceImpl) memberServiceProxy;  \t\tAssertions.assertThrows(ClassCastException.class, () -&gt; {  \t\t\tMemberServiceImpl castingMemberServiceImpl = (MemberServiceImpl) memberServiceProxy;  \t\t});      \t}  }            JDK프록시가 인터페이스인 MemberService를 기반으로 생성된 프록시기때문에 MemberService로의 캐스팅은 문제가없지만 MemberServiceImpl이 무엇인지는 알 수 없기때문에 타입 캐스팅이 불가능하다    그러나 CGLIB는 클래스 기반으로 proxy를 생성함      \t@Test  \tvoid cglibProxy() {  \t\tMemberServiceImpl target = new MemberServiceImpl();  \t\tProxyFactory proxyFactory = new ProxyFactory(target);  \t\t//CGLIB 프록시 사용  \t\tproxyFactory.setProxyTargetClass(true);      \t\t//프록시를 인터페이스로 캐스팅 성공  \t\tMemberService memberServiceProxy = (MemberService) proxyFactory.getProxy();      \t\t//성공  \t\tMemberServiceImpl castingMemberServiceImpl = (MemberServiceImpl) memberServiceProxy;  \t}        MemberServiceImpl을 기반으로 proxy를 생성했기때문에 인터페이스, 구체클래스 모두 타입캐스팅이 가능함        의존관계 주입 문제    타입캐스팅문제와 이어지는 내용      package hello.aop.proxys.codes;      import org.junit.jupiter.api.Test;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.boot.test.context.SpringBootTest;  import org.springframework.context.annotation.Import;      import hello.aop.member.MemberService;  import hello.aop.member.MemberServiceImpl;  import lombok.extern.slf4j.Slf4j;      @Slf4j  //JDK동적 프록시 설정  @SpringBootTest(properties = {\"spring.aop.proxy-target-class=false\"})  @Import(ProxyDIAspect.class)  public class ProxyDITest {  \t@Autowired  \tMemberService memberService;  \t@Autowired  \tMemberServiceImpl memberServiceImpl;      \t@Test  \tvoid go() {  \t\tlog.info(\"memberService class ={}\", memberService.getClass());     \t/*에러 발생*/log.info(\"memberServiceImpl class ={}\", memberServiceImpl.getClass());  \t\tmemberServiceImpl.hello(\"hello\");  \t}  }                물론 CGLIB는 가능함  ⇒ 스프링부트가 기본 proxy타입을 CGLIB로 한 이유CGLIB 한계단, CGLIB는 구체클래스를 상속받아서 AOP를 생성하기때문에 상속이 가지는 문제점을 그대로 편승한다  제약 : 상속을 사용하기때문에 몇가지 제약이있음          기본 생성자 필수      부모클래스 생성자를 체크해야함 → 자식클래스를 동적생성하기때문에 부모클래스에 기본생성자가 필요함(생성자 2번 호출)      클래스에 final이 붙으면 상속불가 → CGLIB에서 예외 발생      메소드에 final이 붙이면 해당 메소드를 오버라이딩 할 수 없다 → CGLIB에서 프록시로직이 동작하지않음        — (그러나 웹 애플리케이션 개발 시 final을 잘 사용하지는 않아서 큰 문제는 안됨. 프레임워크 개발시에는 문제요소 있음)  스프링의 해결책CGLIB는 스프링 내부에 함께 패키징 되어있어 의존성 추가를 해줄 필요없다또한 스프링 4.0부터는 CGLIB의 기본생성자 문제와 생성자 2번 호출 문제가 해결됨 (objenesis 라이브러리 사용)스프링 부터 2.0부터는 별도의 설정이없다면 CGLIB를 사용하고있음사실 개발자입장에서는 JDK 동적 프록시를 쓰든 CGLIB를 쓰든 문제만없으면 되기때문에 상관이없긴함"
  },
  
  {
    "title": "[스프링 부트와 AWS로 혼자 구현하는 웹 서비스] 2장 스프링 부트에서 테스트 코드를 작성하자",
    "url": "/posts/spring_aws_tdd/",
    "categories": "Spring",
    "tags": "spring, aws, 스프링부트와AWS로혼자구현하는웹서비스, tdd",
    "date": "2024-03-02 00:00:00 +0900",
    





    
    "snippet": "  레드 그린 사이클          항상 실패하는 테스트를 먼저 작성(red)      테스트가 통과하하는 프로덕션 코드를 작성(green)      테스트가 통과하면 프로덕션 코드를 리팩토링(Refactor)        테스트 코드 작성 이유          단위 테스트는 개발단계 초기에 문서를 발견하게 도와줌      단위 테스트는 개발자가 나...",
    "content": "  레드 그린 사이클          항상 실패하는 테스트를 먼저 작성(red)      테스트가 통과하하는 프로덕션 코드를 작성(green)      테스트가 통과하면 프로덕션 코드를 리팩토링(Refactor)        테스트 코드 작성 이유          단위 테스트는 개발단계 초기에 문서를 발견하게 도와줌      단위 테스트는 개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지 확인 가능 (ex. 회귀 테스트)      단위 테스트는 기능에 대한 불확실성을 감소      단위 테스트는 시스템에 대한 실제 문서를 제공(테스트 자체가 문서로 사용가능함)      시간 절약.   System.out.println 등으로 콘솔에서 확인하는 시간을 줄여줌. 테스트가 개발자가 원하는대로 나오지 않으면 다시 톰캣을 재시작해야함.      자동검증 가능.   단위테스트를 실행만 하면 더는 수동검증은 불필요함.   A 코드를 수정했을 때 B 코드에 영향을 준다면 B 코드의 테스트가 실패해 예상못한 이슈를 방지가능      단위 테스트 코드package jojoldu.webservice.controller;import org.assertj.core.api.Assertions;import org.hamcrest.core.Is;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.hamcrest.Matchers.is;import jojoldu.webservice.controller.dto.HelloResponseDto;@WebMvcTest(controllers = HelloController.class) //특정 컨트롤러를 대상으로 하는 단위 테스트를 작성할 때 사용. //선언 시 controllerAdvice 사용가능, service, repository, component 사용불가class HelloControllerTest {\t@Autowired\tprivate MockMvc mvc;\t@Test\tpublic void hello가_리턴된다() throws Exception {\t\tString hello = \"hello\";\t\tmvc.perform(get(\"/api/hello\"))\t\t\t.andExpect(status().isOk()) //응답코드가 200인지\t\t\t.andExpect(content().string(hello));\t}\t@Test\tpublic void 롬복기능_테스트() throws Exception {\t\tString name = \"test\";\t\tint amount = 1000;\t\tHelloResponseDto dto = new HelloResponseDto(name, amount);\t\tAssertions.assertThat(dto.getName()).isEqualTo(name);\t\tAssertions.assertThat(dto.getAmount()).isEqualTo(amount);\t\tmvc.perform(get(\"/api/hello/dto\")\t\t\t\t.param(\"name\", name)\t\t\t\t.param(\"amount\", String.valueOf(amount)))\t\t\t.andExpect(status().isOk())\t\t\t.andExpect(jsonPath(\"$.name\", is(name)))\t\t\t.andExpect(jsonPath(\"$.amount\", is(amount)));\t}}  @WithMockUser : 컨트롤러 테스트 시 필요한 유저의 인증정보를 제공하는 어노테이션 ( ↔@WithAnonymousUser). 특정 권한 부여 시 @WithMockUser(roles=”ADMIN”)으로 사용"
  },
  
  {
    "title": "[스프링 부트와 AWS로 혼자 구현하는 웹 서비스] 8장 EC2 서버에 프로젝트를 배포해 보자",
    "url": "/posts/spring_aws_ec2_2/",
    "categories": "AWS",
    "tags": "spring, aws, 스프링부트와AWS로혼자구현하는웹서비스, ec2, 배포",
    "date": "2024-03-02 00:00:00 +0900",
    





    
    "snippet": "sudo yum install git 으로 git 먼저 설치mkdir ~/app &amp;&amp; mkdir ~/app/step1 → cd ~/app/step1 먼저 git clone 할 경로 먼저 만들어주고 git clone./gradlew test로 빌드되는지 확인      빌드 중 멈춤 현상 발생    구글링해보니 메모리 부족이슈라는 답을 얻었...",
    "content": "sudo yum install git 으로 git 먼저 설치mkdir ~/app &amp;&amp; mkdir ~/app/step1 → cd ~/app/step1 먼저 git clone 할 경로 먼저 만들어주고 git clone./gradlew test로 빌드되는지 확인      빌드 중 멈춤 현상 발생    구글링해보니 메모리 부족이슈라는 답을 얻었음..  프리티어로안되나? 연습용으로 간단한 api 하나 만든 스프링프로젝트라 그럴리가 없는데?    하던 도중 스택플로우에서 본   sudo apt-get install lib32stdc++6  sudo apt-get install lib32z1    이 두 명령어를 실행했는데! 안됨..    결국 스왑메모리 설정을 해보기로 결정..    참고로 스왑메모리는 ram이 부족하면 SSD나 HDD의 공간을 ram처럼 사용할수있는 메모리라고함!          하드디스크 용량 확인 df -h      스왑메모리 확인 free      스왑 파일 생성 sudo fallocate -l 2G /swapfile      스왑 권한 설정 sudo chmod 600 /swapfile      파일적용 sudo mkswap /swapfile sudo swapon /swapfile      부팅시 스왑파일 활성화 sudo nano /etc/fstab                  할당 전 메모리           할당 후 메모리                     만약 프로젝트에 push했다면 pull로 땡겨서 하면됨만약 권한없다는 permission denied 에러가 뜬다면chmod +x ./gradlew 로 권한 부여한 후 테스트수행이 과정을배포할때마다 하면 귀찮으니 스크립트를 만들겟음vim ~/app/step1/deploy.sh#!/bin/bashREPOSITORY=/home/ec2-user/app/step1PROJECT_NAME=springboot-web-practisecd $REPOSITORY/$PROJECT_NAME/echo \"&gt; Git Pull\"git pullecho \"&gt; 프로젝트 Build 시작\"./gradlew buildecho \"&gt; step1 디렉토리로 이동\"cd $REPOSITORYecho \"&gt; Build 파일 복사\"cp $REPOSITORY/$PROJECT_NAME/build/libs/*.jar $REPOSITORY/echo \"&gt; 현재 구동중인 어플리케이션 pid 확인\"CURRENT_PID=$(pgrep -f ${PROJECT_NAME}.*.jar)echo \"&gt; 현재 구동중인 어플리케이션 pid: $CURRENT_PID\"if [ -z \"$CURRENT_PID\" ]; then\techo \"&gt; 현재 구동 중인 어플리케이션이 없으므로 종료하지 않습니다.\"else\techo \"&gt; kill -15 $CURRENT_PID\"    kill -15 $CURRENT_PID    sleep 5fiecho \"&gt; 새 어플리케이션 배포\"JAR_NAME=$(ls -tr $REPOSITORY/ | grep jar | tail -n 1)echo \"&gt; JAR Name: $JAR_NAME\"nohup java -jar $REPOSITORY/$JAR_NAME 2&gt;&amp;1 &amp;chmod +x ./deploy.sh 실행권한 추가./deploy.sh 으로 실행vim nohup 으로가면 실행 애플리케이션 로그를 가지고있음다음장인 CI/CD와 무중단 배포는 도서관 대여기간 이슈로 진행하지못하였다.. 다음에 다시 대여해서 정리해볼예정"
  },
  
  {
    "title": "[스프링 부트와 AWS로 혼자 구현하는 웹 서비스] 6장 AWS 서버 환경을 만들어보자 - AWS EC2",
    "url": "/posts/spring-aws_ec2/",
    "categories": "AWS",
    "tags": "spring, aws, 스프링부트와AWS로혼자구현하는웹서비스, ec2",
    "date": "2024-03-02 00:00:00 +0900",
    





    
    "snippet": "인스턴스 시작인스턴스 세부정보는 기업에서 사용할 경우에는 세세하게 다루지만 혼자 1대의 서버를 다룰때는 굳이 설정하지않아도됨. 자세한건 다른 AWS책에서 찾아볼것.다른유형을 선택하면 비용청구됨다른유형을 선택하면 비용청구됨프리티어유형인 t2.micro를 선택t2는 요금제, micro는 사양을 의미t2외에 t3도 있는데 이들을 T시리즈(범용 시리즈)라고부...",
    "content": "인스턴스 시작인스턴스 세부정보는 기업에서 사용할 경우에는 세세하게 다루지만 혼자 1대의 서버를 다룰때는 굳이 설정하지않아도됨. 자세한건 다른 AWS책에서 찾아볼것.다른유형을 선택하면 비용청구됨다른유형을 선택하면 비용청구됨프리티어유형인 t2.micro를 선택t2는 요금제, micro는 사양을 의미t2외에 t3도 있는데 이들을 T시리즈(범용 시리즈)라고부름(다른 시리즈는 nano, macro등의 저사양이 존재하지않음)크레딧이라는 일종의 CPU사용가능한 포인트 개념이 있는데 인스턴스 크기에따라 정해진비율로 크레딧을 계속 받으며 사용하지않을때는 크레딧을 축적하고 사용할때 축적된 크레딧을 사용함크레딧을 모두 사용하면 EC2들 더이상 사용할 수 없어 트래픽이 높은 서비스는 T시리즈가아닌 다른 시리즈를 사용하기도함  ssn - port 22 : 터미널로 AWS접속할때 key가없으면 접속이안되니 간혹 전체접속 허용(0.0.0./0, ::/0)하는 경우가 있는데 실수로 pem 키가 노출되는순간 가상화폐 채굴에 이용되기도함 따라서 pem키 관리와 지정된 IP에서만 접근할 수 있도록 구성하는것이 안전함  집을 기본설정하고 외부에서 접속할때 ssh에 해당 장소의 IP를 추가하는것을 권장함  사용자 지정 TCP - port {애플리케이션 포트번호} : 프로젝트의 기본 포트설정 추가. 보안그룹 경고가 날수있는데 이건 지정한 애플리케이션 포트번호가 전체허용되어서 그런것임. 그리 위험한일은 아니니 무시하고 시작해도됨인스턴스는 비밀키(pem)과 매칭되는 공개키를 가지고있어 해당 pem키 외에는 접근을 허용하지않음. 일종의 마스터키이기때문에 유출되면안됨30기가까지 프리티어임EIP할당AWS의 고정 IP를 Elastic IP(EIP)라고 부름. 인스턴스의 퍼블릭 IP는 유동적 주소라서 인스턴스 중지, 실행 시 새주소가 할당됨. 고정 IP를 인스턴스에 할당하는 과정이 필요함생성은 무료이나 생성 후 방치하면 요금이 부과된다고함! 안쓰면 삭제할것!!위 과정으로 인스턴스와 연결해주면됨ec2 터미널 접속글은 Mac을 기준으로 작성하였지만 같은방법으로 윈도우에서 진행했을때도 정상 접속되는것을 확인함.윈도우에서 putty를 이용하여 접근하는 방법도 사용해보았으나 해당 방법이 더 간단함ssh -i {pem키위치} {ec2탄력적IP주소) 로 접속 가능하나 바로접속은 안될거임chmod 600 {pem키위치} 로 권한을 먼저 변경해준 후 접속가능함그러나 ec2에 접속할때마다 pem키를 찾는것은 너무 비효율적임그래서 pem키를 복사한 후 따로 설정해줄것임cp {pem키 다운위치} ~/.ssh/chmod 600 {~/.ssh/{pem키이름}}vim ~/.ssh/configHost {본인이원하는서비스명}HostName {탄력적IP}User ec2-userIdentityFile ~/.ssh/{pem키 이름}을 config에 설정해줌      2024/04/06 글 추가    User ec2-user 부분은 사용자이름이 인스턴스의 이름과 같아야 접속이 가능함 ec2-user는 처음 인스턴스생성시 아마존을 선택했을때 기본으로 지정되는 유저이름인듯함.  우분투로 생성하면 사용자이름은 ubuntu이기때문에 아래처럼 작성해주어야함          &gt; Host {본인이원하는서비스명}     HostName {탄력적IP}     User ubuntu     IdentityFile ~/.ssh/{pem키 이름}      이까지했을때 이렇게나옴chmod 700 ~/.ssh/config 까지 한 후ssh {본인이원하는서비스명}을 해주면 접속 성공함  아마존 리눅스 설정                  자바 설치        sudo yum install java-17-amazon-corretto 자바 17버전 설치(아마존 리눅스서버 1 기준 기본 자바버전이 java7. 책에서는 자바 8버전을 설치하나 17버전으로 설치했음)        사실 설치하기전에 ec2자체 자바버전이 몇인지 확인을 못해서 아직 기본버전이 7인지는 모르겠다;; 다음에 ec2 인스턴스 생성할때 꼭 확인해보고 업데이트하겠음;;        —&gt; 2024/04/06 우분투는 설치안돼있음        sudo /usr/sbin/alternatives --config java 인스턴스 버전 변경                sudo yum remove {삭제하려는자바버전} 으로 사용하지않는 자바버전은 삭제 가능함                    타임존 변경        EC2 서버의 기본 타임존은 UTC라 한국시간과 9시간 차이남. java 어플리케이션에서도 9시간씩 차이가 나서 미리 꼭 수정해두어야함  sudo rm /etc/localtime  sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime  설정 후 date 명령어로 현재시간이 나오는지 확인                            HostName 변경        서버가 여러개인경우 ip만으로 어떤 서비스의 서버인지 확인이 어려워서 각 서버가 어떤 서비스인지 표현하기위해 변경함  sudo vim /etc/sysconfig/network                HOSTNAME을 사진과 같이 추가한다.  처음에 wm-service로만 등록했다가 안돼서 별짓다했는데 HOSTNAME에 .이 하나는 있어야하나봄                hostName확인  sudo reboot로 재부팅하면 됨  sudo vim /etc/hosts 에 127.0.0.1  에 HOSTNAME을 방금 등록한 호스트명으로 등록함                설정 후 curl {HOSTNAME} 을 했을때                위처럼 80포트로 실행된 서비스가 없음. 이라는 문구가 떠야 정상임            "
  },
  
  {
    "title": "[스프링 부트와 AWS로 혼자 구현하는 웹 서비스] 7장 AWS에 데이터베이스 환경을 만들어보자 - AWS RDS",
    "url": "/posts/spring-aws-rds/",
    "categories": "AWS",
    "tags": "aws, spring, 스프링부트와AWS로혼자구현하는웹서비스, RDS",
    "date": "2024-03-02 00:00:00 +0900",
    





    
    "snippet": "설정mariaDB를 사용할것임위 설정으로 생성하면되는데검색해보니 DB인스턴스 클래스는 프리티어를 선택했기때문에 버스터블 클래스(t클래스포함) 만 선택가능하다고한다추가로 책에는 설명이없지만 과금방지를 위해 유지 관리의 마이너버전 자동업그레이드 사용도 해제해주었다설정한다면 마이너 버전이 자동으로 업그레이드되며 DB는 약 30분간 정지된다고한다. (해제해주...",
    "content": "설정mariaDB를 사용할것임위 설정으로 생성하면되는데검색해보니 DB인스턴스 클래스는 프리티어를 선택했기때문에 버스터블 클래스(t클래스포함) 만 선택가능하다고한다추가로 책에는 설명이없지만 과금방지를 위해 유지 관리의 마이너버전 자동업그레이드 사용도 해제해주었다설정한다면 마이너 버전이 자동으로 업그레이드되며 DB는 약 30분간 정지된다고한다. (해제해주어도 취약점 대응시 강제 업데이트가 될 수도 있다고 한다)파라미터 설정버전은 아까 생성한 RDS와 동일버전으로 선택생성 후 목록에서 편집으로 이동한 후 타임존 설정서울로 지정Character Set    utf8mb4가 이모지 사용이 가능해서 보통 많이 씀Max Connection인스턴스 사양에 맞게 자동으로 정해지나 현재 프리티어 사양으로는 60개의 커넥션만 가능해서 넉넉하게 설정함사양을 높이게된다면 기본값으로 돌려놓으면됨다시 rds로 돌아가서파라미터 설정까지해줌보안그룹생성한 RDS에서 보안그룹 밑의 ID링크를 클릭잘못보고 아웃바운드에서 설정을 했는데..인바운드로해야함.. 설정은 다시했는데 캡쳐를 안함;;RDS보안그룹에 EC2보안그룹의 ID를 넣어서 저장해줌.RDS의 엔드포인트로 DB 연결가능해짐ec2에 RDS 접근확인접근 테스트를 위해 ec2에 mysql을 설치함sudo yum install mysql 을 시도했으나 실패하여 찾아보니Amazon linux의 yum에는 mysql 설치 경로가 없기때문에 아래명령어로 yum repository에 등록을 먼저 해줘야한다고sudo yum install https://dev.mysql.com/get/mysql80-community-release-el7-5.noarch.rpmyum repository에 등록 후 sudo yum install mysql로 mysql을 설치했으나Problem: conflicting requests 에러가뜸에러내용을 확인해보니 아마존 리눅스 2023을 쓸 때는 el9 버전 레포지토리를 사용해주어야 한다sudo dnf install [https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm](https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm)sudo dnf install mysql-community-server을 했더니 이번엔 GPG 키에러가 발생함ㅜ Amazon Linux 2 에서 지원하지 않는 버전의 레포지토리를 설치했기 때문이라고sudo rpm --import [https://repo.mysql.com/RPM-GPG-KEY-mysql-2022](https://repo.mysql.com/RPM-GPG-KEY-mysql-2022)로 GPG키 연결을 해준 후 sudo yum update 으로 yum 업데이트까지해준 후 설치 성공했다설치 성공하여 버전정보가 조회되는것을 확인함mysql -u {마스터명} -p -h {엔드포인트} 로 접속. 비밀번호치라고나오는데 마스터명, 비밀번호 모두 RDS 생성할때 적용한걸로 사용하면됨비밀번호치고 show databases; 로 쿼리가 실행되는지 확인"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 프록시 내부 호출",
    "url": "/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EB%82%B4%EB%B6%80%ED%98%B8%EC%B6%9C/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급, 프록시",
    "date": "2024-02-26 00:00:00 +0900",
    





    
    "snippet": "문제package hello.aop.internalcall;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component; @Slf4j@Componentpublic class CallServiceV0 {    public void external() {        lo...",
    "content": "문제package hello.aop.internalcall;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component; @Slf4j@Componentpublic class CallServiceV0 {    public void external() {        log.info(\"call external\");        internal(); //내부 메소드 호출(this.internal())    }    public void internal() {        log.info(\"call internal\");    }}package hello.aop.internalcall.aop;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Slf4j@Aspectpublic class CallLogAspect {    @Before(\"execution(* hello.aop.internalcall..*.*(..))\")    public void doLog(JoinPoint joinPoint) {        log.info(\"aop={}\", joinPoint.getSignature());    }}package hello.aop.internalcall.aop;import hello.aop.internalcall.CallServiceV0;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import static org.junit.jupiter.api.Assertions.*;@Slf4j@SpringBootTest@Import({CallLogAspect.class})class CallLogAspectTest {    @Autowired    CallServiceV0 callServiceV0;    @Test    void external() {        log.info(\"target={}\", callServiceV0.getClass());        callServiceV0.external();    }    @Test    void internal() {        callServiceV0.internal();    }}문제를 파악하기위한 기본 구조external을 실행하면 internal을 호출한다그렇다면 여기서 external과 internal 둘다 어드바이스에 적용시킨다면 external 실행할때 AOP한번 internal실행할때 AOP한번 동작할까?아님external 실행한 후 로그2024-02-26T21:34:32.618+09:00  INFO 14464 — [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV0.external()2024-02-26T21:34:32.618+09:00  INFO 14464 — [    Test worker] hello.aop.internalcall.CallServiceV0     : call external2024-02-26T21:34:32.618+09:00  INFO 14464 — [    Test worker] hello.aop.internalcall.CallServiceV0     : call internal처음 external 실행 시 aop가 적용되어 로그가 찍히나 internal을 호출했을때는 로그가 찍히지않음이유는 프록시를 호출 한 후 어드바이스가 호출되는데 이 어드바이스에서 external를 호출해서 그럼즉 external메소드 내에서 호출한 internal은 어드바이스를 거치지 않고 어드바이스를 통해 호출한 external를 통해 호출한다는것그렇다면 다른 클래스의 메소드를 호출한다면 해당 클래스의 어드바이스 적용여부를 체크해야하기때문에 어드바이스가 호출될것으로 예상됨package hello.aop.internalcall;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;@Slf4j@Component@RequiredArgsConstructorpublic class CallServiceTest {    private final CallServiceV0 callServiceV0;    public void external() {        log.info(\"call external\");        callServiceV0.internal(); //외부 메소드 호출    }    public void internal() {        log.info(\"call internal\");    }}실험을 위해 같은 구조의 외부 메서드 호출 클래스를 생성함package hello.aop.internalcall.aop;import hello.aop.internalcall.CallServiceTest;import hello.aop.internalcall.CallServiceV0;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import static org.junit.jupiter.api.Assertions.*;@Slf4j@SpringBootTest@Import({CallLogAspect.class})class CallLogAspectTest {    @Autowired    CallServiceV0 callServiceV0;    @Autowired    CallServiceTest callServiceTest;    @Test    void external() {        log.info(\"target={}\", callServiceV0.getClass());        callServiceV0.external();    }    @Test    void external2() {        log.info(\"target={}\", callServiceTest.getClass());        callServiceTest.external();    }    @Test    void internal() {        callServiceV0.internal();    }}external2를 실행한 결과2024-02-26T21:44:12.988+09:00  INFO 19592 — [    Test worker] h.a.internalcall.aop.CallLogAspectTest   : target=class hello.aop.internalcall.CallServiceTest$ $SpringCGLIB$ $02024-02-26T21:44:12.993+09:00  INFO 19592 — [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceTest.external()2024-02-26T21:44:12.994+09:00  INFO 19592 — [    Test worker] hello.aop.internalcall.CallServiceTest   : call external2024-02-26T21:44:12.994+09:00  INFO 19592 — [    Test worker] h.aop.internalcall.aop.CallLogAspect     : aop=void hello.aop.internalcall.CallServiceV0.internal()2024-02-26T21:44:12.994+09:00  INFO 19592 — [    Test worker] hello.aop.internalcall.CallServiceV0     : call internal잘 찍히는것을 확인함  [!NOTE]💡 실제 코드에 AOP를 직접 적용하는 AspectJ를 사용하면 이런 문제가 발생하지 않음프록시를 통하는 것이 아니라 해당코드에 AOP코드를 붙여넣기때문에 내부호출과 무관하게 AOP를 사용가능함하지만 사용하기 까다로워서 실무에서는 거의 사용하지않는다해결법자기 자신 주입package hello.aop.internalcall;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Slf4j@Componentpublic class CallServiceV1 {    private CallServiceV1 callServiceV1; //순환참조?    @Autowired //순환참조 해결을 위한 setter주입    public void setCallServiceV1(CallServiceV1 callServiceV1) {        log.info(\"target={}\", callServiceV1.getClass());        this.callServiceV1 = callServiceV1;    }    public void external() {        log.info(\"call external\");        callServiceV1.internal();    }    public void internal() {        log.info(\"call internal\");    }}기존처럼 생성자 주입 방법을 사용하게 된다면 순환참조 문제가 발생하기때문에 setter주입으로 변경하였다그러나 현 시점으로 setter주입에 @autowired 어노테이션을 사용하여도 순환참조가 발생하여 확인해보니스프링 2.6 부터 순환참조를 기본적으로 금지하도록 변경되어 spring.main.allow-circular-references=true 를 추가해주었음package hello.aop.internalcall;import static org.junit.jupiter.api.Assertions.*;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.internalcall.aop.CallLogAspect;import lombok.extern.slf4j.Slf4j;@Slf4j@Import(CallLogAspect.class)@SpringBootTestclass CallServiceV1Test {\t@Autowired\tCallServiceV1 callServiceV1;\t@Test\tvoid external() {\t\tcallServiceV1.external();\t}}기존처럼 어드바이스로 인해 호출된 빈의 내부메소드에서 바로 다른 메소드를 참조하는 것이 아니라external()을 호출 한 후 다시 어드바이스를 호출하여 internal을 호출하는 것을 확인할 수 있음= internal을 호출할때 자기자신의 인스턴스 내에서 호출하는 것이 아니라 프록시 인스턴스 내에서 호출하는것을 확인하능함지연조회package hello.aop.internalcall;import org.springframework.beans.factory.ObjectProvider;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.stereotype.Component;import lombok.extern.slf4j.Slf4j;@Slf4j@Componentpublic class CallServiceV2 {    // private final ApplicationContext applicationContext;\tprivate final ObjectProvider&lt;CallServiceV2&gt; callServiceV2ObjectProvider;\tpublic CallServiceV2(ObjectProvider&lt;CallServiceV2&gt; callServiceV2ObjectProvider) {\t\tthis.callServiceV2ObjectProvider = callServiceV2ObjectProvider;\t}\t// public CallServiceV2(ApplicationContext applicationContext) {\t// \tthis.applicationContext = applicationContext;\t// }\tpublic void external() {        log.info(\"call external\");        CallServiceV2 callServiceV2 = callServiceV2ObjectProvider.getObject (CallServiceV2.class);        callServiceV2.internal();    }    public void internal() {        log.info(\"call internal\");    }}package hello.aop.internalcall;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.internalcall.aop.CallLogAspect;import lombok.extern.slf4j.Slf4j;@Slf4j@Import(CallLogAspect.class)@SpringBootTestclass CallServiceV2Test {\t@Autowired\tCallServiceV2 callServiceV2;\t@Test\tvoid external() {\t\tcallServiceV2.external();\t}}ApplicationContext를 주석하고 ObjectProvider&lt; CallServiceV2 &gt;로 변경한 이유는 ApplicationContext의 기능이 너무 많기때문임ObjectProvider는 스프링컨테이너에서 조회하는 것을 스프링 빈 생성 시점이 아닌 실제 객체 사용시점으로 지연할 수 있음그렇기 때문에 callServiceV2ObjectProvider.getObject (CallServiceV2.class); 를 호출하는 시점에 스프링 컨테이너에서 빈을 조회함또한 자기자신을 주입받는것이아니기때문에 순환참조도 발생하지않음구조 변경package hello.aop.internalcall;import org.springframework.beans.factory.ObjectProvider;import org.springframework.stereotype.Component;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;@Slf4j@Component@RequiredArgsConstructorpublic class CallServiceV3 {\tprivate final InternalService internalService;\tpublic void external() {        log.info(\"call external\");        internalService.internal();    }}package hello.aop.internalcall;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import lombok.extern.slf4j.Slf4j;@Slf4j@Componentpublic class InternalService {\tpublic void internal() {\t\tlog.info(\"call internal\");\t}}컨트롤러 자체를 분리시켜버림package hello.aop.internalcall;import static org.junit.jupiter.api.Assertions.*;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.internalcall.aop.CallLogAspect;import lombok.extern.slf4j.Slf4j;@SpringBootTest@Slf4j@Import(CallLogAspect.class)class CallServiceV3Test {\t@Autowired\tCallServiceV3 callServiceV3;\t@Test\tvoid external() {\t\tcallServiceV3.external();\t}}내부호출이되지않도록 구조자체를 변경하였으나 가능한 경우에만 적용할 수 있음  [!NOTE]  💡 AOP는 트랜젝션이나 로그출력기능에서 주로 사용하는데 보통 인터페이스에 메서드가 나올 규모에 AOP를 적용하게됨== public 메서드에서 주로 사용하게됨. private 단위에서는 잘 사용하지않음AOP적용을 위해 private 메소드를 외부클래스로 변경하거나 public으로 변경하는 일은 거의없음. 위 예제와같이 public 메소드에서 public메소드를 호출하는경우 내부호출 문제가 주로 발생함"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 포인트 컷 지시자",
    "url": "/posts/%ED%8F%AC%EC%9D%B8%ED%8A%B8%EC%BB%B7%EC%A7%80%EC%8B%9C%EC%9E%90/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급, 포인트컷",
    "date": "2024-02-25 00:00:00 +0900",
    





    
    "snippet": "에스팩트J가 제공하는 포인트컷 표현식(pointcut expression)을 포인트컷 표현식이라고 부른다.포인트컷 표현식은 execution같은 포인트컷 지시자(pointcut Designator)로 시작 해 PCD라 부른다  포인트컷 지시자(pointcut Designator)          execution : 메소드 실행 조인 포인트 매칭, 스...",
    "content": "에스팩트J가 제공하는 포인트컷 표현식(pointcut expression)을 포인트컷 표현식이라고 부른다.포인트컷 표현식은 execution같은 포인트컷 지시자(pointcut Designator)로 시작 해 PCD라 부른다  포인트컷 지시자(pointcut Designator)          execution : 메소드 실행 조인 포인트 매칭, 스프링 AOP에서 가장 많이 사용하고 기능도 복잡      within : 특정 타입내 조인포인트를 매칭      args : 인자가 주어진 타입의 인스턴스인 조인포인트      this : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인포인트)      target : Target객체(스프링AOP가 가르키는 실제대상)를 대상으로하는 조인포인트      @target : 실행 객체의 클래스에 주어진 타입의 어노트에션이있는 조인트를 매칭      @within: 주어진 어노테이션이있는 타입 내 조인포인트      @annotation : 메서드가 주어진 어노테이션을 가지고잇는 조인포인트를 매칭      @args : 전달된 실제인수의 런타임 타입이 주어진 타입의 어노테이션을 갖는 조인포인트      bean : 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷을 지정            기본 구조      package hello.aop.member.annotation;      import java.lang.annotation.ElementType;  import java.lang.annotation.Retention;  import java.lang.annotation.RetentionPolicy;  import java.lang.annotation.Target;      @Target(ElementType.METHOD)  @Retention(RetentionPolicy.RUNTIME)  public @interface MethodAop {  \tString value();  }              package hello.aop.member.annotation;      import java.lang.annotation.ElementType;  import java.lang.annotation.Retention;  import java.lang.annotation.RetentionPolicy;  import java.lang.annotation.Target;      @Target(ElementType.TYPE)  @Retention(RetentionPolicy.RUNTIME)  public @interface ClassAop {      }              package hello.aop.member;      public interface MemberService {  \tpublic String hello(String param);  }              package hello.aop.member;      import hello.aop.member.annotation.MethodAop;      public class MemberServiceImpl implements MemberService {  \t@Override  \t@MethodAop(\"test value\")  \tpublic String hello(String param) {  \t\treturn \"OK\";  \t}      \tpublic String internal(String param) {  \t\treturn \"OK\";  \t}  }              package hello.aop.pointcut;      import java.lang.reflect.Method;      import org.junit.jupiter.api.BeforeEach;  import org.junit.jupiter.api.Test;  import org.springframework.aop.aspectj.AspectJExpressionPointcut;      import hello.aop.member.MemberServiceImpl;  import lombok.extern.slf4j.Slf4j;      @Slf4j  public class ExecutionTest {  \tAspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();  \tMethod helloMethod;      \t@BeforeEach  \tpublic void init() throws NoSuchMethodException {  \t\thelloMethod = MemberServiceImpl.class.getMethod(\"hello\", String.class);  \t}      \t@Test  \tvoid printMethod() {  \t\t//helloMethod=public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)  \t\tlog.info(\"helloMethod={}\", helloMethod);  \t}  }          executionpackage hello.aop.pointcut;import static org.assertj.core.api.Assertions.*;import java.lang.reflect.Method;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.aop.aspectj.AspectJExpressionPointcut;import hello.aop.member.MemberServiceImpl;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ExecutionTest {\tAspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\tMethod helloMethod;\t@BeforeEach\tpublic void init() throws NoSuchMethodException {\t\thelloMethod = MemberServiceImpl.class.getMethod(\"hello\", String.class);\t}\t@Test\tvoid printMethod() {\t\t//helloMethod=public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)\t\tlog.info(\"helloMethod={}\", helloMethod);\t}\t@Test\tvoid exactMatch() {\t\tpointcut.setExpression(\"execution(public String hello.aop.member.MemberServiceImpl.hello(String))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t//가장많이 생략한 포인트컷\t@Test\tvoid allMatch() {\t\tpointcut.setExpression(\"execution(* *(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid nameMatch() {\t\tpointcut.setExpression(\"execution(* hello(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid nameMatchStar1() {\t\tpointcut.setExpression(\"execution(* hell*(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid nameMatchStar2() {\t\tpointcut.setExpression(\"execution(* *ll*(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid packageExactMethod1() {\t\tpointcut.setExpression(\"execution(* hello.aop.member.MemberServiceImpl.hello(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid packageExactMethod2() {\t\tpointcut.setExpression(\"execution(* hello.aop.member.*.*(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid packageExactFalse() {\t\tpointcut.setExpression(\"execution(* hello.aop.*.*(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();\t}\t@Test\tvoid packageExactSubPackage1() {\t\tpointcut.setExpression(\"execution(* hello.aop..*.*(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid typeExactMatch() {\t\tpointcut.setExpression(\"execution(* hello.aop.member.MemberServiceImpl.*(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid typeExactMatchSuperType() {\t\tpointcut.setExpression(\"execution(* hello.aop.member.MemberService.*(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid typeMatchNoMatchSuperTypeMethodFalse() throws NoSuchMethodException {\t\tpointcut.setExpression(\"execution(* hello.aop.member.MemberService.*(..))\");\t\tMethod internal = MemberServiceImpl.class.getMethod(\"internal\", String.class);\t\tassertThat(pointcut.matches(internal, MemberServiceImpl.class)).isFalse(); //자식에는 있어도 부모 클래스에없는 메소드는 불가능\t}\t@Test\tvoid typeMatchInternal() throws NoSuchMethodException {\t\tpointcut.setExpression(\"execution(* hello.aop.member.MemberServiceImpl.*(..))\");\t\tMethod internal = MemberServiceImpl.class.getMethod(\"internal\", String.class);\t\tassertThat(pointcut.matches(internal, MemberServiceImpl.class)).isTrue(); //자식에는 있어도 부모 클래스에없는 메소드는 불가능\t}\t//String타입의 파라미터\t@Test\tvoid argsMatch() {\t\tpointcut.setExpression(\"execution(* *(String))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t//파라미터없음\t@Test\tvoid argsMatchNoArgs() {\t\tpointcut.setExpression(\"execution(* *())\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();\t}\t//파라미터가 하나 있으나 모든 타입 허용\t@Test\tvoid argsMatchStar() {\t\tpointcut.setExpression(\"execution(* *(*))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t//파라미터 갯수와 무관하게 모든 파라미터, 모든 타입 허용\t//없음, 하나있음, 여러개있음 모두 허용\t@Test\tvoid argsMatchAll() {\t\tpointcut.setExpression(\"execution(* *(..))\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t//첫 파라미터가 String이여야함(갯수제한X)\t@Test\tvoid argsMatchString() {\t\tpointcut.setExpression(\"execution(* *(String, ..))\");\t\t//갯수제한 두려면 *로해야함\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}}withinpackage hello.aop.pointcut;import static org.assertj.core.api.Assertions.*;import java.lang.reflect.Method;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.aop.aspectj.AspectJExpressionPointcut;import hello.aop.member.MemberServiceImpl;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class WithinTest {\tAspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\tMethod helloMethod;\t@BeforeEach\tpublic void init() throws NoSuchMethodException {\t\thelloMethod = MemberServiceImpl.class.getMethod(\"hello\", String.class);\t}\t@Test\tvoid printMethod() {\t\t//helloMethod=public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)\t\tlog.info(\"helloMethod={}\", helloMethod);\t}\t@Test\tvoid withinMatch() {\t\tpointcut.setExpression(\"within(hello.aop.member.MemberServiceImpl)\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid nameMatchStar1() {\t\tpointcut.setExpression(\"within(hello.aop.member.*Service*)\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\tvoid withinSubPackage() {\t\tpointcut.setExpression(\"within(hello.aop..*)\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t@Test\t@DisplayName(\"타켓의 타입에만 직접 적용, 인터페이스를 선정하면 안됨\")\tvoid withinSuperTypeFalse() {\t\tpointcut.setExpression(\"within(hello.aop.member.MemberService)\");\t\tassertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();\t}}execution과는 다르게 부모클래스를 선언해서 자식클래스를 사용할 수 없다. execution보다는 제약이있어서 실무에서는 잘 사용하지않는다withinpackage hello.aop.pointcut;import static org.assertj.core.api.Assertions.*;import java.lang.reflect.Member;import java.lang.reflect.Method;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.aop.aspectj.AspectJExpressionPointcut;import hello.aop.member.MemberServiceImpl;public class ArgsTest {\tMethod helloMethod;\t@BeforeEach\tpublic void init() throws NoSuchMethodException {\t\thelloMethod = MemberServiceImpl.class.getMethod(\"hello\", String.class);\t}\tprivate AspectJExpressionPointcut pointcut(String expression) {\t\tAspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();\t\tpointcut.setExpression(expression);\t\treturn pointcut;\t}\t@Test\tvoid args() {\t\t//hello(String)\t\tassertThat(pointcut(\"args(String)\").matches(helloMethod, MemberServiceImpl.class)).isTrue();\t\tassertThat(pointcut(\"args(Object)\").matches(helloMethod, MemberServiceImpl.class)).isTrue();\t\tassertThat(pointcut(\"args()\").matches(helloMethod, MemberServiceImpl.class)).isFalse();\t\tassertThat(pointcut(\"args(..)\").matches(helloMethod, MemberServiceImpl.class)).isTrue();\t\tassertThat(pointcut(\"args(*)\").matches(helloMethod, MemberServiceImpl.class)).isTrue();\t\tassertThat(pointcut(\"args(String,..)\").matches(helloMethod, MemberServiceImpl.class)).isTrue();\t}\t//execution(* *(java.io.Serializable)): 메서드의 시그니처로 판단(정적)\t//args(java.io.Serializable):런타임에 전달된 인수로 판단(동적)\t@Test\tvoid argsVsExecution() {\t\t//Args\t\tassertThat(pointcut((\"args(String)\")).matches(helloMethod, MemberServiceImpl.class)).isTrue();\t\tassertThat(pointcut((\"args(java.io.Serializable)\")).matches(helloMethod, MemberServiceImpl.class)).isTrue();\t\tassertThat(pointcut((\"args(Object)\")).matches(helloMethod, MemberServiceImpl.class)).isTrue();\t\t//execution\t\tassertThat(pointcut((\"execution(* *(String))\")).matches(helloMethod, MemberServiceImpl.class)).isTrue();\t\tassertThat(pointcut((\"execution(* *(java.io.Serializable))\")).matches(helloMethod, MemberServiceImpl.class)).isFalse();\t\tassertThat(pointcut((\"execution(* *(Object))\")).matches(helloMethod, MemberServiceImpl.class)).isFalse();\t}}execution보다 동적으로 파라미터 매핑이 편리한것을 확인할 수 있음. 그러나 실무에서 java.io.Serializable을 사용할 일이 별로없음보통 단독으로사용하기보다는 파라미터 바인딩에서 주로 사용됨@target, @within@target은 부모클래스의 메서드까지 어드바이저를 적용, @within은 자기자신의 클래스에 정의된 메서드에만 어드바이스를 적용package hello.aop.pointcut;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Import;import hello.aop.member.annotation.ClassAop;import lombok.extern.slf4j.Slf4j;@Slf4j@Import({AtTargetAtWithinTest.Config.class})@SpringBootTestpublic class AtTargetAtWithinTest {\t@Autowired\tChild child;\t@ClassAop\tstatic class Child extends Parent {\t\tpublic void childMethod() {}\t}\tstatic class Parent {\t\tpublic void parentMethod() {}\t}\t@Aspect\tstatic class AtTargetAtWithinAspect {\t\t//@target : 인스턴스를 기준으로 모든 메서드의 조인포인트를 선정, 부모타입의 메서드도 적용\t\t@Around(\"execution(* hello.aop..*(..)) &amp;&amp; @target(hello.aop.member.annotation.ClassAop)\")\t\tpublic Object atTarget(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tlog.info(\"[@target] {}\", joinPoint.getSignature());\t\t\treturn joinPoint.proceed();\t\t}\t\t//within:선택된 클래스 내부에 있는 메서드만 조인 포인트로 선정, 부모타입의 메서드는 적용되지않음\t\t@Around(\"execution(* hello.aop..*(..)) &amp;&amp; @within(hello.aop.member.annotation.ClassAop)\")\t\tpublic Object atWithin(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tlog.info(\"[@within] {}\", joinPoint.getSignature());\t\t\treturn joinPoint.proceed();\t\t}\t}\tstatic class Config {\t\t@Bean\t\tpublic Parent parent() {\t\t\treturn new Parent();\t\t}\t\t@Bean\t\tpublic Child child() {\t\t\treturn new Child();\t\t}\t\t@Bean\t\tpublic AtTargetAtWithinAspect atTargetAtWithinAspect() {\t\t\treturn new AtTargetAtWithinAspect();\t\t}\t}\t@Test\tvoid success() {\t\tlog.info(\"child proxy = {}\", child.getClass());\t\tchild.childMethod(); //부모 자식 모두있는 메서드\t\tchild.parentMethod(); //부모에만있는메서드\t\t/*\t\t* 2024-02-25T14:58:07.861+09:00  INFO 49300 --- [    Test worker] h.aop.pointcut.AtTargetAtWithinTest      : child proxy = class hello.aop.pointcut.AtTargetAtWithinTest$Child$$SpringCGLIB$$0\t\t2024-02-25T14:58:07.887+09:00  INFO 49300 --- [    Test worker] h.aop.pointcut.AtTargetAtWithinTest      : [@target] void hello.aop.pointcut.AtTargetAtWithinTest$Child.childMethod()\t\t2024-02-25T14:58:07.889+09:00  INFO 49300 --- [    Test worker] h.aop.pointcut.AtTargetAtWithinTest      : [@within] void hello.aop.pointcut.AtTargetAtWithinTest$Child.childMethod()\t\t2024-02-25T14:58:07.891+09:00  INFO 49300 --- [    Test worker] h.aop.pointcut.AtTargetAtWithinTest      : [@target] void hello.aop.pointcut.AtTargetAtWithinTest$Parent.parentMethod()\t\t*/\t}}로그를 보면 child는 부모, 자식 둘다 호출이되고 parent는 부모만 호출됨 == within에서는 AOP가 적용되지않음이것도 단독으로는 잘 사용하지않고 파라미터 바인딩에 사용됨  [!NOTE]💡 args, @args, @target는 단독으로 사용하면안된다위 예제를 보면 execution(* hello.aop..*(..)) &amp; &amp; 로 적용대상의 모수를 먼저 줄인다음 해당 포인트컷지시자를 사용했음위의 3가지 지시자는 실제 객체 인스턴스가 생성된 후 실행될때 어드바이스적용여부를 확인하기때문그런데 실행시점에 일어나는 포인트컷적용여부도 결국 프록시가있어야 판단이 가능하다그러나 스프링 컨테이너가 프록시를 생성하는시점은 스프링컨테이너가만들어지는 애플리케이션 로딩시점에 적용가능하다. 결론은 위의 3가지 포인트컷지시자는 모든 스프링빈에 AOP를 적용하려고 시도함문제는 모든 스프링빈에 aop프록시를 적용하려하면 스프링이 내부에서 사용하는 빈 중 final로 지정된 빈들에서 오류가발생함!요약 : 실제 객체 인스턴스가 만들어지고 실제 런타임시점에 판단이 가능한데 프록시가 없으면 불가능해서 스프링이 프록시를 만들고봄. 이과정에서 문제가 발생함 &gt;  또한 final로 선언된 클래스는 프록시를 생성할 수 없음. 부모-자식 관계를 가질 수 없으므로 CGLIB 가 Proxy 클래스를 만들 수 없기 때문@annotation, @argspackage hello.aop.pointcut;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.member.MemberService;import hello.aop.member.MemberServiceImpl;import lombok.extern.slf4j.Slf4j;@Slf4j@SpringBootTest@Import({AtAnnotationTest.AtAnnotationAspect.class})public class AtAnnotationTest {\t@Autowired\tMemberService memberService;\t@Test\tvoid success() {\t\tlog.info(\"memberService proxy = {}\", memberService.getClass());\t\tmemberService.hello(\"helloA\");\t}\t@Aspect\tstatic class AtAnnotationAspect {\t\t@Around(\"@annotation(hello.aop.member.annotation.MethodAop)\")\t\tpublic Object doAtAnnotation(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tlog.info(\"[@annoatation]{}\",joinPoint.getSignature());\t\t\treturn joinPoint.proceed();\t\t}\t}}@MethodAop가 붙은 메서드만 위의 어드바이스가 적용됨package hello.aop.member;import org.springframework.stereotype.Service;import hello.aop.member.annotation.MethodAop;@Servicepublic class MemberServiceImpl implements MemberService {\t@Override\t@MethodAop(\"test value\")\tpublic String hello(String param) {\t\treturn \"OK\";\t}\tpublic String internal(String param) {\t\treturn \"OK\";\t}}hello에만적용된다는뜻beanpackage hello.aop.pointcut;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.junit.jupiter.api.Order;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.order.OrderService;import lombok.extern.slf4j.Slf4j;@Slf4j@Import({BeanTest.BeanAspect.class})@SpringBootTestpublic class BeanTest {\t@Autowired\tOrderService orderService;\t@Test\tvoid success() {\t\torderService.orderItem(\"itemA\");\t}\t@Aspect\tstatic class BeanAspect {\t\t@Around(\"bean(orderService) || bean(*Repository)\")\t\tpublic Object doLog(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tlog.info(\"[bean] {}\", joinPoint.getSignature());\t\t\treturn joinPoint.proceed();\t\t}\t}}이것도 잘안씀매게변수 전달package hello.aop.pointcut;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.member.MemberService;import hello.aop.member.annotation.ClassAop;import hello.aop.member.annotation.MethodAop;import lombok.extern.slf4j.Slf4j;@Slf4j@SpringBootTest@Import({ParameterTest.ParameterAspect.class})public class ParameterTest {\t@Autowired\tMemberService memberService;\t@Test\tvoid success() {\t\tlog.info(\"memberService proxy = {}\", memberService.getClass());\t\tmemberService.hello(\"helloA\");\t}\t@Aspect\tstatic class ParameterAspect {\t\t@Pointcut(\"execution(* hello.aop.member..*.*(..))\")\t\tpublic void allMember() {\t\t}\t\t@Around(\"allMember()\")\t\tpublic Object logArgs1(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tObject arg1 = joinPoint.getArgs()[0];\t\t\tlog.info(\"[logArgs1]{}, arg={}\", joinPoint.getSignature(), arg1);\t\t\treturn joinPoint.proceed();\t\t}\t\t@Around(\"allMember() &amp;&amp; args(arg, ..)\")\t\tpublic Object logArgs2(ProceedingJoinPoint joinPoint, Object arg) throws Throwable {\t\t\tlog.info(\"[logArgs1]{}, arg={}\", joinPoint.getSignature(), arg);\t\t\treturn joinPoint.proceed();\t\t}\t\t@Before(\"allMember() &amp;&amp; args(arg, ..)\")\t\tpublic void logArg3(String arg/*string 아니면 실행안됨*/) {\t\t\tlog.info(\"[logArgs3] arg={}\", arg);\t\t}\t\t//프록시에서꺼내야할때\t\t@Before(\"allMember() &amp;&amp; this(obj)\")\t\tpublic void thisArgs(JoinPoint joinPoint, MemberService obj) {\t\t\tlog.info(\"[this]{}, obj={}\", joinPoint.getSignature(), obj);\t\t}\t\t//실제객체에서꺼내야할때\t\t@Before(\"allMember() &amp;&amp; target(obj)\")\t\tpublic void targetArgs(JoinPoint joinPoint, MemberService obj) {\t\t\tlog.info(\"[target]{}, obj={}\", joinPoint.getSignature(), obj);\t\t}\t\t@Before(\"allMember() &amp;&amp; @target(annotation)\")\t\tpublic void atTarget(JoinPoint joinPoint, ClassAop annotation) {\t\t\tlog.info(\"[@target]{}, obj={}\", joinPoint.getSignature(), annotation);\t\t}\t\t@Before(\"allMember() &amp;&amp; @within(annotation)\")\t\tpublic void atWithin(JoinPoint joinPoint, ClassAop annotation) {\t\t\tlog.info(\"[@within]{}, obj={}\", joinPoint.getSignature(), annotation);\t\t}\t\t@Before((\"allMember() &amp;&amp; @annotation(annotation)\"))\t\tpublic void atAnnotation(JoinPoint joinPoint, MethodAop annotation) {\t\t\tlog.info(\"[@annotation]{}, annotationValue={}\", joinPoint.getSignature(), annotation);\t\t}\t}}  logArgs1 : joinPoint.getArgs()[0] 와 같이 매개변수를 전달 받는다.  logArgs2 : args(arg,..) 와 같이 매개변수를 전달 받는다.  logArgs3 : @Before 를 사용한 축약 버전이다. 추가로 타입을 String 으로 제한했다.  this : 프록시 객체를 전달 받는다.  target : 실제 대상 객체를 전달 받는다.  @target , @within : 타입의 애노테이션을 전달 받는다.  @annotation : 메서드의 애노테이션을 전달 받는다. 여기서는 annotation.value()로 해당 애노테이션의 값을 출력하는 모습을 확인할 수 있다. (제일쓸만함)  로그2024-02-25T16:17:41.355+09:00  INFO 65532 — [    Test worker] hello.aop.pointcut.ParameterTest         : memberService proxy = class hello.aop.member.MemberServiceImpl$ $SpringCGLIB$ $02024-02-25T16:17:41.371+09:00  INFO 65532 — [    Test worker] hello.aop.pointcut.ParameterTest         : [logArgs1]String hello.aop.member.MemberServiceImpl.hello(String), arg=helloA2024-02-25T16:17:41.374+09:00  INFO 65532 — [    Test worker] hello.aop.pointcut.ParameterTest         : [logArgs1]String hello.aop.member.MemberServiceImpl.hello(String), arg=helloA2024-02-25T16:17:41.376+09:00  INFO 65532 — [    Test worker] hello.aop.pointcut.ParameterTest         : [@annotation]String hello.aop.member.MemberServiceImpl.hello(String), annotationValue=@hello.aop.member.annotation.MethodAop(“test value”)2024-02-25T16:17:41.394+09:00  INFO 65532 — [    Test worker] hello.aop.pointcut.ParameterTest         : [logArgs3] arg=helloA2024-02-25T16:17:41.395+09:00  INFO 65532 — [    Test worker] hello.aop.pointcut.ParameterTest         : [target]String hello.aop.member.MemberServiceImpl.hello(String), obj=hello.aop.member.MemberServiceImpl@39851c52024-02-25T16:17:41.395+09:00  INFO 65532 — [    Test worker] hello.aop.pointcut.ParameterTest         : [this]String hello.aop.member.MemberServiceImpl.hello(String), obj=hello.aop.member.MemberServiceImpl@39851c5this vs target별로 안중요하다근데 어렵다어쩔까일단 * 사용못함스프링에서 AOP를 적용하면 실제 target객체대신 프록시가 빈으로 등록된다 그럼 여기서  this : 스프링빈으로 등록된 프록시 객체를 대상으로 포인트컷 매핑  target: 실제 target객체를 대상으로 포인트컷을 매칭  MemberService Interface 지정          this(MemberService) : 프록시객체를 보고 판단. this는 부모타입을 허용하기때문에 memberService interface에도 AOP적용      target(MemberService) :  target객체를 보고 판단. target은 부모타입을 허용하기때문에 memberService interface에도 AOP적용        MemberServiceImpl 구체클래스 지정          this(MemberServiceImpl) : proxy객체를 보고 판단. JDK 동적 프록시로 만들어진 proxy 객체는 MemberService 인터페이스를 기반으로 구현된 새로운 클래스다  ⇒ MemberServiceImpl을 알지못해 AOP적용대상이 아님      target(MemberServiceImpl) : target객체를 보고 판단. AOP적용대상임        MemberService interface 지정          this(MemberService) : proxy객체를 보고 판단. this는 부모를 허용해서 AOP 적용됨      target(MemberService) : target객체를 보고 판단. target은 부모를 허용해서 AOP 적용됨        MemberServiceImpl 구체클래스 지정          this(MemberServiceImpl) : proxy객체를 보고 판단하는데 CGLIB proxy객체가 MemberServiceImpl을 상속받아 만들어져서 AOP적용됨. this가 부모를 허용해서 포인트컷의 대상임                  this(MemberServiceImpl) : target객체를 보고 판단. target객체가 MemberServiceImpl타입이라 AOP적용 대상임⇒ 프로시 대상인 this는 프록시 생성전략에따라 결과가 다름                    package hello.aop.pointcut;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.member.MemberService;import hello.aop.member.MemberServiceImpl;import lombok.extern.slf4j.Slf4j;@Slf4j@SpringBootTest@Import({ThisTargetTest.ThisTargetAspect.class})public class ThisTargetTest {\t@Autowired\tMemberService memberService;\t@Test\tvoid success() {\t\tlog.info(\"memberService Proxy={}\", memberService.getClass());\t\tmemberService.hello(\"helloA\");\t}\t@Aspect\tstatic class ThisTargetAspect {\t\t//부모타입허용\t\t@Around(\"this(hello.aop.member.MemberService)\")\t\tpublic Object doThisInterface(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tlog.info(\"[this-interface] {}\", joinPoint.getSignature());\t\t\treturn joinPoint.proceed();\t\t}\t\t//부모타입허용\t\t@Around(\"target(hello.aop.member.MemberService)\")\t\tpublic Object doTargetInterface(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tlog.info(\"[target-interface] {}\", joinPoint.getSignature());\t\t\treturn joinPoint.proceed();\t\t}\t\t//부모타입허용\t\t@Around(\"this(hello.aop.member.MemberServiceImpl)\")\t\tpublic Object doThisClass(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tlog.info(\"[this-class] {}\", joinPoint.getSignature());\t\t\treturn joinPoint.proceed();\t\t}\t\t//부모타입허용\t\t@Around(\"target(hello.aop.member.MemberServiceImpl)\")\t\tpublic Object doTargetClass(ProceedingJoinPoint joinPoint) throws Throwable {\t\t\tlog.info(\"[target-class] {}\", joinPoint.getSignature());\t\t\treturn joinPoint.proceed();\t\t}\t}}  JDK프록시 로그  2024-02-25T17:19:51.082+09:00  INFO 78071 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : memberService Proxy=class jdk.proxy3.$Proxy63  2024-02-25T17:19:51.113+09:00  INFO 78071 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : [target-class] String hello.aop.member.MemberService.hello(String)  2024-02-25T17:19:51.116+09:00  INFO 78071 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : [target-interface] String hello.aop.member.MemberService.hello(String)  2024-02-25T17:19:51.119+09:00  INFO 78071 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : [this-interface] String hello.aop.member.MemberService.hello(String)  CGLIB  2024-02-25T17:21:38.735+09:00  INFO 78414 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : memberService Proxy=class hello.aop.member.MemberServiceImpl$ $SpringCGLIB$ $0  2024-02-25T17:21:38.751+09:00  INFO 78414 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : [target-class] String hello.aop.member.MemberServiceImpl.hello(String)  2024-02-25T17:21:38.752+09:00  INFO 78414 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : [target-interface] String hello.aop.member.MemberServiceImpl.hello(String)  2024-02-25T17:21:38.752+09:00  INFO 78414 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : [this-class] String hello.aop.member.MemberServiceImpl.hello(String)  2024-02-25T17:21:38.752+09:00  INFO 78414 — [    Test worker] hello.aop.pointcut.ThisTargetTest        : [this-interface] String hello.aop.member.MemberServiceImpl.hello(String)참고로 스프링은 프록시를 기본으로 CGLIB를 사용하는데 spring.aop.proxy-target-class=false false로 하면 JDK프록시로 생성됨기본값이 왜 CGLIB인지는 이후 강의에 설명"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 프록시- 프록시 패턴, 데코레이터 패턴",
    "url": "/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4,-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급, 프록시",
    "date": "2024-02-17 00:00:00 +0900",
    





    
    "snippet": "      구조1. 인터페이스 + 구현클래스 - 수동등록      package com.example.proxy.app.v1;      import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.RequestMapping...",
    "content": "      구조1. 인터페이스 + 구현클래스 - 수동등록      package com.example.proxy.app.v1;      import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RequestParam;  import org.springframework.web.bind.annotation.ResponseBody;      @RequestMapping //@Controller or RequestMapping 이 있어야 스프링 컨트롤러로 인식함  @ResponseBody  public interface OrderControllerV1 {          @GetMapping(\"/v1/request\")      String request(@RequestParam(\"itemId\") String itemId); //인터페이스에서는 @RequestParam(\"itemId\") 라고 명시해줘야 인식됨          @GetMapping(\"/v1/no-log\")      String noLog();  }          package com.example.proxy.app.v1;      public class OrderControllerV1Impl implements OrderControllerV1 {          private final OrderServiceV1 orderServiceV1;          public OrderControllerV1Impl(OrderServiceV1 orderServiceV1) {          this.orderServiceV1 = orderServiceV1;      }          @Override      public String request(String itemId) {          orderServiceV1.orderItem(itemId);          return \"OK\";      }          @Override      public String noLog() {          return null;      }  }        보통 컨트롤러는 인터페이스를 만들지않는데 컨트롤러도 인터페이스로 생성이 가능하다는걸 보여주기 위해 이번 강의에서는 컨트롤러까지 인터페이스로 생성함      package com.example.proxy.app.v1;      public interface OrderServiceV1 {      void orderItem(String itemId);  }          package com.example.proxy.app.v1;      public class OrderServiceV1Impl implements OrderServiceV1 {          private final OrderRepositoryV1 orderRepositoryV1;          public OrderServiceV1Impl(OrderRepositoryV1 orderRepositoryV1) {          this.orderRepositoryV1 = orderRepositoryV1;      }          @Override      public void orderItem(String itemId) {          orderRepositoryV1.save(itemId);      }  }          package com.example.proxy.app.v1;      public interface OrderRepositoryV1 {      void save(String itemId);  }          package com.example.proxy.app.v1;          public class OrderRepositoryV1Impl implements OrderRepositoryV1  {      @Override      public void save(String itemId) {          if(itemId.equals(\"ex\")) {              throw new IllegalArgumentException(\"예외\");          }          sleep(1000);      }          private void sleep(int millis) {          try {              Thread.sleep(millis);          }catch (Exception e) {              e.printStackTrace();          }      }  }          package com.example.proxy.config;      import com.example.proxy.app.v1.*;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;      @Configuration  public class AppV1Config {          @Bean      public OrderControllerV1 orderControllerV1() {          return new OrderControllerV1Impl(orderServiceV1());      }          @Bean      public OrderServiceV1 orderServiceV1() {          return new OrderServiceV1Impl(orderRepositoryV1());      }          @Bean      public OrderRepositoryV1 orderRepositoryV1() {          return new OrderRepositoryV1Impl();      }  }          @Import(AppV1Config.class) //클래스를 스프링 빈으로 등록  @SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")  public class ProxyApplication {        일반적인 구조의 인터페이스 - 구현클래스로 구현됨    단, 스프링 부트 3.0이상에서는 위의 구조가 작동하지않음! 아래처럼 어노테이션을 사용해주어야함      @RequestMapping //스프링은 @Controller 또는 @RequestMapping 이 있어야 스프링 컨트롤러로 인식 @ResponseBody   public interface OrderControllerV1 {}          @RestController //스프링은 @Controller, @RestController가 있어야 스프링 컨트롤러로 인식   public interface OrderControllerV1 {}          @Import(AppV1Config.class) @SpringBootApplication(scanBasePackages = \"hello.proxy.app\") //주의   public class ProxyApplication {}          @Import(AppV1Config.class) @SpringBootApplication(scanBasePackages = \"com.example.proxy.app.v3\") //주의   public class ProxyApplication {}        com.example.proxy.app → com.example.proxy.app.v3 이렇게 하는 이유는 스프링 부트 3.0부터는 @Controller , @RestController 를 사용했는데, 이렇게 하면 내부에 @Component 를 가지고 있어서 컴포넌트 스캔의 대상이 된다. 지금 처럼 컴포넌트 스캔도 되고, 빈도 수동으로 직 접 등록하게 되면 스프링 컨테이너에 등록시 충돌 오류가 발생        구조2. 구현클래스 - 수동등록      package com.example.proxy.app.v2;      import org.springframework.web.bind.annotation.GetMapping;      public class OrderControllerV2 {          private final OrderServiceV2 orderService;          public OrderControllerV2(OrderServiceV2 orderServiceV1) {          this.orderService = orderServiceV1;      }          @GetMapping(\"/v2/request\")      public String request(String itemId) {          orderService.orderItem(itemId);          return \"OK\";      }          @GetMapping(\"/v2/no-log\")      public String noLog() {          return null;      }  }          package com.example.proxy.app.v2;      public class OrderServiceV2 {          private final OrderRepositoryV2 orderRepository;          public OrderServiceV2(OrderRepositoryV2 orderRepositoryV1) {          this.orderRepository = orderRepositoryV1;      }          public void orderItem(String itemId) {          orderRepository.save(itemId);      }  }          package com.example.proxy.app.v2;          import com.example.proxy.app.v2.OrderRepositoryV2;      public class OrderRepositoryV2 {      public void save(String itemId) {          if(itemId.equals(\"ex\")) {              throw new IllegalArgumentException(\"예외\");          }          sleep(1000);      }          private void sleep(int millis) {          try {              Thread.sleep(millis);          }catch (Exception e) {              e.printStackTrace();          }      }  }          package com.example.proxy.config;      import com.example.proxy.app.v1.*;  import com.example.proxy.app.v2.OrderControllerV2;  import com.example.proxy.app.v2.OrderRepositoryV2;  import com.example.proxy.app.v2.OrderServiceV2;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;      @Configuration  public class AppV2Config {          @Bean      public OrderControllerV2 orderControllerV2() {          return new OrderControllerV2(orderServiceV2());      }          @Bean      public OrderServiceV2 orderServiceV2() {          return new OrderServiceV2(orderRepositoryV2());      }          @Bean      public OrderRepositoryV2 orderRepositoryV2() {          return new OrderRepositoryV2();      }  }          @Import(AppV2Config.class) //클래스를 스프링 빈으로 등록  @Import(AopConfig.class)  @SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")  public class ProxyApplication {                      구조3. 클래스 + 컴포넌트스캔 등록          package com.example.proxy.app.v3;          import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.RestController;          @RestController  public class OrderControllerV3 {              private final OrderServiceV3 orderService;              public OrderControllerV3(OrderServiceV3 orderServiceV1) {          this.orderService = orderServiceV1;      }              @GetMapping(\"/v3/request\")      public String request(String itemId) {          orderService.orderItem(itemId);          return \"OK\";      }              @GetMapping(\"/v3/no-log\")      public String noLog() {          return null;      }  }                  package com.example.proxy.app.v3;          import org.springframework.stereotype.Service;          @Service  public class OrderServiceV3 {              private final OrderRepositoryV3 orderRepository;              public OrderServiceV3(OrderRepositoryV3 orderRepositoryV1) {          this.orderRepository = orderRepositoryV1;      }              public void orderItem(String itemId) {          orderRepository.save(itemId);      }  }                  package com.example.proxy.app.v3;                  import org.springframework.web.bind.annotation.RestController;          @RestController  public class OrderRepositoryV3 {      public void save(String itemId) {          if(itemId.equals(\"ex\")) {              throw new IllegalArgumentException(\"예외\");          }          sleep(1000);      }              private void sleep(int millis) {          try {              Thread.sleep(millis);          }catch (Exception e) {              e.printStackTrace();          }      }  }                컴포넌트스캔으로 빈을 자동 등록하기때문에 Config설정은 해줄필요없음            프록시 패턴 구현시 사용될 app구조는 위의 구조를 사용함. 원본 코드를 손대지않고 설정만으로 로그를 찍는법을 정리할거임프록시현재는 클라이언트가 서버로 요청과 응답을 직접적으로 처리하고있음그러나 클라이언트의 요청을 직접 호출하는것이 아니라 프록시를 통해 간접 호출하는 것이 가능함이때 이 프록시가 요청을 서버로 전달하면서 특정 요구사항을 함께 처리할 수 있음. 이번강의에서는 로그찍는 기술을 의미함대표적으로 프록시로 많이 사용하는 기능은  접근제어 - 프록시패턴 : 접근 제어가 목적임          캐싱 : db에 값을 조회하려했는데 캐싱데이터에 이미 해당데이터가 있음 → db조회없이 빠르게 데이터 조회 가능      접근제어 : 권한에 따른 접근 차단      지연로딩        부가기능 추가 - 데코레이터패턴 : 새로운 기능 추가가 목적임          로그 기능 추가      요청값이나 응답값을 중간에 변형        프록시 체인 : 1번 프록시를 호출했으나 프록시 내에서 다른 프록시를 호출 ⇒ 클라이언트는 어떤 프록시가 응답을 했는지 알필요없음이 있음. 어떤 기능을 사용하냐에 따라 사용하는 디자인패턴도 달라짐대표적으로클라이언트는 요청을 서버에하는지 프록시에하는지도 알수없음프록시 패턴      테스트 코드에 lombok 사용      //테스트에 lombok 사용  testCompileOnly 'org.projectlombok:lombok'  testAnnotationProcessor 'org.projectlombok:lombok'        의존성 추가해줘야 @Slfj4같은 어노테이션을 사용가능함  캐시 적용xpackage com.example.proxy.pureProxy.code;public interface Subject {    String operation();}package com.example.proxy.pureProxy.code;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ReaSubject implements Subject {    @Override    public String operation() {        log.info(\"실제 객체 호출\");        sleep(1000);        return \"OK\";    }    private void sleep(int millis) {        try {            Thread.sleep(millis);        } catch (Exception e) {            e.printStackTrace();        }    }}package com.example.proxy.pureProxy.code;public class ProxyPatternClient {    private Subject subject;    public ProxyPatternClient(Subject subject) {        this.subject = subject;    }    public void execute() {        subject.operation();    }}package com.example.proxy.pureProxy;import com.example.proxy.pureProxy.code.CacheProxy;import com.example.proxy.pureProxy.code.ProxyPatternClient;import com.example.proxy.pureProxy.code.ReaSubject;import org.junit.jupiter.api.Test;public class ProxyPatternTest {    @Test    void noProxyTest() {        ReaSubject reaSubject = new ReaSubject();        ProxyPatternClient client = new ProxyPatternClient(reaSubject);        client.execute();        client.execute();        client.execute();    }}client.execute();를 3번호출함 → realSubject를 3번 호출해서 값을 조회함여기서 캐시를 사용하면 realSubject를 저장해두고 호출없이 바로 조회가능함캐시 적용package com.example.proxy.pureProxy.code;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class CacheProxy implements Subject {    private Subject target;    private String cacheValue;    public CacheProxy(Subject subject) {        this.target = subject;    }    @Override    public String operation() {        log.info(\"프록시 호출\");        if (cacheValue == null) {            cacheValue = target.operation();        }        return cacheValue;    }}Subject의 구현체인 프록시 안에 값을 저장해 둘 cacheValue를 선언했음cacheValue의 값이 없다면 Subject에서 값을 조회해오겠지만 있다면 꺼내쓸수있기때문에 성능상 더 빨리짐지금은 객체에서 값을 단순 조회해오기때문에 큰 차이는없으나 이것이 DB에서 쿼리로 가져오는 예시였다면 쿼리가 하나 덜나가는거임package com.example.proxy.pureProxy;import com.example.proxy.pureProxy.code.CacheProxy;import com.example.proxy.pureProxy.code.ProxyPatternClient;import com.example.proxy.pureProxy.code.ReaSubject;import org.junit.jupiter.api.Test;public class ProxyPatternTest {    @Test    void cacheProxyTest() {        ReaSubject reaSubject = new ReaSubject();        CacheProxy cacheProxy = new CacheProxy(reaSubject);        ProxyPatternClient client = new ProxyPatternClient(cacheProxy);        client.execute();        client.execute();        client.execute();    }}똑같이 3번 호출했으나 이번에는 첫번째 execute만 realSubject에서 값을 조회하고 나머지 2번은 캐시에서 값을 가져옴데코레이터 패턴      데코레이터 패턴 적용 전      package com.example.proxy.decorator.code;      public interface Component {      String operation();  }          package com.example.proxy.decorator.code;      import lombok.extern.slf4j.Slf4j;      @Slf4j  public class RealComponent implements Component {      @Override      public String operation() {          log.info(\"Real Component 실행\");          return \"data\";      }  }          package com.example.proxy.decorator.code;      import lombok.extern.slf4j.Slf4j;      @Slf4j  public class DecoratorPatternClient {      private Component component;          public DecoratorPatternClient(Component component) {          this.component = component;      }          public void execute() {          String result = component.operation();          log.info(\"result = {}\", result);      }  }          package com.example.proxy.decorator;      import com.example.proxy.decorator.code.*;  import lombok.extern.slf4j.Slf4j;  import org.junit.jupiter.api.Test;      @Slf4j  public class DecoratorPatternTest {          @Test      void noDecorator() {          Component realComponent = new RealComponent();          DecoratorPatternClient client = new DecoratorPatternClient(realComponent);          client.execute();      }  }            이런 의존관계를 가짐  응답 값 꾸며주는 데코레이터  클래스 의존관계  런타임객체 의존관계package com.example.proxy.decorator.code;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class MessageDecorator implements Component {    private Component component;    public MessageDecorator(Component component) {        this.component = component;    }    @Override    public String operation() {      log.info(\"message Decorator 실행\");        String result = component.operation();        String decoResult = \"*****\" + result + \"*****\";        log.info(\"MessageDecorator 적용 전 = {}, 적용 후 = {}\", result, decoResult);        return decoResult;    }}package com.example.proxy.decorator;import com.example.proxy.decorator.code.*;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;@Slf4jpublic class DecoratorPatternTest {    @Test    void decorator() {        Component realComponent = new RealComponent();        Component messageDecorate = new MessageDecorator(realComponent);        DecoratorPatternClient client = new DecoratorPatternClient(messageDecorate);        client.execute();    }}단순하게 메세지에 별달아주는 데코레이터를 적용함클라이언트가 메세지데코레이터를, 메세지 데코레이터가 컴포넌트의 구현클래스를 의존하면서 execute가 실행되어 컴포넌트의 구현클래스의 기능과 메세지데코레이터의 기능이 모두 실행됨MessageDecorator - MessageDecorator 실행RealComponent - RealComponent 실행MessageDecorator - MessageDecorator 꾸미기 적용 전=data, 적용 후=**data**DecoratorPatternClient - result=**data**실행시간 측정 데코레이터위의 메세지데코레이터에 실행시간을 측정하는 데코레이터까지 추가할거임  클래스 의존관계  런타임객체 의존관계package com.example.proxy.decorator.code;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class TimeDecorator implements Component {    private Component component;    public TimeDecorator(Component component) {        this.component = component;    }    @Override    public String operation() {        log.info(\"TimeDecorator 실행\");        long startTime = System.currentTimeMillis();        String result = component.operation();        long endTime = System.currentTimeMillis();        log.info(\"TimeDecorator 종료\");        log.info(\"실행 시간 : 시작 = {}, 종료 = {}\", startTime, endTime);        return result;    }}@Test    void decorator2() {        Component realComponent = new RealComponent();        Component messageDecorate = new MessageDecorator(realComponent);        Component timeDecorator = new TimeDecorator(messageDecorate);        DecoratorPatternClient client = new DecoratorPatternClient(timeDecorator);        client.execute();    }데코레이터는 스스로 존재할 수 없음. 항상 의존해야함 = 내부에 호출대상인 component를 가지고있어야함그런데 프론시패턴과 데코레이터 패턴의 모양이 거의 비슷한것을 확인할수있음디자인패턴에서 중요한것은 모양이아니라 패턴을 만든 의도이기때문임인터페이스기반 프록시 적용구조 1에 프록시를 적용하여 로그를 구현할거임  클래스 의존 관계  런타임 의존관계            ![[IMG-20240909145042-1.png      IMG-20240909145042-1.png]]      package com.example.proxy.config.v1_proxy.interface_proxy;import com.example.proxy.app.v1.OrderControllerV1;import com.example.proxy.app.v1.OrderServiceV1;import com.example.proxy.trace.TraceStatus;import com.example.proxy.trace.logtrace.LogTrace;import lombok.RequiredArgsConstructor;@RequiredArgsConstructorpublic class OrderControllerInterfaceProxy implements OrderControllerV1 {    private final OrderControllerV1 target;    private final LogTrace logTrace;    @Override    public String request(String itemId) {        TraceStatus status = null;        try {            status = logTrace.begin(\"OrderController.request()\");            //target 호출            target.request(itemId);            logTrace.end(status);        } catch (Exception e) {            logTrace.exception(status, e);            throw e;        }        return \"OK\";    }    @Override    public String noLog() {        return target.noLog();    }}package com.example.proxy.config.v1_proxy.interface_proxy;import com.example.proxy.app.v1.OrderRepositoryV1;import com.example.proxy.app.v1.OrderServiceV1;import com.example.proxy.trace.TraceStatus;import com.example.proxy.trace.logtrace.LogTrace;import lombok.RequiredArgsConstructor;@RequiredArgsConstructorpublic class OrderServiceInterfaceProxy implements OrderServiceV1 {    private final OrderServiceV1 target;    private final LogTrace logTrace;    @Override    public void orderItem(String itemId) {        TraceStatus status = null;        try {            status = logTrace.begin(\"OrderService.orderItem()\");            //target 호출            target.orderItem(itemId);            logTrace.end(status);        } catch (Exception e) {            logTrace.exception(status, e);            throw e;        }    }}package com.example.proxy.config.v1_proxy.interface_proxy;import com.example.proxy.app.v1.OrderRepositoryV1;import com.example.proxy.trace.TraceStatus;import com.example.proxy.trace.logtrace.LogTrace;import lombok.RequiredArgsConstructor;@RequiredArgsConstructorpublic class OrderRepositoryInterfaceProxy implements OrderRepositoryV1 {    private final OrderRepositoryV1 target;    private final LogTrace logTrace;    @Override    public void save(String itemId) {        TraceStatus status = null;        try {            status = logTrace.begin(\"OrderRepository.request()\");            //target 호출            target.save(itemId);            logTrace.end(status);        } catch (Exception e) {            logTrace.exception(status, e);            throw e;        }    }}프록시를 만들기 위해서 인터페이스를 구현하여 로그가 포함된 구체클래스를 만들어줬음OrderRepositoryImpl의 코드를 수정하지않고 로그를 적용할수있음package com.example.proxy.config.v1_proxy;import com.example.proxy.app.v1.*;import com.example.proxy.app.v2.OrderControllerV2;import com.example.proxy.app.v2.OrderRepositoryV2;import com.example.proxy.app.v2.OrderServiceV2;import com.example.proxy.config.v1_proxy.interface_proxy.OrderControllerInterfaceProxy;import com.example.proxy.config.v1_proxy.interface_proxy.OrderRepositoryInterfaceProxy;import com.example.proxy.config.v1_proxy.interface_proxy.OrderServiceInterfaceProxy;import com.example.proxy.trace.logtrace.LogTrace;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class InterfaceProxyConfig {    @Bean    public OrderControllerV1 orderController(LogTrace logTrace) {        OrderControllerV1Impl controller = new OrderControllerV1Impl(orderService(logTrace));        return new OrderControllerInterfaceProxy(controller, logTrace);    }    @Bean    public OrderServiceV1 orderService(LogTrace logTrace) {        OrderServiceV1Impl serviceV1 = new OrderServiceV1Impl(orderRepository(logTrace));        return new OrderServiceInterfaceProxy(serviceV1, logTrace);    }    @Bean    public OrderRepositoryV1 orderRepository(LogTrace logTrace) {        OrderRepositoryV1Impl orderRepository = new OrderRepositoryV1Impl();        return new OrderRepositoryInterfaceProxy(orderRepository, logTrace);    }}@Import(InterfaceProxyConfig.class)@SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")public class ProxyApplication public static void main(String[] args) {        SpringApplication.run(ProxyApplication.class, args);    }    @Bean    public LogTrace logTrace() {      return new ThreadLocalLogTrace();    }}그러나 너무많은 프록시 클래스가 만들어진다는 단점이있음구체클래스 기반 프록시지금까지 프록시 적용을 위해 인터페이스를 계속 만들었는데 이번엔 구체클래스만 있을때는 프록시 적용을 해볼거임package com.example.proxy.pureProxy.concreteproxy;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ConcreteLogic {    public String operation() {        log.info(\"ConcreteLogic 실행\");        return \"data\";    }}package com.example.proxy.pureProxy.concreteproxy;public class ConcreteClient {    private ConcreteLogic concreteLogic;    public ConcreteClient(ConcreteLogic concreteLogic) {        this.concreteLogic = concreteLogic;    }    public void execute() {        concreteLogic.operation();    }}package com.example.proxy.pureProxy.concreteproxy;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class TimeProxy extends ConcreteLogic {    private ConcreteLogic concreteLogic;    public TimeProxy(ConcreteLogic concreteLogic) {        this.concreteLogic = concreteLogic;    }    @Override    public String operation() {        log.info(\"timeProxy 실행\");        long startTime = System.currentTimeMillis();        String result = concreteLogic.operation();        long endTime = System.currentTimeMillis();        log.info(\"timeProxy 종료\");        log.info(\"실행 시간 : 시작 = {}, 종료 = {}\", startTime, endTime);        return result;    }}package com.example.proxy.pureProxy.concreteproxy;import org.junit.jupiter.api.Test;import java.sql.Time;public class ConcreteProxyTest {    @Test    void noProxy() {        ConcreteLogic concreteLogic = new ConcreteLogic();        ConcreteClient client = new ConcreteClient(concreteLogic);        client.execute();    }    @Test    void addProxy() {        ConcreteLogic concreteLogic = new ConcreteLogic();        TimeProxy timeProxy = new TimeProxy(concreteLogic);        ConcreteClient client = new ConcreteClient(timeProxy); //timeProxy가 concreteLogic의 자식이라 가능        client.execute();    }}상속을 이용하여 가능하다구체클래스 기반 프록시 - 적용package com.example.proxy.config.v1_proxy.concreteProxy;import com.example.proxy.app.v2.OrderControllerV2;import com.example.proxy.trace.TraceStatus;import com.example.proxy.trace.logtrace.LogTrace;public class OrderControllerConcreteProxy extends OrderControllerV2 {    private final OrderControllerV2 target;    private final LogTrace logTrace;    public OrderControllerConcreteProxy(OrderControllerV2 target, LogTrace logTrace) {        super(null);        this.target = target;        this.logTrace = logTrace;    }    @Override    public String request(String itemId) {        TraceStatus status = null;        try {            status = logTrace.begin(\"OrderController.request()\");            //target 호출            target.request(itemId);            logTrace.end(status);        } catch (Exception e) {            logTrace.exception(status, e);            throw e;        }        return \"OK\";    }    @Override    public String noLog() {        return target.noLog();    }}package com.example.proxy.config.v1_proxy.concreteProxy;import com.example.proxy.app.v2.OrderServiceV2;import com.example.proxy.trace.TraceStatus;import com.example.proxy.trace.logtrace.LogTrace;public class OrderServiceConcreteProxy extends OrderServiceV2 {    private final OrderServiceV2 target;    private final LogTrace logTrace;    public OrderServiceConcreteProxy(OrderServiceV2 orderServiceV2, LogTrace logTrace) {        //부모클래스의 기본생성자가 없어서 생기는 문제        super(null); //지금 당장은 proxy용이라서 어차피 안쓸거라 null로 주입해도 문제 없음        //↑클래스기반 프록시의 단점        this.target = orderServiceV2;        this.logTrace = logTrace;    }    @Override    public void orderItem(String itemId) {        TraceStatus status = null;        try {            status = logTrace.begin(\"OrderService.orderItem()\");            //target 호출            target.orderItem(itemId);            logTrace.end(status);        } catch (Exception e) {            logTrace.exception(status, e);            throw e;        }    }}package com.example.proxy.config.v1_proxy.concreteProxy;import com.example.proxy.app.v2.OrderRepositoryV2;import com.example.proxy.trace.TraceStatus;import com.example.proxy.trace.logtrace.LogTrace;public class OrderRepositoryConcreteProxy extends OrderRepositoryV2 {    private final OrderRepositoryV2 target;    private final LogTrace logTrace;    public OrderRepositoryConcreteProxy(OrderRepositoryV2 target, LogTrace logTrace) {        this.target = target;        this.logTrace = logTrace;    }    @Override    public void save(String itemId) {        TraceStatus status = null;        try {            status = logTrace.begin(\"OrderRepository.request()\");            //target 호출            target.save(itemId);            logTrace.end(status);        } catch (Exception e) {            logTrace.exception(status, e);            throw e;        }    }}자바기본문법에 의해 자식클래스를 생성할때는 부모클래스의 생성자를 호출해야한다는것. 이부분을 생략하면 부모클래스의 기본 생성자가 호출됨.문제는 부모인 OrderServiceV2에 기본생성자는 없고 파라미터 1개를 필수로 받고있기때문에 꼭 super(..)를 호출해주어야함그래서 어쩔수 없이 위 예제에서는 super(null);를 호출해줌. 프록시는 부모객체의 기능을 사용하지않기때문에 에러는 나지않으나 구조상 찜찜함이있음;;package com.example.proxy.config.v1_proxy;import com.example.proxy.app.v1.*;import com.example.proxy.app.v2.OrderControllerV2;import com.example.proxy.app.v2.OrderRepositoryV2;import com.example.proxy.app.v2.OrderServiceV2;import com.example.proxy.config.v1_proxy.concreteProxy.OrderControllerConcreteProxy;import com.example.proxy.config.v1_proxy.concreteProxy.OrderRepositoryConcreteProxy;import com.example.proxy.config.v1_proxy.concreteProxy.OrderServiceConcreteProxy;import com.example.proxy.config.v1_proxy.interface_proxy.OrderControllerInterfaceProxy;import com.example.proxy.config.v1_proxy.interface_proxy.OrderRepositoryInterfaceProxy;import com.example.proxy.config.v1_proxy.interface_proxy.OrderServiceInterfaceProxy;import com.example.proxy.trace.logtrace.LogTrace;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ConcreteProxyConfig {    @Bean    public OrderControllerV2 orderController(LogTrace logTrace) {        OrderControllerV2 controller = new OrderControllerV2(orderService(logTrace));        return new OrderControllerConcreteProxy(controller, logTrace);    }    @Bean    public OrderServiceV2 orderService(LogTrace logTrace) {        OrderServiceV2 serviceV2 = new OrderServiceV2(orderRepository(logTrace));        return new OrderServiceConcreteProxy(serviceV2, logTrace);    }    @Bean    public OrderRepositoryV2 orderRepository(LogTrace logTrace) {        OrderRepositoryV2 orderRepository = new OrderRepositoryV2();        return new OrderRepositoryConcreteProxy(orderRepository, logTrace);    }}package com.example.proxy;@Import(ConcreteProxyConfig.class)@SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")public class ProxyApplication {    public static void main(String[] args) {        SpringApplication.run(ProxyApplication.class, args);    }    @Bean    public LogTrace logTrace() {      return new ThreadLocalLogTrace();    }}정리하자면  클래스기반 프록시 가능  클래스 기반 프록시는 해당클래스에만, 인터페이스기반 프로시는 인터페이스만같으면 모든곳에  클래스기반 프록시는 제약이있음          부모클래스의 생성자를 호출해야함      클래스에 final이 붙으면 상속 불가      메서드에 final이 붙으면 해당 메소드를 오버라이딩 불가        인터페이스 기반 프록시는 캐스팅 단점이있다 → 뒤에 설명(정리하면 링크달것)  공통적으로 클래스가 너무 많이 생긴다는 단점이있음 ⇒ 동적 프록시로 해결"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 프록시 팩토리(스프링이 지원하는 프록시)",
    "url": "/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A9%ED%86%A0%EB%A6%AC/",
    "categories": "Spring",
    "tags": "김영한스프링핵심원리-고급, spring, 프록시",
    "date": "2024-02-17 00:00:00 +0900",
    





    
    "snippet": "JDK 동적프록시와 CGLIB를 동적으로 사용하려면(인터페이스가있는경우에는 JDK동적프록시, 아니면 CGLIB를 사용) 스프링이 제공하는 프록시 팩토리를 사용해야함사용할때 InvocationHandler(JDK 동적프록시가 제공), MethodInterceptor(CGLIB가 제공)을 각각 중복으로 만들지않고 Advice를 사용하면된다.Advice는 ...",
    "content": "JDK 동적프록시와 CGLIB를 동적으로 사용하려면(인터페이스가있는경우에는 JDK동적프록시, 아니면 CGLIB를 사용) 스프링이 제공하는 프록시 팩토리를 사용해야함사용할때 InvocationHandler(JDK 동적프록시가 제공), MethodInterceptor(CGLIB가 제공)을 각각 중복으로 만들지않고 Advice를 사용하면된다.Advice는 InvocationHandler와 MethodInterceptor를 신경쓰지않기위해 스프링이 만들어 낸 개념임결과적으로 InvocationHandler와 MethodInterceptor는 Advice를 호출하게됨. 프록시 팩토리가 Advice를 호출하는 전용 InvocationHandler와 MethodInterceptor를 내부에서 사용함또한 특정 조건에 해당하는 메서드만 프록시 로직을 적용하려면 Pointcut이라는 스프링이 만들어 낸 개념을 사용하면 된다  예제                  Advice          package com.example.proxy.common.advice;          import lombok.extern.slf4j.Slf4j;  import org.aopalliance.intercept.MethodInterceptor;  import org.aopalliance.intercept.MethodInvocation;          @Slf4j  public class TimeAdvice implements MethodInterceptor {      @Override      public Object invoke(MethodInvocation invocation) throws Throwable {          log.info(\"Time Proxy 실행\");          long startTime = System.currentTimeMillis();          //        Object result = method.invoke(target, args);          //target에 대한 정보가 invocation에 있음          Object result = invocation.proceed();                  long endTime = System.currentTimeMillis();                  long resultTime = startTime - endTime;                  log.info(\"TimeProxy 종료, resultTime={}\", resultTime);          return result;      }  }                  package com.example.proxy.proxyfactory;          import com.example.proxy.common.ConcreteService;  import com.example.proxy.common.ServiceInterface;  import com.example.proxy.common.ServiceImpl;  import com.example.proxy.common.advice.TimeAdvice;  import lombok.extern.slf4j.Slf4j;  import org.junit.jupiter.api.DisplayName;  import org.junit.jupiter.api.Test;  import org.springframework.aop.framework.ProxyFactory;  import org.springframework.aop.support.AopUtils;          import static org.assertj.core.api.Assertions.*;          @Slf4j  public class ProxyFactoryTest {              @Test      @DisplayName(\"인터페이스가 있으면 JDK동적 프록시 사용\")      void interfaceProxy() {          ServiceInterface target = new ServiceImpl();          //proxyFactory생성 시 타겟 클래스를 생성자 파라미터로 넘겨줌          ProxyFactory proxyFactory = new ProxyFactory(target);          proxyFactory.addAdvice(new TimeAdvice());          ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();                  log.info(\"targetClass={}\", target.getClass());          log.info(\"proxyClass={}\", proxy.getClass()); //class jdk.proxy3.$Proxy13                  proxy.save();          \t\t\t\t//프록시의 생성 유무          assertThat(AopUtils.isAopProxy(proxy)).isTrue();  \t\t\t\t//JDK 동적 프록시 유무          assertThat(AopUtils.isJdkDynamicProxy(proxy)).isTrue();  \t\t\t\t//CGLIB 동적프록시 유무          assertThat(AopUtils.isCglibProxy(proxy)).isFalse();      }              @Test      @DisplayName(\"구체클래스가 있으면 CGLIB 사용\")      void concreteProxy() {          ConcreteService target = new ConcreteService();          //proxyFactory생성 시 타겟 클래스를 생성자 파라미터로 넘겨줌          ProxyFactory proxyFactory = new ProxyFactory(target);          proxyFactory.addAdvice(new TimeAdvice());          ConcreteService proxy = (ConcreteService) proxyFactory.getProxy();                  log.info(\"targetClass={}\", target.getClass());          log.info(\"proxyClass={}\", proxy.getClass()); //class com.example.proxy.common.ConcreteService$$SpringCGLIB$$0                  proxy.call();                  assertThat(AopUtils.isAopProxy(proxy)).isTrue();          assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse();          assertThat(AopUtils.isCglibProxy(proxy)).isTrue();      }              @Test      @DisplayName(\"ProxyTargetClass 옵션을 사용하면 인터페이스가 있어도 CGLIB를 사용, 클래스기반 프록시 사용\")      void proxyTargetCLass() {          ServiceInterface target = new ServiceImpl();          //proxyFactory생성 시 타겟 클래스를 생성자 파라미터로 넘겨줌          ProxyFactory proxyFactory = new ProxyFactory(target);                  proxyFactory.setProxyTargetClass(true);                  proxyFactory.addAdvice(new TimeAdvice());          ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();                  log.info(\"targetClass={}\", target.getClass());          log.info(\"proxyClass={}\", proxy.getClass()); //com.example.proxy.common.ServiceImpl$$SpringCGLIB$$0                  proxy.save();                  assertThat(AopUtils.isAopProxy(proxy)).isTrue();          assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse();          assertThat(AopUtils.isCglibProxy(proxy)).isTrue();      }  }                프록시의 부가기능을 특정 기술에 종속적이지않게 Advice하나로 편리하게 사용 가능                  용어 정리          포인트컷(pointcut) : 특정 조건에따라 부가기능 적용 유무를 판단하는 필터링 로직. 주로 클래스와 메소드 이름으로 필터링함      어드바이스(Advice) : 프록시가 호출하는 부가 기능(프록시 로직)      어드바이저(Advisor) : 포인트컷 1 + 어드바이스 1 조합                어드바이저 예제코드      package com.example.proxy.advisor;      import com.example.proxy.common.ServiceImpl;  import com.example.proxy.common.ServiceInterface;  import com.example.proxy.common.advice.TimeAdvice;  import lombok.extern.slf4j.Slf4j;  import org.junit.jupiter.api.DisplayName;  import org.junit.jupiter.api.Test;  import org.springframework.aop.ClassFilter;  import org.springframework.aop.MethodMatcher;  import org.springframework.aop.Pointcut;  import org.springframework.aop.framework.ProxyFactory;  import org.springframework.aop.support.AopUtils;  import org.springframework.aop.support.DefaultPointcutAdvisor;  import org.springframework.aop.support.NameMatchMethodPointcut;      import java.lang.reflect.Method;      import static org.assertj.core.api.Assertions.assertThat;      @Slf4j  public class AdvisorTest {          @Test      void advisorTest1() {          ServiceInterface target = new ServiceImpl();          ProxyFactory proxyFactory = new ProxyFactory(target);          //Pointcut.TRUE : 항상 TRUE를 반환하는 포인트 컷. 아직 포인트컷을 구현안해서 사용함          // 기존의 proxyFactory.addAdvice 내부에 Pointcut.TRUE를 주입하는 로직이 있음          DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(Pointcut.TRUE, new TimeAdvice());          proxyFactory.addAdvisor(advisor);              ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();              log.info(\"targetClass={}\", target.getClass());          log.info(\"proxyClass={}\", proxy.getClass()); //com.example.proxy.common.ServiceImpl$$SpringCGLIB$$0              proxy.save();          proxy.find();          }          @Test      @DisplayName(\"직접만든 포인트 컷\")      void advisorTest2() {          ServiceInterface target = new ServiceImpl();          ProxyFactory proxyFactory = new ProxyFactory(target);          DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(new MyPointcut(), new TimeAdvice());          proxyFactory.addAdvisor(advisor);              ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();              log.info(\"targetClass={}\", target.getClass());          log.info(\"proxyClass={}\", proxy.getClass()); //com.example.proxy.common.ServiceImpl$$SpringCGLIB$$0              proxy.save();          proxy.find();          }      \t\t//포인트컷 생성      static class MyPointcut implements Pointcut {              @Override          public ClassFilter getClassFilter() {              return ClassFilter.TRUE; //모든 클래스에 적용          }              @Override          public MethodMatcher getMethodMatcher() {              return new MyMethodMatcher();          }      }          static class MyMethodMatcher implements MethodMatcher {              private String matchName = \"save\"; //save메소드에만 프록시 적용          @Override          public boolean matches(Method method, Class&lt;?&gt; targetClass) {              boolean result = method.getName().equals(matchName);              log.info(\"포인트컷 호출 method={}, targetClass={}\", method.getName(), targetClass);              log.info(\"result={}\", result);              return result;          }              @Override          public boolean isRuntime() {              return false; //클래스의 정적 정보만 사용(캐싱가능. true면 캐싱 불가능)          }              @Override          public boolean matches(Method method, Class&lt;?&gt; targetClass, Object... args) {              return false;          }      }          @Test      @DisplayName(\"스프링이 제공하는 포인트 컷\")      void advisorTest3() {          ServiceInterface target = new ServiceImpl();          ProxyFactory proxyFactory = new ProxyFactory(target);          NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();          pointcut.setMappedName(\"save\");              DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, new TimeAdvice());          proxyFactory.addAdvisor(advisor);              ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();              log.info(\"targetClass={}\", target.getClass());          log.info(\"proxyClass={}\", proxy.getClass()); //com.example.proxy.common.ServiceImpl$$SpringCGLIB$$0              proxy.save();          proxy.find();          }  }            만약 포인트컷 대상이 아니라면 3번이 실행되지않고 4번이 수행된다          스프링이 제공하는 포인트컷(aspectJ 표현식만 기억해도됨)                  NameMatchMethodPointcut : 메서드 이름을 기반으로 매칭한다. 내부에서는 PatternMatchUtils 를 사용한다.(ex. xxx 허용)          JdkRegexpMethodPointcut : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다.          TruePointcut : 항상 참을 반환한다.          AnnotationMatchingPointcut : 애노테이션으로 매칭한다.          AspectJExpressionPointcut : aspectJ 표현식으로 매칭한다.                          멀티 프록시 적용      package com.example.proxy.advisor;      import com.example.proxy.common.ServiceImpl;  import com.example.proxy.common.ServiceInterface;  import com.example.proxy.common.advice.TimeAdvice;  import lombok.extern.slf4j.Slf4j;  import org.aopalliance.intercept.MethodInterceptor;  import org.aopalliance.intercept.MethodInvocation;  import org.junit.jupiter.api.DisplayName;  import org.junit.jupiter.api.Test;  import org.springframework.aop.Pointcut;  import org.springframework.aop.framework.ProxyFactory;  import org.springframework.aop.support.DefaultPointcutAdvisor;  import org.springframework.aop.support.NameMatchMethodPointcut;      @Slf4j  public class MulitAdvisorTest {      @Test      @DisplayName(\"여러 프록시\")      void mulitAdvisorTest1() {          //client -&gt; proxy2(advisor2) -&gt; proxy1(advisor1) -&gt; target              //프록시1 생성          ServiceInterface target = new ServiceImpl();          ProxyFactory proxyFactory1 = new ProxyFactory(target);          DefaultPointcutAdvisor advisor1 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice1());          proxyFactory1.addAdvisor(advisor1);              ServiceInterface proxy1 = (ServiceInterface) proxyFactory1.getProxy();              //프록시 2 생성, target -&gt; proxy1 입력          ProxyFactory proxyFactory2 = new ProxyFactory(proxy1);          DefaultPointcutAdvisor advisor2 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice2());          proxyFactory2.addAdvisor(advisor2);              ServiceInterface proxy2 = (ServiceInterface) proxyFactory2.getProxy();              log.info(\"targetClass={}\", target.getClass());          log.info(\"proxyClass={}\", proxy1.getClass());              //실행          proxy2.save();              /*          15:16:35.847 [Test worker] INFO com.example.proxy.advisor.MulitAdvisorTest -- targetClass=class com.example.proxy.common.ServiceImpl  15:16:35.853 [Test worker] INFO com.example.proxy.advisor.MulitAdvisorTest -- proxyClass=class jdk.proxy3.$Proxy13  15:16:35.860 [Test worker] INFO com.example.proxy.advisor.MulitAdvisorTest -- advice2 호출  15:16:35.861 [Test worker] INFO com.example.proxy.advisor.MulitAdvisorTest -- advice1 호출  15:16:35.861 [Test worker] INFO com.example.proxy.common.ServiceImpl -- save 호출           */          //프록시를 여러개 생성해야한다는 단점 있음      }          static class Advice1 implements MethodInterceptor {              @Override          public Object invoke(MethodInvocation invocation) throws Throwable {              log.info(\"advice1 호출\");              return invocation.proceed();          }      }          static class Advice2 implements MethodInterceptor {              @Override          public Object invoke(MethodInvocation invocation) throws Throwable {              log.info(\"advice2 호출\");              return invocation.proceed();          }      }              @Test      @DisplayName(\"하나의 프록시, 여러 어드바이저\")      void multiAdviceTest2() {          //client -&gt; proxy -&gt; advisor2 -&gt; advisor1 -&gt; target          DefaultPointcutAdvisor advisor1 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice1());          DefaultPointcutAdvisor advisor2 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice2());              ServiceInterface target = new ServiceImpl();          ProxyFactory proxyFactory = new ProxyFactory(target);              //넣은 순서대로 동작함          proxyFactory.addAdvisor(advisor2);          proxyFactory.addAdvisor(advisor1);              ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();                  log.info(\"targetClass={}\", target.getClass());          log.info(\"proxyClass={}\", proxy.getClass());              //실행          proxy.save();      }  }              1프록시 1어드바이저                          1프록시 N 어드바이저                          [!important]중요한것은 어드바이저의 갯수만큼 프록시가 생성되지않는다는점임마찬가지로 스프링 AOP 적용수만큼 프록시가 생성되지않음많이 착각하는점이니 알아두면 좋음                      적용                  JDK 동적 프록시          package com.example.proxy.config.v3_proxyfactory.advice;          import com.example.proxy.trace.TraceStatus;  import com.example.proxy.trace.logtrace.LogTrace;  import org.aopalliance.intercept.MethodInterceptor;  import org.aopalliance.intercept.MethodInvocation;          import java.lang.reflect.Method;          public class LogTraceAdvice implements MethodInterceptor {      private final LogTrace logTrace;              public LogTraceAdvice(LogTrace logTrace) {          this.logTrace = logTrace;      }              @Override      public Object invoke(MethodInvocation invocation) throws Throwable {         TraceStatus status = null;          try {              Method method = invocation.getMethod();              String message = method.getDeclaringClass().getSimpleName() + \".\" + method.getName() + \"()\";              status = logTrace.begin(message);              //로직 호출              Object result = invocation.proceed();              logTrace.end(status);              return result;          } catch (Exception e) {              logTrace.exception(status, e);              throw e;          }      }          }                  package com.example.proxy.config.v3_proxyfactory;          import com.example.proxy.app.v1.*;  import com.example.proxy.config.v3_proxyfactory.advice.LogTraceAdvice;  import com.example.proxy.trace.logtrace.LogTrace;  import lombok.extern.slf4j.Slf4j;  import org.springframework.aop.Advisor;  import org.springframework.aop.framework.ProxyFactory;  import org.springframework.aop.support.DefaultPointcutAdvisor;  import org.springframework.aop.support.NameMatchMethodPointcut;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;          @Slf4j  @Configuration  public class ProxyFactoryConfigV1 {      @Bean      public OrderControllerV1 orderControllerV1(LogTrace logTrace) {          OrderControllerV1Impl orderController = new OrderControllerV1Impl(orderServiceV1(logTrace));          ProxyFactory factory = new ProxyFactory(orderController);          factory.addAdvisor(getAdvisor(logTrace));          OrderControllerV1 proxy = (OrderControllerV1) factory.getProxy();          return proxy;      }              @Bean      public OrderServiceV1 orderServiceV1(LogTrace logTrace) {          OrderServiceV1Impl orderServiceV1 = new OrderServiceV1Impl(orderRepositoryV1(logTrace));          ProxyFactory factory = new ProxyFactory(orderServiceV1);          factory.addAdvisor(getAdvisor(logTrace));          OrderServiceV1 proxy = (OrderServiceV1)factory.getProxy();          return proxy;      }              @Bean      public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace) {          OrderRepositoryV1Impl orderRepository = new OrderRepositoryV1Impl();          ProxyFactory factory = new ProxyFactory(orderRepository);          factory.addAdvisor(getAdvisor(logTrace));          OrderRepositoryV1 proxy = (OrderRepositoryV1) factory.getProxy();          log.info(\"proxyFactory proxy={}, target={}\", proxy.getClass(), orderRepository.getClass());          return proxy;      }              private Advisor getAdvisor(LogTrace logTrace) {          //pointcut          NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();          pointcut.setMappedNames(\"request*\", \"order*\",\"save*\");                  //advice          LogTraceAdvice advice = new LogTraceAdvice(logTrace);          return new DefaultPointcutAdvisor(pointcut, advice);      }  }                  package com.example.proxy;          @Import(ProxyFactoryConfigV1.class)  @SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")  public class ProxyApplication {              public static void main(String[] args) {          SpringApplication.run(ProxyApplication.class, args);      }              @Bean      public LogTrace logTrace() {        return new ThreadLocalLogTrace();      }  }                위 코드는 구조1을 사용하여 인터페이스 + 구현클래스 조합이라 JDK로 동작함                    CGLIB 프록시          package com.example.proxy.config.v3_proxyfactory.advice;          import com.example.proxy.trace.TraceStatus;  import com.example.proxy.trace.logtrace.LogTrace;  import org.aopalliance.intercept.MethodInterceptor;  import org.aopalliance.intercept.MethodInvocation;          import java.lang.reflect.Method;          public class LogTraceAdvice implements MethodInterceptor {      private final LogTrace logTrace;              public LogTraceAdvice(LogTrace logTrace) {          this.logTrace = logTrace;      }              @Override      public Object invoke(MethodInvocation invocation) throws Throwable {         TraceStatus status = null;          try {              Method method = invocation.getMethod();              String message = method.getDeclaringClass().getSimpleName() + \".\" + method.getName() + \"()\";              status = logTrace.begin(message);              //로직 호출              Object result = invocation.proceed();              logTrace.end(status);              return result;          } catch (Exception e) {              logTrace.exception(status, e);              throw e;          }      }          }                  package com.example.proxy.config.v3_proxyfactory;          import com.example.proxy.app.v1.*;  import com.example.proxy.app.v2.OrderControllerV2;  import com.example.proxy.app.v2.OrderRepositoryV2;  import com.example.proxy.app.v2.OrderServiceV2;  import com.example.proxy.config.v3_proxyfactory.advice.LogTraceAdvice;  import com.example.proxy.trace.logtrace.LogTrace;  import lombok.extern.slf4j.Slf4j;  import org.springframework.aop.Advisor;  import org.springframework.aop.framework.ProxyFactory;  import org.springframework.aop.support.DefaultPointcutAdvisor;  import org.springframework.aop.support.NameMatchMethodPointcut;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;          @Slf4j  @Configuration  public class ProxyFactoryConfigV2 {      @Bean      public OrderControllerV2 orderControllerV1(LogTrace logTrace) {          OrderControllerV2 orderController = new OrderControllerV2(orderService(logTrace));          ProxyFactory factory = new ProxyFactory(orderController);          factory.addAdvisor(getAdvisor(logTrace));          OrderControllerV2 proxy = (OrderControllerV2) factory.getProxy();          return proxy;      }              @Bean      public OrderServiceV2 orderService(LogTrace logTrace) {          OrderServiceV2 orderService = new OrderServiceV2(orderRepository(logTrace));          ProxyFactory factory = new ProxyFactory(orderService);          factory.addAdvisor(getAdvisor(logTrace));          OrderServiceV2 proxy = (OrderServiceV2)factory.getProxy();          return proxy;      }              @Bean      public OrderRepositoryV2 orderRepository(LogTrace logTrace) {          OrderRepositoryV2 orderRepository = new OrderRepositoryV2();          ProxyFactory factory = new ProxyFactory(orderRepository);          factory.addAdvisor(getAdvisor(logTrace));          OrderRepositoryV2 proxy = (OrderRepositoryV2) factory.getProxy();          log.info(\"proxyFactory proxy={}, target={}\", proxy.getClass(), orderRepository.getClass());          return proxy;      }              private Advisor getAdvisor(LogTrace logTrace) {          //pointcut          NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();          pointcut.setMappedNames(\"request*\", \"order*\",\"save*\");                  //advice          LogTraceAdvice advice = new LogTraceAdvice(logTrace);          return new DefaultPointcutAdvisor(pointcut, advice);      }  }                  package com.example.proxy;          @Import(ProxyFactoryConfigV2.class)  @SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")  public class ProxyApplication {              public static void main(String[] args) {          SpringApplication.run(ProxyApplication.class, args);      }              @Bean      public LogTrace logTrace() {        return new ThreadLocalLogTrace();      }  }                위랑 구현방법은 동일하나결과가 달라서 일단 적음            남은 문제는  Config설정 파일이 너무 많다는것. 빈이 100개면 Config하나씩 다만들거?  컴포넌트 스캔방식에서 어떻게적용? 위는 빈을 수동등록했기때문에 이렇게 적용이 가능하나 어노테이션을 사용해서 컴포넌트 스캔으로 사용한다면? 프록시가 적용되지않음⇒ 빈 후처리기로 해결"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 스프링 AOP 구현",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81AOP%EA%B5%AC%ED%98%84/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급, AOP",
    "date": "2024-02-17 00:00:00 +0900",
    





    
    "snippet": "  필요한 의존성 추가          aop  implementation 'org.springframework.boot:spring-boot-starter-aop'      테스트 코드에서 롬복 사용  testCompileOnly 'org.projectlombok:lombok'testAnnotationProcessor 'org.projectlombo...",
    "content": "  필요한 의존성 추가          aop  implementation 'org.springframework.boot:spring-boot-starter-aop'      테스트 코드에서 롬복 사용  testCompileOnly 'org.projectlombok:lombok'testAnnotationProcessor 'org.projectlombok:lombok'      Aspect는 원래 @EnableAspectJAutoProxy를 추가해야하지만 스프링부트가 자동으로 추가해줌        프로젝트 구조package hello.aop.order;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Repository;@Slf4j@Repositorypublic class OrderRepository {    public String save(String itemId) {        log.info(\"[orderRepository] 실행\");        //저장 로직        if (itemId.equals(\"ex\")) {            throw new IllegalArgumentException(\"예외 발생\");        }        return \"ok\";    }}package hello.aop.order;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;@Slf4j@Servicepublic class OrderService {    private final OrderRepository orderRepository;    public OrderService(OrderRepository orderRepository) {        this.orderRepository = orderRepository;    }    public void orderItem(String itemId) {        log.info(\"[orderService] 실행\");        orderRepository.save(itemId);    }}package hello.aop.order.aop;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;@Slf4j@Aspectpublic class AspectV1 {    @Around(\"execution(* hello.aop.order..*(..))\")    public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable {        log.info(\"[log] {}\", joinPoint.getSignature());        return joinPoint.proceed();    }}package hello.aop;import hello.aop.order.OrderRepository;import hello.aop.order.OrderService;import hello.aop.order.aop.AspectV1;import lombok.extern.slf4j.Slf4j;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.aop.support.AopUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;@Slf4j@SpringBootTest@Import(AspectV1.class) //보통 설정파일을 추가할때 사용하나 빈을 등록할때도 사용가능하다. //테스트에서는 버전을 올려가면서 변경할 예정이라 Import기능을 사용했다public class AopTest {    @Autowired    OrderService orderService;    @Autowired    OrderRepository orderRepository;    @Test    void aopInfo() {\t\t\t\t//true반환됨. 위의 @Import(AspectV1.class)가 없으면 false        log.info(\"isAopProxy, orderService={}\", AopUtils.isAopProxy(orderService));        log.info(\"isAopProxy, orderService={}\", AopUtils.isAopProxy(orderRepository));    }    @Test    void success() {        orderService.orderItem(\"itemA\");    }    @Test    void exception() {        Assertions.assertThatThrownBy(() -&gt; orderService.orderItem(\"ex\"))                .isInstanceOf(IllegalArgumentException.class);    }}포인트 컷 분리package hello.aop.order.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import lombok.extern.slf4j.Slf4j;@Slf4j@Aspectpublic class AspectV2 {    //hello.aop.order 패키지와 하위 패키지    @Pointcut(\"execution(* hello.aop.order..*(..))\")    private void allOrder() { //pointcut signature    }    @Around(\"allOrder()\")    public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable {        log.info(\"[log] {}\", joinPoint.getSignature());        return joinPoint.proceed();    }    //예시를 위해 작성. 포인트 컷을 분리했기때문에 중복 선언없이 포인트컷을 호출해서 쓰면됨    @Around(\"allOrder()\")    public Object doLog2(ProceedingJoinPoint joinPoint) throws Throwable {        // log.info(\"[log] {}\", joinPoint.getSignature());        return joinPoint.proceed();    }}package hello.aop;import hello.aop.order.OrderRepository;import hello.aop.order.OrderService;import hello.aop.order.aop.AspectV1;import hello.aop.order.aop.AspectV2;import lombok.extern.slf4j.Slf4j;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.aop.support.AopUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;@Slf4j@SpringBootTest// @Import(AspectV1.class)@Import(AspectV2.class)public class AopTest {    @Autowired    OrderService orderService;    @Autowired    OrderRepository orderRepository;    @Test    void aopInfo() {        log.info(\"isAopProxy, orderService={}\", AopUtils.isAopProxy(orderService));        log.info(\"isAopProxy, orderService={}\", AopUtils.isAopProxy(orderRepository));    }    @Test    void success() {        orderService.orderItem(\"itemA\");    }    @Test    void exception() {        Assertions.assertThatThrownBy(() -&gt; orderService.orderItem(\"ex\"))                .isInstanceOf(IllegalArgumentException.class);    }}결과의 차이는 없음. 그냥 분리해서 쓸수있다는거임포인트컷 내부는 비워두어도 아무 문제없음위 예제에서는 분리한 포인트컷에 private 접근제어자를 사용했지만 public을 사용해서 다른 애스펙트에서 참고하는것도 가능하다어드바이스 추가package hello.aop.order.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import lombok.extern.slf4j.Slf4j;@Slf4j@Aspectpublic class AspectV3 {    //hello.aop.order 패키지와 하위 패키지    @Pointcut(\"execution(* hello.aop.order..*(..))\")    private void allOrder() { //pointcut signature    }    //클래스 이름 패턴이 *Service임    @Pointcut(\"execution(* *..*Service.*( ..))\")    private void allService() { //pointcut signature    }    @Around(\"allOrder()\")    public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable {        log.info(\"[log] {}\", joinPoint.getSignature());        return joinPoint.proceed();    }    //예시를 위해 작성. 포인트 컷을 분리했기때문에 중복 선언없이 포인트컷을 호출해서 쓰면됨    @Around(\"allOrder()\")    public Object doLog2(ProceedingJoinPoint joinPoint) throws Throwable {        // log.info(\"[log] {}\", joinPoint.getSignature());        return joinPoint.proceed();    }    //hello.aop.order 패키지와 하위 패키지면서 클래스 이름 패턴이 *Service    @Around(\"allOrder() &amp;&amp; allService()\")    //두 포인트 컷 모두 해당하는 곳에 적용됨    public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable {        try {            log.info(\"[트랜잭션 시작] {}\", joinPoint.getSignature());            Object result = joinPoint.proceed();            log.info(\"[트랜잭션 커밋] {}\", joinPoint.getSignature());            return result;        } catch (Exception e) {            log.info(\"[트랜잭션 롤백] {}\", joinPoint.getSignature());            throw e;        } finally {            log.info(\"[트랜잭션 릴리즈] {}\", joinPoint.getSignature());        }    }}결론적으로orderService: doLog와 doTransaction 모두 적용orderRepository : doLog만 적용      로그  2024-02-17T17:38:44.038+09:00 INFO 91584 — [ Test worker] hello.aop.AopTest : Starting AopTest using Java 20.0.1 with PID 91584 (started by rubric in /Users/rubric/Desktop/Study/Spring/aop)  2024-02-17T17:38:44.046+09:00 INFO 91584 — [ Test worker] hello.aop.AopTest : No active profile set, falling back to 1 default profile: “default”  2024-02-17T17:38:47.575+09:00 INFO 91584 — [ Test worker] hello.aop.AopTest : Started AopTest in 3.977 seconds (process running for 5.77)  2024-02-17T17:38:48.956+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [log] void hello.aop.order.OrderService.orderItem(String)  2024-02-17T17:38:48.961+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [트랜잭션 시작] void hello.aop.order.OrderService.orderItem(String)  2024-02-17T17:38:48.964+09:00 INFO 91584 — [ Test worker] hello.aop.order.OrderService : [orderService] 실행  2024-02-17T17:38:48.966+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [log] String hello.aop.order.OrderRepository.save(String)  2024-02-17T17:38:48.967+09:00 INFO 91584 — [ Test worker] hello.aop.order.OrderRepository : [orderRepository] 실행  2024-02-17T17:38:48.968+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [트랜잭션 커밋] void hello.aop.order.OrderService.orderItem(String)  2024-02-17T17:38:48.969+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [트랜잭션 릴리즈] void hello.aop.order.OrderService.orderItem(String)  2024-02-17T17:38:49.037+09:00 INFO 91584 — [ Test worker] hello.aop.AopTest : isAopProxy, orderService=true  2024-02-17T17:38:49.037+09:00 INFO 91584 — [ Test worker] hello.aop.AopTest : isAopProxy, orderService=true  2024-02-17T17:38:49.083+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [log] void hello.aop.order.OrderService.orderItem(String)  2024-02-17T17:38:49.083+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [트랜잭션 시작] void hello.aop.order.OrderService.orderItem(String)  2024-02-17T17:38:49.084+09:00 INFO 91584 — [ Test worker] hello.aop.order.OrderService : [orderService] 실행  2024-02-17T17:38:49.084+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [log] String hello.aop.order.OrderRepository.save(String)  2024-02-17T17:38:49.084+09:00 INFO 91584 — [ Test worker] hello.aop.order.OrderRepository : [orderRepository] 실행  2024-02-17T17:38:49.084+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [트랜잭션 롤백] void hello.aop.order.OrderService.orderItem(String)  2024-02-17T17:38:49.085+09:00 INFO 91584 — [ Test worker] hello.aop.order.aop.AspectV3 : [트랜잭션 릴리즈] void hello.aop.order.OrderService.orderItem(String)        포인트컷을 모듈화 하고싶다면? -&gt; 포인트컷참조    ### 포인트 컷 참조    포인트컷만 특정 클래스에 모아서 사용하는 법      package hello.aop.order.aop;      import org.aspectj.lang.annotation.Pointcut;      public class Pointcuts {  \t@Pointcut(\"execution(* hello.aop.order..*(..))\")  \tpublic void allOrder() { //pointcut signature      \t}      \t//클래스 이름 패턴이 *Service임  \t@Pointcut(\"execution(* *..*Service.*( ..))\")  \tpublic void allService() { //pointcut signature      \t}      \t@Pointcut(\"allOrder() &amp;&amp; allService()\")  \tpublic void orderAndService(){}  }          package hello.aop.order.aop;      import org.aspectj.lang.ProceedingJoinPoint;  import org.aspectj.lang.annotation.Around;  import org.aspectj.lang.annotation.Aspect;      import lombok.extern.slf4j.Slf4j;      @Slf4j  @Aspect  public class AspectV4Pointcut {          @Around(\"hello.aop.order.aop.Pointcuts.allOrder()\")      public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable {          log.info(\"[log] {}\", joinPoint.getSignature());          return joinPoint.proceed();      }          //예시를 위해 작성. 포인트 컷을 분리했기때문에 중복 선언없이 포인트컷을 호출해서 쓰면됨      @Around(\"hello.aop.order.aop.Pointcuts.allOrder()\")      public Object doLog2(ProceedingJoinPoint joinPoint) throws Throwable {          // log.info(\"[log] {}\", joinPoint.getSignature());          return joinPoint.proceed();      }          //hello.aop.order 패키지와 하위 패키지면서 클래스 이름 패턴이 *Service      @Around(\"hello.aop.order.aop.Pointcuts.orderAndService()\")      //두 포인트 컷 모두 해당하는 곳에 적용됨      public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable {          try {              log.info(\"[트랜잭션 시작] {}\", joinPoint.getSignature());              Object result = joinPoint.proceed();              log.info(\"[트랜잭션 커밋] {}\", joinPoint.getSignature());              return result;          } catch (Exception e) {              log.info(\"[트랜잭션 롤백] {}\", joinPoint.getSignature());              throw e;          } finally {              log.info(\"[트랜잭션 릴리즈] {}\", joinPoint.getSignature());              }      }  }            위 로그내용을 보면 doLog → transaction순으로 적용되는데 순서를 바꾸고싶다면?    ### 어드바이스 순서    어드바이스는 기본적으로 순서를 적용하지않기때문에 클래스단위로 적용해야함  순서는 @Aspect단위로 지정되기때문에 @Aspect어노테이션이 있는 위치에 @Order어노테이션을 사용해야함  메소드 단위로 @Order를 사용해도 변화없음..      package hello.aop.order.aop;      import org.aspectj.lang.ProceedingJoinPoint;  import org.aspectj.lang.annotation.Around;  import org.aspectj.lang.annotation.Aspect;  import org.springframework.core.annotation.Order;      import lombok.extern.slf4j.Slf4j;      public class AspectV5Order {      @Slf4j      @Aspect      @Order(2)      static class LogAspect {          @Around(\"hello.aop.order.aop.Pointcuts.allOrder()\")          public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable {              log.info(\"[log] {}\", joinPoint.getSignature());              return joinPoint.proceed();          }              //예시를 위해 작성. 포인트 컷을 분리했기때문에 중복 선언없이 포인트컷을 호출해서 쓰면됨          @Around(\"hello.aop.order.aop.Pointcuts.allOrder()\")          public Object doLog2(ProceedingJoinPoint joinPoint) throws Throwable {              // log.info(\"[log] {}\", joinPoint.getSignature());              return joinPoint.proceed();          }      }              @Slf4j      @Aspect      @Order(1)      static class TxAspect {          //hello.aop.order 패키지와 하위 패키지면서 클래스 이름 패턴이 *Service          @Around(\"hello.aop.order.aop.Pointcuts.orderAndService()\")          //두 포인트 컷 모두 해당하는 곳에 적용됨          public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable {              try {                  log.info(\"[트랜잭션 시작] {}\", joinPoint.getSignature());                  Object result = joinPoint.proceed();                  log.info(\"[트랜잭션 커밋] {}\", joinPoint.getSignature());                  return result;              } catch (Exception e) {                  log.info(\"[트랜잭션 롤백] {}\", joinPoint.getSignature());                  throw e;              } finally {                  log.info(\"[트랜잭션 릴리즈] {}\", joinPoint.getSignature());                  }          }      }  }          package hello.aop;      import hello.aop.order.OrderRepository;  import hello.aop.order.OrderService;  import hello.aop.order.aop.AspectV1;  import hello.aop.order.aop.AspectV2;  import hello.aop.order.aop.AspectV3;  import hello.aop.order.aop.AspectV4Pointcut;  import hello.aop.order.aop.AspectV5Order;  import lombok.extern.slf4j.Slf4j;  import org.assertj.core.api.Assertions;  import org.junit.jupiter.api.Test;  import org.springframework.aop.support.AopUtils;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.boot.test.context.SpringBootTest;  import org.springframework.context.annotation.Import;      @Slf4j  @SpringBootTest  // @Import(AspectV1.class)  // @Import(AspectV3.class)  // @Import(AspectV4Pointcut.class)  @Import(AspectV5Order.class)  public class AopTest {          @Autowired      OrderService orderService;      @Autowired      OrderRepository orderRepository;          @Test      void aopInfo() {          log.info(\"isAopProxy, orderService={}\", AopUtils.isAopProxy(orderService));          log.info(\"isAopProxy, orderService={}\", AopUtils.isAopProxy(orderRepository));      }          @Test      void success() {          orderService.orderItem(\"itemA\");      }          @Test      void exception() {          Assertions.assertThatThrownBy(() -&gt; orderService.orderItem(\"ex\"))                  .isInstanceOf(IllegalArgumentException.class);      }  }      "
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 빈 후처리기 - BeanPostProcessor",
    "url": "/posts/%EB%B9%88%ED%9B%84%EC%B2%98%EB%A6%AC%EA%B8%B0_BeanPostProcessor/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급",
    "date": "2024-02-17 00:00:00 +0900",
    





    
    "snippet": "@Bean이나 컴포넌트스캔으로 빈을 등록하면 스프링은 해당 객체를 생성하고 스프링컨테이너 내부에 빈저장소에 등록함. 이후에 등록한 스프링빈을 컨테이너에서 조회해 사용만약 스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 저장하기 직전에 조작하고싶다면 사용하는것이 빈후처리기  생성 - 빈 등록 대상 객체 생성  전달 - 스프링이 빈 후처리기에 에 생성...",
    "content": "@Bean이나 컴포넌트스캔으로 빈을 등록하면 스프링은 해당 객체를 생성하고 스프링컨테이너 내부에 빈저장소에 등록함. 이후에 등록한 스프링빈을 컨테이너에서 조회해 사용만약 스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 저장하기 직전에 조작하고싶다면 사용하는것이 빈후처리기  생성 - 빈 등록 대상 객체 생성  전달 - 스프링이 빈 후처리기에 에 생성객체를 전달  후처리작업 - 빈 후처리기가 생성된 객체를 받아서 조작 or 다른객체로 바꿔치기  등록 - 빈 후처리기가 빈 저장소에 넘겨준 (조작or바꿔치기한)객체를 저장함(스프링이 빈후처리기에 전달한 원본객체는 빈 저장소에 저장되지않음)⇒ 빈 등록할때 선언한 클래스와 다른 구조로 스프링빈이 등록됨  예제                  일반적인 빈 등록          package com.example.proxy.postprocessor;          import lombok.extern.slf4j.Slf4j;  import org.junit.jupiter.api.Assertions;  import org.junit.jupiter.api.Test;  import org.springframework.beans.factory.NoSuchBeanDefinitionException;  import org.springframework.context.ApplicationContext;  import org.springframework.context.annotation.AnnotationConfigApplicationContext;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;          @Slf4j  public class BasicTest {              @Test      void basicConfig() {          ApplicationContext applicationContext = new AnnotationConfigApplicationContext(BasicConfig.class); //스프링 빈 등록                  //A는 스프링빈으로 등록해서 가능          A a = applicationContext.getBean(\"beanA\", A.class);          a.helloA();                  //B는 스프링빈으로 등록하지않아서 에러          Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -&gt; applicationContext.getBean(B.class));      }              @Configuration      static class BasicConfig {          @Bean(name = \"beanA\")          public A a() {              return new A();          }      }              static class A {          public void helloA() {              log.info(\"helloA\");          }      }              static class B {          public void helloB() {              log.info(\"helloB\");          }      }  }                            빈후처리기 적용 한 후          package com.example.proxy.postprocessor;          import lombok.extern.slf4j.Slf4j;  import org.junit.jupiter.api.Assertions;  import org.junit.jupiter.api.Test;  import org.springframework.beans.BeansException;  import org.springframework.beans.factory.NoSuchBeanDefinitionException;  import org.springframework.beans.factory.config.BeanPostProcessor;  import org.springframework.context.ApplicationContext;  import org.springframework.context.annotation.AnnotationConfigApplicationContext;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;          @Slf4j  public class BeanPostProcessorTest {              @Test      void basicConfig() {          ApplicationContext applicationContext = new AnnotationConfigApplicationContext(BasicConfig.class); //스프링 빈 등록                  //A로 등록한 빈을 빈 후처리기에서 B로 변경했기때문에 가능          B b = applicationContext.getBean(\"beanA\", B.class);          b.helloB();                  //A로 등록한 빈을 빈 후처리기에서 B로 변경했기때문에 불가능          Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -&gt; applicationContext.getBean(A.class));      }              @Configuration      static class BasicConfig {          @Bean(name = \"beanA\")          public A a() {              return new A();          }                  @Bean          public AToBPostProcessor helloPostProcessor() {              return new AToBPostProcessor();          }      }              static class A {          public void helloA() {              log.info(\"helloA\");          }      }              static class B {          public void helloB() {              log.info(\"helloB\");          }      }              static class AToBPostProcessor implements BeanPostProcessor {          @Override          public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {              log.info(\"beanName={}, bean={}\", beanName, bean);              if(bean instanceof A) {                  return new B();              }              return bean;          }      }  }                      [!important]@PostConstruct : 스프링 빈 생성 후 빈을 초기화하는 역할을 함근데 빈의 초기화 라는 것은 단순이 @PostConstruct 어노테이션이 붙은 초기화 메소드를 한번 호출만 하면됨 = 생성된 빈을 한번 조작그래서 빈을 조작하는 행위는 빈 후처리기만있어도됨스프링은 CommonAnnotationBeanPostProcessor이라는 빈 후처리기를 자동으로 등록하는데 여기서 @PostConstruct 어노테이션이 붙은 메소드를 호출함= 스프링 스스로도 스프링 내부기능을 확장하기위해 빈후처리기를 사용함  적용package com.example.proxy.config.v4_postprocessor.postprocessor;import lombok.extern.slf4j.Slf4j;import org.springframework.aop.Advisor;import org.springframework.aop.framework.ProxyFactory;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;@Slf4jpublic class PackageLogTracePostProcessor implements BeanPostProcessor {    private final String basePackage;    private final Advisor advisor;    public PackageLogTracePostProcessor(String basePackage, Advisor advisor) {        this.basePackage = basePackage;        this.advisor = advisor;    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        log.info(\"param beanName={}, bean={}\", beanName, bean.getClass());        //프록시 대상여부 체크        //프록시 대상이아니면 원본반환        String packageName = bean.getClass().getPackageName();        if(!packageName.startsWith(basePackage)) {            return bean;        }        //프록시 대상이면 프록시 만들어서 반환        ProxyFactory proxyFactory = new ProxyFactory(bean);        proxyFactory.addAdvisor(advisor);        Object proxy = proxyFactory.getProxy();        log.info(\"create proxy: target={}, proxy={}\", bean.getClass(), proxy.getClass());        return proxy;    }}package com.example.proxy.config.v4_postprocessor;import com.example.proxy.config.AppV1Config;import com.example.proxy.config.AppV2Config;import com.example.proxy.config.v3_proxyfactory.advice.LogTraceAdvice;import com.example.proxy.config.v4_postprocessor.postprocessor.PackageLogTracePostProcessor;import com.example.proxy.trace.logtrace.LogTrace;import lombok.extern.slf4j.Slf4j;import org.springframework.aop.Advisor;import org.springframework.aop.support.DefaultPointcutAdvisor;import org.springframework.aop.support.NameMatchMethodPointcut;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Slf4j@Configuration@Import({AppV1Config.class, AppV2Config.class})//v3는 어노테이션써서 자동등록됨public class BeanPostProcessorConfig {    @Bean     public PackageLogTracePostProcessor logTracePostProcessor(LogTrace logTrace) {        return new PackageLogTracePostProcessor(\"com.example.proxy.app\", getAdvisor(logTrace));    }    private Advisor getAdvisor(LogTrace logTrace) {        //pointcut        NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();        pointcut.setMappedNames(\"request*\", \"order*\",\"save*\");        //advice        LogTraceAdvice advice = new LogTraceAdvice(logTrace);        return new DefaultPointcutAdvisor(pointcut, advice);    }}package com.example.proxy;@Import(BeanPostProcessorConfig.class)@SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")public class ProxyApplication {    public static void main(String[] args) {        SpringApplication.run(ProxyApplication.class, args);    }    @Bean    public LogTrace logTrace() {      return new ThreadLocalLogTrace();    }}이렇게 등록하면 컴포넌트스캔을 통해 저장하는 빈들도 모두 빈후처리기가 적용됨적용 패키지는 꼭 지정해주는것이 좋음 - 스프링 부트가 기본으로 제공하는 빈 중에서 프록시 객체를 만들 수 없는 빈도 있기때문에 오류가 발생함그러나 굳이 빈 후처리기를 이렇게 만들어줘야하나? 이미 만들어진것은 없나? → 있음스프링이 제공하는 빈 후처리기implementation 'org.springframework.boot:spring-boot-starter-aop 를 의존성 추가해주어야함  AutoProxyCreator : 자동 프록시 생성기          AnnotationAwareAspectJAutoProxyCreator라는 빈 후처리기가 스프링 빈에 자동 등록됨      스프링 빈으로 등록된 Advisor를 자동으로 찾아 프록시가 필요한곳에 자동으로 적용함      AnnotationAwareAspectJAutoProxyCreator는 @AspectJ와 관련된 기능도 자동으로 찾아서 처리해줌        생성 : 스프링 빈 대상 객체 생성  전달 : 생성객체 빈후처리기에 전달  모든 Advisor빈 조회 : 자동 프록시 생성기 - 빈 후처리기가 모든 Advisor를 조회하여  프록시 적용 대상 체크 : 조회한 Advisor에 있는 pointcut으로 해당 객체가 적용대상인지 확인함  프록시 생성 : 만약 적용대상이였다면 프록시를 생성하여 반환함(아니면 받은 원본객체 그대로 반환함)  빈 등록 : 반환된 객체는 스프링 빈으로 등록⇒ 프록시는 내부에 어드바이저와 실제 호출해야할 대상 객체를 알고있음  적용package com.example.proxy.config.v5_autoproxy;import com.example.proxy.config.AppV1Config;import com.example.proxy.config.AppV2Config;import com.example.proxy.config.v3_proxyfactory.advice.LogTraceAdvice;import com.example.proxy.trace.logtrace.LogTrace;import org.springframework.aop.Advisor;import org.springframework.aop.aspectj.AspectJExpressionPointcut;import org.springframework.aop.support.DefaultPointcutAdvisor;import org.springframework.aop.support.NameMatchMethodPointcut;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@Import({AppV1Config.class, AppV2Config.class})public class AutoProxyConfig {//    @Bean//    public Advisor advisor1(LogTrace logTrace) {//        //pointcut//        NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();//        pointcut.setMappedNames(\"request*\", \"order*\",\"save*\");////        //advice//        LogTraceAdvice advice = new LogTraceAdvice(logTrace);//        return new DefaultPointcutAdvisor(pointcut, advice);//    }    //AspectExpressionPointcut 실무에서는 이것만 씀//    @Bean//    public Advisor advisor2(LogTrace logTrace) {//        //pointcut//        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();//        //com.example.proxy.app패키지 아래 모든, 파라미터 상관없음//        pointcut.setExpression(\"execution(* com.example.proxy.app..*(..))\");////        //advice//        LogTraceAdvice advice = new LogTraceAdvice(logTrace);//        return new DefaultPointcutAdvisor(pointcut, advice);//    }    //no log 메소드 제외    @Bean    public Advisor advisor3(LogTrace logTrace) {        //pointcut        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();        //com.example.proxy.app패키지 아래 모든, 파라미터 상관없음 &amp;&amp; no log 메소드는 제외        pointcut.setExpression(\"execution(* com.example.proxy.app..*(..)) &amp;&amp; !execution(* com.example.proxy.app..noLog(..))\");        //advice        LogTraceAdvice advice = new LogTraceAdvice(logTrace);        return new DefaultPointcutAdvisor(pointcut, advice);    }}  [!important]결론적으로 포인트컷은1. 프록시 적용여부 판단(생성시) : 빈 등록시 해당 빈이 프록시 대상여부인지 판단2. 어드바이스 적용여부 판단(사용시) : 프록시 호출 시 부가기능인 어드바이스를 적용할지말지 포인트컷을 보고 판단함(적용대상이면 어드바이스먼저호출 → 타겟클래스 호출, 아니면 타겟클래스만 호출)2가지 경우에 사용됨그럼 여기서 빈 후처리기에서 advisor를 조회 후 프록시적용여부를 판단한다고했는데advisor가 여러개일경우는?프록시 1개를 생성한 후 프록시에 여러 어드바이저를 모두 적용함= 프록시 1개 - 어드바이저 N개 의 구조로 생성됨스프링 AOP도 같은 방식으로 동작함"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 동적 프록시",
    "url": "/posts/%EB%8F%99%EC%A0%81%ED%94%84%EB%A1%9D%EC%8B%9C/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급, 프록시",
    "date": "2024-02-17 00:00:00 +0900",
    





    
    "snippet": "프록시를 적용하여 프록시패턴, 데코레이터패턴을 적용해보니 클래스가 너무 많이생긴다는 단점이있었음게다가 많은 프록시 클래스들의 코드는 거의 중복코드였음자바가 기본으로 제공하는 JDK 동적프록시 기술이나 CGLIB같은 프록시 생성 오픈기술을 활용하면 프록시 객체를 동적으로 만들 수 있음JDK 동적 프록시구조    package com.example.pro...",
    "content": "프록시를 적용하여 프록시패턴, 데코레이터패턴을 적용해보니 클래스가 너무 많이생긴다는 단점이있었음게다가 많은 프록시 클래스들의 코드는 거의 중복코드였음자바가 기본으로 제공하는 JDK 동적프록시 기술이나 CGLIB같은 프록시 생성 오픈기술을 활용하면 프록시 객체를 동적으로 만들 수 있음JDK 동적 프록시구조    package com.example.proxy.jdkdynamic;        import lombok.extern.slf4j.Slf4j;    import org.junit.jupiter.api.Test;        import java.lang.reflect.InvocationTargetException;    import java.lang.reflect.Method;        @Slf4j    public class ReflectionTest {            @Test        void reflection0() {            Hello target = new Hello();                //로직 1            log.info(\"start\");            String result1 = target.callA();            log.info(\"result = {}\", result1);            //로직 2            log.info(\"start\");            String result2 = target.callB(); //로직 1과 호출 메소드만 다름            log.info(\"result = {}\", result2);        }            @Test        void reflection1() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {            Class&lt;?&gt; classHello = Class.forName(\"com.example.proxy.jdkdynamic.ReflectionTest$Hello\");                //callA 메소드 정보            Hello target = new Hello();            Method methodCallA = classHello.getMethod(\"callA\");            Object result1 = methodCallA.invoke(target);            log.info(\"result = {}\", result1);            //callB 메소드정보            Method methodCallB = classHello.getMethod(\"callB\");            Object result2 = methodCallB.invoke(target);            log.info(\"result = {}\", result2);        }            @Test        void reflection2() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {            Class&lt;?&gt; classHello = Class.forName(\"com.example.proxy.jdkdynamic.ReflectionTest$Hello\");                //callA 메소드 정보            Hello target = new Hello();            Method methodCallA = classHello.getMethod(\"callA\");            dynamicCall(methodCallA, target);            //callB 메소드정보            Method methodCallB = classHello.getMethod(\"callB\");            dynamicCall(methodCallB, target);        }            private void dynamicCall(Method method, Object target) throws InvocationTargetException, IllegalAccessException {            log.info(\"start\");            Object result = method.invoke(target);            log.info(\"result = {}\", result);        }            @Slf4j        static class Hello {            public String callA() {                log.info(\"CALL A\");                return \"A\";            }                public String callB() {                log.info(\"CALL B\");                return \"B\";            }        }    }    ```    클래스나 메소드를 호출할때 이름으로 호출하고있음중요한것은 메소드정보를 동적으로 변경가능하며 메소드 호출 부분을 추상화했기때문에 공통로직으로 변경이 가능함그러나 리플렉션은 컴파일시점에 오류를 찾을 수 없기때문에 일반적으로 사용하면 안되는 기술임### 예제```javapackage com.example.proxy.jdkdynamic.code;public interface AInterface {    String call();}package com.example.proxy.jdkdynamic.code;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class AImpl implements AInterface {    @Override    public String call() {        log.info(\"A 호출\");        return \"a\";    }}package com.example.proxy.jdkdynamic.code;public interface BInterface {    String call();}package com.example.proxy.jdkdynamic.code;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class BImpl implements BInterface {    @Override    public String call() {        log.info(\"B 호출\");        return \"b\";    }}package com.example.proxy.jdkdynamic.code;import lombok.extern.slf4j.Slf4j;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;@Slf4jpublic class TimeInvocationHandler implements InvocationHandler {    private final Object target;    public TimeInvocationHandler(Object target) {        this.target = target;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        log.info(\"Time Proxy 실행\");        long startTime = System.currentTimeMillis();        Object result = method.invoke(target, args);        long endTime = System.currentTimeMillis();        long resultTime = startTime - endTime;        log.info(\"TimeProxy 종료, resultTime={}\", resultTime);        return result;    }}package com.example.proxy.jdkdynamic;import com.example.proxy.jdkdynamic.code.*;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import java.lang.reflect.Proxy;@Slf4jpublic class JdkDynamicProxyTest {    @Test    void dynamicA() {        AInterface target = new AImpl();        TimeInvocationHandler handler = new TimeInvocationHandler(target);        //동적 프록시에 적용할 핸들러 로직        AInterface proxy = (AInterface) Proxy.newProxyInstance(AInterface.class.getClassLoader(), new Class[]{AInterface.class}, handler);        proxy.call();        /*           1. handler로직 실행 -&gt; timeProxy실행 로그           2. handler에서 주입받은 target의 call메소드 호출 -&gt; Aimpl A호출 로그         */        log.info(\"targetClass={}\", target.getClass()); //targetClass=class com.example.proxy.jdkdynamic.code.AImpl        log.info(\"proxyClass={}\", proxy.getClass()); //proxyClass=class jdk.proxy3.$Proxy12        // AInterface를 구현받아 프록시가 생성됨 = proxy클래스를 만들지않아도 자동으로 생성 됨    }    @Test    void dynamicB() {        BInterface target = new BImpl();        TimeInvocationHandler handler = new TimeInvocationHandler(target);        BInterface proxy = (BInterface) Proxy.newProxyInstance(BInterface.class.getClassLoader(), new Class[]{BInterface.class}, handler);        proxy.call();        /*           1. handler로직 실행 -&gt; timeProxy실행 로그           2. handler에서 주입받은 target의 call메소드 호출 -&gt; Aimpl A호출 로그         */        log.info(\"targetClass={}\", target.getClass()); //targetClass=class com.example.proxy.jdkdynamic.code.BImpl        log.info(\"proxyClass={}\", proxy.getClass()); //proxyClass=class jdk.proxy3.$Proxy12    }}      실행 순서          클라이언트는 JDK동적 프록시의 call()을 실행함      JDK동적 프록시는 InvocationHandler.invoke()를 호출, TimeInvocationHandler가 구현체로 있으므로 TimeInvocationHandler.invoke()가 호출됨      TimeInvocationHandler가 내부 로직을 수행하고 method.invoke(target, args)를 호출해서 target인 실제 객체(Aimpl or Bimpl)을 호출      target인 실제 객체(Aimpl or Bimpl) 인스턴스의 call()이 실행됨      target인 실제 객체(Aimpl or Bimpl) 인스턴스의 call()이 실행된 후 TimeInvocationHandler로 응답이 돌아옴 → 시간로그 출력, 결과 반환                          테스트코드의 dynamicA()와 dynamicB()를 동시에 실행하면 다른 프록시 클래스가 생성된다        13:52:40.512 [Test worker] INFO com.example.proxy.jdkdynamic.code.TimeInvocationHandler – TimeProxy 종료, resultTime=-2  13:52:40.519 [Test worker] INFO com.example.proxy.jdkdynamic.JdkDynamicProxyTest – targetClass=class com.example.proxy.jdkdynamic.code.AImpl  13:52:40.519 [Test worker] INFO com.example.proxy.jdkdynamic.JdkDynamicProxyTest – proxyClass=class jdk.proxy3.$Proxy12  13:52:40.556 [Test worker] INFO com.example.proxy.jdkdynamic.code.TimeInvocationHandler – Time Proxy 실행  13:52:40.557 [Test worker] INFO com.example.proxy.jdkdynamic.code.BImpl – B 호출  13:52:40.557 [Test worker] INFO com.example.proxy.jdkdynamic.code.TimeInvocationHandler – TimeProxy 종료, resultTime=-1  13:52:40.557 [Test worker] INFO com.example.proxy.jdkdynamic.JdkDynamicProxyTest – targetClass=class com.example.proxy.jdkdynamic.code.BImpl  13:52:40.557 [Test worker] INFO com.example.proxy.jdkdynamic.JdkDynamicProxyTest – proxyClass=class jdk.proxy3.$Proxy13  13:52:40.512 [Test worker] INFO com.example.proxy.jdkdynamic.code.TimeInvocationHandler – TimeProxy 종료, resultTime=-2  13:52:40.519 [Test worker] INFO com.example.proxy.jdkdynamic.JdkDynamicProxyTest – targetClass=class com.example.proxy.jdkdynamic.code.AImpl  13:52:40.519 [Test worker] INFO com.example.proxy.jdkdynamic.JdkDynamicProxyTest – proxyClass=class jdk.proxy3.$Proxy12  13:52:40.556 [Test worker] INFO com.example.proxy.jdkdynamic.code.TimeInvocationHandler – Time Proxy 실행  13:52:40.557 [Test worker] INFO com.example.proxy.jdkdynamic.code.BImpl – B 호출  13:52:40.557 [Test worker] INFO com.example.proxy.jdkdynamic.code.TimeInvocationHandler – TimeProxy 종료, resultTime=-1  13:52:40.557 [Test worker] INFO com.example.proxy.jdkdynamic.JdkDynamicProxyTest – targetClass=class com.example.proxy.jdkdynamic.code.BImpl  13:52:40.557 [Test worker] INFO com.example.proxy.jdkdynamic.JdkDynamicProxyTest – proxyClass=class jdk.proxy3.$Proxy13              덕분에 적용대상만큰 프록시 객체를 만들지 않아도 됨  그리고 같은 부가기능 록직을 한번만 구현하면 공통으로 사용 가능함. invocationHandler만 만들어서 넣어주면됨  ⇒ 프록시 클래스를 수없이 만들어야했던 문제 해결, 부가기능 로직도 하나의 클래스에 모아서 단일책임원칙 지킴        JDK동적 프록시는 구현할 필요없음        ### 적용      package com.example.proxy.config.v2_dynamicproxy.handler;      import com.example.proxy.trace.TraceStatus;  import com.example.proxy.trace.logtrace.LogTrace;      import java.lang.reflect.InvocationHandler;  import java.lang.reflect.Method;      public class LogTraceBasicHandler implements InvocationHandler {      private final Object target;      private final LogTrace logTrace;          public LogTraceBasicHandler(Object target, LogTrace logTrace) {          this.target = target;          this.logTrace = logTrace;      }          @Override      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {          TraceStatus status = null;          try {              String message = method.getDeclaringClass().getSimpleName() + \".\" + method.getName() + \"()\";              status = logTrace.begin(message);              //로직 호출             Object result = method.invoke(target, args);              logTrace.end(status);              return result;          } catch (Exception e) {              logTrace.exception(status, e);              throw e;          }      }  }          package com.example.proxy.config.v2_dynamicproxy;      import com.example.proxy.app.v1.*;  import com.example.proxy.config.v2_dynamicproxy.handler.LogTraceBasicHandler;  import com.example.proxy.trace.logtrace.LogTrace;  import org.springframework.context.annotation.Bean;  import org.springframework.context.annotation.Configuration;      import java.lang.reflect.Proxy;      @Configuration  public class DynamicProxyBasicConfig {      @Bean      public OrderControllerV1 orderControllerV1(LogTrace logTrace) {          OrderControllerV1 orderController = new OrderControllerV1Impl(orderServiceV1(logTrace));          return (OrderControllerV1) Proxy.newProxyInstance(orderController.getClass().getClassLoader(), new Class[]{OrderControllerV1.class}, new LogTraceBasicHandler(orderController, logTrace));      }          @Bean      public OrderServiceV1 orderServiceV1(LogTrace logTrace) {          OrderServiceV1 orderService = new OrderServiceV1Impl(orderRepositoryV1(logTrace));              return (OrderServiceV1) Proxy.newProxyInstance(orderService.getClass().getClassLoader(), new Class[]{OrderServiceV1.class}, new LogTraceBasicHandler(orderService, logTrace));      }      @Bean      public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace) {          OrderRepositoryV1 orderRepository = new OrderRepositoryV1Impl();              OrderRepositoryV1 proxy = (OrderRepositoryV1) Proxy.newProxyInstance(OrderRepositoryV1.class.getClassLoader(), new Class[]{OrderRepositoryV1.class}, new LogTraceBasicHandler(orderRepository, logTrace));              return proxy;      }  }          package com.example.proxy;      @Import(DynamicProxyBasicConfig.class)  @SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")  public class ProxyApplication {          public static void main(String[] args) {          SpringApplication.run(ProxyApplication.class, args);      }          @Bean      public LogTrace logTrace() {        return new ThreadLocalLogTrace();      }  }                    필터 추가 - 메소드 이름 필터  지금까지의 요구사항을 보면 noLog api에는 로그가 적용되면안되나 JDK 동적 프록시를 적용했을때 구분없이 모두 적용되는것을 볼수있음요구사항을 지키기위해서는 프록시가 특정 조건을 만족할때만 적용되도록 해야함package com.example.proxy.config.v2_dynamicproxy.handler;import com.example.proxy.trace.TraceStatus;import com.example.proxy.trace.logtrace.LogTrace;import org.springframework.util.PatternMatchUtils;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Arrays;public class LogTraceFilterHandler implements InvocationHandler {    private final Object target;    private final LogTrace logTrace;    private final String[] patterns;    public LogTraceFilterHandler(Object target, LogTrace logTrace, String[] patterns) {        this.target = target;        this.logTrace = logTrace;        this.patterns = patterns;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        TraceStatus status = null;        try {            String methodName = method.getName();            if(!PatternMatchUtils.simpleMatch(patterns, methodName)) {                return method.invoke(target, args);            }            String message = method.getDeclaringClass().getSimpleName() + \".\" + methodName + \"()\";            status = logTrace.begin(message);            //로직 호출           Object result = method.invoke(target, args);            logTrace.end(status);            return result;        } catch (Exception e) {            logTrace.exception(status, e);            throw e;        }    }}package com.example.proxy.config.v2_dynamicproxy;import com.example.proxy.app.v1.*;import com.example.proxy.config.v2_dynamicproxy.handler.LogTraceFilterHandler;import com.example.proxy.trace.logtrace.LogTrace;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.lang.reflect.Proxy;@Configurationpublic class DynamicProxyFilterConfig {    private static final String[] PATTERNS = {\"request*\", \"order*\", \"save*\"};    @Bean    public OrderControllerV1 orderControllerV1(LogTrace logTrace) {        OrderControllerV1 orderController = new OrderControllerV1Impl(orderServiceV1(logTrace));        return (OrderControllerV1) Proxy.newProxyInstance(orderController.getClass().getClassLoader(), new Class[]{OrderControllerV1.class}, new LogTraceFilterHandler(orderController, logTrace, PATTERNS));    }    @Bean    public OrderServiceV1 orderServiceV1(LogTrace logTrace) {        OrderServiceV1 orderService = new OrderServiceV1Impl(orderRepositoryV1(logTrace));        return (OrderServiceV1) Proxy.newProxyInstance(orderService.getClass().getClassLoader(), new Class[]{OrderServiceV1.class}, new LogTraceFilterHandler(orderService, logTrace, PATTERNS));    }    @Bean    public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace) {        OrderRepositoryV1 orderRepository = new OrderRepositoryV1Impl();        OrderRepositoryV1 proxy = (OrderRepositoryV1) Proxy.newProxyInstance(OrderRepositoryV1.class.getClassLoader(), new Class[]{OrderRepositoryV1.class}, new LogTraceFilterHandler(orderRepository, logTrace, PATTERNS));        return proxy;    }}package com.example.proxy;@Import(DynamicProxyFilterConfig.class)@SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")public class ProxyApplication {    public static void main(String[] args) {        SpringApplication.run(ProxyApplication.class, args);    }    @Bean    public LogTrace logTrace() {      return new ThreadLocalLogTrace();    }}— 한계 : 클래스기반에는 사용불가 → 일반적인 방법으로는 클래스기반에 사용할수없고 CGLIB라는 바이트코드를 조작하는 특별한 라이브러리를 사용해야함JDK동적 프록시를 이해하기위해서는 먼저 자바의 리플렉션기술을 먼저 이해해야함CGLIB : Code Generator Library바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들 수 있음원래는 외부라이브러리이나 스프링프레임워크가 스프링 내부코드에 포함함. 스프링을 사용한다면 외부라이브러리 추가없이 사용가능사실 개발자가 CGLIB를 직접 사용하는 경우는 거의 없고 스프링의 ProxyFactory라는것이 이 기술을 사용하는것을 도와주기때문에 개념만 잡으면됨실무에서 프로젝트 로그를 볼때 CGLIB를 몇번 본적이있는데 같은 맥락인거같음예제package com.example.proxy.common;public interface ServiceInterface {    void save();    void find();}package com.example.proxy.common;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ServiceImpl implements ServiceInterface {    @Override    public void save() {        log.info(\"save 호출\");    }    @Override    public void find() {        log.info(\"find 호출\");    }}package com.example.proxy.common;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ConcreteService {    public void call() {        log.info(\"ConcreteService 호출\");    }}package com.example.proxy.cglib.code;import lombok.extern.slf4j.Slf4j;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;@Slf4jpublic class TimeMethodInterceptor implements MethodInterceptor {    private final Object target;    public TimeMethodInterceptor(Object target) {        this.target = target;    }    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        log.info(\"Time Proxy 실행\");        long startTime = System.currentTimeMillis();        //둘다 결과는 같으나 methodProxy로 하는게 좀 더 빠름(권장)        Object result = methodProxy.invoke(target, args);//        Object result = method.invoke(target, args);        long endTime = System.currentTimeMillis();        long resultTime = startTime - endTime;        log.info(\"TimeProxy 종료, resultTime={}\", resultTime);        return result;    }}package com.example.proxy.cglib;import com.example.proxy.cglib.code.TimeMethodInterceptor;import com.example.proxy.common.ConcreteService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.cglib.proxy.Enhancer;@Slf4jpublic class CglibTest {    @Test    void cglib() {        ConcreteService target = new ConcreteService();        //인터페이스가없는 구체클래스기반 프록시 사용 -&gt; cglib 라이브러리 사용        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(ConcreteService.class);        enhancer.setCallback(new TimeMethodInterceptor(target));        ConcreteService proxy = (ConcreteService) enhancer.create();        log.info(\"targetClass={}\", target.getClass()); //class com.example.proxy.common.ConcreteService        log.info(\"proxyClass={}\", proxy.getClass()); //proxyClass=class com.example.proxy.common.ConcreteService$$EnhancerByCGLIB$$dc11b845        proxy.call();    }}JDK 동적 프록시는 인터페이스를 구현해서 만들어지나 CGLIB는 구체클래스를 상속받아서 만들어짐      실행결과 - 프록시 클래스 이름    14:23:22.934 [Test worker] INFO com.example.proxy.cglib.CglibTest – targetClass=class com.example.proxy.common.ConcreteService  14:23:22.939 [Test worker] INFO com.example.proxy.cglib.CglibTest – proxyClass=class com.example.proxy.common.  ConcreteService$ $EnhancerByCGLIB $ $dc11b845  14:23:22.939 [Test worker] INFO com.example.proxy.cglib.code.TimeMethodInterceptor – Time Proxy 실행  14:23:23.010 [Test worker] INFO com.example.proxy.common.ConcreteService – ConcreteService 호출  14:23:23.012 [Test worker] INFO com.example.proxy.cglib.code.TimeMethodInterceptor – TimeProxy 종료, resultTime=-71    제약 : 상속을 사용하기때문에 몇가지 제약이있음          기본 생성자 필수      부모클래스 생성자를 체크해야함 → 자식클래스를 동적생성하기때문에 부모클래스에 기본생성자가 필요함(생성자 2번 호출)      클래스에 final이 붙으면 상속불가 → CGLIB에서 예외 발생      메소드에 final이 붙이면 해당 메소드를 오버라이딩 할 수 없다 → CGLIB에서 프록시로직이 동작하지않음  — (그러나 웹 애플리케이션 개발 시 final을 잘 사용하지는 않아서 큰 문제는 안됨. 프레임워크 개발시에는 문제요소 있음)      "
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] @Aspect AOP + 스프링 AOP 개념",
    "url": "/posts/@AspectAOP+%EC%8A%A4%ED%94%84%EB%A7%81AOP%EA%B0%9C%EB%85%90/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급, AOP",
    "date": "2024-02-17 00:00:00 +0900",
    





    
    "snippet": "빈 후처리기에서 프록시 생성시 빈으로 등록된 어드바이저를 모두 조회하여 적용대상여부를 판단한다고했는데여기서 어드바이저를 편리하게 등록하려면?@Aspect어노테이션을 사용하면됨package com.example.proxy.config.V6_aop.aspect;import com.example.proxy.trace.TraceStatus;import com...",
    "content": "빈 후처리기에서 프록시 생성시 빈으로 등록된 어드바이저를 모두 조회하여 적용대상여부를 판단한다고했는데여기서 어드바이저를 편리하게 등록하려면?@Aspect어노테이션을 사용하면됨package com.example.proxy.config.V6_aop.aspect;import com.example.proxy.trace.TraceStatus;import com.example.proxy.trace.logtrace.LogTrace;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;@Slf4j@Aspectpublic class LogTraceAspect {    private final LogTrace logTrace;    public LogTraceAspect(LogTrace logTrace) {        this.logTrace = logTrace;    }    //advice 로직이 구현됨    @Around(\"execution(* com.example.proxy.app..*(..))\")    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {        TraceStatus status = null;        try {            String message = joinPoint.getSignature().toShortString();            status = logTrace.begin(message);            //로직 호출            Object result = joinPoint.proceed();            logTrace.end(status);            return result;        } catch (Exception e) {            logTrace.exception(status, e);            throw e;        }    }}package com.example.proxy.config.V6_aop;import com.example.proxy.config.AppV1Config;import com.example.proxy.config.AppV2Config;import com.example.proxy.config.V6_aop.aspect.LogTraceAspect;import com.example.proxy.trace.logtrace.LogTrace;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@Import({AppV1Config.class, AppV2Config.class})public class AopConfig {    @Bean    public LogTraceAspect logTraceAspect(LogTrace logTrace) {        return new LogTraceAspect(logTrace);    }}package com.example.proxy;@Import(AopConfig.class)@SpringBootApplication(scanBasePackages = \"com.example.proxy.app\")public class ProxyApplication {    public static void main(String[] args) {        SpringApplication.run(ProxyApplication.class, args);    }    @Bean    public LogTrace logTrace() {      return new ThreadLocalLogTrace();    }}  실행 : 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기 호출  모든 @Aspect빈을 조회 : 스프링컨테이너에서 @Aspect가 붙은 스프링 빈을 모두 조회  어드바이저 생성 : @Aspect 어드바이저 빌더를 통해 @Aspect 어노테이션 정보를 기반으로 어드바이저 생성  @Aspect 기반 어드바이저 저장 : 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장— @AspectBeanFactoryAspectJAdvisorsBuilder클래스. @Aspect의 정보를 기반으로 포인트컷, 어드바이스, 어드바이저를 생성, 보관@Aspect 정보를 기반으로 어드바이저를 만들고 @Aspect 어드바이저 빌더 내부 저장소에 캐시. 캐시에 어드바이저가 이미 만들어져 있으면 저장된 어드바이저 반환  빈 객체 생성  전달  어드바이저 조회          스프링컨테이너의 Advisor 빈조회      @Aspect Advisor 조회 : @Aspect 어드바이저 빌더 내부에 저장된 어드바이저 모두 조회        프록시 적용 대상 여부 체크  프록시 생성  빈 등록지금까지 요구사항을 적용하기위해 프록시를 사용하여 처리를 했는데 이처럼여러 메소드에서 공통으로 사용해야하는 부가 기능(해당객체가 제공하는 고유의 기능을 보조하기위한 기능)을 횡단관심사 라고한다스프링 AOP는 여기서 횡단 관심사를 전문으로 해결하는 기술이다=  핵심 기능과 부가기능을 분리하여  한번의 구현으로 원하는곳 모든 곳에 일괄로 부가기능을 적용  애스팩트(관점)을 사용한 프로그래밍 = 관점지향프로그래밍(AOP)라고 함  대표적인 기능으로는 AspectJ 프레임워크가 있음. 스프링도 AOP를 지원하지만 Aspect의 문법을 차용하고 일부만 제공함  적용방식은 크게 3가지가 있는데          컴파일 시점 - 위빙                              .java 소스 코드를 컴파일러를 사용해 .class를 만드는 시점에 부가기능 로직을 추가함. AspectJ가 제공하는 특별한 컴파일러를 사용해야하는데 .class를 디컴파일해보면 애스펙트 관련 호출하는 코드가 들어감  = 부가기능 코드가 핵심 기능이있는 컴파일된 코드 주변에 붙어버림  이렇게 원본로직이 부가기능이 추가되어버리는것을 위빙(Weaving)이라고 함                                단점 : 특별한 컴파일러가 필요, 복잡                              클래스 로딩시점                              자바를 실행하면 자바언어는 .class파일을 JVM 내부의 클래스 로더에 보관. 이때 중간에서 .class파일을 조작한 다음 JVM에 올릴 수 있음. 자바 언어는 .class를 JVM에 저장하기 전에 조작할 수 있는 기능을 제공함(java instrumentation)  참고로 많은 모니터링 툴들이 이 방식을 사용함                    클래스 로딩시점에 애스펙트를 적용하는 것을 로드타임 위빙이라함          단점 : 자바를 실행할때 특별한 옵션(java -javaagent)를 통해 클래스 로더 조작기를 지정해야하는데 이 부분이 번거롭고 운영하기 어려움                    런타임시점(프록시)                  컴파일도 끝나고 클래스로더에 클래스도 다 올라가서 이미 자바가 실행된 다음(자바 main메소드 실행 후) 자바언어가 제공하는 범위 안에서 부가기능을 적용          스프링과같은 컨테이너의 도움을 받고 프록시와 DI, 빈 포스트 프로세서같은 개념을 총 동원해야한다. 최종적으로 프록시를 통해 스프링 빈에 부가기능을 적용할 수 있음          지금까지 강의에서 학습한 것          프록시를 사용하기때문에 AOP기능에 일부 제약이있으나 특별한 컴파일러나 복잡한 옵션없이 스프링만 있으면 AOP를 적용할 수 있음                          AOP 적용 위치                                          적용 가능 지점(조인포인트) : 생성자, 필드 값 접근, static 메소드 접근, 메서드 실행                  이렇게 AOP를 적용할 수 있는 지점을 조인 포인트라고 함                    AspectJ를 사용하여 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 바이트 코드를 실제 조작하기 때문에 해당 기능을 모든 지점에 다 적용 가능      프록시 방식을 사용하는 스프링 AOP는 메소드 실행 지점에서만 AOP를 적용                  프록시는 메소드 오버라이딩 개념으로 동작. 따라서 생성자, static메서드, 필드 값 접근에는 프록시 개념이 적용불가능함          프록시를 사용하는 스프링 AOP의 조인포인트는 메서드 실행으로 제한됨                    프록시를 사용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP를 적용가능함❗스프링은 AspectJ를 차용하는것이지 직접 사용하는것이 아님❗그렇다면 조인포인트에 제한이있는 스프링 AOP보다는 Aspect를 직접 사용하는것이 좋은것이 아닌가? → 불필요하게 공부해야할 내용이 많고 어지간하면 스프링 AOP로도 대부분의 문제를 해결 가능하기때문에 굳이 AspectJ를 공부할 필요는 없음      — 용어 정리  포인트컷(Pointcut)          조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능      주로 AspectJ 표현식을 사용해서 지정      프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능        타켓(Target)  어드바이스를 받는 객체, 포인트컷으로 결정  어드바이스(Advice)          부가 기능      특정 조인 포인트에서 Aspect에 의해 취해지는 조치      Around(주변), Before(전), After(후)와 같은 다양한 종류의 어드바이스가 있음        애스펙트(Aspect)          어드바이스 + 포인트컷을 모듈화 한 것      @Aspect를 생각하면 됨      여러 어드바이스와 포인트 컷이 함께 존재        어드바이저(Advisor)          하나의 어드바이스와 하나의 포인트 컷으로 구성      스프링 AOP에서만 사용되는 특별한 용어        위빙(Weaving)          포인트컷으로 결정한 타켓의 조인 포인트에 어드바이스를 적용하는 것      위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가 할 수 있음      AOP 적용을 위해 애스펙트를 객체에 연결한 상태                  컴파일 타임(AspectJ compiler)          로드 타임          런타임, 스프링 AOP는 런타임, 프록시 방식                      AOP 프록시          AOP 기능을 구현하기 위해 만든 프록시 객체, 스프링에서 AOP 프록시는 JDK 동적 프록시 또는CGLIB 프록시이다.      "
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 실전 예제",
    "url": "/posts/%EC%8B%A4%EC%A0%84%EC%98%88%EC%A0%9C/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급, AOP",
    "date": "2024-02-05 00:00:00 +0900",
    





    
    "snippet": "로그 출력 AOP@Trace어노테이션을 생성하여 구현package hello.aop.exam.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java....",
    "content": "로그 출력 AOP@Trace어노테이션을 생성하여 구현package hello.aop.exam.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Trace {}package hello.aop.exam.aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import lombok.extern.slf4j.Slf4j;@Slf4j@Aspectpublic class TraceAspect {\t@Before(\"@annotation(hello.aop.exam.annotation.Trace)\")\tpublic void doTrace(JoinPoint joinPoint) {\t\tObject[] args = joinPoint.getArgs();\t\tlog.info(\"[trace] {} args ={}\", joinPoint.getSignature(), args);\t}}package hello.aop.exam;import org.springframework.stereotype.Repository;import hello.aop.exam.annotation.Retry;import hello.aop.exam.annotation.Trace;import lombok.extern.slf4j.Slf4j;@Repository@Slf4jpublic class ExamRepository {\tprivate static int seq = 0;\t@Trace\t//5번에 1번 실패\tpublic String save(String itemId) {\t\tseq++;\t\tif(seq % 5 == 0) {\t\t\tthrow new IllegalStateException(\"예외\");\t\t}\t\treturn \"OK\";\t}}package hello.aop.exam;import org.springframework.stereotype.Service;import hello.aop.exam.annotation.Retry;import hello.aop.exam.annotation.Trace;import lombok.RequiredArgsConstructor;@Service@RequiredArgsConstructorpublic class ExamService {\tprivate final ExamRepository examRepository;\t@Trace\tpublic void request(String itemId) {\t\texamRepository.save(itemId);\t}}package hello.aop.exam;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.exam.aop.RetryAspect;import hello.aop.exam.aop.TraceAspect;import lombok.extern.slf4j.Slf4j;@SpringBootTest@Slf4j@Import({TraceAspect.class})public class ExamTest {\t@Autowired\tExamService examService;\t@Test\tvoid test() {\t\tfor (int i = 0; i &lt; 5; i++) {\t\t\tlog.info(\"request ={}\", i);\t\t\texamService.request(\"data\" + i);\t\t}\t}}간단하게 구현함재시도 AOPpackage hello.aop.exam.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Retry {\tint value() default 3;}package hello.aop.exam.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import hello.aop.exam.annotation.Retry;import lombok.extern.slf4j.Slf4j;@Slf4j@Aspectpublic class RetryAspect {\t@Around(\"@annotation(retry)\") //파라미터에 retry가 있어서 패키지명 안적어줘도\tpublic Object doRetry(ProceedingJoinPoint joinPoint, Retry retry) throws Throwable {\t\tlog.info(\"[retry] {}, retry={}\", joinPoint.getSignature(), retry);\t\tint maxRetry = retry.value();\t\tException exceptionHolder = null;\t\tfor (int i = 0; i &lt; maxRetry; i++) {\t\t\ttry {\t\t\t\tlog.info(\"[retry] try count ={}/{}\", i, maxRetry);\t\t\t\treturn joinPoint.proceed();\t\t\t} catch (Exception e) {\t\t\t\texceptionHolder = e;\t\t\t}\t\t}\t\treturn exceptionHolder;\t}}package hello.aop.exam;import org.springframework.stereotype.Repository;import hello.aop.exam.annotation.Retry;import hello.aop.exam.annotation.Trace;import lombok.extern.slf4j.Slf4j;@Repository@Slf4jpublic class ExamRepository {\tprivate static int seq = 0;\t@Trace\t@Retry\t//5번에 1번 실패\tpublic String save(String itemId) {\t\tseq++;\t\tif(seq % 5 == 0) {\t\t\tthrow new IllegalStateException(\"예외\");\t\t}\t\treturn \"OK\";\t}}package hello.aop.exam;import org.springframework.stereotype.Service;import hello.aop.exam.annotation.Retry;import hello.aop.exam.annotation.Trace;import lombok.RequiredArgsConstructor;@Service@RequiredArgsConstructorpublic class ExamService {\tprivate final ExamRepository examRepository;\t@Trace\t@Retry\tpublic void request(String itemId) {\t\texamRepository.save(itemId);\t}}package hello.aop.exam;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Import;import hello.aop.exam.aop.RetryAspect;import hello.aop.exam.aop.TraceAspect;import lombok.extern.slf4j.Slf4j;@SpringBootTest@Slf4j@Import({TraceAspect.class, RetryAspect.class})public class ExamTest {\t@Autowired\tExamService examService;\t@Test\tvoid test() {\t\tfor (int i = 0; i &lt; 5; i++) {\t\t\tlog.info(\"request ={}\", i);\t\t\texamService.request(\"data\" + i);\t\t}\t}}실무에서 간단한 조회api에서 에러가 발생했을때 retry시킨다면 에러로그없이 수향될수있음재실행 한계를 미리 지정해놓지않으면 무한재시도될수도있으니 주의할것  [!NOTE]  💡 @Transactional 어노테이션도 스프링 AOP임"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 디자인 패턴 - template call back",
    "url": "/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_template_call_back/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급",
    "date": "2024-01-07 00:00:00 +0900",
    





    
    "snippet": "-전략패턴에서 구현한package com.hello.high.trace.strategy.code;import com.hello.high.trace.strategy.code.strategy.Strategy;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ContextV2 {\tpublic void execute...",
    "content": "-전략패턴에서 구현한package com.hello.high.trace.strategy.code;import com.hello.high.trace.strategy.code.strategy.Strategy;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ContextV2 {\tpublic void execute(Strategy strategy) {\t\tlong startTime = System.currentTimeMillis();\t\t//비지니스로직 실행\t\tstrategy.call(); //위임\t\tlong endTime = System.currentTimeMillis();\t\tlong resultTime = endTime - startTime;\t\tlog.info(\"resultTime = {}\", resultTime);\t}}ContextV2는 변하지 않는 템플릿을 의미함변하는 부분은 파라미터로 넘어온 Strategy에서 처리함이렇게 다른코드의 인스로서 넘겨주는 실행가능한 코드를 콜백이라고 부름context.execute(new StrategyLogic2()); -&gt; 여기에서 new StrategyLogic2()context.execute(new Strategy() { @Override public void call() { *log*.info(\"비지니스로직3 실행\"); }}); -&gt; 여기에서 new Strategy() { @Override public void call() { *log*.info(\"비지니스로직3 실행\"); }}context.execute(() -&gt; *log*.info(\"비지니스로직3 실행\")); -&gt; 여기에서 () -&gt; *log*.info(\"비지니스로직3 실행\")부분을 말함필요에따라 즉시실행하거나 나중에 실행가능함즉 코드가 호출(call)되는데 실행은 코드를 넘겨준 곳의 뒤(back)에서 실행된다는 뜻스프링에서는 ContextV2와 같은 전략패턴을 템플릿 콜백 패턴이라고 함(GOF패턴은 아니고 스프링에서만 이렇게 부름. 전략패턴에서 템플릿과 콜백이 강조된 패턴). 스트링에서 ~~template 라는 이름이있으면 템플릿 콜백 패턴임public interface Callback {\tvoid call();}@Slf4jpublic class TimeLogTemplate {\tpublic void execute(Callback callback) {\t\tlong startTime = System.currentTimeMillis();\t\t//비지니스로직 실행\t\tcallback.call(); //위임\t\tlong endTime = System.currentTimeMillis();\t\tlong resultTime = endTime - startTime;\t\tlog.info(\"resultTime = {}\", resultTime);\t}}전략패턴과 거의 동일함/*\t템플릿 콜백 패턴 - 익명내부클래스\t */\t@Test\tvoid templateV1() {\t\tContextV2  context = new ContextV2();\t\tlog.info(\"strategyLogic1\");\t\tcontext.execute(new Strategy() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직3 실행\");\t\t\t}\t\t});\t\tcontext.execute(new Strategy() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직4 실행\");\t\t\t}\t\t});\t\tTimeLogTemplate template = new TimeLogTemplate();\t\ttemplate.execute(new Callback() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"~~~\");\t\t\t}\t\t});\t\ttemplate.execute(new Callback() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"!!!\");\t\t\t}\t\t});\t}\t@Test\tvoid templateV2() {\t\tTimeLogTemplate template = new TimeLogTemplate();\t\tlog.info(\"strategyLogic1\");\t\ttemplate.execute(new Callback() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직3 실행\");\t\t\t}\t\t});\t\ttemplate.execute(new Callback() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직4 실행\");\t\t\t}\t\t});\t}\t@Test\tvoid templateV3() {\t\tTimeLogTemplate template = new TimeLogTemplate();\t\ttemplate.execute(() -&gt; log.info(\"비지니스로직3 실행\"));\t\ttemplate.execute(() -&gt; log.info(\"비지니스로직4 실행\"));\t}\t@Test\tvoid templateV4() {\t\t//인터페이스 내 메소드가 한개만있을때는 람다로 변경 가능\t\tTimeLogTemplate template = new TimeLogTemplate();\t\ttemplate.execute(() -&gt; log.info(\"비지니스로직3 실행\"));\t\ttemplate.execute(() -&gt; log.info(\"비지니스로직4 실행\"));\t}위 패턴을 애플리케이션에 적용시킨다면package com.hello.high.trace.callback;public interface TraceCallback&lt;T&gt; {\tT call();}package com.hello.high.trace.callback;import com.hello.high.trace.TraceStatus;import com.hello.high.trace.logtrace.LogTrace;public class TraceTemplate {\tprivate final LogTrace trace;\tpublic TraceTemplate(LogTrace trace) {\t\tthis.trace = trace;\t}\tpublic &lt;T&gt; T execute(String message, TraceCallback&lt;T&gt; callback) {\t\tTraceStatus status = null;\t\ttry {\t\t\tstatus = trace.begin(message);\t\t\tT result = callback.call();\t\t\ttrace.end(status);\t\t\treturn result;\t\t} catch (Exception e) {\t\t\ttrace.exception(status, e);\t\t\tthrow e;\t\t}\t}}@RestControllerpublic class OrderControllerV5 {\tprivate final OrderServiceV5 orderService;\tprivate final TraceTemplate template;\tpublic OrderControllerV5(OrderServiceV5 orderService, LogTrace trace) {\t\tthis.orderService = orderService;\t\tthis.template = new TraceTemplate(trace);\t}\t@GetMapping(\"/v5/request\")\tpublic String request(String itemId) {\t\treturn template.execute(\"OrderController.request()\", new TraceCallback&lt;String&gt;() {\t\t\t@Override\t\t\tpublic String call() {\t\t\t\torderService.orderItem(itemId);\t\t\t\treturn \"OK\";\t\t\t}\t\t});\t}}@Servicepublic class OrderServiceV5 {\tprivate final OrderRepositoryV5 orderRepository;\tprivate final TraceTemplate template;\tpublic OrderServiceV5(OrderRepositoryV5 orderRepository, LogTrace logTrace) {\t\tthis.orderRepository = orderRepository;\t\tthis.template = new TraceTemplate(logTrace);\t}\tpublic void orderItem(String itemId) {\t\ttemplate.execute(\"OrderServiceV5.orderItem()\", () -&gt; {\t\t\torderRepository.save(itemId);\t\t\treturn null;\t\t});\t}}@Repositorypublic class OrderRepositoryV5 {\tprivate final TraceTemplate template;\tpublic OrderRepositoryV5(LogTrace logTrace) {\t\tthis.template = new TraceTemplate(logTrace);\t}\tpublic void save(String itemId) {\t\ttemplate.execute(\"OrderRepositoryV5.save()\", () -&gt; {\t\t\tif (itemId.equals(\"ex\")) {\t\t\t\tthrow new InvalidParameterException(\"예외\");\t\t\t}\t\t\tsleep(1000);\t\t\treturn null;\t\t});\t}\tprivate void sleep(int millis) {\t\ttry {\t\t\tThread.sleep(millis);\t\t} catch (InterruptedException e) {\t\t\te.printStackTrace();\t\t}\t}}this.template = new TraceTemplate(trace);생성자 파라미터로 받은 logTrace를 이용해 의존관계 주입을 받으면서 필요한 TraceTemplate를 생성함. 참고로 TraceTemplate를 스프링 빈으로 등록해서 주입받아도됨그러나 지금까지 사용한 템플릿메소드, 전략, 템플릿콜백패턴 모두 원본코드를 수정해야한다는 단점있음원본코드를 손대지않고 로그추적기를 적용할 수 있는 방법을 찾기위해 프록시의 개념을 먼저 이해해야함"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 디자인 패턴 - templateMethod",
    "url": "/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_templateMethod/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급",
    "date": "2024-01-01 00:00:00 +0900",
    





    
    "snippet": "그전 강의 챕터에서 비지니스로직을 구현할때마다 로그를 찍을때@GetMapping(\"/v2/request\")\tpublic String request(String itemId) {\t\tTraceStatus status = null;\t\ttry {\t\t\t status = trace.begin(\"OrderController.requset()\");\t\t\torderSe...",
    "content": "그전 강의 챕터에서 비지니스로직을 구현할때마다 로그를 찍을때@GetMapping(\"/v2/request\")\tpublic String request(String itemId) {\t\tTraceStatus status = null;\t\ttry {\t\t\t status = trace.begin(\"OrderController.requset()\");\t\t\torderService.orderItem(status.getTraceId(), itemId);\t\t\ttrace.end(status);\t\t\treturn \"ok\";\t\t} catch (Exception e) {\t\t\ttrace.exception(status, e);\t\t\tthrow e; //예외를 꼭 다시 던져줘야함\t\t}\t}위처럼 중복 코드를 작성해주었는데이것을 해결하기위해서는 디자인패턴중에 템플릿메소드패턴을 사용하면 좋음package com.hello.high.trace.template.code;import lombok.extern.slf4j.Slf4j;@Slf4jpublic abstract class AbstractTemplate {\tpublic void execute() {\t\tlong startTime = System.currentTimeMillis();\t\t//비지니스로직 실행\t\tcall(); //상속\t\tlong endTime = System.currentTimeMillis();\t\tlong resultTime = endTime - startTime;\t\tlog.info(\"resultTime = {}\", resultTime);\t}\tprotected abstract void call();}추상클래스를 구현한 후, 실제 비지니스로직은 call로 호출함. call로 호출하는 실제 비지니스로직은package com.hello.high.trace.template.code;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class SubClassLogin1 extends AbstractTemplate {\t@Override\tprotected void call() {\t\tlog.info(\"비지니스로직2 실행\");\t}}추상클래스를 상속받아 오버라이드해주면됨.그러나 이렇게하면 불필요한 클래스가 계속 생성된다는 단점이있기때문에@Test\tvoid templateMethodV2() {\t\tAbstractTemplate template1 = new AbstractTemplate() {\t\t\t@Override\t\t\tprotected void call() {\t\t\t\tlog.info(\"비지니스로직1 실행\");\t\t\t}\t\t};\t\tlog.info(\"클래스이름1 = {}\", template1.getClass());\t\ttemplate1.execute();\t\tAbstractTemplate template2 = new AbstractTemplate() {\t\t\t@Override\t\t\tprotected void call() {\t\t\t\tlog.info(\"비지니스로직2 실행\");\t\t\t}\t\t};\t\tlog.info(\"클래스이름2 = {}\", template2.getClass());\t\ttemplate2.execute();\t}이렇게 익명의 클래스를 오버라이드해주면 클래스 생성없이 비지니스로직을 구현가능함.물론 전보다 코드가 길어지긴했지만 불필요한 클래스가 너무 증가하면 프로젝트가 너무 복잡해지고…힘들어요..위 디자인패턴을 로그 어플리케이션에 적용하면package com.hello.high.trace.template;import com.hello.high.trace.TraceStatus;import com.hello.high.trace.logtrace.LogTrace;public abstract class AbstractTemplate&lt;T&gt; {\tprivate final LogTrace trace;\tpublic AbstractTemplate(LogTrace trace) {\t\tthis.trace = trace;\t}\tpublic T execute(String message) {\t\tTraceStatus status = null;\t\ttry {\t\t\tstatus = trace.begin(message);\t\t\tT result = call();\t\t\ttrace.end(status);\t\t\treturn result;\t\t} catch (Exception e) {\t\t\ttrace.exception(status, e);\t\t\tthrow e;\t\t}\t}\tprotected abstract T call();}package com.hello.high.app.v4;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import com.hello.high.trace.TraceStatus;import com.hello.high.trace.logtrace.LogTrace;import com.hello.high.trace.template.AbstractTemplate;import lombok.RequiredArgsConstructor;@RestController@RequiredArgsConstructorpublic class OrderControllerV4 {\tprivate final OrderServiceV4 orderService;\tprivate final LogTrace trace;\t@GetMapping(\"/v4/request\")\tpublic String request(String itemId) {\t\tAbstractTemplate&lt;String&gt; template = new AbstractTemplate&lt;String&gt;(trace) {\t\t\t@Override\t\t\tprotected String call() {\t\t\t\torderService.orderItem(itemId);\t\t\t\treturn \"ok\";\t\t\t}\t\t};\t\treturn template.execute(\"OrderController.request()\");\t}}package com.hello.high.app.v4;import org.springframework.stereotype.Service;import com.hello.high.trace.TraceStatus;import com.hello.high.trace.logtrace.LogTrace;import com.hello.high.trace.template.AbstractTemplate;import lombok.RequiredArgsConstructor;@Service@RequiredArgsConstructorpublic class OrderServiceV4 {\tprivate final OrderRepositoryV4 orderRepository;\tpublic void orderItem(String itemId) {\t\tAbstractTemplate&lt;String&gt; template = new AbstractTemplate&lt;String&gt;(trace) {\t\t\t@Override\t\t\tprotected String call() {\t\t\t\torderRepository.save(itemId);\t\t\t\treturn null;\t\t\t}\t\t};\t\ttemplate.execute(\"OrderServiceV4.orderItem()\");\t}}package com.hello.high.app.v4;import java.security.InvalidParameterException;import org.springframework.stereotype.Repository;import com.hello.high.trace.TraceStatus;import com.hello.high.trace.logtrace.LogTrace;import com.hello.high.trace.template.AbstractTemplate;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class OrderRepositoryV4 {\tpublic void save(String itemId) {\t\tAbstractTemplate&lt;String&gt; template = new AbstractTemplate&lt;String&gt;(trace) {\t\t\t@Override\t\t\tprotected String call() {\t\t\t\tif (itemId.equals(\"ex\")) {\t\t\t\t\tthrow new InvalidParameterException(\"예외\");\t\t\t\t}\t\t\t\tsleep(1000);\t\t\t\treturn null;\t\t\t};\t\t};\t\ttemplate.execute(\"OrderRepositoryV4.save()\");\t}\tprivate void sleep(int millis) {\t\ttry {\t\t\tThread.sleep(millis);\t\t} catch (InterruptedException e) {\t\t\te.printStackTrace();\t\t}\t}}이렇게 중복 코드를 하나의 클래스로 관리가능.그러나 템플릿메소드패턴을 사용하면 상속에서 오는 단점을 그대로 안고감. 자식클래스가 부모 클래스와 컴파일 시점에 강하게 결합된다는 문제가있음자식입장에서는 부모의 기능을 사용하지않는데 강하게 의존(부모클리스의 코드가 자식클래스에 적혀있음)하는 상태가되서 부모클래스 수정 시 자식클래스에도 영향을 줄수있음또한 상속구조때문에 별도의 클래스나 익명 내부 클래스를 만들어야하는 부분이 복잡함⇒ 전략 패턴을 사용하면 이러한 단점을 해결 가능함"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] 디자인 패턴 - strategy",
    "url": "/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_strategy/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급",
    "date": "2024-01-01 00:00:00 +0900",
    





    
    "snippet": "템플릿 메소드 패턴의 상속의 단점을 해결할 수 있는 전략패턴package com.hello.high.trace.strategy.code;import com.hello.high.trace.strategy.code.strategy.Strategy;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ContextV1...",
    "content": "템플릿 메소드 패턴의 상속의 단점을 해결할 수 있는 전략패턴package com.hello.high.trace.strategy.code;import com.hello.high.trace.strategy.code.strategy.Strategy;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ContextV1 {\tprivate Strategy strategy;\tpublic ContextV1(Strategy strategy) {\t\tthis.strategy = strategy;\t}\tpublic void execute() {\t\tlong startTime = System.currentTimeMillis();\t\t//비지니스로직 실행\t\tstrategy.call(); //위임\t\tlong endTime = System.currentTimeMillis();\t\tlong resultTime = endTime - startTime;\t\tlog.info(\"resultTime = {}\", resultTime);\t}}public interface Strategy {\tvoid call();}package com.hello.high.trace.strategy.code.strategy;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class StrategyLogic1 implements Strategy {\t@Override\tpublic void call() {\t\tlog.info(\"비지니스로직 1 실행\");\t}}템플릿 메소드 패턴과 마찬가지로 공통 로직은 execute를 사용해서 구현하고 비지니스 로직은 call메소드를 호출하는것으로 처리했다중요한것은 call 하는 메소드가 인터페이스인 Strategy를 전역변수로 선언해 call에서 사용할 비지니스로직이 있는 Strategy의 구현체를 생성자 파라미터로 받아 외부에서 주입받도록 함스프링에서 가장많이사용하는 의존관계가 전략패턴임/**\t * 전략패턴 사용\t */\t@Test\tvoid strategyV1() {\t\tStrategyLogic1 logic1 = new StrategyLogic1();\t\tContextV1 contextV1 = new ContextV1(logic1);\t\tcontextV1.execute();\t\tStrategyLogic2 logic2 = new StrategyLogic2();\t\tContextV1 contextV2 = new ContextV1(logic2);\t\tcontextV2.execute();\t}\t@Test\tvoid strategyV2() {\t\tStrategy logic1 = new Strategy() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직3 실행\");\t\t\t}\t\t};\t\tContextV1 contextV1 = new ContextV1(logic1);\t\tlog.info(\"strategyLogic1\");\t\tcontextV1.execute();\t\tStrategy logic2 = new Strategy() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직4 실행\");\t\t\t}\t\t};\t\tContextV1 contextV2 = new ContextV1(logic2);\t\tlog.info(\"strategyLogic2\");\t\tcontextV2.execute();\t}\t@Test\tvoid strategyV3() {\t\tContextV1 contextV1 = new ContextV1(new Strategy() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직3 실행\");\t\t\t}\t\t});\t\tcontextV1.execute();\t\tContextV1 contextV2 = new ContextV1(new Strategy() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직4 실행\");\t\t\t}\t\t});\t\tcontextV2.execute();\t}\t@Test\tvoid strategyV4() {\t\t//인터페이스 내 메소드가 한개만있을때는 람다로 변경 가능\t\tContextV1 contextV1 = new ContextV1(() -&gt; log.info(\"비지니스로직3 실행\"));\t\tcontextV1.execute();\t\tContextV1 contextV2 = new ContextV1(() -&gt; log.info(\"비지니스로직4 실행\"));\t\tcontextV2.execute();\t}단 이렇게 Context를 생성하는 과정이 복잡하다는 단점이있음.물론 한번 생성해두면 여러번 편리하게 재사용가능하나 한번 생성한 후에는 변경하기 어렵다는것도 단점Context내에 전역변수로 사용한 Strategy에 setter를 생성하지않는 한 변경할 수 없을것이고Context를 싱글톤으로 사용할때는 동시성이슈도 고려해야한다이를 해결하기 위해서package com.hello.high.trace.strategy.code;import com.hello.high.trace.strategy.code.strategy.Strategy;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ContextV2 {\tpublic void execute(Strategy strategy) {\t\tlong startTime = System.currentTimeMillis();\t\t//비지니스로직 실행\t\tstrategy.call(); //위임\t\tlong endTime = System.currentTimeMillis();\t\tlong resultTime = endTime - startTime;\t\tlog.info(\"resultTime = {}\", resultTime);\t}}Strategy를 execute의 파라미터로 받아도된다/**\t * 전략패턴 사용\t */\t@Test\tvoid strategyV1() {\t\tContextV2 context = new ContextV2();\t\tcontext.execute(new StrategyLogic1());\t\tcontext.execute(new StrategyLogic2());\t}\t@Test\tvoid strategyV2() {\t\tContextV2 context = new ContextV2();\t\tlog.info(\"strategyLogic1\");\t\tcontext.execute(new Strategy() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직3 실행\");\t\t\t}\t\t});\t\tcontext.execute(new Strategy() {\t\t\t@Override\t\t\tpublic void call() {\t\t\t\tlog.info(\"비지니스로직4 실행\");\t\t\t}\t\t});\t}\t@Test\tvoid strategyV3() {\t\tContextV2 context = new ContextV2();\t\tlog.info(\"strategyLogic1\");\t\tcontext.execute(() -&gt; log.info(\"비지니스로직3 실행\"));\t\tcontext.execute(() -&gt; log.info(\"비지니스로직4 실행\"));\t}execute를 실행할때마다 파라미터로 strategy를 넘겨주기때문에 쉽게 조립하여 사용할 수 있다그러나 실행할때마다 전략을 계속 파라미터로 넘겨주어야한다는 단점이있다"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 - 고급] ThreadLocal",
    "url": "/posts/ThreadLocal/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리-고급",
    "date": "2024-01-01 00:00:00 +0900",
    





    
    "snippet": "package com.hello.high.trace.logtrace;import org.springframework.stereotype.Component;import com.hello.high.trace.TraceId;import com.hello.high.trace.TraceStatus;import lombok.extern.slf4j.Slf4j;//...",
    "content": "package com.hello.high.trace.logtrace;import org.springframework.stereotype.Component;import com.hello.high.trace.TraceId;import com.hello.high.trace.TraceStatus;import lombok.extern.slf4j.Slf4j;// @Component@Slf4jpublic class FieldLogTrace implements LogTrace {\tprivate static final String START_PREFIX = \"---&gt;\";\tprivate static final String COMPLETE_PREFIX = \"&lt;---\";\tprivate static final String EX_PREFIX = \"&lt;X-\";\tprivate TraceId traceIdHolder; //traceId 동기화, 동시성 이슈 발생\t@Override\tpublic TraceStatus begin(String message) {\t\tsyncTraceId();\t\tTraceId traceId = traceIdHolder;\t\tLong startTimeMs = System.currentTimeMillis();\t\tlog.info(\"[{}] {}{}\", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);\t\treturn new TraceStatus(traceId, startTimeMs, message);\t}\tprivate void syncTraceId() {\t\tif (traceIdHolder == null) {\t\t\ttraceIdHolder = new TraceId();\t\t} else {\t\t\ttraceIdHolder = traceIdHolder.createNextId();\t\t}\t}\t@Override\tpublic void end(TraceStatus status) {\t\tcomplete(status, null);\t}\t@Override\tpublic void exception(TraceStatus status, Exception e) {\t\tcomplete(status, e);\t}\tprivate void complete(TraceStatus status, Exception e) {\t\tLong stopTimeMs = System.currentTimeMillis();\t\tLong resultTimeMs = stopTimeMs - status.getStartTimeMs();\t\tTraceId traceId = status.getTraceId();\t\tif (e == null) {\t\t\tlog.info(\"[{}] {}{} time={}ms\", traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), resultTimeMs);\t\t} else {\t\t\tlog.info(\"[{}] {}{} time={}ms\", traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), resultTimeMs);\t\t}\t\t\t\treleaseTraceId();\t}\tprivate void releaseTraceId() {\t\tif (traceIdHolder.isFirstLevel()) {\t\t\ttraceIdHolder = null;\t\t} else {\t\t\ttraceIdHolder = traceIdHolder.createPreviousId();\t\t}\t}\tprivate static String addSpace(String prefix, int level) {\t\tStringBuilder sb = new StringBuilder();\t\tfor (int i = 0; i &lt; level; i++) {\t\t\tsb.append((i == level - 1) ? \"|\" + prefix : \"|    \");\t\t}\t\treturn sb.toString();\t}\tpublic TraceStatus beginSync(TraceId beforeTraceId, String message) {\t\tTraceId traceId = beforeTraceId.createNextId();\t\tLong startTimeMs = System.currentTimeMillis();\t\tlog.info(\"[{}] {}{}\", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);\t\treturn new TraceStatus(traceId, startTimeMs, message);\t}}위와같이 그 전의 메소드 호출 레벨을 받아서 로그를 찍는 클래스를 구현함문제는private TraceId traceIdHolder;이부분→ 다중 스레드의 환경에서 동시성 문제가 발생할 수 있음위의 문제를 해결하기위해서는 ThreadLocal을 사용하면됨여기서 말하는 ThreadLocal이란 각 스레드별로 별도의 저장공간을 의미함. 각 스레드가 처리할 정보를 ThreadLocal에 저장한 후 필요할때 꺼내쓰는 방법.package com.hello.high.trace.logtrace;import com.hello.high.trace.TraceId;import com.hello.high.trace.TraceStatus;import lombok.extern.slf4j.Slf4j;// @Component@Slf4jpublic class ThreadLocalLogTrace implements LogTrace {\tprivate static final String START_PREFIX = \"---&gt;\";\tprivate static final String COMPLETE_PREFIX = \"&lt;---\";\tprivate static final String EX_PREFIX = \"&lt;X-\";\tprivate ThreadLocal&lt;TraceId&gt; traceIdHolder = new ThreadLocal&lt;&gt;();\t@Override\tpublic TraceStatus begin(String message) {\t\tsyncTraceId();\t\tTraceId traceId = traceIdHolder.get();\t\tLong startTimeMs = System.currentTimeMillis();\t\tlog.info(\"[{}] {}{}\", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);\t\treturn new TraceStatus(traceId, startTimeMs, message);\t}\tprivate void syncTraceId() {\t\tTraceId traceId = traceIdHolder.get();\t\tif (traceId == null) {\t\t\ttraceIdHolder.set(new TraceId());\t\t} else {\t\t\ttraceIdHolder.set(traceId.createNextId());\t\t}\t}\t@Override\tpublic void end(TraceStatus status) {\t\tcomplete(status, null);\t}\t@Override\tpublic void exception(TraceStatus status, Exception e) {\t\tcomplete(status, e);\t}\tprivate void complete(TraceStatus status, Exception e) {\t\tLong stopTimeMs = System.currentTimeMillis();\t\tLong resultTimeMs = stopTimeMs - status.getStartTimeMs();\t\tTraceId traceId = status.getTraceId();\t\tif (e == null) {\t\t\tlog.info(\"[{}] {}{} time={}ms\", traceId.getId(), addSpace(COMPLETE_PREFIX, traceId.getLevel()), resultTimeMs);\t\t} else {\t\t\tlog.info(\"[{}] {}{} time={}ms\", traceId.getId(), addSpace(EX_PREFIX, traceId.getLevel()), resultTimeMs);\t\t}\t\t\t\treleaseTraceId();\t}\tprivate void releaseTraceId() {\t\tTraceId traceId = traceIdHolder.get();\t\tif (traceId.isFirstLevel()) {\t\t\ttraceIdHolder.remove(); //ThreadLocal 초기화\t\t} else {\t\t\ttraceIdHolder.set(traceId.createPreviousId());\t\t}\t}\tprivate static String addSpace(String prefix, int level) {\t\tStringBuilder sb = new StringBuilder();\t\tfor (int i = 0; i &lt; level; i++) {\t\t\tsb.append((i == level - 1) ? \"|\" + prefix : \"|    \");\t\t}\t\treturn sb.toString();\t}\tpublic TraceStatus beginSync(TraceId beforeTraceId, String message) {\t\tTraceId traceId = beforeTraceId.createNextId();\t\tLong startTimeMs = System.currentTimeMillis();\t\tlog.info(\"[{}] {}{}\", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);\t\treturn new TraceStatus(traceId, startTimeMs, message);\t}}적용하여 재구현한 로그 클래스ThreadLocal에 TraceId를 타입지정해주는 방식으로 변경함private ThreadLocal&lt;TraceId&gt; traceIdHolder = new ThreadLocal&lt;&gt;();이렇게 사용하면 다중 스레드환경에서 traceIdHolder에 동시접근하여도 각각의 저장공간에 traceId를 저장하여 사용하기때문에 안전함그러나 조심해야할 것이있는데 요청을 종료할때 무조건 ThreadLocal을 초기화시켜줘야함.traceIdHolder.remove(); 으로 초기화하면됨이유는 thread가 사용자의 정보를 저장하고 초기화 하지않은경우, 다른 사용자가 요청했을때 저장된 정보를 꺼내어 보여줄수있기때문임.강의에서 사용된 주요 로직은 중복이 심해서 굳이 블로그에 옮기지는 않음. 다음 강의에서 공통 메소드로 구현될것으로 예상됨."
  },
  
  {
    "title": "[책] 도메인 주도 설계 철저 입문",
    "url": "/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EC%84%A4%EA%B3%84-%EC%B2%A0%EC%A0%80-%EC%9E%85%EB%AC%B8/",
    "categories": "프로그래밍 방법",
    "tags": "DDD, jpa",
    "date": "2023-11-12 00:00:00 +0900",
    





    
    "snippet": "책 정보값 객체public class User {\t@Id\t@Column(name = \"user_id\")\tprivate Long userId;\t@Column(name = \"first_name\")\tprivate String firstName;\t@Column(name = \"last_name\")\tprivate String lastName;\t@Enumerate...",
    "content": "책 정보값 객체public class User {\t@Id\t@Column(name = \"user_id\")\tprivate Long userId;\t@Column(name = \"first_name\")\tprivate String firstName;\t@Column(name = \"last_name\")\tprivate String lastName;\t@Enumerated(EnumType.STRING)\tprivate UserType type;위의 firstName, lastName처럼 name이라는 정보로 묶어서 관리하고싶을때 쓰는 방법@EmbeddedId\t@Column(name = \"user_id\")\tprivate UserId id;\t@Embedded\t@Column(name = \"user_name\")\tprivate UserName name;\t@Enumerated(EnumType.STRING)\tprivate UserType type;@Embeddable@NoArgsConstructorpublic class UserName {\t@Column(name = \"first_name\")\tprivate String firstName;\t@Column(name = \"last_name\")\tprivate String lastName;다중 값에만 적용하는것이아니라 id처럼 단일한 값에도 값타입을 적용할 수 있음. 위의 케이스에서는 타입만 보고 해당 필드가 아이디라는것을 알 수 있음(과하다고 보는사람도있음)값 타입의 장점으로는  가독성          타입만으로 해당 필드가 어떤 정보인지 알 수 있음        값 타입에 setter를 생성하지않는다면 불변타입이 됨                  값 타입에 변경가능성을 차단시켰기때문에 값을 변경하려면 새로운 객체를 생성해줘야함          public void changeName(String firstName, String lastName) {  \tthis.name = new UserName(firstName, lastName);;  }          public void changeName(UserName name) {  \tif(name == null) {  \t\tthrow new IllegalArgumentException();  \t}  \tthis.name = name;  }                          규칙성을 관리하기 용이함          userName 객체 생성자에 필요한 유효성검사를 추가하여 해당 값타입 생성조건을 객체 하나에 몰아넣고 관리가 가능함.         public UserName(String firstName, String lastName) { \t\tif (firstName == null || lastName == null) throw new IllegalArgumentException(); \t\tif (firstName.length() + lastName.length() &lt; 3) { \t\t\tthrow new IllegalArgumentException(\"사용자명은 3글자 이상이어야 함\"); \t\t} \t\tif (firstName.length() + lastName.length() &gt; 20) { \t\t\tthrow new IllegalArgumentException(\"사용자명은 20글자 이하이어야 함\"); \t\t}     \t\tthis.firstName = firstName; \t\tthis.lastName = lastName; \t}        변경이 일어나도 수정하기 편리함          위와 같은 이유로 사용자명의 길이제한이 변경되면 userName 생성자만 수정해주면 모든 곳에 적용이됨. 변수가 추가되도 마찬가지임.      김영한 자바 ORM 표준 JPA 강의 정리자료를 보면 단점이 뚜렷해서 실무에서는 잘 쓰이지않는 방법인듯함.공통 관리 컬럼에 대한 @Embeddable만 주로쓰면 될거같음엔티티값 타입은 속성의 값이 일치하더라도 다른 객체로 분리됨(이름이 같다고 같은 유저는 아님)그러나 엔티티는 속성의 값이 달라져도 사용자가 바뀐것은아님(개명했다고 다른사람이된것은아님) = 엔티티는 가변객체임(식별자로 동일성을 구분함)단, 모든 속성이 가변일 필요는 없음. 가능가면 불변으로 남겨두면 좋음.❗ 문제는 값객체도, 엔티티도 될수있는 모델이 존재함. 어떤 환경이냐에 따라 모델링방법이 달라지니 상황에따라 어떤 방법이 적합한지 고려해야함도메인 서비스행동을 정의할때 엔티티 내에 정의하기 애매한 행동들이 있음 (ex. 중복 아이디 검사)이럴때 사용하는 것이 도메인서비스.그러나 너무 남발한다면 모든 처리가 서비스에 정의된다는 문제가 생길수있음. → 엔티티에 게터, 세터만 남게되어 객체만 보고 어떤 객체인지 파악하기 어려움+중복 코드 발생리포지토리데이터를 가져오기위해 데이터베이스에서 값을 가져올때 도메인에 코드를 작성하면 이해하기 어려움+특정기술에 의존된 코드를 서비스에 작성하게됨⇒ 데이터베이스에서 값을 가져오는 코드를 리포지토리로 묶어서 관리하면 서비스는 데이터베이스 기술이 무엇인지 몰라도된다는 장점이있음 + 서비스에는 행동과 관련된 순수한 로직만 남게됨애플리케이션 서비스유스케이스를 구현하는 객체@Transactionalpublic UserResult&lt;Long&gt; register(UserRegisterCommand command) {\tUserName name = new UserName(command.getFirstName(), command.getLastName());\tUser user = userFactory.create(name);\tif(userService.exists(user)) {\t\tthrow new IllegalArgumentException(\"이미등록된사용자\");\t}\tuserRepository.save(user);\treturn new UserResult&lt;&gt;(user.getId().value());}사용자 등록이라는 유스케이스를 애플리케이션서비스에 구현, 도메인서비스인 userService에서 중복검사를 한 후 결과에따른 처리는 애플리케이션서비스에 작성함중복체크로직을 애플리케이션서비스에 구현한다면 비슷한 유스케이스를 만날때마다 같은 코드를 중복작성하게될수도있음. 도메인서비스에 이런 로직을 몰아두고 호출만하는것이 더 편리함응집도정처기할때 말만들은건데.. 정확하게 뭔지모르고있었어서 정리함public class TestClass {\tprivate int num1;\tprivate int num2;\tprivate int num3;\tprivate int num4;\tpublic int mothod1() {\t\treturn num1 + num2;\t}\t\tpublic int mothod1() {\t\treturn num3 + num4;\t}}코드를 확인해보면 mothod1은 num3, num4를 모르고 mothod2는 num1,2를 모르는 형태임. 이렇것을 두고 응지보가 낮다고 말함위의 코드는 응집도를 높이기 위해서public class TestClass {\tprivate int num1;\tprivate int num2;\tpublic int mothod1() {\t\treturn num1 + num2;\t}}public class TestClass2 {\tprivate int num3;\tprivate int num4;\t\tpublic int mothod1() {\t\treturn num3 + num4;\t}}이렇게 분리하는 것이 더 효율적임.애플리케이션 서비스도 비슷함. 무조건 응집도가 높은것이 좋은것은아니나 설계시 고려해볼만한 요소임.애플리케이션서비스의 응집도가 너무 낮다면 애플리케이션 서비스를 분리시키는 것도 좋은 방법임 (조회용, 생성용 등)예를들면 위의 코드에서 사용한 사용자 중복체크는 사용자 조회관련 유스케이스에서는 사용하지않는 로직임. 그렇가면 조회관련 로직은 도메인서비스인 userService를 몰라도됨!! → 분리가능추가로 애플리케이션 서비스의 인터페이스로 만들어 목업객체를 반환해준다면 클라이언트는 구현완성을 기다릴필요없이 미리 작업이가능함유연성을 위한 의존관계 제거의존  ObjectA가 ObjectB에 의존public class ObjectA {       private ObjectB objectb;}  구현체가 인터페이스에 의존public interface UserRepository {    User find(UserId id);}public class UserRepositoryImpl implements UserRepository {    @Override    public User find(UserId Id) {        }}  모듈간 의존public class UserApplicationService {\tprivate final UserRepositoryImpl userRepository;위를 해결하게위해서 의존관계역전원칙(Dependency Inversion Principle)을 이용하여 제어함의존관계역전원칙  추상타입에 의존 → 구현체보다는 인터페이스에 의존함  주도권을 추상타입으로 → 중요도가 높은 도메인규칙은 항상 추상화 수준이 높은쪽에 기술됨. 낮은 수준의 추상화모델이 변경된다고 높은 수준의 추상화모델이 변경되지않도록함의존관계 제어public class UserApplicationService {    private fianl UserRepository userRepository;          public UserApplicationService() {        // this.userRepository = new InMemoryUserRepository;        this.userRepository = new MySqlUserRepository;    }}userRepository가 추상타입이지만 생성자안에서 구상클래스의 객체를 만들면서 InMemoryUserRepository에 의존관계가 발생함또한 변경 시 MySqlUserRepository로 일괄변경해야하는 단점이있음Service LocatorServiceLocator 객체에 의존 해소 대상이 되는 객체를 미리 등록해 둔 다음, 인스턴스가 필요한 곳에서 ServiceLocator 객체에게 인스턴스를 받아 사용하는 패턴public class UserApplicationService {    private fianl UserRepository userRepository;    public UserApplicationService() {        this.userRepository = ServiceLocator.resolve&lt;UserRepository&gt;();    }}위처럼 사용하는데 처음 어플리케이션이 실행되는 시점에 ServiceLocator.register&lt;UserRepository, InMemoryUserRepository&gt;(); 를 등록해야하만한다.그러나 의존관계를 보기 어렵고 테스트가 힘들다는 단점이있다IoC 패턴Dependency Injection. 생성자를 통해 의존관계를 주입함.팩토리패턴복잡한 객체 생성 절차를 캡슐화하기 위한 방법만약 객체의 identity를 미리 주입받아야하는 조건(jpa identity속성이 아닐때)일때 엔티티내에 db에서 identity를 구하는 repository를 의존하는것은 좋은 방법이아니라 엔티티에서는 사용할 수 없음→ 서비스에 이를 구현하면 객체를 생성할때마다 아이디를 가져와야함→ 팩토리 패턴 적용public interface UserFactory {\tUser create(UserName name);}public class UserFactoryImpl implements UserFactory {\tprivate final UserRepository userRepository;\t@Override\tpublic User create(UserName name) {\t\tLong rawId = userRepository.findTop1ByOrderById();\t\treturn new User(\t\t\tnew UserId(rawId==null?0L:++rawId),\t\t\tname,\t\t\tUserType.NORMAL\t\t);\t}}@Transactionalpublic UserResult&lt;Long&gt; register(UserRegisterCommand command) {\tUserName name = new UserName(command.getFirstName(), command.getLastName());\tUser user = userFactory.create(name);\tif(userService.exists(user)) {\t\tthrow new IllegalArgumentException(\"이미등록된사용자\");\t}\tuserRepository.save(user);\treturn new UserResult&lt;&gt;(user.getId().value());}위처럼 객체 생성을 factory에 맡기게되면서 생성을 캡슐화할수있음데이터 무결성 유지동일 이메일 회원가입 불가 조건 시 같은 이메일로 동시 회원가입을 하면 db의 무결성이깨질수도있음유일키 제약db에 동일 이메일이 들어오지않게 유일키속성을 지정하는 방법이나 최후의 수단으로 생각해야한다. 개발자의 실수로 동일 이메일이 들어왔을대 db에서 최종적으로 막히도록 해야함.트랜젝션에러 발생 시 요청을 롤백스프링은 aop @Transactional 어노테이션을 사용함  [!important]DB가 제공하는 트랜잭션은 일관성유지를 위해 데이터에 lock을 검.트랜잭션 사용시 lock의 범위를 항상 염두해두어야함. lock범위는 최소한으로 잡는것이 좋다. 범위가 넓어지면 실패가능성이 커짐.애그리게이트여러 객체가 모여 하나의 의미를 가지는 묶음이 될때 애그리게이트라고함객체 스스로가 자기자신에 대해 일관성있게 행동해야한다.쉽게말하자면 애그리게이트 범위를 넘어서 다른 애그리게이트 범위의 객체를 수정하지말라는것.이런 문제는 대개 객체안에 다른 객체를 참조(ex. 단방향매핑)하고있을때 흔히 일어나는데 주문 객체가 회원객체를 가지고있어 자연스럽게 회원도 변경하려하는 상황..이런 참조관계를 제거하고 약한 참조(식별자를 참조)로 변경하면 막을 수 있음근데..음 그럼 jpa에서는 fetch join등 편리한 기능을 못쓰게되는건데 괜찮나?아직 어렵다..단방향 매핑을 걸되 update, insert를 불가능하게 막아두면 문제상황을 겪지않으면서 직접참조의 장점을 가질수있으려나?하지만 update, insert 속성이 false라는건 호출시점에서 알수없어서 수정을 시도하려는 경우가 생길거같아서 고민임ㅜ명세객체를 평가할때 해당 객페에 메소드로 정의하지 못하는 경우 + 애플리케이션서비스에 구현하려고하나 객체에대한 평가는 중요도가 높아 애플리케이션서비스에서 구현할 사항이아님 ⇒ 명세 이용public class CircleFullSpecification {    private final UserRepository userRepository;    public CircleFullSpecification(IUserRepository userRepository) {        this.userRepository = userRepository;    }    public bool IsSatisfiedBy(Circle circle) {        var membersCount = circle.CountMembers();        if (membersCount &lt; 30) {            return false;        }        var members = circle.GetMembers();        var users = userRepository.Find(members);        var premiumMemberCount = CountPremiumMember(users);        var max = premiumMemberCount &gt; 10 ? 50 : 30;        return membersCount &gt;= max;    }    private int CountPremiumMember(List&lt;User&gt; members) {        return members.Count(x =&gt; x.Type == UserType.Premium);    }}❗서비스는 도메인 규칙에 근거한 로직을 포함해서는 안됨!명세와 리포지토리를 사용하는것도 좋은방법이나 성능이 느려질수도있으니 잘 사용해야함복잡한 쿼리는 리드모델로만약 서클과 서클장의 정보를 한번에 들고오는 쿼리를 작성해야한다면? 도메인을 지키자고 성능 문제를 발생시킬수는 없음이런경우는 queryService처럼 따로 빼내어 이런 부분만 도메인 제약에서 벗어나게하는것도 가능함"
  },
  
  {
    "title": "[코틀린 쿡북] 9장 - 테스트",
    "url": "/posts/%ED%85%8C%EC%8A%A4%ED%8A%B8/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-10-28 00:00:00 +0900",
    





    
    "snippet": "테스트 생명주기자바에서 테스트 메소트마다 새로운 인스턴스를 생성해야할떄 static으로 문제를 해결했는데 코틀린에서는 static이 없음.→ @BeforeClass 어노테이션이 달린 메소드 안에 배치 (1번)companion object {        @JvmStatic        private val Strings = listOf(\"a\",\"B\",...",
    "content": "테스트 생명주기자바에서 테스트 메소트마다 새로운 인스턴스를 생성해야할떄 static으로 문제를 해결했는데 코틀린에서는 static이 없음.→ @BeforeClass 어노테이션이 달린 메소드 안에 배치 (1번)companion object {        @JvmStatic        private val Strings = listOf(\"a\",\"B\",\"c\",\"d\")        @BeforeClass        @JvmStatic        fun runBefore() {            println(Strings)        }        private val modifiable = ArrayList&lt;Int&gt;()        @AfterClass        @JvmStatic        fun initalize() {            println(modifiable)            modifiable.add(4)            modifiable.add(3)            modifiable.add(1)            modifiable.add(5)            modifiable.add(2)        }    }    @Test    fun contextLoads() {    }→ @TestInstance 어노테이션 사용(2번)@TestInstance(TestInstance,Lifecycle.PER_CLASS)class Test2 {    private val strings = listOf(\"a\",\"b\",\"c\",\"d\",\"e\")    private lateinit val modifiable : MutableList&lt;Int&gt;    @BeforeEach    fun setUp() {        modifiable = mutableListOf(3,1,2,5,4)        println(modifiable)    }    @AfterEach    fun finish() {        println(modifiable)    }}2번이 더 나음테스트 인스턴스 수명 주기를 PER_CLASS로 설정하면 테스트 메소드의 양과 상관없이 인스턴스가 하나만 생성됨모든 테스트의 수명주기를 properties에서 junit.jupiter.testinstance.lifecycle.default 으로 설정 가능함  PER_METHOD : 메소드 단위 (기본값)  PER_CLASS : 클래스 단위이렇게 있는듯테스트에 데이터 클래스 사용data class Book(    val isbn: String,    val title: String,    val author: String,    val published: LocalDate)위와 같은 데이터 클래스가 있을때 속성을 검사하는 테스트 방법으로  수동 테스트@Testinternal fun `test book the hard way` () {    val book = Book(isbn = \"1\", title = \"title\", author = \"au\", published = LocalDate.now())    assertThat(book.isbn, `is`(\"12345\"))    assertThat(book.title, `is`(\"kotlin cookbook\")) // 만약 여기서 실패하면 테스트 끝.    assertThat(book.author, `is`(\"author of book\"))    assertThat(book.published, `is`(LocalDate.now()))}  assertAll로 모든 속성 테스트@Testfun `use JUnit 5 assertAll`() {    val book = Book(isbn = \"1\", title = \"title\", author = \"au\", published = LocalDate.now())    assertAll(\"check all properties of a book\",            {assertThat(book.isbn, `is`(\"1\"))},            {assertThat(book.title, `is`(\"title\"))},            {assertThat(book.author, `is`(\"au\"))},            {assertThat(book.published, `is`(LocalDate.now()))})}한개의 assertThat이 실패해도 모든 인스턴스를 실행한다고함  테스트에 Book 데이터 클래스 사용@Testinternal fun `use data class`() {    val book = Book(isbn = \"1\", title = \"title\", author = \"au\", published = LocalDate.now())    val book2 = Book(isbn = \"1\", title = \"title\", author = \"au\", published = LocalDate.now())    assertThat(book, `is`(book2))}assertThat(book, `is`(book2)) 으로 모든 속성을 테스트함.사용하려면 equals를 재정의해야함  여러 객체를 테스트@Testinternal fun `check all elements in list`() {    val book = Book(isbn = \"1\", title = \"title\", author = \"au\", published = LocalDate.now())    val book2 = Book(isbn = \"2\", title = \"title2\", author = \"au\", published = LocalDate.now())    val book3 = Book(isbn = \"3\", title = \"title3\", author = \"au\", published = LocalDate.now())    val bookList = arrayOf(book, book2, book3)    val expected = arrayOf(            Book(isbn = \"1\", title = \"title\", author = \"au\", published = LocalDate.now()),            Book(isbn = \"2\", title = \"title2\", author = \"au\", published = LocalDate.now()),            Book(isbn = \"3\", title = \"title3\", author = \"au\", published = LocalDate.now())    )\t\tassertThat(bookList, arrayContainingInAnyOrder(*expected))}arrayContainingInAnyOrder 햄크레스트메소드는 각 원소의 vararg리스트를 인자로 받음. 배열을 개별항목으로 확장하기위해 *(펄침연산자)을 사용기본 인자와 함께 도움 함수 사용테스트 객체 생성을 위해fun createBook(    isbn: String = \"1\",    title: String = \"title\",    author: String = \"au\",    published: LocalDate = LocalDate.now()) = Book(isbn, title, author, published)val modern = createBook()val making = createBook(isbn = \"2\", title = \"aa\", author = \"ss\", published = LocalDate.now())data class MultiAuthorBook(        val isbn: String,        val title: String,        val author: List&lt;String&gt;,        val published: LocalDate)fun createMuliAutorBook(    isbn: String = \"1\",    title: String = \"title\",    author: List&lt;String&gt; = listOf(\"a\",\"b\",\"c\",\"d\"),    published: LocalDate = LocalDate.now()) = MultiAuthorBook(isbn, title, author, published)val bookMulti = createMuliAutorBook()여러 데이터에 JUnit테스트 반복@JvmOverloadstailrec fun fibonacci(n: Int, a: Int = 0, b: Int = 1): Int =    when(n) {        0 -&gt; a        1 -&gt; b        else -&gt; fibonacci(n-1, b, a+b)    }꼬리 재귀로 구현된 피보나치 수열 함수  명시적 호출@Testfun `fibonacci numbers(explicit)`() {    assertAll(        { assertThat(fibonacci(4), `is`(3)) },        { assertThat(fibonacci(9), `is`(34)) },        { assertThat(fibonacci(2000), `is`(1122414)) }    )}  CSV데이터를 사용해 파라미터화된 테스트@ParameterizedTest@CsvSource(\"1,1\",\"2,1\",\"3,2\",\"4,3\",\"4,4\",\"6,8\",\"7,13\",\"8,21\",\"9,34\",\"10,55\")fun `frist 10 fibonacci numbers(csv)`(n:Int, fib: Int) =        assertThat(fibonacci(n), `is`(fib))테스트 시 결과가[1] 1,1 frist 10 fibonacci numbers(csv)(int, int)[1] 0s passed[2] 2,1 frist 10 fibonacci numbers(csv)(int, int)[2] 0s passed[3] 3,2 frist 10 fibonacci numbers(csv)(int, int)[3] 0s passed[4] 3,41 frist 10 fibonacci numbers(csv)(int, int)[] 0s passed[5] 4,4, frist 10 fibonacci numbers(csv)(int, int)[5] 0s passed…이렇게 나옴  파라미터 소스로 인스턴스 함수 접근private fun fibnumbers() = listOf(    Arguments.of(1,1),    Arguments.of(2,1),    Arguments.of(3,2),    Arguments.of(4,3),    Arguments.of(4,4),    Arguments.of(6,8),    Arguments.of(7,13),    Arguments.of(8,21),    Arguments.of(9,34),    Arguments.of(10,55))@ParameterizedTest(name = \"fibonacci({0}) == {1}\")@MethodSource(\"fibnumbers\")fun `first 10 Fibonacci numbers (instance method)`(n: Int, fib: Int) =        assertThat(fibonacci(n), `is`(fib))Arguments.of 으로 두개의 입력 인자를 결합시켜줌.만약 수명주기가 Lifecycle.PER_METHOD(기본옵션임)이면 데이터 소스 함수를 동반객체안에 위치시켜야함companion object {        @JvmStatic        fun fibs() = listOf(                Arguments.of(1, 1),                Arguments.of(2, 1),                Arguments.of(3, 2),                Arguments.of(4, 3),                Arguments.of(4, 4),                Arguments.of(6, 8),                Arguments.of(7, 13),                Arguments.of(8, 21),                Arguments.of(9, 34),                Arguments.of(10, 55)        )    }    @ParameterizedTest(name = \"fibonacci({0}) == {1}\")    @MethodSource(\"fibs\")    fun `first 10 Fibonacci numbers (instance method)`(n: Int, fib: Int) =            assertThat(fibonacci(n), `is`(fib))파라미터화된 테스트에 data class 사용data class FibonacciTestData(        val number: Int,        val expected: Int)@ParameterizedTest@MethodSource(\"fibonacciDataClass\")fun `check fibonacci using data class`(data: FibonacciTestData) {    assertThat(data.number, `is`(data.expected))}private fun fibonacciTestData() = Stream.of(        FibonacciTestData(number = 1, expected = 1),        FibonacciTestData(number = 2, expected = 1),        FibonacciTestData(number = 3, expected = 2),        FibonacciTestData(number = 4, expected = 3),        FibonacciTestData(number = 5, expected = 5),        FibonacciTestData(number = 6, expected = 8),        FibonacciTestData(number = 7, expected = 13))이게 되려면 toString이 오버라이딩되어야함"
  },
  
  {
    "title": "[코틀린 쿡북] 13장 - 코루틴",
    "url": "/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-10-28 00:00:00 +0900",
    





    
    "snippet": "솔직히 잘 모르겠어서 일단 가볍게 정리함.. 다음에 다시 봐야지빌더 선택funBlocking최상위 함수suspend함수가 아니라 보통 함수에서 호출 가능implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0\")runtimeOnly(\"org.jetbrains.kotlinx:kotlinx-...",
    "content": "솔직히 잘 모르겠어서 일단 가볍게 정리함.. 다음에 다시 봐야지빌더 선택funBlocking최상위 함수suspend함수가 아니라 보통 함수에서 호출 가능implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0\")runtimeOnly(\"org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.6.0\")implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-slf4j:1.6.0\")의존성 추가 후package com.example.kotlintest.coroutinimport kotlinx.coroutines.delayimport kotlinx.coroutines.runBlockingfun main() {    runBlocking {        println(\"1\")        delay(200L)        println(\"2\")    }}1 2사이에 지연있음launchcoroutineScope의 확장함수. 리턴값 없음완전 제거할것이 아니라면 globalScope에서 사용 금지runBlocking {    println(\"1\")    launch {        println(\"3\")        delay(200L)        println(\"4\")    }}asynccoroutineScope의 확장함수. 리턴시 함수가 지연된다고함완전 제거할것이 아니라면 globalScope에서 사용 금지suspend fun add(x: Int, y: Int): Int {    delay(Random.nextLong(1000L)) //랜덤지연    return x+y}suspend fun main() = coroutineScope {    val firstSum = async { //async로 시작        println(Thread.currentThread().name)        add(2,2)    }    val secondSum = async {        println(Thread.currentThread().name)        add(3,4)    }    println(\"~~~~\")    val total = firstSum.await() + secondSum.await() //await - 코루틴 종료까지 블록    println(total)}coroutineScope종료 전에 모든 코루틴이 종료될때까지 기다림suspend fun main() = coroutineScope { //coroutineScope 빌더    for (i in 0 until 10) { //10개 시작        launch {            delay(1000L - i * 10) //줄어드는 시간 각각 지연            println(\"@$i\")        }    }}asycn/ await → wuthContextsuspend fun retrieve1(url: String) = coroutineScope {    async(Dispatchers.IO) { //async로 시작        println(Thread.currentThread().name)        delay(100L)        \"asyncResults\"    }.await()}suspend fun retrieve2(url: String) = coroutineScope {    withContext(Dispatchers.IO) { //async로 시작        println(Thread.currentThread().name)        delay(100L)        \"withContextResults\"    }}fun main() = runBlocking{    println(retrieve1(\"www.mysite.com\"))    println(retrieve2(\"www.mysite.com\"))}디스패처fun main() = runBlocking{    launchWithIo()    launchWithDefault()}suspend fun launchWithIo() {    withContext(Dispatchers.IO) {        delay(1000L)        println(\"dispatcherIO\")        println(Thread.currentThread().name)    }}suspend fun launchWithDefault() {    withContext(Dispatchers.IO) {        delay(1000L)        println(\"launchWithDefault\")        println(Thread.currentThread().name)    }}  [!important]안드로이드 Main디스패처 사용시 koklinx-coroutine-android 의존성 추가 필요자바 스레드 풀에서 코루틴val dispatcher = Executors.newFixedThreadPool(10).asCoroutineDispatcher() //크기가 10인 스레드 풀 생성withContext(dispatcher) { //생성한 스레드 풀을 코루틴을 위한 디스패처로 사용    delay(100L)    println(Thread.currentThread().name)}dispatcher.close() //스레드 풀 종료안닫아주면 스레드 안닫힘닫는거 까먹을거같으면Executors.newFixedThreadPool(10).asCoroutineDispatcher().use {    withContext(it) {         delay(100L)        println(Thread.currentThread().name)    }}이렇게 사용코루틴 취소fun main() = runBlocking{    val job = launch {        repeat(100) { i-&gt;            println(\"job: I'm waiting $i\")            delay(100L)        }    }    delay(500L)    println(\"main:Thread waiting\")    job.cancel()    job.join()    println(\"main: done\")}main에서 job을 중간에 취소시킴잡을 취소하는 이유가 시간때문에면 withTimeOut함수를 써도됨val job2 = launch {        withTimeout(1000L){            repeat(100) { i-&gt;                println(\"job: I'm waiting $i\")                delay(100L)            }        }    }책에선 마지막에 예외가 발생한다는데 난 안되네  [!important]안드로이드에선 dispatcher.Main을 사용디버깅suspend fun retrieve1(url: String) = coroutineScope {    async(Dispatchers.IO + CoroutineName(\"이름\")) { //async로 시작        println(Thread.currentThread().name)        delay(100L)        \"asyncResults\"    }.await()}이름 부여이걸 Dkotlinx.coroutines.debug 플래그와 함께 실행하면 스레드 이름이 나온다고.. 지정안하면 @coroutine#1 이렇게 나옴"
  },
  
  {
    "title": "[코틀린 쿡북] 5장 - 컬렉션",
    "url": "/posts/%EC%BB%AC%EB%A0%89%EC%85%98/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-10-28 00:00:00 +0900",
    





    
    "snippet": "배열  선언 동시 초기화 - val strings = arrayOf(“a”,”b”,”c”,”d”)  null로만 채워진 배열 - val nullStrings = arrayOfNulls&lt; String&gt;(5)val strings = arrayOf(\"a\",\"b\",\"c\",\"d\")  println(strings.size) //4  val nullSt...",
    "content": "배열  선언 동시 초기화 - val strings = arrayOf(“a”,”b”,”c”,”d”)  null로만 채워진 배열 - val nullStrings = arrayOfNulls&lt; String&gt;(5)val strings = arrayOf(\"a\",\"b\",\"c\",\"d\")  println(strings.size) //4  val nullStrings = arrayOfNulls&lt;String&gt;(5)  println(nullStrings.size) //5 출력;  println(nullStrings.isEmpty()) //false 출력;;  println(nullStrings[0]) //null 출력  nullStrings[0] = \"a\"  nullStrings[1] = \"b\"  nullStrings[2] = \"c\"  nullStrings[3] = \"d\"  println(nullStrings.size) //5 출력;;;  println(nullStrings[0]) //a 출력val nullStrings = arrayOfNulls&lt;String&gt;(5) 이 빈 배열이 아니고 null로 채워진 배열이라는걸 기억해둬야할듯val squares = Array(5) {i-&gt;(i*i).toString()} 이런식으로 람다 사용 가능val squares = Array(5) {i-&gt;(i*i).toString()}squares.forEach { s-&gt;print(\"$s,\") } //0,1,4,9,16,println()//squares 사이즈 2로 줄이니까 0,1만 나옴val indices = squares.indicesindices.forEach{i-&gt; print(\"$i,\")} //0,1,2,3,4, 인덱스인듯..;; 어따써 이거for (withIndex in squares.withIndex()) {    println(\"${withIndex.index}, ${withIndex.value}\")    //인덱스, 값 동시사용}컬렉션 생성  변경 불가능한 컬렉션 : listOf, setOf, mapOf → 원소 추가제거 불가  변경 가능한 컬렉션 : mutableListOf, mutableSetOf, mutableMapOfval numList = listOf(1,2,3,4,4,5,5)val numSet = setOf(1,2,3,4,4,5,5)val numMap = setOf(1 to \"a\", 2 to \"b\")println(numList.size) //7println(numSet.size) //5println(numMap.size)val numMutableList = mutableListOf(1,2,3,4,4,5,5)val numMutableSet = mutableSetOf(1,2,3,4,4,5,5)val numMutableMap = mutableSetOf(1 to \"a\", 2 to \"b\")//    numMutableList.numMutableList.add(10)numMutableSet.add(10)numMutableMap.add(3 to \"c\")val list = LinkedList&lt;Int&gt;();list.add(10)list.addAll(numList)val list2 = ArrayList&lt;Int&gt;();list2.addAll(list)mutableList가 상위개념이고 ArrayList가 하위개념인듯동작과정에서 큰 차이는 없다고함현재 mutableList를 생성하면 그냥 ArrayList가 반환되는거같음— 변경 가능한 컬렉션 → 변경 불가능한 컬렉션val readOnly: List&lt;Int&gt; = numMutableList.toList();println(numMutableList.size) //8println(readOnly.size) //8println(\"------\")numMutableList.add(20)println(numMutableList.size) //9println(readOnly.size) //8val readOnly2: List&lt;Int&gt; = numMutableListnumMutableList.add((40))println(readOnly2.size) //10println(numMutableList.size) //10—변경 불가능한 컬렉션 → 변경 가능한 컬렉션//    val mutable: MutableList&lt;Int&gt; = readOnly //이건 안됨val mutable = readOnly.toMutableList()mutable.add(30)컬렉션 → 맵val keys = 'a'..'f' //와 이게되나val map = keys.associate { it to it.toString().repeat(5).capitalize() }val map2 = keys.associateWith { it.toString().repeat(5).capitalize() } //더 나음println(map)println(map2)근데흠val map = keys.associate { it -&gt;  it to it.toString().repeat(5)  .replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() } }val map2 = keys.associateWith { it -&gt;  it.toString().repeat(5)  .replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() } }인텔리제이가 이렇게 바꿔주긴함capitalize는 그냥 첫문자를 대문자로 바꿔주는거라함 안써도될듯빈 컬렉션의 기본값 리턴val prod1 = Product2(name = \"prod1\", price = 10.0, onSale = false)val prod2 =Product2(name = \"prod2\", price = 10.0, onSale = true)val prod3 =Product2(name = \"prod3\", price = 10.0, onSale = true)val prodList = listOf&lt;Product2&gt;(prod1, prod2, prod3)val joinToString = prodList.filter { it.onSale }    .map { it.name }    .joinToString(separator = \", \")println(joinToString) //prod2, prod3 출력만약 filter조건에 맞는 값이 없다면val joinToString2 = prodList.filter { it.price != 10.0 }    .map { it.name }    .joinToString(separator = \", \")println(joinToString2.length) //0 출력아래처럼 빈 문자열이 반환됨val joinToString3 = prodList.filter { it.price != 10.0 }    .map { it.name }    .ifEmpty { listOf(\"none\") }    .joinToString(separator = \", \")//        .ifEmpty { \"none\" }println(joinToString3) //none 출력아래 코드로 기본값 지정 가능..ifEmpty { listOf(“none”) } → 빈 컬렉션에 기본 리스트 제공 (기존 컬렉션이랑은 관계없는듯).ifEmpty { “none” } → 빈 문자열에 기본 문자열 제공optional도 있는데 ifEmpty가 더 사용하기 쉽다고함범위 내 값 제한val range = 3..8println(5.coerceIn(range)) //5println(1.coerceIn(range)) //3println(9.coerceIn(range)) //8//범위를 넘어서면 범위의 max or minval max = 10val min = 2println(1.coerceIn(min, max)) //2println(5.coerceIn(min, max)) //5println(11.coerceIn(min, max)) //10//    println(1.coerceIn(max, min)) //IllegalArgumentException: Cannot coerce value to an empty range: maximum 2 is less than minimum 10.값이 범위 내이면 값을 반환. 범위 밖이면 min 또는 max값 반환컬렉션 윈도우  chunkedval range2 = 0..10val chunked = range2.chunked(3)println(chunked) //[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]val chunked2 = range2.chunked(3) { it.sum() }println(chunked2) //[3, 12, 21, 19]println(range2.chunked(3) {it.average()}) //[1.0, 4.0, 7.0, 9.5]  windowedprintln(range2.windowed(3,1)) //[[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10]]println(range2.windowed(3,1, true)) //[[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10], [9, 10], [10]]println(range2.windowed(3,1) {it.sum()}) //[[3, 6, 9, 12, 15, 18, 21, 24, 27]println(range2.windowed(3,1) {it.average()}) //[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]window의 마지막 파라미터인 partialWindosw가 마지막으로 남는 부분이 필요한만큼 원소가 없을경우 표시 하냐 마냐를 나타내는 파라미터인데 기본값은 false라서 표시되지않음.chunked는 windowed를 호출하면서 true로 지정하기때문에 남는 원소도 뜸리스트 분해val list3 = listOf(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\")val (a,b,c,d,e) = list3println(\"$a $b $c $d $e\") //a b c d e코틀린 List 클래스에 conponestN이라는 확장함수가 정의되어있어서 원소의 이름으로 값을 꺼내올수있다고함근데 5까지밖에안뜸6번째 자리부터는 안되는구만..val (b,c,e,d,a) = list3 이렇게 순서바꿔봤는데 a b c d e로 나옴이름으로 들어가는거아니고 순서대로 나오나봄~~착각해서 좀 헛짓했넹정렬  listval golfer = listOf(    Golfer(70,\"Jack\",\"Nicklaus\"),    Golfer(68,\"Tom\",\"Watson\"),    Golfer(68,\"Bubba\",\"Watson\"),    Golfer(70,\"Tiger\",\"Woods\"),    Golfer(68,\"Ty\",\"Webb\"))  sortedWith + compareByval sorted = golfer.sortedWith(    compareBy({it.score},{it.last},{it.first}))sorted.forEach{println(it)}  compareBy + thenBy + sortedWithval comparator = compareBy&lt;Golfer&gt;(Golfer::score)    .thenBy(Golfer::last)    .thenBy(Golfer::first)val sorted2 = golfer.sortedWith(comparator)sorted2.forEach{println(it)}둘다 결과는 동일함desc정렬은 어케하는데 그럼val comparatorDesc = compareByDescending&lt;Golfer&gt;(Golfer::score)    .thenBy(Golfer::last)    .thenBy(Golfer::first)val sorted3 = golfer.sortedWith(comparatorDesc)sorted3.forEach{println(it)}검색해보니까 이렇게하라고함사용자 정의 이터레이터  기본class Team(  val name: String,  val players: MutableList&lt;Player&gt; = mutableListOf()){  fun addPlayer(vararg people: Player) =      players.addAll(people)}val team = Team(\"warriors\")team.addPlayer(    Player(\"a\"),    Player(\"b\"),    Player(\"c\"),    Player(\"d\"))for (player in team.players) {    println(player)}→ iterator 함수 정의operator fun Team.iterator() : Iterator&lt;Player&gt; = players.iterator()for (player in team) {        println(player)    }team 객체 내 player에 접근하지않고도 사용가능함  iterable 구현data class Player(  val name: String)class Team2 (  val name: String,  val players: MutableList&lt;Player&gt; = mutableListOf()) : Iterable&lt;Player&gt; {  override fun iterator(): Iterator&lt;Player&gt; =      players.iterator()  fun addPlayer(vararg people: Player) =      players.addAll(people)}val team2 = Team2(\"warriors\")team2.addPlayer(    Player(\"a\"),    Player(\"b\"),    Player(\"c\"),    Player(\"d\"))for (player in team2) {    println(player)    //iterator 오버라이딩 없어도 됨}iterator 함수 정의 없이도 team안의 player에 접근 가능함val joinToString1 = team2.map { it.name }.joinToString()println(joinToString1)//    val joinToString2 = team.map { it.name }.joinToString() //이건안됨val joinToString4 = team.players.map { it.name }.joinToString()println(joinToString4)위 예시처럼 iterator함수를 정의해도 모든 확장함수를 사용할수는 없음. 모든확장함수를 사용하려면 iterable 인터페이스를 구현해야함타입으로 컬렉션 필터링val list4 = listOf(\"a\", LocalDate.now(), 3,1,4,\"b\")val strings2 = list4.filter { it is String }println(strings2) //[a, b]for (item in strings2) {//        item.length //컴파일에러    //-&gt; Strings 변수의 추론타입이 List&lt;Any&gt;라서 String이아님}여러 타입의 컬렉션에서 타입으로 필터링할수있음근데 영리한 타입변환이 일어나지않아서 타입의 함수를 사용할수없음is확인을 추가하거나 아래처럼 filterIsInstance로 타입을 지정해서 필터링할수있음val stringInstances = list4.filterIsInstance&lt;String&gt;()for (s in stringInstances) {    println(s.length) //1\\n1}val filterIsInstance = list4.filterIsInstance(LocalDate::class.java)for (localDate in filterIsInstance) {    localDate.monthValue}filterIsInstance를 호출하면 filterIsInstanceTo이 호출되는데 filterIsInstanceTo을 바로 사용해도됨val list5 = list4.filterIsInstanceTo(mutableListOf&lt;String&gt;())for (s in list5) {    println(s.length)}범위를 수열로val staDe = LocalDate.now();val midDe = staDe.plusDays(3)val endDe = staDe.plusDays(5)var dateRange = staDe..endDeprintln(staDe in dateRange) //trueprintln(midDe in dateRange) //trueprintln(endDe in dateRange) //trueprintln(staDe.minusDays(1) in dateRange) //falseprintln(endDe.plusDays(1) in dateRange) //false//    for(date in dateRange) {////    } //컴파일 에러!!위의 dateRange은 수열(순서있는 값의 연속)이 아니라서 범위 순회가 안됨수열 생성을 위해서는 아래와 같은 과정이 필요class LocalDateProgression(    override val start: LocalDate,    override val endInclusive: LocalDate,    val step: Long = 1) : Iterable&lt;LocalDate&gt;, ClosedRange&lt;LocalDate&gt; {    override fun iterator(): Iterator&lt;LocalDate&gt; =        LocalDateProgressionIterator(start, endInclusive, step)    infix fun step(days: Long) = LocalDateProgression(start, endInclusive, step)}internal class LocalDateProgressionIterator(    start: LocalDate,    val endInclusive: LocalDate,    val step: Long) : Iterator&lt;LocalDate&gt; {    private var current = start    override fun hasNext() = current &lt;= endInclusive    override fun next(): LocalDate {        val next = current        current = current.plusDays(step)        return next    }}operator fun LocalDate.rangeTo(other: LocalDate) =    LocalDateProgression(this, other)dateRange.forEachIndexed { index, localDate -&gt;    println(localDate)    println(index.toLong())    println(\"------\")}val dateList = dateRange.map { it.toString()}println(dateList.size) //6dateRange = staDe..endDe step 2dateRange.forEachIndexed { index, localDate -&gt;    println(staDe.plusDays(index.toLong() * 2))}val dateList2 = dateRange.map { it.toString() }println(dateList2.size)"
  },
  
  {
    "title": "[코틀린 쿡북] 7장 - 영역함수",
    "url": "/posts/%EC%98%81%EC%97%AD%ED%95%A8%EC%88%98/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-10-28 00:00:00 +0900",
    





    
    "snippet": "apply로 객체 생성 후 초기화apply : 람다 내부에서 수신 객체의 함수를 사용하지 않고 수신 객체 자신을 다시 반환db가 기본키를 생성할때 제공 객체가 새로운 키로 갱신되어야함 → apply를 이용하면 편함이미 인스턴스화됨 객체의 추가설정을 위해 주로 사용부수효과를 위한 also 사용val boox = Book(\"?\")  .also { prin...",
    "content": "apply로 객체 생성 후 초기화apply : 람다 내부에서 수신 객체의 함수를 사용하지 않고 수신 객체 자신을 다시 반환db가 기본키를 생성할때 제공 객체가 새로운 키로 갱신되어야함 → apply를 이용하면 편함이미 인스턴스화됨 객체의 추가설정을 위해 주로 사용부수효과를 위한 also 사용val boox = Book(\"?\")  .also { println(it) }  .also { Logger.getAnonymousLogger().info(it.toString()) } //가장 마지막에 출력  .run { println(\"???\") }설명만 읽어보면 apply는 객체에 직접접근이 가능, also는 불가능하다는의미인거같음apply는 this 사용가능, it 사용불가능also는 this 사용불가능, it 사용가능ㅇ궁금해져서 실행해봤는데data class Book (    val name: String,    val price: Int,    var test: Boolean? = null) {    fun testFun(): Unit {        test = this.price&gt;10    }}//----1번-----var book = Book(\"?\", 10)  .also {      it.testFun()      println(it)  }//-------2번--------var book = Book(\"?\", 10)  .apply {      this.testFun()      println(this.test)      println(this)  }코드를 이렇게 바꿔봤는데 1번, 2번 둘다 test에 false가 찍힘also와 apply는 객체를 넘겨받는 방식만 다른거같음let함수 + 엘비스연산자let은 블록의 return 값만 반환한다는 차이점이있음fun processString(str: String?) =    str?.let {        when {            it.isEmpty() -&gt; \"empty\"            it.isBlank() -&gt; \"Blank\"            else -&gt; it.capitalize()        }    } ?: \"null\"?: \"null\" 이 엘비스연산자많이 사용하는 조합이라고함var book = Book(\"?\", 10)        .let {            it.testFun()            println(it.test)            println(it)        }이거도 다시해봤는데 false 잘 출력됨임시변수로 let사용val resultList = numbers.map { it.length }.filter { it&gt;3 }println(resultList)위 코드를val resultList = numbers.map { it.length }.filter { it&gt;3 }   .let(::println)이렇게 변경 가능함  [!important]출력 이후 값을 사용하지않는다면 무엇을 사용해도 같은 결과가 나타나긴함"
  },
  
  {
    "title": "[코틀린 쿡북] 6장 - 시퀀스",
    "url": "/posts/%EC%8B%9C%ED%80%80%EC%8A%A4/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-10-28 00:00:00 +0900",
    





    
    "snippet": "지연 시퀀스// ----1번----//    val first = (100 until 200).map { it * 2 }//        .filter { it % 3 == 0 }//        .first() //아래가 나음// ----2번----//    val first = (100 until 200).map { it * 2 }//       ...",
    "content": "지연 시퀀스// ----1번----//    val first = (100 until 200).map { it * 2 }//        .filter { it % 3 == 0 }//        .first() //아래가 나음// ----2번----//    val first = (100 until 200).map { it * 2 }//        .first { it % 3 == 0 } //조건에 해당하는 첫번째 값만 찾으면 순환종료 + 첫번째 값 반환//이것도 아래가 나음// ----3번----val first = (100 until 200).asSequence()    .map { println(\"doubling $it\"); it * 2 }    .filter { println(\"filtering $it\"); it % 3 == 0 }    .first()3번의 방법이 가장 효율적이나 시퀀스가 비었다면(필터에 해당하는 값이 없는경우를 말하는듯) 예외가 발생함val first = (100 until 200).asSequence()        .map { println(\"doubling $it\"); it * 2 }        .filter { println(\"filtering $it\"); it % 9999 == 0 }        .first()이런경우 first대신 firstOrNull을 사용하면됨val first = (100 until 200).asSequence()    .map { println(\"doubling $it\"); it * 2 }    .filter { println(\"filtering $it\"); it % 9999 == 0 }    .firstOrNull()println(first)시퀀스 생성val numSeq1 = sequenceOf(3,1,4,1,5,9)val numSeq2 = listOf(3,1,4,1,5,9).asSequence()둘다 Sequence&lt; Int&gt;가 생성됨  소수찾기fun Int.isPrime() =    this == 2 || (2..ceil(sqrt(this.toDouble())).toInt())    .none {divisor -&gt; this % divisor == 0}var num = 10println(num.isPrime()) //falsenum = 11println(num.isPrime()) //true  주어진 정수 다음의 소수 찾기fun nextPrime(num: Int) =    generateSequence(num + 1) {it + 1} //파라미터에서 1큰 값에서 시작, 1씩 증가        .first(Int::isPrime) //조건에 맞는 첫 값을 returnprintln(nextPrime(19)) //23시퀀스 안에서 무한대의 정수를 생성하고 조건에 맞을때까지 생성한 무한대의 정수를 하나씩 평가함무한 시퀀스  N번째까지의 모든 소수 찾기fun firstNPrimes(count: Int) =    generateSequence(2, ::nextPrime) //2부터 시작하는 소수의 무한 시퀀스        .take(count) //요청한 수만큼 가져옴        .toList()  N보다 작은 모든 소수                  버전 1          fun primesLessThan(max: Int) : List&lt;Int&gt; =      generateSequence(2) {n-&gt; if(n&lt;max) nextPrime(n) else null}          .toList()          .dropLast(1)                            버전 2          fun primesLessThan2(max: Int) : List&lt;Int&gt; =      generateSequence(2, ::nextPrime)      .takeWhile { it&lt;max }      .toList()                    yield중단 함수  피보나치fun fibonacciSequence() = sequence {    var terms = Pair(0, 1)    while (true) {        yield(terms.first)        terms = Pair(terms.second, terms.first + terms.second)    }}val fibs = fibonacciSequence()    .take(10)    .toList()println(fibs) //[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]  yieldAllval seq = sequence {    val start = 0    yield(start)    yieldAll(1..5 step 2)    yield(generateSequence(8) {it * 3})} //0,1,3,5,8,24,72 ....솔직히 제대로 이해못함;코루틴이 쓰레드랑 유사?한 개념같은데 사실 쓰레드도 아직 잘 모른단말임;;일단 특정 조건이 긑나면 다시 돌아와서 실행 이라고만 이해함.."
  },
  
  {
    "title": "[코틀린 쿡북] 12장 - 스프링 프레임워크",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-10-28 00:00:00 +0900",
    





    
    "snippet": "책 안보고 공부겸으로 만든 코틀린-jpa 프로젝트를 책내용이랑 비교하면서 정리하겠음import org.jetbrains.kotlin.gradle.tasks.KotlinCompileplugins {    id(\"org.springframework.boot\") version \"3.1.3\"    id(\"io.spring.dependency-managemen...",
    "content": "책 안보고 공부겸으로 만든 코틀린-jpa 프로젝트를 책내용이랑 비교하면서 정리하겠음import org.jetbrains.kotlin.gradle.tasks.KotlinCompileplugins {    id(\"org.springframework.boot\") version \"3.1.3\"    id(\"io.spring.dependency-management\") version \"1.1.3\"    kotlin(\"jvm\") version \"1.8.22\"    kotlin(\"plugin.spring\") version \"1.8.22\"    kotlin(\"plugin.jpa\") version \"1.8.22\"}group = \"com.example\"version = \"0.0.1-SNAPSHOT\"java {    sourceCompatibility = JavaVersion.VERSION_17}configurations {    compileOnly {        extendsFrom(configurations.annotationProcessor.get())    }}repositories {    mavenCentral()}dependencies {    implementation(\"org.springframework.boot:spring-boot-starter-data-jpa\")    implementation(\"org.springframework.boot:spring-boot-starter-web\")    implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\")    implementation(\"org.jetbrains.kotlin:kotlin-reflect\")    testImplementation(\"org.testng:testng:7.1.0\")    compileOnly(\"org.projectlombok:lombok\")    developmentOnly(\"org.springframework.boot:spring-boot-devtools\")    runtimeOnly(\"com.mysql:mysql-connector-j\")    annotationProcessor(\"org.projectlombok:lombok\")    testImplementation(\"org.springframework.boot:spring-boot-starter-test\")}tasks.withType&lt;KotlinCompile&gt; {    kotlinOptions {        freeCompilerArgs += \"-Xjsr305=strict\"        jvmTarget = \"17\"    }}tasks.withType&lt;Test&gt; {    useJUnitPlatform()}  엔티티@Entity@Table(name = \"order_dtl_info\")class OrderDetail (    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)    val orderDetailSeq: Long? = null,    val orderSeq: Long,    val productSeq: Long,    val productQuantity: Int,    @ManyToOne var order: Order){}  의존성 주입@RestController@RequestMapping(\"/api/order\")@RequiredArgsConstructorclass OrderController(    private val orderService : OrderService) {책에서 설명된 방법으로는-- 단일 생성자@Serviceclass MemberService (    val memberRepo: MemberJpaRepository)-- 명시적@Serviceclass MemberService (    @Autowired val memberRepo: MemberJpaRepository)-- 생성자@Serviceclass MemberService @Autowired constructor(val memberRepo: MemberJpaRepository) {-- 필드주입(비추지만 유용할수도)@Serviceclass MemberService {    @Autowired     lateinit var memberRepo: MemberJpaRepository  파라미터@PostMappingfun createProductsOrder(@RequestBody data: OrderDto.Create) : ResponseEntity&lt;Any&gt; {    orderService.createProductsOrder(data)    return ResponseEntity(null, HttpStatus.CREATED)}@GetMapping(\"/member/{memberSeq}\")fun getMemberOrderList(@PathVariable memberSeq: Long) : ResponseEntity&lt;List&lt;OrderDto.Header&gt;&gt;    = ResponseEntity(orderService.getMemberOrderList(memberSeq), HttpStatus.OK)이렇게 가능하고 책에서@GetMapping(\"/member/{memberSeq}\")fun getMemberOrderList(@PathVariable memberSeq: Long?) : ResponseEntity&lt;List&lt;OrderDto.Header&gt;&gt;    = ResponseEntity(orderService.getMemberOrderList(memberSeq ?: 1L), HttpStatus.OK)이렇게 null 허용도 가능하다고  테스트@DataJpaTestclass SpringTest @Autowired constructor(        val memberRepo: MemberJpaRepository){    @Test    fun test() {        val member = Member(userId = \"user001\", password = \"1234\", email = \"user001@email.com\", age = 10, nickname = \"test\");        memberRepo.save(member)    }}@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)class Test2 (        @Autowired val val memberRepo: MemberJpaRepository){    @Test    fun test() {        val member = Member(userId = \"user001\", password = \"1234\", email = \"user001@email.com\", age = 10, nickname = \"test\");        memberRepo.save(member)    }}"
  },
  
  {
    "title": "[코틀린 쿡북] 8장 - 코틀린 대리자",
    "url": "/posts/%EC%BD%94%ED%8B%80%EB%A6%B0-%EB%8C%80%EB%A6%AC%EC%9E%90/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-09-28 00:00:00 +0900",
    





    
    "snippet": "대리자를 이용한 합성interface Dialable {    fun dial(number: String) :String}class Phone : Dialable {    override fun dial(number: String): String = \"dialing\"}interface Snappable {    fun takePicture(): Str...",
    "content": "대리자를 이용한 합성interface Dialable {    fun dial(number: String) :String}class Phone : Dialable {    override fun dial(number: String): String = \"dialing\"}interface Snappable {    fun takePicture(): String}class Camera: Snappable {    override fun takePicture(): String = \"taking\"}class SmartPhone(    private val phone: Dialable = Phone(),    private val camera: Snappable = Camera()) : Dialable by phone, Snappable by camera생성자에서 phone과 camera를 인스턴스화, public 함수를 Phone과 Camere에 위임되도록 by를 사용lazy 대리자val ultimateAnswer: Int by lazy {    println(\"answer\")    10}println(\"-------\")println(ultimateAnswer==10)println(ultimateAnswer==20)처음 선언될때는 answer가 출력되지않음이후 값에 접근할때 출력됨. 다시 값에 접근하면 answer가 출력되지않음초기화되기 전 객체 접근 금지var shouldBeNotNull: String by Delegates.notNull&lt;String&gt;()//    shouldBeNotNull.length //IllegalStateExceptionshouldBeNotNull = \"www\"println(shouldBeNotNull.length)값이 초기화되기전에 접근하면 IllegalStateException예외 발생observable(변경감지), vetoable(변경금지여부)  observablevar watch: Int by Delegates.observable(1) {  property, oldValue, newValue -&gt;  println(\"${property.name} changed from $oldValue to $newValue\")}watch = 10println(watch) //10  vetoablevar checked: Int by Delegates.vetoable(0) {    property, oldValue, newValue -&gt;    println(\"trying to change ${property.name} from $oldValue to $newValue\")    newValue &gt;= 0}checked = 20println(checked) //20checked = -1println(checked) //20 변경안됨newValue &gt;= 0 조건에 맞지 않으면 변경되지않음대리자로서 map 제공data class Project (val map: MutableMap&lt;String, Any?&gt;){    val name: String by map    val priority: Int by map    val completed: Boolean by map}val project = Project(    mutableMapOf(\"name\" to \"kotlin\", \"priority\" to 10, \"completed\" to true))println(project) //Project(map={name=kotlin, priority=10, completed=true})println(project.name) //kotlinmap의 key와 동일한 변수명에 value가 대입됨해봤는데 key랑 동일한 변수명이 없으면 멤버변수에는 세팅안됨. sout으로 찍어보니까 map에는 일치하지않는 변수명이 들어가는데 값이 세팅안된 변수에 접근하면 에러남사용자 대리 정의자class Delegate {    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String {        return \"$thisRef, thank you fir delegatting '${property.name}' to me!\"    }    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) {        println(\"$value ~~~~ '${property.name}' in $thisRef\")    }}class Example {    var p: String by Delegate()}val e = Example();println(e.p) //Example@30946e09, thank you fir delegatting 'p' to me!e.p = \"new\" //new ~~~~ 'p' in Example@30946e09println(e.p) //Example@30946e09, thank you fir delegatting 'p' to me!특정 클래스의 속성이 다른 클래스의 getter, setter를 사용할수있음"
  },
  
  {
    "title": "[코틀린 쿡북] 4장 - 함수형 프로그래밍",
    "url": "/posts/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-09-10 00:00:00 +0900",
    





    
    "snippet": "fold시퀀스나 컬렉션을 하나의 값으로 축약시키고싶을때 사용fun sum(vararg nums: Int) = nums.fold(0) { acc, n-&gt; acc+n}가변인자 nums를 받아서 반환값의 초기값을 0으로 설정, 반환값 acc와 파라미터로 밭은 nums의 값을 n에 넣어서 acc+n 실행, acc에 값 누적됨fun sumWithTrace...",
    "content": "fold시퀀스나 컬렉션을 하나의 값으로 축약시키고싶을때 사용fun sum(vararg nums: Int) = nums.fold(0) { acc, n-&gt; acc+n}가변인자 nums를 받아서 반환값의 초기값을 0으로 설정, 반환값 acc와 파라미터로 밭은 nums의 값을 n에 넣어서 acc+n 실행, acc에 값 누적됨fun sumWithTrace(vararg nums: Int) =    nums.fold(0){ acc, i -&gt;        println(\"acc = $acc, i = $i\")        acc + i    }  팩토리얼when = switch— 재귀 함수 사용fun recursiveFactorial(n: Long): BigInteger =    when(n) {        0L, 1L -&gt; BigInteger.ONE        else -&gt; BigInteger.valueOf(n) * recursiveFactorial(n-1)    }— fold를 사용한 반복연산fun factorialFold(n: Long): BigInteger =    when(n) {         0L, 1L -&gt; BigInteger.ONE        else -&gt; (2..n).fold(BigInteger.ONE) { acc, i -&gt;            acc * BigInteger.valueOf(i)        }    }  피보나치fun fibonacciFold(n: Int) =    (2 until n).fold(1 to 1) { (prev, curr), _ -&gt;\t\t\t\tprintln(\"$prev, $curr\")        curr to (prev + curr)}.secondfold의 초가화 값이 Pair임. 첫번째 인자인 Pair은 1,1로 받고, 두번째 인자는 사용하지 않아 _로 처리함각 반복문을 돌때 Pair값이 현재값 - (이전값 + 현재값)으로 초기화됨오른쪽의 과정을 거쳐 반환값이 55가 나옴reduce누적자의 초기값을 설정하고 싶지 않을때 사용. 초기값을 컬렉션의 가장 첫번째 값으로 지정함그래서 컬렉션 값의 모든 값에 특정 조건을 적용한 값(각 값에 +2를 한 총합 등)을 반환하고싶을땐 부합하지않음. (컬렉션의 첫번째값에는 조건이 적용되지않음)컬렌션의 값에 추가 연산을 하지 않을때만 사용fun sumReduce(vararg nums: Int) =    nums.reduce{acc, i -&gt; acc + i}println(\"reduce sum = \"+sumReduce(*nums)) //23 출력val nums2: IntArray = intArrayOf()println(nums2.sum()) //0 출력println(sum(*nums2)) //0 출력sumReduce(*nums2) //UnsupportedOperationException 발생fold와는 다르게 reduce는 구현부에 isEmpty처리가 되어있어서 빈 컬렉션이 들어오면 UnsupportedOperationException이 발생함. 컬렉션이 비어있을 가능성이 있다면 fold를 사용해야할듯꼬리 재귀재귀 함수 사용시 발생하는 _StackOverflowError_를 피하기 위한 방법recursiveFactorial(1000000000000000000) 이건 자바에서도 에러남tailrec fun factorial(    n: Long,    acc: BigInteger = BigInteger.ONE    ): BigInteger =    when(n) {        0L -&gt; BigInteger.ONE        1L-&gt; acc        else -&gt; factorial(n-1, acc * BigInteger.valueOf(n))    }tailrec을 선언해서 컴파일러에게 재귀호출을 최적화하라는 의미임재귀함수가 자기자신만 호출해서 값을 반환함fun recursiveFactorial(n: Long): BigInteger =    when(n) {        0L, 1L -&gt; BigInteger.ONE        else -&gt; BigInteger.valueOf(n) * recursiveFactorial(n-1)    }_StackOverflowError_가 발생한 코드를 보면 recursiveFactorial함수와 BigInteger.valueOf(n)가 계속 곱해지는 추가연산이 일어나는걸 말하는듯tailrec을 선언해도 BigInteger.valueOf(n) * recursiveFactorial(n-1)을 사용하니 _StackOverflowError_가 발생함— 조건  마지막 연산으로 자기 자신을 호출하야함  try/catch/finally에서 못씀  jvm 백엔드에서만 사용 가능"
  },
  
  {
    "title": "[코틀린 쿡북] 2장 - 기초",
    "url": "/posts/%EA%B8%B0%EC%B4%88/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-09-10 00:00:00 +0900",
    





    
    "snippet": "널 허용 타입val name: Stringname = \"test\"//    name = null //컴파일 에러남val nullName: String? //?로 null가능 설정함nullName = null;  classclass Person(    val first: String,    val middle: String?,    val last: S...",
    "content": "널 허용 타입val name: Stringname = \"test\"//    name = null //컴파일 에러남val nullName: String? //?로 null가능 설정함nullName = null;  classclass Person(    val first: String,    val middle: String?,    val last: String)fun main(args: Array&lt;String&gt;) {    val person = Person(\"fist\", null, \"last\");    println(person.first + person.middle + person.last);}변수: 타입으로 타입지정. ?있으면 null 허용 아니면 비허용. wapper클래스는 없는듯?var-val차이는 수정되냐 안되냐인가봄var - 수정됨val - 수정안됨val p1 = Person(first = \"??\", middle = null, last=\"????\")//    p1.middle = \"??\" p1은 var이라도 middle이 val라서 수정안되는듯?    var p2 = Person(middle = \"saaas\", last=\"????\", first = \"sss\") //순서바꿔도 되는듯?//    val p = Person(first = null, middle = \"sss\", last = null) //first, last 컴파일에러//    println(p1.middle.length) //컴파일에러남//    if(p2.middle!=null) {////        var middleLength = p2.middle.length //null체크해도 컴파일 에러남;;//    }//엥?    if(p1.middle!=null) {        var middleLength = p1.middle.length        println(\"middleLength=$middleLength\")        //var, val에도 영향을 받나봄; val은 컴파일 에러 안남    }  println(p1.middle!!.length) //NullPointerException  //null이 아님을 단언 null 체크없이는 사용x -&gt; 안전호출 연산자 사용val에서 컴파일 에러가 안나는건 왜지? 변경안전호출var length = p1.middle?.length    println(length) //null 출력    length = null //문제는 이렇게하면 length도 null허용타입이됨 주의    val length2 = p1.middle?.length ?: 0    println(length2) //0 출력//    length2 = null //컴파일 에러    var length3 = p1.middle?.length ?: throw NullPointerException() //가능함!p1.middle?에서 ?로 null이 올수있다는걸 미리 지정해주는듯?대신 이렇게만하면 middle이 null일 경우는 null로 반환해줘서 length도 null이 허용된다는 단점이있음그래서 p1.middle?.length ?: 0 로 null일 경우에 넣을 값을 지정하주는듯. 삼항연산자랑 다른가? 흠응용해서 null일경우 에러 던지기도 가능함!안전 타입 변환타입변환 실패시 ClassCastException 발생 방지하는 법기본적으로 타입 캐스팅은 as로 함 그러나 반환 대상인 데이터가 변환하려는 타입이 아닐시 ClassCastException가 발생함 그것을 대비하기 위해as?로 위 상황에서는 null이 반환되도록 해줌val p3 = p1 as? Person //p1이 Person타입이 아니면 null로 반환시킴println(\"pr=$p3\")val test: String = \"test\"val length4 = test as? Intprintln(\"length4=$length4\") //null 출력됨메소드 사용fun addProduct(name: String, price: Double = 0.0, desc: String? = null) =    \"Adding ~~~ $name, ${desc ?: \"none\"}, and \"+NumberFormat.getCurrencyInstance().format(price)fun addProduct(name: String, price: Double = 0.0, desc: Int? = null): String {    return \"Adding ~~~ $name, ${desc ?: \"none\"}, and \"+NumberFormat.getCurrencyInstance().format(price)}//fun addProduct(name: String, price: Double = 0.0, desc: Int? = null): Int {//    return \"Adding ~~~ $name, ${desc ?: \"none\"}, and \"+NumberFormat.getCurrencyInstance().format(price)//} 안됨fun addProduct2(name: String, price: Double = 0.0, desc: String? = null): String {    return \"Adding ~~~ $name, ${desc ?: \"none\"}, and \"+NumberFormat.getCurrencyInstance().format(price)}오버로딩 기준은 자바와 동일변수 타입지정방법, null 허용여부는 위와 동일하게 지정가능함null이 들어왔을때 기본값 설정가능한게 좀 다른듯맨 위 메소드처럼 = 으로 바로 지정할수도있는듯 구현부가 한줄일때만 가능하겠지만println(addProduct(\"a\", 1.3, \"ddd\")) //Adding ~~~ a, ddd, and ₩1println(addProduct(\"a\", 1.3)) //Adding ~~~ a, none, and ₩1println(addProduct(\"a\")) //Adding ~~~ a, none, and ₩0//    println(addProduct(\"a\", \"ddd\"))println(addProduct(name = \"sss\", desc = \"dddd\")) //Adding ~~~ sss, dddd, and ₩0사용법은 위쪽 생성자에서 본 거랑 같음— 객체 생성data class /*hashCode(),copy(),equals(),toString(),componentsN() 자동 생성*/ Product /*@JvmOverloads constructor*//*생성자 오버로딩 생성 어노테이션*/(    val name: String,    val price: Double = 0.0,    val desc:String? = null) //@JvmOverloads 이거 의미를 잘 모르겠음 없어도 잘되는거같은데//JvmOverloads : 생성자 호출시 같은 개수의 인자를 갖는 super를 호출하지않음. 제공된 기본인자와 함께 모든 인자를 요구하는 생성자를 호출//뭔소리임//아 부모클래스의 생성자를 호출할때 파라미터가 정확히 일치하는 생성자를 호출하는게아니고 모든 값을 받는 부모클래스의 생성자를 호출한다? 이말인가?      data class    data class로 객체를 생성하면          hashCode()      copy()      equals()      toString()      componentsN() - 각 멤버변수에 번호가 붙어 구조 분해가 가능한 형태가됨        가 생성시 함께 만들어짐        @JvmOverloads constructor    아직 제대로 이해못하긴함;;    이해한 바로는 부모클래스의 생성자를 호출할때 내가 파라미터로 넣은 타입과 정확히 일치하는 생성자를 호출하는것이 아니라 모든 값이 있는 생성자를 호출해서 있는 값만 지정해주는 느낌인듯?          https://medium.com/@mmlodawski/https-medium-com-mmlodawski-do-not-always-trust-jvmoverloads-5251f1ad2cfe        사이트 참고하라고 적혀있어서 읽었는데 아직 이해못했음;;    아무튼 위의 케이스에서는 있으나 없으나 큰 차이는 없어보였음  val prod = Product(name=\"sss\", price = 1.1, desc = \"sss\")val prod2 = Product(\"sss\")val prod3 = Product(\"sss\",1.2)//    val prod4 = Product(\"sss\", null, \"se\") //이건안됨println(prod) //Product(name=sss, price=1.1, desc=sss)println(prod2)  //Product(name=sss, price=0.0, desc=null)println(prod3) //Product(name=sss, price=1.2, desc=null)타입 변환val intVal: Int = 3//    val longVal: Long = intVal; //컴파일 에러val longVal: Long = intVal.toLong();//이진법 변환println(42.toString(2)) //오잉 쩐다 근데 쓸일없을듯기수변환println(Character.MIN_RADIX)println(Character.MAX_RADIX)(Character.MIN_RADIX..Character.MAX_RADIX).forEach{radix-&gt; println(\"$radix: ${42.toString(radix)}\")}//42를 각 각 기수로 출력 ..은 &lt;= &lt;= 조건인듯?인텔리제이에선 ..에 저렇게 표시해줌기수가 저렇게 많은지도 오늘 알았음;Character.MIN_RADIX = 2Character.MAX_RADIX = 36임거듭제곱책에는 Math.pow()를 못쓴다고 돼있는데 (Math자체를 못쓰는건 아니고 저것만 그런듯)println(Math.pow(2.0,2.0)) Math.pow 있는데? 뭐지? 라는 의문의 눈싸움하다가← 이거 뭐고 뭐고 하고 눌러봤는데println(2.0.pow(2.0))일케 변환해줌아마.. 그때는 없었지만 지금은 있단다 상황인듯?pow구현부는 일단 스킵했음그런데 2.toDouble().pow(2) 로 사용한다고 해도 반환타입은 Double이라서 .ToInt()로 타입 변환 해줘야함println(Math.pow(2.0,2.0)) //Math.pow 있는데? 뭐지//Should be replaced with Kotlin function 라는 경고문구가 뜨긴 하는데println(2.0.pow(2.0)) ////오!!!!!!!!!//    val pow: Int = Math.pow(2.0,2.0); //자동 타입변환이 안됨val pow: Int = 2.0.pow(2.0).toInt();println(pow)println(2.toDouble().pow(2).toInt())중위연산자위 내용이랑 책에서 이어지는 내용이었는데 pow부분을 빼서 일단 결론만 정리하겠음infix fun Int.add(b: Int): Int{    return this+b;}infix fun Int.`+`(b: Int): Int {    return this + b}infix로 설정하는 메소드인데 저렇게 해주면 일반 메소드와 달리println(5 add(3))println(5 add 3)println(2 `**` 3)이렇게 사용 가능함이렇게 코틀린 자체에 등록된 중위 연산자가 꽤 되는모양임//비트 시프트println(1 shl 5) //&lt;&lt;println(235 shr 1) //&gt;&gt;println(100 ushr 2) //&gt;&gt;&gt;//코틀린 기본 중위연산자인듯//비트 불리언 //??println(4.inv())println(12 and 22)println(12 or 22)println(12 xor 22)//뭐가뭔지..;;이런..녀석들비트불리언부터는 뭐가뭔지 이해를 못해서 그냥 넘어가겠음쓸일없겠죵?Pairkey-value형태이나 Map처럼 리스트형태가 아니라 단건 한쌍인듯함val pair = Pair(\"a\", 1)val pair2 = Pair(1, 1)val pair3 = \"a\" to 1println(pair)println(pair2)println(pair3)//    val javaClass = pair.javaClass//    println(javaClass.name) //이건뭐지?println(pair.first)println(pair.second)val (x,y) = pair //분리가능!!println(x)println(y)val(temp, temp2) = \"a\" to 1println(temp)println(temp2)//    val temp3, temp4 = 1,2 //안되는군//    val temp3, temp4 = 1 //안됨//key-value만 되는듯?val (x,y)를 보고 선언할때 여러개가 되나싶어서 별짓을 다해봤는데 안되는듯함흠그럼 List&lt; Pair &gt;형태로 파라미터를 받아도되는걸까?이번프로젝트에서 key-value형태로 파라미터를 받고싶었는데 Map을 사용하니까 파라미터가 여러건인 경우 모두 매핑이돼버려서 포기했음;;참고로 Map은val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3, \"d\" to 4)println(map)책에서 이렇게 사용함. 뒤에서 더 자세히 나오겠지만 궁금해서 조금 깔짝거려봤는데var map: Map&lt;String, Int&gt;map = mutableMapOf&lt;String, Int&gt;()map[\"A\"] = 1val mutableMapOf = mutableMapOf&lt;String, Int&gt;()mutableMapOf.put(\"ss\", 1)이런..식인듯흠val triple = Triple(\"A\", \"a\", 1)println(triple) //오triple이란 녀석도 있는데 자바엔 없는듯걍 값 3개 쌍으로 단건 저장가능한거"
  },
  
  {
    "title": "[코틀린 쿡북] 11장 - 그 밖의 코틀린 기능",
    "url": "/posts/%EA%B7%B8-%EB%B0%96%EC%9D%98-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B8%B0%EB%8A%A5/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-09-10 00:00:00 +0900",
    





    
    "snippet": "코틀린 버전 알아보기println(KotlinVersion.CURRENT)println(KotlinVersion(1,3,41) &lt; KotlinVersion.CURRENT) //trueprintln(KotlinVersion.CURRENT.isAtLeast(major = 1, minor = 3, patch = 40)) //true코틀린 버전끼리 비교...",
    "content": "코틀린 버전 알아보기println(KotlinVersion.CURRENT)println(KotlinVersion(1,3,41) &lt; KotlinVersion.CURRENT) //trueprintln(KotlinVersion.CURRENT.isAtLeast(major = 1, minor = 3, patch = 40)) //true코틀린 버전끼리 비교도 가능함KotlinVersion(1,3,41) 이건 코틀린 특정 버전을 확인하기위해서 사용한거반복 람다 실행repeat(5) {    println(it) //0 1 2 3 4}코틀린 내장 repeat함수로 가능완변한 when 강제when은 자바의 switch와 비슷하지만 break나 반환을 위해 변수를 밖에서 선언할 필요 없음fun printMod3(n : Int) {    when (n%3){        0-&gt; println(\"$n % 3 == 0\")        1-&gt; println(\"$n % 3 == 1\")        2-&gt; println(\"$n % 3 == 2\")    }}위처럼 값을 리턴하지않아도 가능함 하지만fun printMod3SingleStatement(n : Int) = when (n%3) {        0-&gt; println(\"$n % 3 == 0\")        1-&gt; println(\"$n % 3 == 1\")        2-&gt; println(\"$n % 3 == 2\")        else -&gt; println(\"~~~\") //없으면 컴파일에러}이 케이스에서는 else문 없이는 컴파일안됨. 반환값이 없지만 else없이 컴파일이 안된다는게 이상함=를 사용했기때문에 코틀린이 반환값이 있어야한다고 요구한다는것인데.. 그런데 위케이스에서는 sout을 사용해서 이상함이것을 위해val &lt;T&gt; T.exhaustive: T    get() = thisfun printMod3Exhaustive(n : Int) { //완벽    when (n%3){        0-&gt; println(\"$n % 3 == 0\")        1-&gt; println(\"$n % 3 == 1\")        2-&gt; println(\"$n % 3 == 2\")        else -&gt; println(\"~~~\") //없으면 컴파일에러    }.exhaustive //속성이 컴파일러에게 else절을 요구하도록 강요함}exhaustive확장 속성을 이용해서 =가 없어도 else를 강제할 수 있음정규 표현식과 함꼐 replace 사용    println(\"one.two\".replace(\".\",\"*\")) //one*two    println(\"one.two\".replace(\".\".toRegex(), \"*\")) //*******  뭐지?    //아 \".\"을 정규표현식으로 만들어서 .이 각 단일 문자를 의미하도록    //조건에 일치하는 첫번째 항목X, 모든 항목O = 자바의 replaceAll바이너리 문자열로 변환 &amp; 되돌리기    println(\"rwewr\".isPalindrome()) //true    println(42.toString(radix = 2))    println(\"101010\".toInt(radix = 2))실행 가능한 클래스 만들기클래스에서 단일 함수를 간단하게 호출하는 방법 - invoke 재정의(연산자 중복)https://api.open-notify.org/astros.jsonjson은 여기서 받아올거임data class AstroResult (    val message: String,    val number: Number,    val people: List&lt;Assignment&gt;)class AstroRequest {    companion object {        private const val ASTRO_URL = \"http://api.open-notify.org/astros.json\"    }//    fun execute() : AstroResult {        operator fun invoke(): String {            val responseString = URL(ASTRO_URL).readText()//        return Gson.fromJson(responseString, AstroResult::class.java)            return responseString;        }//    }}val request = AstroRequest();val result = request() //invoke 호출됨println(result)사실 책에선 Gson라이브러리를 사용했는데 라이브러리 추가하기 귀찮아서 걍 String 반환함..ㅋㅋ어쨌든 반환되는거 확인함경과시간 측정fun doubleIt(x: Int) : Int {    Thread.sleep(100L)    println(\"doubling $x with thread ${Thread.currentThread().name}\")    return x*2}println(\"${Runtime.getRuntime().availableProcessors()} processors\")    var time = measureTimeMillis {      IntStream.rangeClosed(1, 6)          .map { doubleIt(it)}          .sum()    }println(time) //630time = measureTimeMillis {    IntStream.rangeClosed(1, 6)        .parallel()        .map { doubleIt(it)}        .sum()}println(time) // 107스레드 시작(0..5).forEach {n -&gt;    val sleepTime = Random.nextLong(range = 0..100L)    thread {        Thread.sleep(sleepTime)        println(\"${Thread.currentThread().name} for $n after ${sleepTime}ms\")    }}6개의 스레드가 시작하며 0~1000사이의 무작위 밀리초동안 sleep한 후 해당 쓰레드 이름 출력(0..5).forEach {n -&gt;    val sleepTime = Random.nextLong(range = 0..100L)    thread(isDaemon = true) {        Thread.sleep(sleepTime)        println(\"${Thread.currentThread().name} for $n after ${sleepTime}ms\")    }}실행해도 출력되지않음. isDaemon이 true라서 그렇다고..그리고(0..5).forEach { n -&gt;        val sleepTime = Random.nextLong(range = 0..100L)        thread {            Thread.sleep(sleepTime)            println(\"${Thread.currentThread().name} for $n after ${sleepTime}ms\")        }.join() //각 스레드는 자신 이전의 스레드에 Join 실행    }이건 join()을 사용해서 각 스레드는 자신 이전의 스레드에 Join을 실행함.그리고 쓰레드를 보면 순차적으로 출력된걸 확인할수있음TODOTODO(reason = \"none\")TODO함수를 사용할 수 있음 실행하면kotlin.NotImplementedError: An operation is not implemented: none라고 나옴구현중이고 실행하면 안되는 함수에 중단을 시킬수도있음!!RANDOM//import kotlin.random.Random 사용println(Random.nextInt()) //1565262279println(Random.nextInt(10)) //3println(Random.nextInt(5, 10)) //8//import kotlin.random.nextInt 사용println(Random.nextInt(7..12)) //9Random.nextInt(7..12) 는 random.nextInt을 사용함응용하면val r1 = Random(12345)val nums1 = (1..10).map {    r1.nextInt()}val r2 = Random(12345)val nums2 = (1..10).map {    r2.nextInt()}시드값을 받는 난수생성 가능함수 이름에 특수문자 사용fun `only use backticks on test funtions1` () {    println(\"어지간하면_로 만드는게..\")}주로 테스트에서 쓰이는 방법이나 테스트에서 함수이름에 _가 안되는게아니라서 어지간하면.. _쓰는게?거슬려요자바 예외 알리기코틀린에서 모든 예외는 unchecked exception이다 = 예외처리가 필요없음그럼 자바에서 코틀린 예외가 발생한다면??fun houstonWeHaveAProblem() {    throw IOException();}자바에서도 unchecked exception인 IOException을 발생시킨 함수를 자바에서 호출한다면??예외처리를 강제하지않는다!!그럼 자바에서 try-catch문을 사용한다고해도 이렇게되고throws를 시켜도 불필요하다고 경고절이..엥?그새…업데이트가?아무튼;;아무리 throws를 사용해도된다고해도 이건 헷갈리긴할듯 안에 예외가있는지없는지 어떻게 다 확인함@Throws(IOException::class)fun houstonWeHaveAProblem2() {    throw IOException();}이렇게 예외발생을 알리는 어노테이션을 달아준다면            ![[IMG-20240910152840.png      IMG-20240910152840.png]]      컴파일시점에서 에러가 뜨는걸확인가능함"
  },
  
  {
    "title": "[코틀린 쿡북] 3장 - 코틀린 객체 지향 프로그래밍",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/",
    "categories": "Kotlin",
    "tags": "kotlin, 코틀린쿡북",
    "date": "2023-09-10 00:00:00 +0900",
    





    
    "snippet": "const - val 차이둘다 수정 불가능한건 동일함  const : 컴파일 타임 상수. 컴파일 시점에 값을 할당  = 컴파일러는 해당 상수가 어떤 값을 가지고 있는지 미리 알수 있음          const val TEST = validPriority(10) 이런거 안됨      const 단독 사용, const var는 안되는듯함      사용시...",
    "content": "const - val 차이둘다 수정 불가능한건 동일함  const : 컴파일 타임 상수. 컴파일 시점에 값을 할당  = 컴파일러는 해당 상수가 어떤 값을 가지고 있는지 미리 알수 있음          const val TEST = validPriority(10) 이런거 안됨      const 단독 사용, const var는 안되는듯함      사용시 companion object안에 넣어줘햐하는듯.        val : 런타임 타임 상수. 런타임 시점에 값을 할당라고는 하는데class Task(  val name: String,  _priority: Int = DEFAULT_PRIORITY) {  companion object{ //static..같은놈인가?      const val MIN_PRIORITY = 1      const val MAX_PRIORITY = 5      const val DEFAULT_PRIORITY = 3  }  var priority = validPriority(_priority) //사용자 정의 설정자(setter) -3.2에서 자세히      set(value) {          field = validPriority(value)      }  private fun validPriority(p: Int) = //private 검증 함수      p.coerceIn(MIN_PRIORITY, MAX_PRIORITY)}일단 예시코드흠.. 일단 companion object ~ const val가 final static처럼 동작하게 해주는거같음굳이따지자면 const val가 finalconpanion object가 static처럼 동작하게 해주는데 companion object는 객체기때문에 그렇게 보이는거지 static이랑 동일한것은 아님참고로 object는 싱글톤val task = Task(\"a\")println(task.name) //a 출력println(task.priority) //3 출력task.priority = 10println(task.priority) //5출력  [!important]var priority = validPriority(_priority) //사용자 정의 설정자(setter) -3.2에서 자세히 set(value) { field = validPriority(value) }이 부분때문에 priority로 설정했을때 validPriority가 작동해서 값이 5로 세팅된듯 함 그렇다면class Task(    val name: String,    _priority: Int = 100) {    companion object{ //static..같은놈인가?        const val MIN_PRIORITY = 1        const val MAX_PRIORITY = 5        const val DEFAULT_PRIORITY = 3    }    var priority = validPriority(_priority) //사용자 정의 설정자(setter) -3.2에서 자세히        set(value) {            field = validPriority(value)        }    private fun validPriority(p: Int) = //private 검증 함수        p.coerceIn(MIN_PRIORITY, MAX_PRIORITY)}동일 조건에서 이렇게 해봄.val task = Task(\"a\")println(task.name) //a 출력println(task.priority) //5 출력!!!task.priority = 10println(task.priority) //5출력처음 객체를 인스턴스화할때 private 메소드인 validPriority가 작동해서 5가 세팅된걸 확인함신기하구만사용자 정의 획득자(getter)/설정자(setter)class Task2(val name: String) {  var priority = 10 //여기선 아래 조건 안탐      set(value) {          field = value.coerceIn(1..5) //값이 경계안에있으면 해당 값을, 아니면 경계 값을      }  val isLowPriority      get() = priority &lt; 3}아까와는 다르게 priority가 생성자에서 빠짐set의 범위 밖으로 값을 설정해주었으나 set이 작동하지는 않은것으로 보임 10이 적용됨추후에 priority에 범위보다 큰 값을 set해주자 5가 적용되는 것을 확인함val task2_1 = Task2(\"ㅇ\")//    val task2_2 = Task2(\"ㅇ\", 1) //안됨//    val task2_3 = Task2(name = \"ㅇ\", priority = 1) //안됨println(task2_1.name) //ㅇ 출력println(task2_1.priority) //3 출력task2_1.priority = 5;println(task2_1.priority) //5 출력var tesk2_4 = Task2(\"?\").apply { priority = 1 }println(tesk2_4.name) //? 출력println(tesk2_4.priority) //1 출력println(tesk2_4.isLowPriority) //true 출력tesk2_4.priority = 100println(tesk2_4.priority) //5 출력val task2_5 = Task2(\"ㅇ\")println(task2_5.priority) //10 출력task2_5.priority = task2_5.priorityprintln(task2_5.priority) //5 출력data classequals, hashCode, toString, copy, component 자동 구현 클래스data class Product2(    val name: String,    var price: Double,    var onSale: Boolean = false)data class OrderItem(    val product: Product2,    var quantity: Int)val prod = Product2(name = \"prod\", price = 2.2)val copyProd = Product2(name = \"prod\", price = 2.2)println(prod == copyProd) //trueprintln(prod.hashCode() == copyProd.hashCode()) //trueprintln(prod.name == copyProd.name) //trueval copyProd2 = prod.copy(name = \"prod2\")println(prod == copyProd2) //falseprintln(prod.hashCode() == copyProd2.hashCode()) //falseprintln(prod.name == copyProd2.name) //falseval item = OrderItem(product = prod, quantity = 10);val copyItem = item.copy()println(item == copyItem) //trueprintln(item.product == copyItem.product) //trueitem.quantity -= 10;println(item.quantity == copyItem.quantity) //falsevar (name, price, onSale) = prod //구조 분해 component를 이용해서 이루어짐println(name) //prodprintln(price) //2.2println(onSale) //falseonSale = trueprintln(onSale == prod.onSale) //falseprod.onSale = trueprintln(prod.onSale == item.product.onSale) //truecomponent를 통해 class안의 멤버변수들을 분해할 수 있음지원 속성 기법속성을 읽거나 초기화하는 방법을 제어하기위한 방법  버전1class Customer(    val name: String) {   private var _message: List&lt;String&gt;? = null //null 허용 private 속성 초기화    val messages: List&lt;String&gt; //불러올 속성        get() {            print(\"getter \")            if(_message==null){                _message = loadMessages()            }            return _message!!        }    //private 함수    private fun loadMessages() :MutableList&lt;String&gt; =        mutableListOf(            \"In~~~\",            \"!!!!!\",            \"?????\"        ).also { println(\"loaded\") }}val customer = Customer(\"test\").apply { messages } //getter loaded 출력됨println(customer.messages) //getter \\n [In~~~, !!!!!, ?????]println(\"-----------\")val customer2 = Customer(\"test\") //출력값 없음println(customer2.messages) //getter loaded \\n [In~~~, !!!!!, ?????] 출력custom은 apply를 사용하여선언시 getter호출(getter출력) -&gt; null이라서 loadMessages 호출 -&gt; 값 세팅과 함께 loaded 출력 -&gt; 추후 getter호출시 getter + return만 적용됨custom2는 생성시에는 message가 초기화되지않았다가 추후 getter를 호출했을때getter 호출(getter출력) -&gt; null이라서 loadMessages 호출 -&gt; 값 세팅과 함께 loaded 출력 -&gt; return 출력순으로 움직인듯그러나 lazy를 사용하면 더 효율적으로 사용 가능함  버전2. by lazy 사용class Customer2(    val name: String) {    val _message: List&lt;String&gt; by lazy { loadMessages() } //lazy var에선 안됨    //private 함수    private fun loadMessages() :MutableList&lt;String&gt; =        mutableListOf(            \"In~~~\",            \"!!!!!\",            \"?????\"        ).also { println(\"loaded\") }}val customer3 = Customer2(\"test\") //출력값 없음    println(customer3._message) //loaded \\n [In~~~, !!!!!, ?????] 출력lazy는 8장에서 더 자세히연산자 중복var num = 10println(-num) //-10출력println(+num) //10 출력var num2 = -10println(-num2) //10 출력println(+num2) //-10 출력이런식으로 코틀린 자체에 정의된 함수를 응용할수있다는거같음data class Point(    val x: Int,    val y: Int) {    //오버라이딩 시 operator 필수(equals제외)    operator fun unaryMinus() = Point(-x, -y) //- 자체 정의 함수    operator fun unaryPlus() = x+y //+ 자체 정의 함수}val point = Point(x = 10, y = 20)println(point) //Point(x=10, y=20) 출력println(-point) //Point(x=-10, y=-20) 출력println(+point) //30 출력lateinitlazy와 비슷하나 의존성 주입을 제외하고는 권장되지않음class TestController {    @AutoWired    lateinit val testFacade: TestFacade}@Autowired에서는 값의 인스턴스가 생성된 이후 의존성이 주입되어 lateinit을 사용해야함찾아보니 @RequiredArgsConstructor의 경우에는 사용하지않는듯함class LateInitDemo {    lateinit var name: String    fun intitializeName() {        println(\"befor : ${::name.isInitialized}\")        name = \"lateintit\"        println(\"after : ${::name.isInitialized}\")    }}val lateInitDemo = LateInitDemo()//    println(lateInitDemo.name) //UninitializedPropertyAccessException 에러 발생    lateInitDemo.intitializeName()    lateInitDemo.intitializeName()    lateInitDemo.name = \"test\"    println(lateInitDemo.name) //test 출력equals 재정의override fun equals(other: Any?): Boolean {    if (this === other) return true    val otherVersion = (other as? KotlinVersion) ?: return false    return this.version == otherVersion.version}  == 으로 레퍼런스 동등성 확인  안전타입 변환 연산자(as?)로 타입 불일치시 null 반환  엘비스 연산자(?: ~~~ )로 2번에서 null이 반환되었을시 false를 반환  현 클래스와 인자의 타입이 같다면 속성비교후 결과 반환class LateInitDemo {    lateinit var name: String    fun intitializeName() {        println(\"befor : ${::name.isInitialized}\")        name = \"lateintit\"        println(\"after : ${::name.isInitialized}\")    }    override fun equals(other: Any?): Boolean {        if (this === other) return true        if (javaClass != other?.javaClass) return false        other as LateInitDemo        return name == other.name    }    override fun hashCode(): Int {        return name.hashCode()    }싱글톤class 대신 object를 사용  조건          클래스의 모든 생성자를 private로      필요하다면 해당 클래스를 인스턴스화, 인스턴스 레퍼런스를 리턴하는 정적 팩토리메소드 사용→ 코틀린의 object로 구현 가능      object MySingleton {  val myProperty = 3  fun myFuntion() = \"hello\"}println(MySingleton.myProperty)println(MySingleton.myFuntion())//    MySingleton() //안됨대신 생성자가 private라 인자를 전달하는 방법으로 쉬운방법이없음굳이 받아야한다면  [!info] Kotlin singletons with argumentobject has its limitshttps://bladecoder.medium.com/kotlin-singletons-with-argument-194ef06edd9e아래 블로그처럼 하면되나 너무 복잡하다는 단점이있음Nothingpublic class Nothing private constructor()private constructor로 인스턴스화 불가.함수의 void타입이 없고 nothing으로 반환을 해줌fun doNothing() :Nothing {    throw Exception(\"Nothing at all\");}위처럼 무조건 예외를 던지도록 설정됨//    doNothing(); //exception 발생var x = null // -&gt; nothing타입이 됨//    x = \"ss\" //안됨//    x = 1 //안됨//    x= 1.1 안됨println(x) //null반환또한 변수에 null타입을 받으면 x는 nothing타입으로 결정되서 다른 타입의 값을 넣을 수 없음예외 없이 반환타입을 없애고싶으면 Unit을 사용하는듯"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 상품 도메인 개발",
    "url": "/posts/%EC%83%81%ED%92%88%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B0%9C%EB%B0%9C/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1, 타임리프",
    "date": "2023-08-05 00:00:00 +0900",
    





    
    "snippet": "  entitypackage hello.itemservice.domain.item;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;@Getter@Setter@AllArgsConstructor@NoArgsCons...",
    "content": "  entitypackage hello.itemservice.domain.item;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Item {\tprivate Long id;\tprivate String itemName;\tprivate Integer price;\tprivate Integer quantity;}  repositorypackage hello.itemservice.domain.item;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.springframework.stereotype.Repository;@Repositorypublic class ItemRepository {\tprivate static final Map&lt;Long, Item&gt; store = new HashMap&lt;&gt;();\tprivate static Long seq = 0L;\tpublic Item save(Item item) {\t\titem.setId(++seq);\t\tstore.put(item.getId(), item);\t\treturn item;\t}\tpublic Item findById(Long id) {\t\treturn store.get(id);\t}\tpublic List&lt;Item&gt; findAll() {\t\treturn new ArrayList&lt;&gt;(store.values());\t\t//반환타입을 Collection으로 해서 store.values(); 해도되는데 원본 훼손방지를 위해 감쌈\t}\tpublic void update(Long itemId, Item updateParam) {\t\tItem findItem = findById(itemId);\t\tfindItem.setItemName(updateParam.getItemName());\t\tfindItem.setPrice(updateParam.getPrice());\t\tfindItem.setQuantity(updateParam.getQuantity());\t}\tpublic void clearStore() {\t\tstore.clear();\t}}실무에선 HashMap말고 ConcurrnetHashMap써야한다고함. 멀티쓰레드 환경에서 사용가능함  [!important]정적 리소스가 공개되는 /resource/static 폴더에 HTML을 넣어두면 실제 서비스에도 공개됨. 서비스를 운영할때는 공개할 필요없는 HTML을 두는것을 주의타임리프  상품 목록package hello.itemservice.web.basic;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import hello.itemservice.domain.item.Item;import hello.itemservice.domain.item.ItemRepository;import jakarta.annotation.PostConstruct;import lombok.RequiredArgsConstructor;@Controller@RequestMapping(\"/basic/items\")@RequiredArgsConstructorpublic class BasicItemController {\tprivate final ItemRepository itemRepository;\t@GetMapping\tpublic String item(Model model) {\t\tList&lt;Item&gt; all = itemRepository.findAll();\t\tmodel.addAttribute(\"items\", all);\t\treturn \"/basic/items\";\t}\t\t@PostConstruct\tpublic void init() {\t\titemRepository.save(new Item(null, \"ItemA\", 1000, 10));\t\titemRepository.save(new Item(null, \"ItemB\", 2000, 30));\t}}&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;link th:href=\"@{/css/bootstrap.min.css}\"            href=\"../css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\" style=\"max-width: 600px\"&gt;    &lt;div class=\"py-5 text-center\"&gt;        &lt;h2&gt;상품 목록&lt;/h2&gt; &lt;/div&gt;    &lt;div class=\"row\"&gt;        &lt;div class=\"col\"&gt;            &lt;button class=\"btn btn-primary float-end\"                    onclick=\"location.href='addForm.html'\"                    type=\"button\"&gt;상품                등록&lt;/button&gt; &lt;/div&gt;    &lt;/div&gt;    &lt;hr class=\"my-4\"&gt;    &lt;div&gt;        &lt;table class=\"table\"&gt;            &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;ID&lt;/th&gt;                 &lt;th&gt;상품명&lt;/th&gt; &lt;th&gt;가격&lt;/th&gt; &lt;th&gt;수량&lt;/th&gt;            &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;            &lt;tr th:each=\"item : ${items}\"&gt;                &lt;td&gt;&lt;a th:href=\"@{/basic/items/{itemId}(itemId=${item.id})}\" th:text=\"${item.id}\"&gt;회원ID&lt;/a&gt;&lt;/td&gt;                &lt;td&gt;&lt;a th:href=\"@{/basic/items/{itemId}(itemId=${item.id})}\" th:text=\"${item.itemName}\"&gt;상품명&lt;/a&gt;&lt;/td&gt;                &lt;td&gt;&lt;a th:href=\"@{/basic/items/{itemId}(itemId=${item.id})}\" th:text=\"${item.price}\"&gt;가격&lt;/a&gt;&lt;/td&gt;                &lt;td&gt;&lt;a th:href=\"@{/basic/items/{itemId}(itemId=${item.id})}\" th:text=\"${item.quantity}\"&gt;수량&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/div&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt;동적 페이지 생성  [!important]리터럴 대체 - |…||…| :\t이렇게 사용한다.타임리프에서 문자와 표현식 등은 분리되어 있기 때문에 더해서 사용해야 한다.&lt; span th:text=\"'Welcome to our application, ' + ${user.name} + '!'\" &gt;다음과 같이 리터럴 대체 문법을 사용하면, 더하기 없이 편리하게 사용할 수 있다.&lt; span th:text=\"|Welcome to our application, ${user.name}!|\" &gt;  상품 상세@GetMapping(\"/{itemId}\")\tpublic String item(@PathVariable Long itemId, Model model) {\t\tItem item = itemRepository.findById(itemId);\t\tmodel.addAttribute(\"item\", item);\t\treturn \"/basic/item\";\t}&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;link th:href=\"@{/css/bootstrap.min.css}\"          href=\"../css/bootstrap.min.css\" rel=\"stylesheet\"&gt;    &lt;style&gt;        .container {            max-width: 560px;        } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt;    &lt;div class=\"py-5 text-center\"&gt;        &lt;h2&gt;상품 상세&lt;/h2&gt; &lt;/div&gt;    &lt;div&gt;        &lt;label for=\"itemId\"&gt;상품 ID&lt;/label&gt;        &lt;input type=\"text\" id=\"itemId\" name=\"itemId\" class=\"form-control\"               th:value=\"${item.id}\" readonly&gt;    &lt;/div&gt; &lt;div&gt;    &lt;label for=\"itemName\"&gt;상품명&lt;/label&gt;    &lt;input type=\"text\" id=\"itemName\" name=\"itemName\" class=\"form-control\"           th:value=\"${item.itemName}\" readonly&gt; &lt;/div&gt;    &lt;div&gt;        &lt;label for=\"price\"&gt;가격&lt;/label&gt;        &lt;input type=\"text\" id=\"price\" name=\"price\" class=\"form-control\"               th:value=\"${item.price}\" readonly&gt;    &lt;/div&gt; &lt;div&gt;    &lt;label for=\"quantity\"&gt;수량&lt;/label&gt;    &lt;input type=\"text\" id=\"quantity\" name=\"quantity\" class=\"form-control\"           th:value=\"${item.quantity}\" readonly&gt;&lt;/div&gt;    &lt;hr class=\"my-4\"&gt;    &lt;div class=\"col\"&gt;        &lt;button class=\"w-100 btn btn-primary btn-lg\"                onclick=\"location.href='editForm.html'\"                th:onclick=\"|location.href='@{/basic/items/{itemId}/ edit(itemId=${item.id})}'|\" type=\"button\"&gt;상품 수정&lt;/button&gt;    &lt;/div&gt;    &lt;div class=\"col\"&gt;        &lt;button class=\"w-100 btn btn-secondary btn-lg\"                onclick=\"location.href='items.html'\"                th:onclick=\"|location.href='@{/basic/items}'|\" type=\"button\"&gt;목록으로&lt;/button&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt;  상품등록// @PostMapping(\"/add\")\t// public String save(@RequestParam String itemName, @RequestParam Integer price, @RequestParam Integer quantity, Model model) {\t// \tItem save = itemRepository.save(new Item(null, itemName, price, quantity));\t// \tmodel.addAttribute(\"item\", save);\t// \treturn \"/basic/item\";\t// }\t@PostMapping(\"/add\")\tpublic String save(@ModelAttribute(\"item\")/*Model에 item으로 값 들어감*/ Item item) {\t\titemRepository.save(item);\t\treturn \"/basic/item\";\t}&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;link th:href=\"@{/css/bootstrap.min.css}\"          href=\"../css/bootstrap.min.css\" rel=\"stylesheet\"&gt;    &lt;style&gt;        .container {            max-width: 560px;        } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt;    &lt;div class=\"py-5 text-center\"&gt; &lt;h2&gt;상품 등록 폼&lt;/h2&gt;    &lt;/div&gt;    &lt;h4 class=\"mb-3\"&gt;상품 입력&lt;/h4&gt;    &lt;form action=\"item.html\" th:action method=\"post\"&gt;        &lt;div&gt;            &lt;label for=\"itemName\"&gt;상품명&lt;/label&gt;            &lt;input type=\"text\" id=\"itemName\" name=\"itemName\" class=\"form-control\" placeholder=\"이름을 입력하세요\"&gt; &lt;/div&gt;        &lt;div&gt;            &lt;label for=\"price\"&gt;가격&lt;/label&gt;            &lt;input type=\"text\" id=\"price\" name=\"price\" class=\"form-control\" placeholder=\"가격을 입력하세요\"&gt;        &lt;/div&gt; &lt;div&gt;        &lt;label for=\"quantity\"&gt;수량&lt;/label&gt;        &lt;input type=\"text\" id=\"quantity\" name=\"quantity\" class=\"form-control\" placeholder=\"수량을 입력하세요\"&gt; &lt;/div&gt;        &lt;hr class=\"my-4\"&gt;        &lt;div class=\"row\"&gt;            &lt;div class=\"col\"&gt;                &lt;button class=\"w-100 btn btn-primary btn-lg\" type=\"submit\"&gt;상품                    등록&lt;/button&gt; &lt;/div&gt;            &lt;div class=\"col\"&gt;                &lt;button class=\"w-100 btn btn-secondary btn-lg\"                        onclick=\"location.href='items.html'\"        th:onclick=\"|location.href='@{/basic/items}'|\" type=\"button\"&gt;취소&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt;그런데 이 구조는 상품 등록 후 새로고침 시 중복등록된다는 큰 문제가있음!!새로고침은 마지막에 서버에 전송한 데이터를 다시 전송해서 마지막 작업이었던 등록 작업을 재실행한거임!그래서 저장 후 새로 저장한 객체의 id로 redirect를 해줘야함! → 마지막 작업이 GET요청으로 변경됨@PostMapping(\"/add\")\tpublic String save(@ModelAttribute(\"item\")/*Model에 item으로 값 들어감*/ Item item) {\t\titemRepository.save(item);\t\treturn \"redirect:/basic/items/\"+item.getId();\t}이렇게 바껴야함그런데 이렇게되면 id에 url로 들어올수 없는 값이(ex:띄어쓰기 등)들어오면 에러가 날거임RedirectAttributes을 사용하면 해결 가능!!@PostMapping(\"/add\")\tpublic String save(@ModelAttribute(\"item\") Item item, RedirectAttributes redirectAttributes) {\t\tredirectAttributes.addAttribute(\"itemId\", item.getId());\t\tredirectAttributes.addAttribute(\"status\", true); //저장 결과 -&gt; 성공\t\titemRepository.save(item);\t\treturn \"redirect:/basic/items/{itemId}\";\t\t// 남는 애들은 쿼리파라미터 형태로 전달됨 (url에 ?status=true)\t}  상품 수정@GetMapping(\"/{itemId}/edit\")\tpublic String editForm(@PathVariable Long itemId, Model model) {\t\tItem item = itemRepository.findById(itemId);\t\tmodel.addAttribute(\"item\", item);\t\treturn \"basic/editForm\";\t}\t@PostMapping(\"/{itemId}/edit\")\tpublic String edit(@PathVariable Long itemId, @ModelAttribute Item item) {\t\titemRepository.update(itemId, item);\t\treturn \"redirect:/basic/items/{itemId}\";\t}&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;link href=\"../css/bootstrap.min.css\"          th:href=\"@{/css/bootstrap.min.css}\" rel=\"stylesheet\"&gt;    &lt;style&gt;        .container {            max-width: 560px;        } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt;    &lt;div class=\"py-5 text-center\"&gt; &lt;h2&gt;상품 수정 폼&lt;/h2&gt;    &lt;/div&gt;    &lt;form action=\"item.html\" th:action method=\"post\"&gt;        &lt;div&gt;            &lt;label for=\"id\"&gt;상품 ID&lt;/label&gt;            &lt;input type=\"text\" id=\"id\" name=\"id\" class=\"form-control\" value=\"1\"                   th:value=\"${item.id}\" readonly&gt;        &lt;/div&gt; &lt;div&gt;        &lt;label for=\"itemName\"&gt;상품명&lt;/label&gt;        &lt;input type=\"text\" id=\"itemName\" name=\"itemName\" class=\"form-control\" value=\"상품A\" th:value=\"${item.itemName}\"&gt; &lt;/div&gt;        &lt;div&gt;            &lt;label for=\"price\"&gt;가격&lt;/label&gt;            &lt;input type=\"text\" id=\"price\" name=\"price\" class=\"form-control\"                   th:value=\"${item.price}\"&gt;        &lt;/div&gt; &lt;div&gt;        &lt;label for=\"quantity\"&gt;수량&lt;/label&gt;        &lt;input type=\"text\" id=\"quantity\" name=\"quantity\" class=\"form-control\" th:value=\"${item.quantity}\"&gt;    &lt;/div&gt;        &lt;hr class=\"my-4\"&gt;        &lt;div class=\"row\"&gt;            &lt;div class=\"col\"&gt;                &lt;button class=\"w-100 btn btn-primary btn-lg\" type=\"submit\"&gt;저장                &lt;/button&gt;            &lt;/div&gt;            &lt;div class=\"col\"&gt;                &lt;button class=\"w-100 btn btn-secondary btn-lg\"                        onclick=\"location.href='item.html'\"                        th:onclick=\"|location.href='@{/basic/items/{itemId}(itemId=${item.id})}'|\"                type=\"button\"&gt;취소&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 스프링 MVC 구조",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81_MVC_%EA%B5%AC%EC%A1%B0/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-06-25 00:00:00 +0900",
    





    
    "snippet": "DispatcherServletDIspatcherServlet도 부모클래스가 HttpServlet을 상속받고있음. → 모든경로에대해 매핑을 해놓음(자세한 경로가 우선순위가 높아서 기존에 등록한 서블릿도 동작함)protected void doDispatch(HttpServletRequest request, HttpServletResponse respon...",
    "content": "DispatcherServletDIspatcherServlet도 부모클래스가 HttpServlet을 상속받고있음. → 모든경로에대해 매핑을 해놓음(자세한 경로가 우선순위가 높아서 기존에 등록한 서블릿도 동작함)protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {    HttpServletRequest processedRequest = request;    HandlerExecutionChain mappedHandler = null;    ModelAndView mv = null;\t\t// 1. 핸들러 조회\t\tmappedHandler = getHandler(processedRequest); \t\tif (mappedHandler == null) {      noHandlerFound(processedRequest, response);\t\t\treturn; \t\t}\t\t//2.핸들러 어댑터 조회-핸들러를 처리할 수 있는 어댑터\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\t\t// 3. 핸들러 어댑터 실행 -&gt; 4. 핸들러 어댑터를 통해 핸들러 실행 -&gt; 5. ModelAndView 반환 \t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\t}  private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView  mv, Exception exception) throws Exception {\t\t\t // 뷰 렌더링 호출\t\t\trender(mv, request, response);  }  protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {    View view;\t\tString viewName = mv.getViewName(); //6. 뷰 리졸버를 통해서 뷰 찾기,7.View 반환    view = resolveViewName(viewName, mv.getModelInternal(), locale, request);\t\t// 8. 뷰 렌더링    view.render(mv.getModelInternal(), request, response);  }중요로직만 설명한거같음동작 순서  핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.  핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.  핸들러 어댑터 실행: 핸들러 어댑터를 실행한다.  핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다.  ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다.  viewResolver 호출: 뷰 리졸버를 찾고 실행한다.          JSP의 경우: InternalResourceViewResolver 가 자동 등록되고, 사용된다.        View반환:뷰리졸버는뷰의논리이름을물리이름으로바꾸고,렌더링역할을담당하는뷰객체를 반환한다.          JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다.        뷰렌더링:뷰를 통해서 뷰를 렌더링한다.핸들러 매핑/핸들러 어댑터  예시 1)package com.mvc1.servlet.web.springmvc.old;import org.springframework.stereotype.Component;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Component(\"/springmvc/old-controller\")public class OldController implements Controller {\t@Override\tpublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\t\tSystem.out.println(\"OldController.handleRequest\");\t\treturn null;\t}}  Handler Mapping          0순위 - @RequestMapping      1순위 - 스프링 빈의 이름으로 핸들러를 찾음 ← 위 코드 예시. url이름이랑 똑같은 이름의 bean을 찾음        Handler Adapter          0순위 - @RequestMapping      1순위 - HttpRequestHandler 처리      2순위 - Controller 인터페이스(어노테이션x, 과거에 사용) ← 위 코드 예시      — 결론핸들러 매핑, 핸들러 어댑터도 모두 순서대로 찾고 없으면 다음순서로  핸들러 매핑으로 핸들러 조회          HandlerMapping을 순서대로 실행 → 핸들러 찾음      빈이름으로 핸들러를 찾아야해서 BeanNameUrlHandlerMapping이 실행성공하고 핸들러인 OldContorller를 반환        핸들러 어댑터 조회          HandlerAdapter의 supports()를 순서대로 호출      SimpleControllerHandlerAdapter가 Controller 인터페이스를 지원하므로 대상이됨        핸들러 어댑터 실행          디스패처서블릿이 조회한 simpleControllerHandlerAdapter를 실행하면서 핸들러 정보도 함께 넘김      SimpleControllerHandlerAdapter는 핸들러인 OldController를 내부에서 실행→ 결과 반환        예시 2)package com.mvc1.servlet.web.springmvc.old;import java.io.IOException;import org.springframework.stereotype.Component;import org.springframework.web.HttpRequestHandler;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Component(\"/springmvc/request-handler\")public class MyHttpRequestHandler implements HttpRequestHandler {\t@Override\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tSystem.out.println(\"MyHttpRequestHandler\");\t}}스프링 빈의 이름으로 핸들러를 찾음 → HttpRequestHandler 처리뷰 리졸버단순히package com.mvc1.servlet.web.springmvc.old;import org.springframework.stereotype.Component;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Component(\"/springmvc/old-controller\")public class OldController implements Controller {\t@Override\tpublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\t\tSystem.out.println(\"OldController.handleRequest\");\t\treturn new ModelAndView(\"new-form\");\t}}이렇게만 해주면 OldController.handleRequest는 콘솔창에 찍히나 view를 못찾기때문에 404에러가 뜸→ 뷰 리졸버 필요application.properties에spring.mvc.view.prefix=/WEB-INF/views/spring.mvc.view.suffix=.jsp을 해주면 페이지 로딩은 됨(저장 로직은 구현안해서 저장하면 오류남)@BeanViewResolver internalResourceViewResolver() {\treturn new InternalResourceViewResolver(\"/WEB-INF/views/\", \".jsp\");}이 작업을 스프링 부트에서 해주는 듯  스프링 부트가 자동 등록하는 뷰 리졸버          1순위 - 빈 이름으로 뷰 찾아서 반환(ex.엑셀파일 생성기능사용)      2순위 - JSP를 처리할 수 있는 뷰를 반환      — 순서  핸들러 어댑터 호출          핸들러 어댑터를 통해 new-form 이라는 논리 뷰 이름을 획득한다.        ViewResolver 호출          new-form 이라는 뷰 이름으로 viewResolver를 순서대로 호출한다.      BeanNameViewResolver 는 new-form 이라는 이름의 스프링 빈으로 등록된 뷰를 찾아야 하는데 없다.      InternalResourceViewResolver 가 호출된다.        InternalResourceViewResolver          이 뷰 리졸버는 InternalResourceView 를 반환한다.        뷰 - InternalResourceView          InternalResourceView 는 JSP처럼 포워드 forward() 를 호출해서 처리할 수 있는 경우에 사용한다.        view.render()          view.render() 가 호출되고 InternalResourceView 는 forward() 를 사용해서 JSP를 실행한다.        [!important]InternalResourceViewResolver는 JSTL라이브러리가 있으면 InternalResourceView를 상속받은 JstlView를 반환함(JSTL 태그 사용시 약간의 부가기능 추가됨)  [!important]보통 실제뷰를 랜더링하지만 JSP는 forward()를 통해서 해당 JSP로 이동해야 랜더링이 됨.  [!important]Thymeleaf 뷰 템플릿을 사용하면 ThymeleafViewResolver를 등록해야함. 최근엔 라이브러리만 추가하면 스프링부트가 자동으로 해줌spring mvcpackage com.mvc1.servlet.web.springmvc.v1;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controller //자동으로 빈 등록, 어노테이션기반 컨트롤러로 인식됨//@RequestMapping() //이건 클래스레벨이 붙어서 RequestMappingHandlerMapping으로 인식됨public class SpringMemberFormControllerV1 {\t@RequestMapping(\"/springmvc/v1/members/new-form\") //요청정보 매핑, 매소드의 이름은 임의로 지으면 됨\tpublic ModelAndView process() {\t\treturn new ModelAndView(\"new-form\"); //Model과 View의 정보를 담아서 반환\t}}이런식으로 됨다른 코드에도적 용해보면package com.mvc1.servlet.web.springmvc.v1;import java.util.List;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v3.ModelView;@Controllerpublic class SpringMemberListController {\tprivate final MemberRepository memberRepository = MemberRepository.getInstance();\t@RequestMapping(\"/springmvc/v1/members\")\tpublic ModelAndView process(Map&lt;String, String&gt; paramMap) {\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\tModelAndView mv = new ModelAndView(\"members\");\t\tmv.addObject(\"members\", members);\t\treturn mv;\t}}package com.mvc1.servlet.web.springmvc.v1;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Controllerpublic class SpringMemberSaveControllerV1 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@RequestMapping(\"/springmvc/v1/members/save\")\tpublic ModelAndView process(HttpServletRequest request, HttpServletResponse response) {\t\tString username = request.getParameter(\"username\");\t\tint age = Integer.parseInt(request.getParameter(\"age\"));\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tModelAndView mv = new ModelAndView(\"save-result\");\t\tmv.addObject(\"member\", member);\t\treturn mv;\t}}더 발전해서 각각의 컨트롤러를 하나로 통합 가능package com.mvc1.servlet.web.springmvc.v2;import java.util.List;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Controller@RequestMapping(\"springmvc/v2/members\")public class SpringMemberControllerV2 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@RequestMapping(\"/new-form\") //요청정보 매핑, 매소드의 이름은 임의로 지으면 됨\tpublic ModelAndView process() {\t\treturn new ModelAndView(\"new-form\"); //Model과 View의 정보를 담아서 반환\t}\t@RequestMapping\tpublic ModelAndView process(Map&lt;String, String&gt; paramMap) {\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\tModelAndView mv = new ModelAndView(\"members\");\t\tmv.addObject(\"members\", members);\t\treturn mv;\t}\t@RequestMapping(\"/save\")\tpublic ModelAndView process(HttpServletRequest request, HttpServletResponse response) {\t\tString username = request.getParameter(\"username\");\t\tint age = Integer.parseInt(request.getParameter(\"age\"));\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tModelAndView mv = new ModelAndView(\"save-result\");\t\tmv.addObject(\"member\", member);\t\treturn mv;\t}}여기서 더 발전해서 ModelAndView를 하나하나 만들기 귀찮으니까 개선할거임(v4에서 잠깐 본 거)package com.mvc1.servlet.web.springmvc.v3;import java.util.List;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Controller@RequestMapping(\"springmvc/v3/members\")public class SpringMemberControllerV3 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@RequestMapping(\"/new-form\") //요청정보 매핑, 매소드의 이름은 임의로 지으면 됨\tpublic String process() {\t\treturn \"new-form\"; //Model과 View의 정보를 담아서 반환\t}\t@RequestMapping\tpublic String process(Model model) {\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\tmodel.addAttribute(\"members\", members);\t\treturn \"members\";\t}\t@RequestMapping(\"/save\")\tpublic String process(\t\t\t\t@RequestParam(\"username\") String username,\t\t\t\t@RequestParam(\"age\") int age,\t\t\t\tModel model\t) {\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tmodel.addAttribute(\"member\", member);\t\treturn \"save-result\";\t}}RequestMapping으로 해주면 getMapping이든 postMapping이든 모두 호출됨. getMapping같이 제약을 거는게 더 좋음~@RequestMapping(value = \"/new-form\", method = RequestMethod._GET_) 이것도 되긴함"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 스프링 MVC 기본기능",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81MVC%EA%B8%B0%EB%B3%B8%EA%B8%B0%EB%8A%A5/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-06-25 00:00:00 +0900",
    





    
    "snippet": "기본적인 내용이 많아서 좀 생략함  war : 톰캣 별도 설치(내장도되긴함), servlet, jsp에도 배포가능함  jar : 내장톰캣 사용. 내장서버사용에 최적화됨— 로깅운영시스템에서는 sout안씀. SLF4J와 Logback 두 라이브러리가있는데 대부분 Logback사용함(스프링부트 기본제공)package com.hello.springmvc1.b...",
    "content": "기본적인 내용이 많아서 좀 생략함  war : 톰캣 별도 설치(내장도되긴함), servlet, jsp에도 배포가능함  jar : 내장톰캣 사용. 내장서버사용에 최적화됨— 로깅운영시스템에서는 sout안씀. SLF4J와 Logback 두 라이브러리가있는데 대부분 Logback사용함(스프링부트 기본제공)package com.hello.springmvc1.basic;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class LogTestController {\tprivate final Logger log = LoggerFactory.getLogger(getClass());\t@GetMapping(\"/log-test\")\tpublic String logTest() {\t\tlog.trace(\"trace log={}, {}\",\"test1\",\"test2\");\t\tlog.debug(\"debug\",\"debugTest\");\t\tlog.info(\"log-test\");\t\tlog.warn(\"warn\",\"warnTest\");\t\tlog.error(\"error\",\"errorTest\");\t\treturn \"ok\";\t}}trace, debug는 안뜨는거확인,application.properties에서 로그레벨 설정 가능함강의에서는 logging.level.hello.springmvc=trace로 했는데 나는 안돼서..구글링해보니 logging.level.root=trace 으로 설정하니 다 뜨는 것을 확인함..→ 아 root는 전체세팅이라고함 위 강의에서 사용한 레벨은 패키지단 설정이라 둘다해놓으면 패키지에는 해당 레벨이 적용되고 전체에는 기본레벨이 적용됨. root를 trace로 하면 메세지가 너무 많이찍힘암튼 순서대로 trace(다보임)→debug→info→warn→error순임.개발서버는 debug, 운영서버는 info로 설정하면될듯참고로 restController = 반환값으로 뷰를 찾는게아니고 Http메세지 바디에 바로 입력함package com.hello.springmvc1.basic;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import lombok.extern.slf4j.Slf4j;@RestController@Slf4jpublic class LogTestController {\t// private final Logger log = LoggerFactory.getLogger(getClass());\t@GetMapping(\"/log-test\")\tpublic String logTest() {\t\tlog.trace(\"trace log={}, {}\",\"test1\",\"test2\");\t\tlog.debug(\"debug\",\"debugTest\");\t\tlog.info(\"log-test\");\t\tlog.warn(\"warn\",\"warnTest\");\t\tlog.error(\"error\",\"errorTest\");\t\treturn \"ok\";\t}}lombok쓰면 @Slf4j만 해줘도됨참고로log.debug(“debug”+”debugTest”); 이렇게되면 ()안의 연산부터 이루어져서 로그레벨을 info로해도 연산이됨=메모리잡아먹음그리고 log는 파일로 남길수도있음. 파일 용량이 커지면 분할하도록 할수있음. sout보다 성능도 좋음요청 매핑@Contorller는 반환값이 String이면 뷰 이름으로 인식해서 뷰를 찾고 뷰가 랜더링하나 @RestController는 반환값으로 뷰를 찾는게 아니라 HTTP바디에 바로 입력됨 → 실행결과로 ok메세지를 받을 수 있음@RequestMapping은 요청메소드타입에 상관없이 모두 실행됨. method로 타입 지정가능, 이거의 축약버전이 @GetMapping같은거@GetMapping에 params =”mode=debug”나 headers=”mode=debug”같이 추가로 설정해주면 특정 값이 있어야 호출이됨, 요즘은 잘 사용하지않으니 있다는거만 알고 넘어가면될듯미디어타입조건도 매핑가능함(consumes = “application/json” 등) - http 헤더의 accept헤더에 특정 데이터 타입만 허용하겠다고 지정하는것너무 기본적인 내용이라서 코드는 생략함헤더 조회@RequestMapping(\"/headers\")    public String headers(          HttpServletRequest request,          HttpServletResponse response,          HttpMethod httpMethod,          Locale locale,          @RequestHeader MultiValueMap&lt;String, String&gt;                  headerMap,          @RequestHeader(\"host\") String host,          @CookieValue(value = \"myCookie\", required = false)          String cookie    ) {        log.info(\"request={}\", request);        log.info(\"response={}\", response);        log.info(\"httpMethod={}\", httpMethod);        log.info(\"locale={}\", locale);        log.info(\"headerMap={}\", headerMap);        log.info(\"header host={}\", host);        log.info(\"myCookie={}\", cookie);        return \"ok\";    }  locale(사용자 인터페이스에서 사용되는 언어, 지역 설정, 출력 형식 등을 정의하는 문자열) 가장 우선순위가 높은 locale을 받아옴. localeresolver도 있다고하는데 잘 사용하지는 않는듯? 글로벌서비스에서는 쓰일수도? 링크들어가보면 언어, 장소같은 느낌인듯  MultiValueMap : Map과 비슷하나 하나의 키에 여러 값을 받을 수 있음. 하나의 하나의 헤더에 여러 값이 들어올수있을때 사용하는듯. 키로 호출시 배열형태로 나옴https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html자세한건 여기데이터 전달 방법  get 쿼리파라미터          메세지 바디 없이 URL의 쿼리파라미터에 데이터 포함해서 전달      검색, 필터, 페이징등에 많이 사용         @RequestMapping(\"/request-param-v1\") public void requestParamV1(HttpServletRequest request, HttpServletResponse  \tresponse) throws IOException  { \t String username = request.getParameter(\"username\"); \t int age = Integer.parseInt(request.getParameter(\"age\")); \t log.info(\"username={}, age={}\", username, age); \t response.getWriter().write(\"ok\"); }        POST - HTML Form          content-type: application/x-www-form-urlencoded      메에시 바디에 쿼리파라미터 형식으로 전달(위랑 형식 같아서 똑같이꺼낼수있음)      회원가입, 상품주문, HTML Form 사용         &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;form action=\"/request-param-v1\" method=\"post\"&gt;  username: &lt;input type=\"text\" name=\"username\" /&gt;  age: &lt;input type=\"text\" name=\"age\" /&gt;  &lt;button type=\"submit\"&gt;전송&lt;/button&gt;  &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;        HTTP message body 에 데이터를 담아서 요청          HTTP API에서 주로 사용(JSON, XML, TEXT)      데이터형식은 주로 JSON      @RequestParam참고로 @Controller 어노테이션을 붙여도 API위에 @ResponseBody를 쓰면 특정 요청만 RestController가됨HTTP 파라미터 이름이 변수 이름이랑 같거나 String, int, Integer 등 단순 타입이면 아예 생략가능함그런데 너무 생략하면 명확하지않다는 단점이 있을수도있음required가 true면 필수, false면 null 가능defaultValue로 값이 안들어오면 기본 값 설정 가능(이때는 required 불필요), 참고로 “”도 기본값으로 대체해줌 - “ “이거도 걸러주는지 확인필요@GetMapping\tpublic String test(@RequestParam(defaultValue = \"ss\") String test) {\t\tSystem.out.println(test);\t\treturn \"ok\";\t}localhost:8250?test → defaultValue로 변환됨localhost:8250?test=s → 변환안됨localhost:8250?test= → 변환됨localhost:8250?test= (띄어쓰기있음) → 변환안됨null, “” 체크는 해주나 “ “는 체크안해주는거같음!요청 파라미터가 많으면 Map&lt;String, Object&gt; 식으로 받아서 파라미터명으로 값을 꺼내오는 것도 가능HTTP 요청파라미터 - @ModelAttribute@RequestParam으로 객체의 요소를 받는다면 굳이 RequestParam을 쓰지않고 @ModelAttribute Dto 이런식으로 바로 매핑가능단, setter가 필요하며 param과 객체의 멤버변수 이름이 동일해야함(다르면 네임 설정 가능함)물론 타입에러는 bindException이 발생함.또한 @RequestParam처럼 @ModelAttribute 자체도 생략가능함.생략 시 String, int, Integer처럼 단순 타입은 @RequestParam으로,argument resolver로 지정한 타입 외에는 @ModelAttribute로 매핑됨HTTP 요청 메세지 - 단순 텍스트@PostMapping(\"/v1\")public void requestBodyString(HttpServletRequest request, HttpServletResponse response) throws IOException {\t\tServletInputStream inputStream = request.getInputStream();\t\tString messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);\t\tresponse.getWriter().write(messageBody);}@PostMapping(\"/v2\")public void requestBodyString(InputStream inputStream, Writer response) throws IOException {\t\tString messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);\t\tresponse.write(messageBody);}@PostMapping(\"/v3\")public HttpEntity&lt;String&gt; requestBodyString(HttpEntity&lt;String&gt; httpEntity) throws IOException {\t\tString messageBody = httpEntity.getBody();\t\treturn new HttpEntity&lt;&gt;(messageBody);}참고로 HttpEntity는 요청파라미터를 조회하는 기능(@RequestParam, @ModelAttribute 와는 관련x)HttpEntity대신 RequestEntity, ResponseEntity를 사용하면 더 다양한 기능을 사용할 수 있음. HttpEntity를 상속받는 애들임. 예를들어 ResponseEntity는 상태코드 설정 가능여기서 제일 최종 버전이 @RequestBody String임컨트롤러 앞에 @ResponseBody를 사용하면 return 타입을 응답코드에 넣어서 반환해줌HTTP 요청 메세지 - JSONprivate ObjectMapper objectMapper = new ObjectMapper();@PostMapping(\"/v1\")public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException {\tServletInputStream inputStream = request.getInputStream();\tString messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);\tHelloData helloData = objectMapper.readValue(messageBody, HelloData.class);\tresponse.getWriter().write(\"OK\");}@PostMapping(\"/v2\")public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException {\tHelloData helloData = objectMapper.readValue(messageBody, HelloData.class);\treturn \"OK\";}@PostMapping(\"/v3\")public String requestBodyJsonV2(@RequestBody HelloData helloData) throws IOException {\treturn \"OK\";}참고로 @RequestBody는 생략 불가능함생략하면 @ModelAttribute가 적용됨requestBody랑 ModelAttribute는 primitive type 처리하는게 조금 다름정적 리소스/static, /public, /resources, /META-INF/resources 에 있는 정적 리소스 제공뷰 템플릿뷰템플릿을 거쳐서 HTML 생성, 뷰가 응답을 만들어서 전달타임리프에 데이터 바인딩하는 그거 말하는거임return타입 String에 html경로 적어서 반환해주고 model에 데이터 값 넣어서 보내주던 그거ㅇ만약 컨트롤러에 ResponseBody어노테이션 붙이면 그냥 경로가 String으로 화면에 출력됨권장하지는 않으나 void로 매핑주소자체를 뷰의 논리적 경로로 만들어주면 매핑이되긴함. 불명확해서 권장안함!HTTP 응답 - HTTP API, 메세지 바디에 직접 입력@ResponseStatus사용하면 ResponseEntity를 반환타입으로 안해줘도 상태코드 지정 가능함대신 ResponseStatus는 동적으로 상태코드를 변경하지는 못함HTTP 메세지 컨버터@ResponseBody를 사용하면 viewReslover대신에 HttpMessageConverter가 동작함  기본 문자 처리 : String HttpMessageConverter  기본 객체 처리 : MappingJacson2HttpMessageConverter(ObjactMapper같은거?)  byte처리 등 기타 여러 HttpMessageConverter가 기본등록클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 선택됨⇒ 스프링 MVC에서는 요청에는 @RequestBody, HttpEntity(RequestEntity), 응답에는 @ResponseBody, HttpEntity(ResponseEntity)인 경우 HttpMessageConverter를 적용함HttpMessageConverter는 HTTP 요청, HTTP 응답 둘다 사용함  canRead(), canWrite() : 메세지 컨버터가 해당 클래스, 미디어타입을 지원하는지 체크.          canRead() : 메세지 컨버터가 해당 메세지를 읽을 수 있는지 확인하기 위해 호출                  대상 클래스 타입을 지원?  예) @RequestBody 의 대상 클래스 ( byte[] , String , HelloData )          HTTP 요청의 Content-Type 미디어 타입을 지원하는가                    canWrite() : 메세지 컨버터가 해당 메세지를 쓸 수 있는지 확인하기 위해 호출                  대상 클래스 타입을 지원하는가.  예) return의 대상 클래스 ( byte[] , String , HelloData )          HTTP 요청의 Accept 미디어 타입을 지원하는가.(더 정확히는 @RequestMapping 의 produces )  예) text/plain , application/json , /                      read(), write() : 메세지 컨버터를 통해서 메세지를 읽고 쓰는 기능          read() : canRead()조건을 만족하면 호출해서 객체를 생성, 반환      write() : canWrite()조건을 만족하면 호출해서 HTTP 응답 메세지 바디에 데이터를 생성      대상 클래스 타입과 미디어타입 체크 → 사용여부 결정(만족안하면 다음 메세지 컨버터로 우선순위 밀림)  ByteArrayHttpMessageConverter : byte[] 데이터를 처리          클래스 타입: byte[] , 미디어타입: _/_      요청 예) @RequestBody byte[] data      응답 예) @ResponseBody return byte[] 쓰기 미디어타입 application/octet-stream        StringHttpMessageConverter : String 문자로 데이터를 처리          클래스 타입: String , 미디어타입: _/_      요청 예) @RequestBody String data      응답 예) @ResponseBody return “ok” 쓰기 미디어타입 text/plain        MappingJackson2HttpMessageConverter : application/json          클래스 타입: 객체 또는 HashMap , 미디어타입 application/json 관련      요청 예) @RequestBody HelloData data      응답 예) @ResponseBody return helloData 쓰기 미디어타입 application/json 관련      요청 매핑 헨들러 어뎁터 구조핸들러 = 컨트롤러 라고 생각하면됨  v3용 어댑터가 필요한지 v4용 어댑터가 필요한지 찾는과정3~4. 프론트 컨트롤러에서 핸들러(컨트롤러)를 바로 호출할 수 없기때문에 찾아온 어댑터를 사이에 두고 핸들러를 호출함  핸들러가 만들어준 modelview를 반환받음HTTP 메세지 컨버터는 핸들러 어뎁터와 관련있음. @RequestMapping을 처리하는 핸들러 어뎁터인 RequestMappingHandlerAdapter는 아래와 같이 동작함      Argument Resolver    컨트롤러가 매우 다양한 파라미터(HttpServletRequest, Model, @RequestParam, @RequestBody, HttpEntity, @ModelAttribute 등)를 처리할 수 있도록 해줌  RequestMappingHandlerAdapter에서 필요한 파라미터 값(객체)를 ArgumentResolver가 생성하서 넘겨줌. 필요한 파라미터를 생성하기위해 RequestMappingHandlerAdapter가 ArgumentResolver를 호출함. 호출 후 필요한 파라미터값이 모두 준비되면 컨트롤러를 호출해서 값을 넘겨줌  만약 @RequestBody나 HttpEntity라면 HTTP메세지 컨버터까지 사용  ArgumentResolver의 supportsParameter()를 호출해서 해당 파라미터를 지원하는지 체크, 지원하면 resolveArgument()를 호출해서 실제 객체 생성 → 컨트롤러로 전달  원한다면 인터페이스 확장해서 원하는 ArgumentResolver를 만들 수 있음        ReturnValueHandler    HandlerMethodReturnValueHandler를 줄여서 ReturnValueHandler라고 부름  ArgumentResolver와 비슷하나 응답값을 변환하고 처리하는 차이점.  컨트롤러에서 뷰이름 반환을 String으로 해도 동작하는 이유  만약 @ResponeBody나 HttpEntity라면 HTTP메세지 컨버터까지 사용    [!important]HandlerMethodArgumentResolverHandlerMethodReturnValueHandlerHttpMessageConverter는 모두 인터페이스로 제공. 필요하면 확장 가능(거의 쓸일 없음)  @Bean  public WebMvcConfigurer webMvcConfigurer() {  \treturn new WebMvcConfigurer() {  \t\t@Override  \t\tpublic void addArgumentResolvers(List&lt; HandlerMethodArgumentResolver&gt;  \t\tresolvers) {  \t\t//...  \t\t} \t\t@Override  \t\tpublic void extendMessageConverters(List&lt;HttpMessageConverter&lt; ?&gt;&gt;  \t\tconverters) {  \t\t//...  \t\t}  \t};  }\t  "
  },
  
  {
    "title": "[김영한 스프링 MVC 1] MVC 프레임워크",
    "url": "/posts/MVC_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-06-11 00:00:00 +0900",
    





    
    "snippet": "프론트 컨트롤러 도입프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받아 요청에맞는 컨트롤러를 호출(컨트롤러는 서블릿필요없음)package com.mvc1.servlet.web.frontController.v1.controller;import java.io.IOException;import com.mvc1.servlet.web.frontControl...",
    "content": "프론트 컨트롤러 도입프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받아 요청에맞는 컨트롤러를 호출(컨트롤러는 서블릿필요없음)package com.mvc1.servlet.web.frontController.v1.controller;import java.io.IOException;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberFormControllerV1 implements ControllerV1 {\t@Override\tpublic void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tString viewPath = \"/WEB-INF/views/new-form.jsp\"; //jsp생성\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); //컨트롤러-&gt;뷰 이동시 사용\t\tdispatcher.forward(request, response); //서블릿에서 jsp호출\t}}package com.mvc1.servlet.web.frontController.v1.controller;import java.io.IOException;import java.util.List;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberListControllerV1 implements ControllerV1 {\tMemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tSystem.out.println(\"MvcMemberListServlet.service\");\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\trequest.setAttribute(\"members\", members);\t\tSystem.out.println(members.get(0));\t\tString viewPath = \"/WEB-INF/views/members.jsp\";\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);\t\tdispatcher.forward(request, response);\t}}package com.mvc1.servlet.web.frontController.v1.controller;import java.io.IOException;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberSaveControllerV1 implements ControllerV1 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tString username = request.getParameter(\"username\");\t\tint age = Integer.parseInt(request.getParameter(\"age\"));\t\tMember member = new Member(username, age);\t\tSystem.out.println(\"member = \" + member);\t\tmemberRepository.save(member);\t\t//Model에 데이터를 보관한다.\t\trequest.setAttribute(\"member\", member);\t\tString viewPath = \"/WEB-INF/views/save-result.jsp\";\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);\t\tdispatcher.forward(request, response);\t}}package com.mvc1.servlet.web.frontController.v1;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.v1.controller.MemberFormControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberListControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberSaveControllerV1;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV1\", urlPatterns = \"/front-controller/v1/*\")public class FrontControllerServletV1 extends HttpServlet {\tprivate Map&lt;String, ControllerV1&gt; controllerMap = new HashMap&lt;&gt;();\tpublic FrontControllerServletV1() {\t\tcontrollerMap.put(\"/front-controller/v1/members/new-form\", new MemberFormControllerV1());\t\tcontrollerMap.put(\"/front-controller/v1/members/save\", new MemberSaveControllerV1());\t\tcontrollerMap.put(\"/front-controller/v1/members\", new MemberListControllerV1());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV1.service\");\t\tString requestURI = req.getRequestURI();\t\tControllerV1 controller = controllerMap.get(requestURI);\t\tif(controller == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\tcontroller.process(req, resp);\t}}컨트롤러→뷰 부분의 중복이있음⇒ 뷰를 처리하는 객체 생성View 분리package com.mvc1.servlet.web.frontController;import java.io.IOException;import javax.swing.text.View;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MyView {\tprivate String viewPath;\tpublic MyView(String viewPath) {\t\tthis.viewPath = viewPath;\t}\tpublic void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);\t\tdispatcher.forward(request, response);\t}}package com.mvc1.servlet.web.frontController.v2.controller;import java.io.IOException;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberFormControllerV2 implements ControllerV2 {\t@Override\tpublic MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\treturn new MyView(\"/WEB-INF/views/new-form.jsp\");\t}}package com.mvc1.servlet.web.frontController.v2.controller;import java.io.IOException;import java.util.List;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberListControllerV2 implements ControllerV2 {\tMemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tSystem.out.println(\"MvcMemberListServlet.service\");\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\trequest.setAttribute(\"members\", members);\t\tSystem.out.println(members.get(0));\t\treturn new MyView(\"/WEB-INF/views/members.jsp\");\t}}package com.mvc1.servlet.web.frontController.v2.controller;import java.io.IOException;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberSaveControllerV2 implements ControllerV2 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tString username = request.getParameter(\"username\");\t\tint age = Integer.parseInt(request.getParameter(\"age\"));\t\tMember member = new Member(username, age);\t\tSystem.out.println(\"member = \" + member);\t\tmemberRepository.save(member);\t\t//Model에 데이터를 보관한다.\t\trequest.setAttribute(\"member\", member);\t\treturn new MyView(\"/WEB-INF/views/save-result.jsp\");\t}}package com.mvc1.servlet.web.frontController.v2;import java.io.IOException;import java.util.HashMap;import java.util.Map;import javax.swing.text.View;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberFormControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberListControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberSaveControllerV1;import com.mvc1.servlet.web.frontController.v2.controller.MemberFormControllerV2;import com.mvc1.servlet.web.frontController.v2.controller.MemberListControllerV2;import com.mvc1.servlet.web.frontController.v2.controller.MemberSaveControllerV2;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV2\", urlPatterns = \"/front-controller/v2/*\")public class FrontControllerServletV2 extends HttpServlet {\tprivate Map&lt;String, ControllerV2&gt; controllerMap = new HashMap&lt;&gt;();\tpublic FrontControllerServletV2() {\t\tcontrollerMap.put(\"/front-controller/v2/members/new-form\", new MemberFormControllerV2());\t\tcontrollerMap.put(\"/front-controller/v2/members/save\", new MemberSaveControllerV2());\t\tcontrollerMap.put(\"/front-controller/v2/members\", new MemberListControllerV2());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV2.service\");\t\tString requestURI = req.getRequestURI();\t\tControllerV2 controller = controllerMap.get(requestURI);\t\tif(controller == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\tMyView process = controller.process(req, resp);\t\tprocess.render(req, resp);\t}}MyView의 render를 공통 로직으로 처리해서 깔끔해짐. 컨트롤러에서 MyView객체를 생성해서 반환하기만하면됨그런데 컨트롤러에서 HttpServletRequest req, HttpServletResponse resp를 안쓰는 경우도 있음 → request를 Model로 사용하는 대신 별도의 Model객체 생성 후 반환하면 됨Model 추가컨트롤러가 서블릿을 사용하지 않고 뷰 이름 중복 제거할거임package com.mvc1.servlet.web.frontController.v3;import java.util.HashMap;import java.util.Map;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class ModelView {\tprivate String viewPath;\tprivate Map&lt;String, Object&gt; model = new HashMap&lt;&gt;();\tpublic ModelView(String viewPath) {\t\tthis.viewPath = viewPath;\t}}package com.mvc1.servlet.web.frontController.v3;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberFormControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberListControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberSaveControllerV3;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV3\", urlPatterns = \"/front-controller/v3/*\")public class FrontControllerServletV3 extends HttpServlet {\tprivate Map&lt;String, ControllerV3&gt; controllerMap = new HashMap&lt;&gt;();\tpublic FrontControllerServletV3() {\t\tcontrollerMap.put(\"/front-controller/v3/members/new-form\", new MemberFormControllerV3());\t\tcontrollerMap.put(\"/front-controller/v3/members/save\", new MemberSaveControllerV3());\t\tcontrollerMap.put(\"/front-controller/v3/members\", new MemberListControllerV3());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV3.service\");\t\tString requestURI = req.getRequestURI();\t\tControllerV3 controller = controllerMap.get(requestURI);\t\tif(controller == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\tMap&lt;String, String&gt; paramMap = createParamMap(req); //받은 파라미터를 map으로 전환\t\tModelView mv = controller.process(paramMap); //해당 controller에서 viewPath세팅, model 세팅\t\t//논리이름 -&gt; 물리이름\t\tString viewPath = mv.getViewPath();\t\tMyView myView = viewResolver(viewPath);\t\tmyView.render(mv.getModel(), req, resp); //반환할 데이터 세팅\t}\tprivate static MyView viewResolver(String viewPath) {\t\treturn new MyView(\"/WEB-INF/views/\" + viewPath + \".jsp\");\t}\tprivate static Map&lt;String, String&gt; createParamMap(HttpServletRequest req) {\t\tMap&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();\t\treq.getParameterNames().asIterator()\t\t\t.forEachRemaining(paramName -&gt; paramMap.put(paramName, req.getParameter(paramName)));\t\treturn paramMap;\t}}package com.mvc1.servlet.web.frontController.v3.controller;import java.io.IOException;import java.util.Map;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberFormControllerV3 implements ControllerV3 {\t@Override\tpublic ModelView process(Map&lt;String, String&gt; paramMap) {\t\treturn new ModelView(\"new-form\");\t}}package com.mvc1.servlet.web.frontController.v3.controller;import java.io.IOException;import java.util.List;import java.util.Map;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberListControllerV3 implements ControllerV3 {\tMemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic ModelView process(Map&lt;String, String&gt; paramMap) {\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\tModelView modelView = new ModelView(\"members\");\t\tmodelView.getModel().put(\"members\", members);\t\treturn modelView;\t}}package com.mvc1.servlet.web.frontController.v3.controller;import java.io.IOException;import java.util.Map;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberSaveControllerV3 implements ControllerV3 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic ModelView process(Map&lt;String, String&gt; paramMap) {\t\tString username = paramMap.get(\"username\");\t\tint age = Integer.parseInt(paramMap.get(\"age\"));\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tModelView modelView = new ModelView(\"save-result\");\t\tmodelView.getModel().put(\"member\", member);\t\treturn modelView;\t}}package com.mvc1.servlet.web.frontController.v3;import java.util.Map;public interface ControllerV3 {\tModelView process(Map&lt;String, String&gt; paramMap);}ModelView객체 생성, 반환 부분이 번거로움(실용성x)⇒ 컨트롤러가 ViewName만 반환하도록 변경실용적인 컨트롤러package com.mvc1.servlet.web.frontController.v4;import java.util.Map;public interface ControllerV4 {\t/**\t *\t * @param paramMap\t * @param model\t * @return\t */\tString process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model);}package com.mvc1.servlet.web.frontController.v4.controller;import java.util.Map;import com.mvc1.servlet.web.frontController.v4.ControllerV4;public class MemberFormControllerV4 implements ControllerV4 {\t@Override\tpublic String process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model) {\t\treturn \"new-form\";\t}}package com.mvc1.servlet.web.frontController.v4.controller;import java.util.List;import java.util.Map;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v3.ModelView;import com.mvc1.servlet.web.frontController.v4.ControllerV4;public class MemberListControllerV4 implements ControllerV4 {\tMemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic String process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model) {\t\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\t\tModelView modelView = new ModelView(\"members\");\t\t\tmodelView.getModel().put(\"members\", members);\t\t\treturn \"members\";\t}}package com.mvc1.servlet.web.frontController.v4.controller;import java.util.Map;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v4.ControllerV4;public class MemberSaveControllerV4 implements ControllerV4 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic String process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model) {\t\tString username = paramMap.get(\"username\");\t\tint age = Integer.parseInt(paramMap.get(\"age\"));\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tmodel.put(\"member\", member);\t\treturn \"save-result\";\t}}package com.mvc1.servlet.web.frontController.v4;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v4.controller.MemberFormControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberListControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberSaveControllerV4;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV4\", urlPatterns = \"/front-controller/v4/*\")public class FrontControllerServletV4 extends HttpServlet {\tprivate Map&lt;String, ControllerV4&gt; controllerMap = new HashMap&lt;&gt;();\tpublic FrontControllerServletV4() {\t\tcontrollerMap.put(\"/front-controller/v4/members/new-form\", new MemberFormControllerV4());\t\tcontrollerMap.put(\"/front-controller/v4/members/save\", new MemberSaveControllerV4());\t\tcontrollerMap.put(\"/front-controller/v4/members\", new MemberListControllerV4());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV4.service\");\t\tString requestURI = req.getRequestURI();\t\tControllerV4 controller = controllerMap.get(requestURI);\t\tif(controller == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\tMap&lt;String, String&gt; paramMap = createParamMap(req); //받은 파라미터를 map으로 전환\t\tMap&lt;String, Object&gt; model = new HashMap&lt;&gt;(); //추가된부분\t\tString viewName = controller.process(paramMap, model);//해당 controller에서 viewPath세팅, model 세팅\t\tMyView myView = viewResolver(viewName);\t\tSystem.out.println(myView.getViewPath());\t\tmyView.render(model, req, resp); //반환할 데이터 세팅\t}\tprivate static MyView viewResolver(String viewPath) {\t\treturn new MyView(\"/WEB-INF/views/\" + viewPath + \".jsp\");\t}\tprivate static Map&lt;String, String&gt; createParamMap(HttpServletRequest req) {\t\tMap&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();\t\treq.getParameterNames().asIterator()\t\t\t.forEachRemaining(paramName -&gt; paramMap.put(paramName, req.getParameter(paramName)));\t\treturn paramMap;\t}}v3와 거의 동일하나 model을 frontcontroller에서 생성한 후 controller의 반환타입을 String으로 변경한게 다임그러나 모양이 정해져있다는것이 단점임. 예를들면 private Map&lt;String, ControllerV4&gt; controllerMap = new HashMap&lt;&gt;(); 이부분 controller의 버전을 4로 고정시킨게 단점이라는거같음. 유연하지 못하다? 뭐 그런..;;⇒ 어댑터 사용으로 해결유연한 컨트롤러어댑터 패턴으로 다양한 인터페이스를 사용가능하도록 구현핸들러 = 컨트롤러 라고 생각하면됨  v3용 어댑터가 필요한지 v4용 어댑터가 필요한지 찾는과정3~4. 프론트 컨트롤러에서 핸들러(컨트롤러)를 바로 호출할 수 없기때문에 찾아온 어댑터를 사이에 두고 핸들러를 호출함  핸들러가 만들어준 modelview를 반환받음== 중간에 핸들러 어댑터가 추가되었기때문에 v1~v4컨트롤러까지 모두 호출가능함package com.mvc1.servlet.web.frontController.v5;import java.io.IOException;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public interface MyHandlerAdepter {\tboolean supports(Object handler);\tModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException;}package com.mvc1.servlet.web.frontController.v5.adepter;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import com.mvc1.servlet.web.frontController.v5.MyHandlerAdepter;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class ControllerV3HandlerAdapter implements MyHandlerAdepter {\t@Override\tpublic boolean supports(Object handler) {\t\treturn (handler instanceof ControllerV3); //controllerV3를 구현한 무언가가 들어오면 true반환\t}\t@Override\tpublic ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {\t\tControllerV3 controller = (ControllerV3) handler; //supports를 먼저 호출해서 검사한 후 실행할거임. 캐스팅해도됨\t\tMap&lt;String, String&gt; paramMap = createParamMap(request);\t\tModelView mv = controller.process(paramMap);\t\treturn mv;\t}\tprivate Map&lt;String, String&gt; createParamMap(HttpServletRequest req) {\t\tMap&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();\t\treq.getParameterNames().asIterator()\t\t\t.forEachRemaining(paramName -&gt; paramMap.put(paramName, req.getParameter(paramName)));\t\treturn paramMap;\t}}package com.mvc1.servlet.web.frontController.v5.adepter;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import com.mvc1.servlet.web.frontController.v4.ControllerV4;import com.mvc1.servlet.web.frontController.v5.MyHandlerAdepter;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class ControllerV4HandlerAdapter implements MyHandlerAdepter {\t@Override\tpublic boolean supports(Object handler) {\t\treturn (handler instanceof ControllerV4);\t}\t@Override\tpublic ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {\t\tControllerV4 controller = (ControllerV4) handler; //supports를 먼저 호출해서 검사한 후 실행할거임. 캐스팅해도됨\t\tMap&lt;String, String&gt; paramMap = createParamMap(request);\t\tMap&lt;String, Object&gt; model = new HashMap&lt;&gt;();\t\t//반환타입 안맞아서 ModelView로 반환하기위한 작업임\t\tString viewName = controller.process(paramMap, model);\t\tModelView mv = new ModelView(viewName);\t\tmv.setModel(model);\t\treturn mv;\t}\tprivate Map&lt;String, String&gt; createParamMap(HttpServletRequest req) {\t\tMap&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();\t\treq.getParameterNames().asIterator()\t\t\t.forEachRemaining(paramName -&gt; paramMap.put(paramName, req.getParameter(paramName)));\t\treturn paramMap;\t}}package com.mvc1.servlet.web.frontController.v5;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import com.mvc1.servlet.web.frontController.v3.controller.MemberFormControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberListControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberSaveControllerV3;import com.mvc1.servlet.web.frontController.v4.ControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberFormControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberListControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberSaveControllerV4;import com.mvc1.servlet.web.frontController.v5.adepter.ControllerV3HandlerAdapter;import com.mvc1.servlet.web.frontController.v5.adepter.ControllerV4HandlerAdapter;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV5\", urlPatterns = \"/front-controller/v5/*\")public class FrontControllerServletV5 extends HttpServlet {\tprivate final Map&lt;String, Object&gt; handlerMappingMap = new HashMap&lt;&gt;();\tprivate final List&lt;MyHandlerAdepter&gt; handlerAdapters = new ArrayList&lt;&gt;();\tpublic FrontControllerServletV5() {\t\tinitHandlerMappingMap();\t\tinitHandlerAdapters();\t}\tprivate void initHandlerAdapters() {\t\thandlerAdapters.add(new ControllerV3HandlerAdapter());\t\thandlerAdapters.add(new ControllerV4HandlerAdapter());\t}\tprivate void initHandlerMappingMap() {\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members/new-form\", new MemberFormControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members/save\", new MemberSaveControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members\", new MemberListControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members/new-form\", new MemberFormControllerV4());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members/save\", new MemberSaveControllerV4());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members\", new MemberListControllerV4());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV3.service\");\t\t//1. handler 조회\t\t//Controller 버전에 맞는 구현체를 가져옴 (ex.MemberFormControllerV3)\t\tObject handler = getHandler(req);\t\tif(handler == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\t//2. handler 목록에서 핸들러를 처리할 수 있는 handler adapter 조회\t\t//해당하는 버전의 handler adapter가 반환됨 (ex.ControllerV3HandlerAdapter)\t\tMyHandlerAdepter adapter = getHandlerAdapter(handler);\t\t//3. handler를 통해 controller 호출\t\tModelView mv = adapter.handle(req, resp, handler);\t\t/*\t\thandler를 해당 버전의 controller로 캐스팅 -&gt; ModelView반환\t\t여기서 실질적인 로직을 호출 한 후 데이터가 세팅됨\t\t */\t\tString viewPath = mv.getViewPath();\t\tMyView myView = viewResolver(viewPath);\t\tSystem.out.println(myView.getViewPath());\t\tmyView.render(mv.getModel(), req, resp); //반환할 데이터 세팅\t}\tprivate MyHandlerAdepter getHandlerAdapter(Object handler) {\t\tfor (MyHandlerAdepter adapter : handlerAdapters) {\t\t\tif(adapter.supports(handler)) {\t\t\t\treturn adapter;\t\t\t}\t\t}\t\tthrow new IllegalArgumentException(\"handler adapter를 찾을 수 없음. handler = \"+handler);\t}\tprivate Object getHandler(HttpServletRequest req) {\t\tString requestURI = req.getRequestURI();\t\treturn handlerMappingMap.get(requestURI);\t}\tprivate static MyView viewResolver(String viewPath) {\t\treturn new MyView(\"/WEB-INF/views/\" + viewPath + \".jsp\");\t}}frontController하나로 여러 interface의 구현체를 받아서 처리가능함.만약 controller interface가 추가된다하더라도 frontController는\tprivate void initHandlerAdapters() {\t\thandlerAdapters.add(new ControllerV3HandlerAdapter());\t\thandlerAdapters.add(new ControllerV4HandlerAdapter());\t}\tprivate void initHandlerMappingMap() {\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members/new-form\", new MemberFormControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members/save\", new MemberSaveControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members\", new MemberListControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members/new-form\", new MemberFormControllerV4());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members/save\", new MemberSaveControllerV4());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members\", new MemberListControllerV4());\t}이 부분만 추가해주면 되는거임!!여기에 어노테이션을 사용하면 더 편리하게 발전시킬수도있음(어노테이션[RequestMappingHandlerAdapter]을 지원하는 어댑터를 추가하면됨)이 구조가 spring MVC구조 와 동일함frontController → DispatcherServlethandlerMappingMap → HandlerMappingMyHandlerAdapter → HandlerAdapterModelView → ModelAndViewviewResolver → ViewResolverMyView → View(interface)"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 서블릿, MVC, JSP",
    "url": "/posts/%EC%84%9C%EB%B8%94%EB%A6%BF_mvc_jsp/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-05-29 00:00:00 +0900",
    





    
    "snippet": "동시성 문제 고려안하고 진행(고려시 ConcurrentHashMap, AtomicLong사용을 고려해야함)package com.mvc1.servlet.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstruct...",
    "content": "동시성 문제 고려안하고 진행(고려시 ConcurrentHashMap, AtomicLong사용을 고려해야함)package com.mvc1.servlet.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Member {    private Long id;    private String username;    private int age;}package com.mvc1.servlet.domain;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class MemberRespository {    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();    private static Long seq = 0L;    private static final MemberRespository instance = new MemberRespository();    public static MemberRespository getInstance(){ //싱글톤(사실 싱글톤이라서 위에 static빼도됨)        return instance;    }    private MemberRespository(){    }    public Member save(Member member){        member.setId(seq);        store.put(member.getId(), member);        seq++;        return member;    }    public Member findById(Long id){        return store.get(id);    }    public List&lt;Member&gt; findAll(){        return new ArrayList&lt;&gt;(store.values());    }}package com.mvc1.servlet.domain;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class MemberRepository {    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();    private static Long seq = 0L;    private static final MemberRepository instance = new MemberRepository();    public static MemberRepository getInstance(){ //싱글톤(사실 싱글톤이라서 위에 static빼도됨)        return instance;    }    private MemberRepository(){    }    public Member save(Member member){        member.setId(seq);        store.put(member.getId(), member);        seq++;        return member;    }    public Member findById(Long id){        return store.get(id);    }    public List&lt;Member&gt; findAll(){        return new ArrayList&lt;&gt;(store.values());    }    public void clearStore(){        store.clear();    }}package com.mvc1.servlet.domain;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.*;@SpringBootTestclass MemberRepositoryTest {    MemberRepository mRepo = MemberRepository.getInstance();    @AfterEach()    void afterEach(){        mRepo.clearStore();    }    @Test    void save(){        Member member = new Member(\"hello\", 20);        Member saveMember = mRepo.save(member);        Member findMember = mRepo.findById(saveMember.getId());        assertThat(findMember).isEqualTo(saveMember);    }    @Test    void findAll(){        Member member = new Member(\"hello\", 20);        Member member2 = new Member(\"hello\", 20);        mRepo.save(member);        mRepo.save(member2);        List&lt;Member&gt; result = mRepo.findAll();        assertThat(result.size()).isEqualTo(2);    }}서블릿package com.mvc1.servlet.web;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name=\"memberFormServlet\", urlPatterns = \"/servlet/members/new-form\")public class MemberFormServlet extends HttpServlet {    MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        response.setContentType(\"text/html\");        response.setCharacterEncoding(\"utf-8\");        PrintWriter w = response.getWriter();        w.write(\"&lt;!DOCTYPE html&gt;\\n\" +                \"&lt;html&gt;\\n\" +                \"&lt;head&gt;\\n\" +                \" &lt;meta charset=\\\"UTF-8\\\"&gt;\\n\" +                \" &lt;title&gt;Title&lt;/title&gt;\\n\" +                \"&lt;/head&gt;\\n\" +                \"&lt;body&gt;\\n\" +                \"&lt;form action=\\\"/servlet/members/save\\\" method=\\\"post\\\"&gt;\\n\" +                \" username: &lt;input type=\\\"text\\\" name=\\\"username\\\" /&gt;\\n\" +                \" age: &lt;input type=\\\"text\\\" name=\\\"age\\\" /&gt;\\n\" +                \" &lt;button type=\\\"submit\\\"&gt;전송&lt;/button&gt;\\n\" +                \"&lt;/form&gt;\\n\" +                \"&lt;/body&gt;\\n\" +                \"&lt;/html&gt;\\n\");    }}package com.mvc1.servlet.web;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name=\"memberSaveServlet\", urlPatterns = \"/servlet/members/save\")public class MemberSaveServlet extends HttpServlet {    MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println(\"MemberSaveServlet.service\");        String username = request.getParameter(\"username\");        int age = Integer.parseInt(request.getParameter(\"age\"));        Member member = new Member(username, age);        System.out.println(\"member = \" + member);        memberRepository.save(member);        response.setContentType(\"text/html\");        response.setCharacterEncoding(\"utf-8\");        PrintWriter w = response.getWriter();        w.write(\"&lt;html&gt;\\n\" +                \"&lt;head&gt;\\n\" +                \" &lt;meta charset=\\\"UTF-8\\\"&gt;\\n\" +                \"&lt;/head&gt;\\n\" +                \"&lt;body&gt;\\n\" +                \"성공\\n\" +                \"&lt;ul&gt;\\n\" +                \" &lt;li&gt;id=\"+member.getId()+\"&lt;/li&gt;\\n\" +                \" &lt;li&gt;username=\"+member.getUsername()+\"&lt;/li&gt;\\n\" +                \" &lt;li&gt;age=\"+member.getAge()+\"&lt;/li&gt;\\n\" +                \"&lt;/ul&gt;\\n\" +                \"&lt;a href=\\\"/index.html\\\"&gt;메인&lt;/a&gt;\\n\" +                \"&lt;/body&gt;\\n\" +                \"&lt;/html&gt;\");    }}package com.mvc1.servlet.web;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.List;@WebServlet(name=\"memberListServlet\", urlPatterns = \"/servlet/members/list\")public class MemberListServlet extends HttpServlet {    MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        List&lt;Member&gt; members = memberRepository.findAll();        PrintWriter w = response.getWriter();        w.write(\"&lt;html&gt;\");        w.write(\"&lt;head&gt;\");        w.write(\" &lt;meta charset=\\\"UTF-8\\\"&gt;\");        w.write(\" &lt;title&gt;Title&lt;/title&gt;\");        w.write(\"&lt;/head&gt;\");        w.write(\"&lt;body&gt;\");        w.write(\"&lt;a href=\\\"/index.html\\\"&gt;메인&lt;/a&gt;\");        w.write(\"&lt;table&gt;\");        w.write(\" &lt;thead&gt;\");        w.write(\" &lt;th&gt;id&lt;/th&gt;\");        w.write(\" &lt;th&gt;username&lt;/th&gt;\");        w.write(\" &lt;th&gt;age&lt;/th&gt;\");        w.write(\" &lt;/thead&gt;\");        w.write(\" &lt;tbody&gt;\");        for (Member member : members) {            w.write(\" &lt;tr&gt;\");            w.write(\" &lt;td&gt;\" + member.getId() + \"&lt;/td&gt;\");            w.write(\" &lt;td&gt;\" + member.getUsername() + \"&lt;/td&gt;\");            w.write(\" &lt;td&gt;\" + member.getAge() + \"&lt;/td&gt;\");            w.write(\" &lt;/tr&gt;\");        }        w.write(\" &lt;/tbody&gt;\");        w.write(\"&lt;/table&gt;\");        w.write(\"&lt;/body&gt;\");        w.write(\"&lt;/html&gt;\");    }}…별거없음 근데 저 HTML을 어떻게 저렇게 다 해?? + 동적 불가능→ 템플릿 엔진사용(JSP, Thymeleaf, Freemaker, Velocity 등)JSPimplementation 'org.apache.tomcat.embed:tomcat-embed-jasper'implementation 'jakarta.servlet:jakarta.servlet-api' //스프링부트 3.0 이상implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api' //스프링부트 3.0 이상implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl' //스프링부트 3.0 이상gradle추가&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-29  Time: 오후 9:26  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=\"/jsp/members/save.jsp\" method=\"post\"&gt;        username: &lt;input type=\"text\" name=\"username\" /&gt;        age: &lt;input type=\"text\" name=\"age\" /&gt;        &lt;button type=\"submit\"&gt;전송&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;이게 인텔리제이에서 만들어준 jsp형식임. form만 붙인거&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;이게 있어야 jsp라는뜻&lt;%@ page import=\"com.mvc1.servlet.domain.Member\" %&gt;&lt;%@ page import=\"com.mvc1.servlet.domain.MemberRepository\" %&gt;&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-29  Time: 오후 9:34  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%  MemberRepository memberRepository = MemberRepository.getInstance();  String username = request.getParameter(\"username\");  int age = Integer.parseInt(request.getParameter(\"age\"));  Member member = new Member(username, age);  memberRepository.save(member);%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;  &lt;li&gt;id=&lt;%=member.getId()%&gt;&lt;/li&gt;  &lt;li&gt;username=&lt;%=member.getUsername()%&gt;&lt;/li&gt;  &lt;li&gt;age=&lt;%=member.getAge()%&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;% %&gt;부분이 자바 코드임reuquest, response는 import(맨위에 &lt;%@ page import ~~~%&gt; 부분)안해줘도 그냥 쓸수있음자바코드 출력은 &lt;%= ~~~ %&gt;로 해야함&lt;%@ page import=\"java.util.List\" %&gt;&lt;%@ page import=\"com.mvc1.servlet.domain.MemberRepository\" %&gt;&lt;%@ page import=\"com.mvc1.servlet.domain.Member\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%  MemberRepository memberRepository = MemberRepository.getInstance();  List&lt;Member&gt; members = memberRepository.findAll();%&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"/index.html\"&gt;메인&lt;/a&gt;&lt;table&gt;  &lt;thead&gt;  &lt;th&gt;id&lt;/th&gt;  &lt;th&gt;username&lt;/th&gt;  &lt;th&gt;age&lt;/th&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;%    for (Member member : members) {      out.write(\" &lt;tr&gt;\");      out.write(\" &lt;td&gt;\" + member.getId() + \"&lt;/td&gt;\");      out.write(\" &lt;td&gt;\" + member.getUsername() + \"&lt;/td&gt;\");      out.write(\" &lt;td&gt;\" + member.getAge() + \"&lt;/td&gt;\");      out.write(\" &lt;/tr&gt;\");    }  %&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;for문도 가능  [!important]변경주기가 다르다는 것이 중요함변경의 라이프사이클리 다른부분을 함께 관리하는 것은 좋지않음! - ui일부수정과 비지니스로직을 동시수정하는 일은 거의 없음MVC꼭 view에서 HTML파일을 생성하는것은 아니라고함. 엑셀이든 다른 것으로 생성하는것도 가능하다고package com.mvc1.servlet.web.servletmvc;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name=\"mvcMemberFormServlet\", urlPatterns = \"/servlet-mvc/members/new-form\")public class MvcMemberFormServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        String viewPath = \"/WEB-INF/views/new-form.jsp\"; //jsp생성        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); //컨트롤러-&gt;뷰 이동시 사용        dispatcher.forward(request, response); //서블릿에서 jsp호출    }}&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-30  Time: 오후 8:36  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 상대경로 사용, [현재 URL이 속한 계층 경로 + /save] --&gt;    &lt;!-- http://localhost:8080/servlet-mvc/members/save --&gt;    &lt;form action=\"save\" method=\"post\"&gt;        username: &lt;input type=\"text\" name=\"username\" /&gt;        age: &lt;input type=\"text\" name=\"age\" /&gt;        &lt;button type=\"submit\"&gt;전송&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;아 위 서블릿 주소로 들어갔을때 저 저 위치의 jsp파을을 실행한다는거구나!dispatcher.forward()가 다른 서블릿이나 JSP로 이동할 수 있는 기능임. 서버내부에서 다시 호출 발생위에서는 service호출 후 서버 내에서 재호출이 일어나는거임(클라이언트에 다시다녀오는게아님. redirect랑은 다름)참고로 컨트롤러를 거쳐서만 부르고싶다면(외부호출x)면아래처럼 WEB-INF폴더 안에 넣으면됨— 이까지 현재경로 servlet-mvc/members/savepackage com.mvc1.servlet.web.servletmvc;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"mvcMemberSaveServlet\", urlPatterns = \"/servlet-mvc/members/save\")public class MvcMemberSaveServlet extends HttpServlet {    private MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         String username = request.getParameter(\"username\");         int age = Integer.parseInt(request.getParameter(\"age\"));         Member member = new Member(username, age);         System.out.println(\"member = \" + member);         memberRepository.save(member);         //Model에 데이터를 보관한다.         request.setAttribute(\"member\", member);         String viewPath = \"/WEB-INF/views/save-result.jsp\";         RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);         dispatcher.forward(request, response);     } }&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-30  Time: 오후 9:01  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;성공&lt;ul&gt;  &lt;li&gt;id=${member.id}&lt;/li&gt;  &lt;li&gt;username=${member.username}&lt;/li&gt;  &lt;li&gt;age=${member.age}&lt;/li&gt;&lt;/ul&gt;&lt;a href=\"/index.html\"&gt;메인&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;%= request.getAttribute(“member”)%&gt; 로 모델에 저장한 member 를 꺼낼수는 있는데 너무 복잡해서 JSP의 ${} 으로 request의 arrtibute에 담긴 데이터를 조회함package com.mvc1.servlet.web.servletmvc;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(name = \"mvcMemberListServlet\", urlPatterns = \"/servlet-mvc/members\")public class MvcMemberListServlet extends HttpServlet {    private MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         System.out.println(\"MvcMemberListServlet.service\");         List&lt;Member&gt; members = memberRepository.findAll();        request.setAttribute(\"members\", members);        String viewPath = \"/WEB-INF/views/members.jsp\";        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);        dispatcher.forward(request, response);    }}&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-30  Time: 오후 9:08  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"/index.html\"&gt;메인&lt;/a&gt;&lt;table&gt;  &lt;thead&gt;  &lt;th&gt;id&lt;/th&gt;  &lt;th&gt;username&lt;/th&gt;  &lt;th&gt;age&lt;/th&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;c:forEach var=\"item\" items=\"${members}\"&gt;    &lt;tr&gt;      &lt;td&gt;${item.id}&lt;/td&gt;      &lt;td&gt;${item.username}&lt;/td&gt;      &lt;td&gt;${item.age}&lt;/td&gt;    &lt;/tr&gt;  &lt;/c:forEach&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;forEach를 사용해서 테이블 출력— 단점  컨트롤러의 중복(request에서 값 뽑기, viewPath 등)  response를 사용하지않아도 매개변수로 response를 적어줌  공통 처리 어려움→ 프론트 컨트롤러 패턴 도입 시 해결가능"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 서블릿",
    "url": "/posts/%EC%84%9C%EB%B8%94%EB%A6%BF/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링MVC1, 서블릿",
    "date": "2023-04-17 00:00:00 +0900",
    





    
    "snippet": "package com.mvc1.servlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletCom...",
    "content": "package com.mvc1.servlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;@ServletComponentScan //서블릿 자동등록@SpringBootApplicationpublic class ServletApplication {\tpublic static void main(String[] args) {\t\tSpringApplication.run(ServletApplication.class, args);\t}}package com.mvc1.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.ServletRequest;import jakarta.servlet.ServletResponse;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import java.io.IOException;@WebServlet(name=\"helloServlet\", urlPatterns = \"/hello\")public class HelloServlet extends HttpServlet {    @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        super.service(req, res);    }}서블릿이 호출되면 위에 작성한 서비스에서 호출됨별다른 추가설정없이localhost:8080/hello?userName=kim로 들어가면 아래와같이 콘솔에 찍힘!!추가로 response까지 설정해주고package com.mvc1.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.ServletRequest;import jakarta.servlet.ServletResponse;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import java.io.IOException;@WebServlet(name=\"helloServlet\", urlPatterns = \"/hello\")public class HelloServlet extends HttpServlet {    @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        System.out.println(\"test\");        System.out.println(\"req = \" + req);        System.out.println(\"res = \" + res);//        super.service(req, res);        String userName = req.getParameter(\"userName\");        System.out.println(userName);        res.setContentType(\"text/plain\");        res.setCharacterEncoding(\"utf-8\");        res.getWriter().write(\"hello\"+userName);    }}localhost:8080으로 들어가면이렇게뜸참고로req = org.apache.catalina.connector.RequestFacade@258ac8b6res = org.apache.catalina.connector.ResponseFacade@425275f1이거application.properties에 logging.level.org.apache.coyote.http11=debug 이거 해주면            ![[IMG-20240909114444-2.png      IMG-20240909114444-2.png]]      요청정보, 헤더정보 조회가능함근데 운영서버에서 이러면 성능저하될수도있음. 개발단계에서만 사용해야함추가로 HttpServletRequest객체는 여러가지 부가기능(임시저장소기능) 등을 지원함  [!important]HttpServletRequest, HttpServletResponse는 HTTP 요청메세지, 응답메세지를 편리하게 사용하도록 도와주는 객체임. HTTP 스펙에 대한 깊은이해없이는 제대로 이해할수없음HttpServletRequestpackage com.mvc1.servlet.request;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.Cookie;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(name=\"requestHeaderServlet\", urlPatterns = \"/request-header\")public class RequestHeaderServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        extracted(request);        printHeaders(request);        printHeaderUtils(request);        printEtc(request);    }    private static void extracted(HttpServletRequest request) {        System.out.println(\"--- REQUEST-LINE - start ---\");        System.out.println(\"request.getMethod() = \" + request.getMethod()); //GET        System.out.println(\"request.getProtocol() = \" + request.getProtocol()); //HTTP/1.1        System.out.println(\"request.getScheme() = \" + request.getScheme()); //http        // http://localhost:8080/request-header        System.out.println(\"request.getRequestURL() = \" + request.getRequestURL());        // /request-header        System.out.println(\"request.getRequestURI() = \" + request.getRequestURI());        //username=hi        System.out.println(\"request.getQueryString() = \" +                request.getQueryString());        System.out.println(\"request.isSecure() = \" + request.isSecure()); //https 사용유무        System.out.println(\"--- REQUEST-LINE - end ---\");        System.out.println();    }    private void printHeaders(HttpServletRequest request){        System.out.println(\"-------------------header start-----------------------\");        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();        //들어온 헤더 전체 조회하는 법//        while (headerNames.hasMoreElements()){//            String headerName = headerNames.nextElement();//            System.out.println(headerName+\": \"+ headerName);//        } 옛날방식        //요즘방식        request.getHeaderNames().asIterator().forEachRemaining(headerName-&gt; System.out.println(headerName+\": \"+ headerName));        System.out.println(\"-------------------header end-----------------------\");    }    private void printHeaderUtils(HttpServletRequest request){        System.out.println(\"--- Header 편의 조회 start ---\");        System.out.println(\"[Host 편의 조회]\");        System.out.println(\"request.getServerName() = \" +                request.getServerName()); //Host 헤더        System.out.println(\"request.getServerPort() = \" +                request.getServerPort()); //Host 헤더        System.out.println();        System.out.println(\"[Accept-Language 편의 조회]\");        request.getLocales().asIterator()                .forEachRemaining(locale -&gt; System.out.println(\"locale = \" +                        locale));        System.out.println(\"request.getLocale() = \" + request.getLocale());        System.out.println();        System.out.println(\"[cookie 편의 조회]\");        if (request.getCookies() != null) {            for (Cookie cookie : request.getCookies()) {                System.out.println(cookie.getName() + \": \" + cookie.getValue());            }        }        System.out.println();        System.out.println(\"[Content 편의 조회]\");        System.out.println(\"request.getContentType() = \" +                request.getContentType());        System.out.println(\"request.getContentLength() = \" +                request.getContentLength());        System.out.println(\"request.getCharacterEncoding() = \" +                request.getCharacterEncoding());        System.out.println(\"--- Header 편의 조회 end ---\");        System.out.println();    }    //기타 정보    private void printEtc(HttpServletRequest request) {        System.out.println(\"--- 기타 조회 start ---\");        System.out.println(\"[Remote 정보]\");        System.out.println(\"request.getRemoteHost() = \" +                request.getRemoteHost()); //        System.out.println(\"request.getRemoteAddr() = \" +                request.getRemoteAddr()); //        System.out.println(\"request.getRemotePort() = \" +                request.getRemotePort()); //        System.out.println();        System.out.println(\"[Local 정보]\");        System.out.println(\"request.getLocalName() = \" +                request.getLocalName()); //        System.out.println(\"request.getLocalAddr() = \" +                request.getLocalAddr()); //        System.out.println(\"request.getLocalPort() = \" +                request.getLocalPort()); //        System.out.println(\"--- 기타 조회 end ---\");        System.out.println();    }}어차피 위의 내용들은 log설정으로 쉽게볼수있는 정보라서 가볍게 보고 넘어가면 될듯?추가로포스트맨으로 이렇게 보내면이렇게나옴. post도되는구만;;GET 쿼리 파라미터package com.mvc1.servlet.request;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"requestParamServlet\", urlPatterns = \"/request-param\")public class RequestParamServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse            resp) throws ServletException, IOException {        System.out.println(\"[전체 파라미터 조회] - start\");        request.getParameterNames().asIterator()                .forEachRemaining(paramName -&gt; System.out.println(paramName +                        \"=\" + request.getParameter(paramName)));        System.out.println(\"[전체 파라미터 조회] - end\");        System.out.println();        System.out.println(\"[단일 파라미터 조회]\");        String username = request.getParameter(\"username\");        System.out.println(\"request.getParameter(username) = \" + username);        String age = request.getParameter(\"age\");        System.out.println(\"request.getParameter(age) = \" + age);        System.out.println();        System.out.println(\"[이름이 같은 복수 파라미터 조회]\");        System.out.println(\"request.getParameterValues(username)\");        String[] usernames = request.getParameterValues(\"username\");        for (String name : usernames) {            System.out.println(\"username=\" + name);        }        resp.getWriter().write(\"ok\");    }}이렇게 나옴❗만약!! username=kim&amp;username=hello(이렇게 중복으로 오는 경우는 거의 없긴함)이딴식으로 들어온다면? request.getParameter()는 1파람 1값일때만 사용해야해서 위의 예시에서는 request.getParameterValues()을 사용해야함. 참고로 request.getParameter()를 쓰면 request.getParameterValues()의 첫번째값을 가져옴아래 결과 참조. localhost:8080/request-param?username=hi&amp;username=aaa 로 넣음HTML Form 방식위의 get요청은 쿼리파라미터 형식으로 데이터가 전달되었으나 form으로 전달 시 메세지 바디에 직접 데이터를 담아서 전달됨.참고로 POST요청만 가능함(되는데도있는데 되는것처럼 보이는?거라서 그냥 POST로 하면됨)쿼리파라미터나 메세지바디나 형식은 같아서 같은방법으로 꺼낼 수 있음요부분만 다른듯?get일때는 저부분이 null이었음⇒ post html form으로 보내면 데이터가 어떤 형식인지 꼭!!!지정해줘야함!! 폼으로 전송하는 방식은 application/x-www-form-urlencoded 임(그 포스트맨에서 form데이터로 보내달라고 요청할때 x-www-form-urlencoded에서 예시를 보내줬는데 그래서 그렇구나싶은?)  x-www-form-urlencoded랑 form-data 차이          form-data - 일반적으로 바이너리 데이터(파일 같은)와 텍스트 데이터가 포함된 양식을 제출할 때 사용. 바이너리 데이터는 “Content-Disposition” 헤더로 식별되는 각각의 부분으로써 요청 바디에 별도로 전송. 파일 업로드와 같은 복잡한 작업에 적합      x-www-form-urlencoded - 가장 널리 사용되며 일반적으로 간단한 텍스트 데이터를 제출할 때 사용. 데이터는 &amp; 기호로 구분되는 키-값 쌍으로 인코딩, 각 키와 값은 “=” 기호로 구분폼 데이터를 전송하는 간단한 경우에 적합      raw - 요청 바디에서 데이터를 원시 형식으로 전송. 서버는 이 데이터를 그대로 사용할 수 있으며, 주로 JSON 또는 XML 형식의 데이터를 전송할 때 사용서버가 데이터를 그대로 사용할 수 있게 하며, 주로 JSON 또는 XML 형식의 데이터를 전송하는 경우에 적합        API 메세지 바디            단순텍스트package com.mvc1.servlet.request;import jakarta.servlet.Servlet;import jakarta.servlet.ServletException;import jakarta.servlet.ServletInputStream;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.util.StreamUtils;import java.io.IOException;import java.nio.charset.StandardCharsets;@WebServlet(name=\"requestBodyStringServlet\", urlPatterns = \"/request-body-string\")public class RequestBodyStringServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        ServletInputStream inputStream = request.getInputStream();        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);        System.out.println(\"messageBody = \" + messageBody);        response.getWriter().write(\"ok\");    }}이거찍힘끝임jsonpackage com.mvc1.servlet.request;import jakarta.servlet.ServletException;import jakarta.servlet.ServletInputStream;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.util.StreamUtils;import java.io.IOException;import java.nio.charset.StandardCharsets;@WebServlet(name = \"requestBodyJsonServlet\", urlPatterns = \"/request-body-json\")public class RequestBodyJsonServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        ServletInputStream inputStream = request.getInputStream();        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);        System.out.println(\"messageBody = \" + messageBody);    }}덤으로package com.mvc1.servlet.request;import com.fasterxml.jackson.databind.ObjectMapper;import com.mvc1.servlet.HelloData;import jakarta.servlet.ServletException;import jakarta.servlet.ServletInputStream;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.util.StreamUtils;import java.io.IOException;import java.nio.charset.StandardCharsets;@WebServlet(name = \"requestBodyJsonServlet\", urlPatterns = \"/request-body-json\")public class RequestBodyJsonServlet extends HttpServlet {    private ObjectMapper objectMapper = new ObjectMapper();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        ServletInputStream inputStream = request.getInputStream();        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);        System.out.println(\"messageBody = \" + messageBody);        HelloData data = objectMapper.readValue(messageBody, HelloData.class);        System.out.println(\"helloData.username = \" + data.getUsername());        System.out.println(\"helloData.age = \" + data.getAge());    }}이렇게하면 객체와 매핑가능근데 객체 내 변수와 이름이 다르니까 에러뜸당연하겠지만 타입안맞아도 에러남암튼 고쳤더니 잘뜸참고로 html form데이터도 같은방식으로 직접 읽을수는 있다고함. getParameter()한거랑 같은 결과나온다고근데 굳이?느낌?HTTPServletResponse편의 기능 제공 - content-Type, 쿠키, Redirectpackage com.mvc1.servlet.response;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name=\"responseHeaderServlet\", urlPatterns = \"/response-header\")public class ResponseHeaderServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {        //status-line//        response.setStatus(200);        response.setStatus(HttpServletResponse.SC_OK); //위랑 같으나 이렇게쓰는걸 권장함        //response-header        response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\");        response.setHeader(\"Cache-Control\", \"no-cache, must-revalidate\"); //캐쉬 완전 무효화        response.setHeader(\"Pragma\", \"no-cache\");        response.setHeader(\"my-header\", \"hello\");        PrintWriter writer = response.getWriter();        writer.println(\"ok\");    }}아래처럼 메소드로 빼는것도 가능package com.mvc1.servlet.response;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.Cookie;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name=\"responseHeaderServlet\", urlPatterns = \"/response-header\")public class ResponseHeaderServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {        //status-line//        response.setStatus(200);        response.setStatus(HttpServletResponse.SC_OK); //위랑 같으나 이렇게쓰는걸 권장함        //response-header//        response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\");        response.setHeader(\"Cache-Control\", \"no-cache, must-revalidate\"); //캐쉬 완전 무효화        response.setHeader(\"Pragma\", \"no-cache\");        response.setHeader(\"my-header\", \"hello\");        content(response);        cookie(response);        redirect(response);        PrintWriter writer = response.getWriter();        writer.println(\"ok\");    }    private void content(HttpServletResponse response) {        //Content-Type: text/plain;charset=utf-8        //Content-Length: 2        //response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\");        response.setContentType(\"text/plain\");        response.setCharacterEncoding(\"utf-8\");        //response.setContentLength(2); //(생략시 자동 생성)    }    private void cookie(HttpServletResponse response) {        //Set-Cookie: myCookie=good; Max-Age=600;        //response.setHeader(\"Set-Cookie\", \"myCookie=good; Max-Age=600\");        Cookie cookie = new Cookie(\"myCookie\", \"good\");        cookie.setMaxAge(600); //600초        response.addCookie(cookie);    }    private void redirect(HttpServletResponse response) throws IOException {        //Status Code 302        //Location: /basic/hello-form.html        //response.setStatus(HttpServletResponse.SC_FOUND); //302        //response.setHeader(\"Location\", \"/basic/hello-form.html\");        response.sendRedirect(\"/basic/hello-form.html\");    }}참고로 redirect는 다른url로 이동하는 그 redirect맞음응답데이터 - HTMLpackage com.mvc1.servlet.response;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = \"responseHtmlServlet\", urlPatterns = \"/response-html\")public class ResponseHtmlServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse            response)            throws ServletException, IOException {        //Content-Type: text/html;charset=utf-8        response.setContentType(\"text/html\");        response.setCharacterEncoding(\"utf-8\");        PrintWriter writer = response.getWriter();        writer.println(\"&lt;html&gt;\");        writer.println(\"&lt;body&gt;\");        writer.println(\" &lt;div&gt;안녕?&lt;/div&gt;\");        writer.println(\"&lt;/body&gt;\");        writer.println(\"&lt;/html&gt;\");    }}걍… 타입 html로 해서 하나하나 만들어준다는..;;HTTP 응답데이터 - API JSONpackage com.mvc1.servlet.response;import com.fasterxml.jackson.databind.ObjectMapper;import com.mvc1.servlet.HelloData;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"responseJsonServlet\", urlPatterns = \"/response-json\")public class ResponseJsonServlet extends HttpServlet {    private ObjectMapper objectMapper = new ObjectMapper();    @Override    protected void service(HttpServletRequest request, HttpServletResponse            response)            throws ServletException, IOException {        //Content-Type: application/json        response.setHeader(\"content-type\", \"application/json\");        response.setCharacterEncoding(\"utf-8\");        HelloData data = new HelloData();        data.setUsername(\"kim\");        data.setAge(20);        //{\"username\":\"kim\",\"age\":20}        String result = objectMapper.writeValueAsString(data);        response.getWriter().write(result);    }}이것도 걍 JSON으로 내보낸다는 거임"
  },
  
  {
    "title": "[김영한 Querydsl] QueryDsl 기능",
    "url": "/posts/Querydsl_%EA%B8%B0%EB%8A%A5/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-04-17 00:00:00 +0900",
    





    
    "snippet": "  [!important]제약사항이 많아서 실무에서는 사용하기 부족한 기능들을 모아놓음인터페이스 지원 QuerydslPredicateExecutorpackage com.kyh.querydsl2.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaReposi...",
    "content": "  [!important]제약사항이 많아서 실무에서는 사용하기 부족한 기능들을 모아놓음인터페이스 지원 QuerydslPredicateExecutorpackage com.kyh.querydsl2.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.querydsl.QuerydslPredicateExecutor;import com.kyh.querydsl2.entity.Member;public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepositoryCustom, QuerydslPredicateExecutor&lt;Member&gt;{    List&lt;Member&gt; findByUsername(String name);    }QuerydslPredicateExecutor를 상속받아서 querydsl을 조건으로 넣을 수 있음@Test    public void querydslPredicateExecutor(){        Team teamA = new Team(\"teamA\");        Team teamB = new Team(\"teamB\");        em.persist(teamA);        em.persist(teamB);        Member member1 = new Member(\"member1\", 10, teamA);        Member member2 = new Member(\"member2\", 20, teamA);        Member member3 = new Member(\"member3\", 30, teamB);        Member member4 = new Member(\"member4\", 40, teamB);        em.persist(member1);        em.persist(member2);        em.persist(member3);        em.persist(member4);                Iterable&lt;Member&gt; list = memberRepo.findAll(QMember.member.age.between(20, 40).and(QMember.member.username.eq(\"member1\")));        for(Member m : list){            System.out.println(m.getAge());            System.out.println(m.getUsername());            System.out.println(\"-----\");        }    }이런식으로 파라미터로 쿼리문을 넣을 수 있음. 해당 쿼리문은 where문에 조건으로 들어감.그러나 left join이 불가능. 실무에서는 거의 못쓴다고 보면됨. 또한 클라이언트가 querydsl에 의존함. 구현기술을 바꾼다면 대참사가 발생함.하긴 이럴바엔 mybatis를 쓰는게..querydsl Web파라미터 바인딩을 @QuerydslPredicate어노테이션을 사용해 predicate조건으로 달아줘서 파라미터로 넘기는 기능. 한번 만들어놓고 계속쓸수있다는 장점이 있음.그러나 역시 join불가능. 실무에서 사용하기에는.. 또한 사실상 eq만 사용가능하고 사전작업이 복잡함, 컨트롤러가 querydsl에 의존함.. 별로임QuerydslRepositorySupport추상클래스.public class MemberRepositoryImpl extends QuerydslRepositorySupport implements MemberRepositoryCustom,  {    // private final JPAQueryFactory queryfactory;    // public MemberRepositoryImpl(EntityManager em) {    //     this.queryfactory = new JPAQueryFactory(em);    // }    public MemberRepositoryImpl(){        super(Member.class);    }    @Override    public List &lt; MemberTeamDto &gt; search(MemberSearchCondition condition) {        return from(member)            .leftJoin(QMember.member.team, QTeam.team)            .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))            .select(new QMemberTeamDto(                QMember.member.id,                QMember.member.username,                QMember.member.age,                QTeam.team.id,                QTeam.team.name))                .fetch();        // return queryfactory        //     .select(new QMemberTeamDto(        //         QMember.member.id,        //         QMember.member.username,        //         QMember.member.age,        //         QTeam.team.id,        //         QTeam.team.name))        //     .from(QMember.member)        //     .leftJoin(QMember.member.team, QTeam.team)        //     .where(usernameEq(condition.getUsername()),        //         teamNameEq(condition.getTeamName()),        //         ageGoe(condition.getAgeGoe()),        //         ageLoe(condition.getAgeLoe()))        //     .fetch();    }\t\t@Override    public Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable){        // QueryResults&lt;MemberTeamDto&gt; results = queryfactory        // .select(new QMemberTeamDto(        //     QMember.member.id,        //     QMember.member.username,        //     QMember.member.age,        //     QTeam.team.id,        //     QTeam.team.name))        // .from(QMember.member)        // .leftJoin(QMember.member.team, QTeam.team)        // .where(usernameEq(condition.getUsername()),        //     teamNameEq(condition.getTeamName()),        //     ageGoe(condition.getAgeGoe()),        //     ageLoe(condition.getAgeLoe()))        //     .offset(pageable.getOffset())        //     .limit(pageable.getPageSize())        // .fetchResults();        JPQLQuery&lt;MemberTeamDto&gt; results =             from(QMember.member)            .leftJoin(QMember.member.team, QTeam.team)            .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))            .select(new QMemberTeamDto(                QMember.member.id.as(\"memberId\"),                QMember.member.username,                QMember.member.age,                QTeam.team.id.as(\"teamId\"),                QTeam.team.name).as(\"teamName\"));        // System.out.println(results);        // List&lt;MemberTeamDto&gt; content = results.getResults();        // Long total = results.getTotal();        // return new PageImpl&lt;&gt;(content, pageable, total);        JPQLQuery&lt;MemberTeamDto&gt; query = getQuerydsl().applyPagination(pageable, results);        query.fetch();    }주석한 내용을 위처럼 바꿈. 페이징에 편리한 기능을 제공(코드 몇줄 줄어듬)그러나, sort에서 오류가남(버그, 우회해서사용은 가능하다고함), querydsl 3.xx을 대상으로 만들어서 querydsl 4.x에 나온 JPAQueryFactory와 QueryFactory를 사용할 수 없으며 select로 시작할 수 없음.이 페이지에서는 제일 쓸만한 기능인듯함.Querydsl 지원 클래스 직접만들기위의 QuerydslRepositorySupport를 보완하기 위한 방법  spring 데이터가 제공하는 페이징을 편리하게 변환가능  페이징과 카운트 쿼리 분리 가능  스프링데이터 sort지원  select, selectFrom으로 시작가능  EntityManager, QueryFactory 제공package com.kyh.querydsl2.repository.support;import java.util.List;import java.util.function.Function;import com.querydsl.core.types.Expression;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.repository.support.JpaEntityInformation;import org.springframework.data.jpa.repository.support.JpaEntityInformationSupport;import org.springframework.data.jpa.repository.support.Querydsl;import org.springframework.data.querydsl.SimpleEntityPathResolver;import org.springframework.data.support.PageableExecutionUtils;import org.springframework.stereotype.Repository;import org.springframework.util.Assert;import com.querydsl.core.types.EntityPath;import com.querydsl.core.types.dsl.PathBuilder;import com.querydsl.jpa.impl.JPAQuery;import com.querydsl.jpa.impl.JPAQueryFactory;import jakarta.annotation.PostConstruct;import jakarta.persistence.EntityManager;/** * Querydsl 4.x 버전에 맞춘 Querydsl 지원 라이브러리 * * @author Younghan Kim * @see org.springframework.data.jpa.repository.support.QuerydslRepositorySupport */@Repositorypublic abstract class Querydsl4RepositorySupport {    private final Class domainClass;    private Querydsl querydsl;    private EntityManager entityManager;    private JPAQueryFactory queryFactory;    public Querydsl4RepositorySupport(Class &lt; ? &gt; domainClass) {        Assert.notNull(domainClass, \"Domain class must not be null!\");        this.domainClass = domainClass;    }    @Autowired    public void setEntityManager(EntityManager entityManager) {        Assert.notNull(entityManager, \"EntityManager must not be null!\");        JpaEntityInformation entityInformation =            JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);        SimpleEntityPathResolver resolver = SimpleEntityPathResolver.INSTANCE;        EntityPath path = resolver.createPath(entityInformation.getJavaType());        this.entityManager = entityManager;        this.querydsl = new Querydsl(entityManager, new PathBuilder &lt; &gt; (path.getType(), path.getMetadata()));        this.queryFactory = new JPAQueryFactory(entityManager);    }    @PostConstruct    public void validate() {        Assert.notNull(entityManager, \"EntityManager must not be null!\");        Assert.notNull(querydsl, \"Querydsl must not be null!\");        Assert.notNull(queryFactory, \"QueryFactory must not be null!\");    }    protected JPAQueryFactory getQueryFactory() {        return queryFactory;    }    protected Querydsl getQuerydsl() {        return querydsl;    }    protected EntityManager getEntityManager() {        return entityManager;    }    protected &lt; T &gt; JPAQuery &lt; T &gt; select(Expression &lt; T &gt; expr) {        return getQueryFactory().select(expr);    }    protected &lt; T &gt; JPAQuery &lt; T &gt; selectFrom(EntityPath &lt; T &gt; from) {        return getQueryFactory().selectFrom(from);    }    protected &lt; T &gt; Page &lt; T &gt; applyPagination(Pageable pageable,        Function &lt; JPAQueryFactory, JPAQuery &gt; contentQuery) {        JPAQuery jpaQuery = contentQuery.apply(getQueryFactory());        List &lt; T &gt; content = getQuerydsl().applyPagination(pageable,            jpaQuery).fetch();        return PageableExecutionUtils.getPage(content, pageable,            jpaQuery::fetchCount);    }    protected &lt; T &gt; Page &lt; T &gt; applyPagination(Pageable pageable,        Function &lt; JPAQueryFactory, JPAQuery &gt; contentQuery, Function &lt; JPAQueryFactory,        JPAQuery &gt; countQuery) {        JPAQuery jpaContentQuery = contentQuery.apply(getQueryFactory());        List &lt; T &gt; content = getQuerydsl().applyPagination(pageable,            jpaContentQuery).fetch();        JPAQuery countResult = countQuery.apply(getQueryFactory());        return PageableExecutionUtils.getPage(content, pageable,            countResult::fetchCount);    }}package com.kyh.querydsl2.repository;import static com.kyh.querydsl2.entity.QMember.member;import static com.kyh.querydsl2.entity.QTeam.team;import static org.springframework.util.StringUtils.hasText;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.support.PageableExecutionUtils;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.entity.Member;import com.kyh.querydsl2.repository.support.Querydsl4RepositorySupport;import com.querydsl.core.types.dsl.BooleanExpression;import com.querydsl.jpa.impl.JPAQuery;public class MemberTestRepository extends Querydsl4RepositorySupport{    public MemberTestRepository() {        super(Member.class);    }    public List&lt;Member&gt; basicSelect(){        return select(member).from(member).fetch();            }    public List&lt;Member&gt; basicSelectFrom(){        return selectFrom(member).fetch();    }        //기존 사용방법    public Page&lt;Member&gt; searchPageByApplyPage(MemberSearchCondition condition, Pageable pageable){        JPAQuery&lt;Member&gt; query = selectFrom(member)        .leftJoin(member.team, team)        .where(usernameEq(condition.getUsername()),            teamNameEq(condition.getTeamName()),            ageGoe(condition.getAgeGoe()),            ageLoe(condition.getAgeLoe()));        List&lt;Member&gt; content = getQuerydsl().applyPagination(pageable, query).fetch();        return PageableExecutionUtils.getPage(content, pageable,            query::fetchCount);    }    //위와 같은 코드임.    public Page&lt;Member&gt; applyPagination(MemberSearchCondition condition, Pageable pageable){        return applyPagination(pageable, query-&gt;            query.selectFrom(member)                .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))        );    }\t\t//count쿼리 분리    public Page&lt;Member&gt; applyPagination2(MemberSearchCondition condition, Pageable pageable){        return applyPagination(pageable, query-&gt;            query.selectFrom(member)                .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))                ,countQuery-&gt;                    countQuery.select(member.id)                    .from(member)                    .leftJoin(member.team, team)                    .where(usernameEq(condition.getUsername()),                        teamNameEq(condition.getTeamName()),                        ageGoe(condition.getAgeGoe()),                        ageLoe(condition.getAgeLoe()))                );    }    private BooleanExpression usernameEq(String username) {        return !hasText(username) ? null : member.username.eq(username);    }    private BooleanExpression teamNameEq(String teamName) {        return !hasText(teamName) ? null : team.name.eq(teamName);    }    private BooleanExpression ageGoe(Integer ageGoe) {        return ageGoe == null ? null : member.age.goe(ageGoe);    }    private BooleanExpression ageLoe(Integer ageLoe) {        return ageLoe == null ? null : member.age.loe(ageLoe);    }    }Querydsl4RepositorySupport에서 만들어놓은 메소드를 불러와서 훨신 깔끔하게 코드작성 가능함."
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 스프링 시큐리티",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/",
    "categories": "Spring",
    "tags": "spring, security",
    "date": "2023-02-24 00:00:00 +0900",
    





    
    "snippet": "로그아웃은 프론트일임!!!!마찬가지로 sns로그인은 프론트일임세션, 모델을 사용할거면 안쓰는게 맞음토큰은 임의로 만료불가로그아웃은 프론트에서 브라우저 메모리에서 삭제아니면 백에서 레디스 이용찾아보면 테이블을 분리하는경우가 많은데 회원 권한이 하나라면 하나로 통합해도됨이거임plugins {\tid 'java'\tid 'war'\tid 'org.springfr...",
    "content": "로그아웃은 프론트일임!!!!마찬가지로 sns로그인은 프론트일임세션, 모델을 사용할거면 안쓰는게 맞음토큰은 임의로 만료불가로그아웃은 프론트에서 브라우저 메모리에서 삭제아니면 백에서 레디스 이용찾아보면 테이블을 분리하는경우가 많은데 회원 권한이 하나라면 하나로 통합해도됨이거임plugins {\tid 'java'\tid 'war'\tid 'org.springframework.boot' version '3.0.2'\tid 'io.spring.dependency-management' version '1.1.0'}group = 'com.example'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-web'\timplementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.0'\tcompileOnly 'org.projectlombok:lombok'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\truntimeOnly 'com.mysql:mysql-connector-j'\tannotationProcessor 'org.projectlombok:lombok'\tprovidedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\ttestImplementation 'org.springframework.boot:spring-boot-starter-security'\timplementation 'org.springframework.boot:spring-boot-starter-security'\timplementation \"io.jsonwebtoken:jjwt-api:0.11.5\"\timplementation \"io.jsonwebtoken:jjwt-jackson:0.11.5\"\timplementation \"io.jsonwebtoken:jjwt-impl:0.11.5\"}tasks.named('test') {\tuseJUnitPlatform()}설정 후server:  port: 9988spring:  datasource:    url: jdbc:mysql://localhost:3306/security_test_bd    username: root    password: 1234jwt:  secretKey: {key}permission:  permit-all-urls:    - /api/member/login    - /api/member/joinsecretKey는 충분히 길어야함이까지해서 회원가입 되야함.. 안되면 문제있는거— 로그인package com.example.security_test.mapper;import com.example.security_test.vo.entity.MemberInfoVO;import com.example.security_test.vo.request.LoginVO;import com.example.security_test.vo.request.MemberJoinVO;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface MemberMapper {    void insertMember(MemberJoinVO data);    Boolean isDuplicatedId(String id);    MemberInfoVO getMemberInfoByMemberId(String id);    MemberInfoVO getMemberInfoByLoginInfo(LoginVO login);}&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"        \"http://mabatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.example.security_test.mapper.MemberMapper\"&gt;    &lt;insert id=\"insertMember\"&gt;        INSERT INTO member_info(mi_id, mi_pwd, mi_name, mi_nickname)        VALUES(#{id}, #{pwd}, #{name}, #{nickname})    &lt;/insert&gt;    &lt;select id=\"isDuplicatedId\" resultType=\"java.lang.Boolean\"&gt;        select count(*) = 1 from member_info where mi_id = #{id}    &lt;/select&gt;    &lt;select id=\"getMemberInfoByMemberId\" resultType=\"com.example.security_test.vo.entity.MemberInfoVO\"&gt;        select * from member_info where mi_id = #{id}    &lt;/select&gt;    &lt;select id=\"getMemberInfoByLoginInfo\" resultType=\"com.example.security_test.vo.entity.MemberInfoVO\"&gt;        select * from member_info where mi_id = #{id} and mi_pwd = #{pwd}    &lt;/select&gt;&lt;/mapper&gt;@Transactionalpublic LoginResponseVO login(LoginVO login) throws Exception{    login.setPwd(AESAlgorithm.Encrypt(login.getPwd()));    MemberInfoVO member = memberMapper.getMemberInfoByLoginInfo(login);    if(member==null){        return LoginResponseVO.builder()                .status(false).message(\"ID or PWD Error\").code(HttpStatus.UNAUTHORIZED).build();    } else if (!member.isEnabled()) {        return LoginResponseVO.builder()                .status(false).message(\"이용정지됨\").code(HttpStatus.UNAUTHORIZED).build();    }    UsernamePasswordAuthenticationToken authenticationToken =            new UsernamePasswordAuthenticationToken(member.getMi_id(), member.getMi_pwd());    Authentication authentication =            authenticationManagerBuilder.getObject().authenticate(authenticationToken);    return LoginResponseVO.builder()            .status(true)            .message(\"정상 로그인\")            .token(jwtTokenProvider.generateToken(authentication))            .code(HttpStatus.OK)            .build();}@PostMapping(\"/login\")public ResponseEntity&lt;LoginResponseVO&gt; postMemberLogin(@RequestBody LoginVO login) throws Exception{    LoginResponseVO response = memberService.login(login);    return new ResponseEntity&lt;&gt;(response, response.getCode());}위처럼 해서 토큰 나와야함매핑 정보가 틀려도 안됨 415가아니고 403뜨니까 알아둘것.나머지 기능은 토큰없이 접근 불가능함Bearer Token 선택하고 위의 access Token을 붙여넣기하면 이용가능함. 토큰이없으면 403뜸— 회원 정보 조회public MemberDetailResponseVO getUserDetailInfo(String userId){        try{            customUserDetailService.loadUserByUsername(userId);            MemberInfoVO member = memberMapper.getMemberInfoByMemberId(userId);            SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");            return MemberDetailResponseVO.builder()                   .id(member.getMi_id())                    .name(member.getMi_name())                    .nickname(member.getMi_nickname())                    .registered(formatter.format(member.getMi_reg_dt()))                    .build();        }catch (UsernameNotFoundException e){            return null;        }    }@GetMapping(\"/detail/{userId}\")    public ResponseEntity&lt;MemberDetailResponseVO&gt; getMemberDetail(@PathVariable String userId){        return new ResponseEntity&lt;&gt;(memberService.getUserDetailInfo(userId), HttpStatus.OK);    }이렇게하면 다른 회원의 정보도 볼수있다는 문제가있음. 비밀번호 한번 더 입력하면 됨jwt:  secretKey: {key}permission:  permit-all-urls:    - /api/member/login    - /api/member/join    - /api/product/**- /api/product/** 는 product/ 요청을 모두 허용한다는 의미임— entity"
  },
  
  {
    "title": "[김영한 Querydsl] Spring Data Jpa와 QueryDsl",
    "url": "/posts/springdatajpa%EC%99%80querydsl/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-02-08 00:00:00 +0900",
    





    
    "snippet": "StringUtils.hasText → null과 “” 둘다 체크하는 방법!!!!!!!! 값이있으면 true, 없으면 false 반환사용자 정의 repositorypackage com.kyh.querydsl2.repository;import java.util.List;import com.kyh.querydsl2.dto.MemberSearchCondit...",
    "content": "StringUtils.hasText → null과 “” 둘다 체크하는 방법!!!!!!!! 값이있으면 true, 없으면 false 반환사용자 정의 repositorypackage com.kyh.querydsl2.repository;import java.util.List;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.dto.MemberTeamDto;public interface MemberRepositoryCustom {    List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition);}일단 querydsl을 사용할 repository를 만들어서 ~~ repositoryImpl 라는 이름으로 구현체를 만들어줌. 이름 규칙은 바뀌면안됨package com.kyh.querydsl2.repository;import java.util.List;import org.springframework.util.StringUtils;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.dto.MemberTeamDto;import com.kyh.querydsl2.dto.QMemberTeamDto;import com.kyh.querydsl2.entity.QMember;import com.kyh.querydsl2.entity.QTeam;import com.querydsl.core.types.dsl.BooleanExpression;import com.querydsl.jpa.impl.JPAQueryFactory;import jakarta.persistence.EntityManager;public class MemberRepositoryImpl implements MemberRepositoryCustom {    private final JPAQueryFactory queryfactory;    public MemberRepositoryImpl(EntityManager em) {        this.queryfactory = new JPAQueryFactory(em);    }    @Override    public List &lt; MemberTeamDto &gt; search(MemberSearchCondition condition) {        return queryfactory            .select(new QMemberTeamDto(                QMember.member.id,                QMember.member.username,                QMember.member.age,                QTeam.team.id,                QTeam.team.name))            .from(QMember.member)            .leftJoin(QMember.member.team, QTeam.team)            .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))            .fetch();    }    private BooleanExpression usernameEq(String username) {        return StringUtils.hasText(username) ? QMember.member.username.eq(username) : null;    }    private BooleanExpression teamNameEq(String teamName) {        return StringUtils.hasText(teamName) ? QTeam.team.name.eq(teamName) : null;    }    private BooleanExpression ageGoe(Integer ageGoe) {        return ageGoe == null ? null : QMember.member.age.goe(ageGoe);    }    private BooleanExpression ageLoe(Integer ageLoe) {        return ageLoe == null ? null : QMember.member.age.loe(ageLoe);    }}package com.kyh.querydsl2.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import com.kyh.querydsl2.entity.Member;public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepositoryCustom{    List&lt;Member&gt; findByUsername(String name);    }그리고 MemberRepositoryCustom을 extends함.package com.kyh.querydsl2;import static org.assertj.core.api.Assertions.assertThat;import java.util.List;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.transaction.annotation.Transactional;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.dto.MemberTeamDto;import com.kyh.querydsl2.entity.Member;import com.kyh.querydsl2.entity.Team;import com.kyh.querydsl2.repository.MemberRepository;import jakarta.persistence.EntityManager;@SpringBootTest@Transactionalclass MemberRepositoryTest {    @Autowired    EntityManager em;    @Autowired    MemberRepository memberRepo;     @Test    public void searchTest() {        Team teamA = new Team(\"teamA\");        Team teamB = new Team(\"teamB\");        em.persist(teamA);        em.persist(teamB);        Member member1 = new Member(\"member1\", 10, teamA);        Member member2 = new Member(\"member2\", 20, teamA);        Member member3 = new Member(\"member3\", 30, teamB);        Member member4 = new Member(\"member4\", 40, teamB);        em.persist(member1);        em.persist(member2);        em.persist(member3);        em.persist(member4);        MemberSearchCondition condition = new MemberSearchCondition();        condition.setAgeGoe(35);        condition.setAgeLoe(40);        condition.setTeamName(\"teamB\");        List &lt; MemberTeamDto &gt; result = memberRepo.search(condition);        assertThat(result).extracting(\"username\").containsExactly(\"member4\");        //username에 member4가 있는지?            }}사용꼭 custom에 묶여있을 필요는 없음. 그냥 repository class를 하나 만들어서 거기다가 만들어줘도됨. (특정 API에 묶여있다면 별도의 조회용 repository를 만들어도 좋다는 의미같음)페이징package com.kyh.querydsl2.repository;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.dto.MemberTeamDto;public interface MemberRepositoryCustom {    List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition);    Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable);    Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable);}@Overridepublic Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable){    QueryResults&lt;MemberTeamDto&gt; results = queryfactory    .select(new QMemberTeamDto(        QMember.member.id,        QMember.member.username,        QMember.member.age,        QTeam.team.id,        QTeam.team.name))    .from(QMember.member)    .leftJoin(QMember.member.team, QTeam.team)    .where(usernameEq(condition.getUsername()),        teamNameEq(condition.getTeamName()),        ageGoe(condition.getAgeGoe()),        ageLoe(condition.getAgeLoe()))        .offset(pageable.getOffset())        .limit(pageable.getPageSize())    .fetchResults();    List&lt;MemberTeamDto&gt; content = results.getResults();    Long total = results.getTotal();    return new PageImpl&lt;&gt;(content, pageable, total);}오버라이딩 해줌@Testpublic void searchPage() {    Team teamA = new Team(\"teamA\");    Team teamB = new Team(\"teamB\");    em.persist(teamA);    em.persist(teamB);    Member member1 = new Member(\"member1\", 10, teamA);    Member member2 = new Member(\"member2\", 20, teamA);    Member member3 = new Member(\"member3\", 30, teamB);    Member member4 = new Member(\"member4\", 40, teamB);    em.persist(member1);    em.persist(member2);    em.persist(member3);    em.persist(member4);    MemberSearchCondition condition = new MemberSearchCondition();    PageRequest pageRequest = PageRequest.of(0, 3);    Page &lt; MemberTeamDto &gt; result = memberRepo.searchPageSimple(condition, pageRequest);    assertThat(result.getSize()).isEqualTo(3);    assertThat(result.getContent()).extracting(\"username\").containsExactly(\"member1\", \"member2\", \"member3\");    }count와 limit 두개가 나감@Overridepublic Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable){    List&lt;MemberTeamDto&gt; content = queryfactory    .select(new QMemberTeamDto(        QMember.member.id,        QMember.member.username,        QMember.member.age,        QTeam.team.id,        QTeam.team.name))    .from(QMember.member)    .leftJoin(QMember.member.team, QTeam.team)    .where(usernameEq(condition.getUsername()),        teamNameEq(condition.getTeamName()),        ageGoe(condition.getAgeGoe()),        ageLoe(condition.getAgeLoe()))        .offset(pageable.getOffset())        .limit(pageable.getPageSize())    .fetch();    Long total = queryfactory            .select(QMember.member)            .from(QMember.member)            .leftJoin(QMember.member.team, QTeam.team)            .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))                .offset(pageable.getOffset())                .limit(pageable.getPageSize())            .fetchCount();    return new PageImpl&lt;&gt;(content, pageable, total);}count쿼리를 분리해서 해도 됨.count 쿼리 최적화@Override    public Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable){        List&lt;MemberTeamDto&gt; content = queryfactory        .select(new QMemberTeamDto(            QMember.member.id,            QMember.member.username,            QMember.member.age,            QTeam.team.id,            QTeam.team.name))        .from(QMember.member)        .leftJoin(QMember.member.team, QTeam.team)        .where(usernameEq(condition.getUsername()),            teamNameEq(condition.getTeamName()),            ageGoe(condition.getAgeGoe()),            ageLoe(condition.getAgeLoe()))            .offset(pageable.getOffset())            .limit(pageable.getPageSize())        .fetch();        JPAQuery&lt;Member&gt; countQuery = queryfactory                .select(QMember.member)                .from(QMember.member)                .leftJoin(QMember.member.team, QTeam.team)                .where(usernameEq(condition.getUsername()),                    teamNameEq(condition.getTeamName()),                    ageGoe(condition.getAgeGoe()),                    ageLoe(condition.getAgeLoe()));        return PageableExecutionUtils.getPage(content, pageable, ()-&gt;countQuery.fetchCount());        //return PageableExecutionUtils.getPage(content, pageable, countQuery::fetchCount);\t\t\t\t//위와 같은 표현임    }이렇게하면 count쿼리가 필요하지 않을때(ex.마지막페이지)는 spring data jpa가 자동으로 쿼리문을 안날림."
  },
  
  {
    "title": "[김영한 Querydsl] 중급문법",
    "url": "/posts/%EC%A4%91%EA%B8%89%EB%AC%B8%EB%B2%95/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-02-06 00:00:00 +0900",
    





    
    "snippet": "프로젝션 결과 반환 - 기본프로젝션 : select 대상 지정— 프로젝션 대상이 하나일때List&lt;String&gt; result = queryFactory.select(member.username).from(member).fetch();— 프로젝션 대상이 둘 이상  튜플@Test    public void testQuerydsl4(){      ...",
    "content": "프로젝션 결과 반환 - 기본프로젝션 : select 대상 지정— 프로젝션 대상이 하나일때List&lt;String&gt; result = queryFactory.select(member.username).from(member).fetch();— 프로젝션 대상이 둘 이상  튜플@Test    public void testQuerydsl4(){        JPAQueryFactory query = new JPAQueryFactory(em);        // List&lt;String&gt; result = query        //     .select(QMember.member.username)        //     .from(QMember.member)        //     .fetch();                    // for(String member : result){        //     System.out.println(member);        // }        List&lt;Tuple&gt; result = query            .select(QMember.member.username, QMember.member.age)            .from(QMember.member)            .fetch();                    for(Tuple tuple : result){            System.out.println(tuple.get(QMember.member.username));            System.out.println(tuple.get(QMember.member.age));            System.out.println(\"-----\");        }    }위처럼 원하는 값만 가져오는 거를 프로젝션이라고 함  DTO 조회(추천)                  setter를 통한 사용방법          @Test      public void findDtoBySetter(){          JPAQueryFactory query = new JPAQueryFactory(em);          List&lt;MemberDto&gt; result = query              .select(Projections.bean(MemberDto.class, QMember.member.username, QMember.member.age))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                Setter와 기본생성자가 있어야 실행됨 아니면 QBean.newInstance 에러 발생. setter를 통해서 들어가는 거임                    필드 사용 방법          @Test      public void findDtoByField(){          JPAQueryFactory query = new JPAQueryFactory(em);          List&lt;MemberDto&gt; result = query              .select(Projections.fields(MemberDto.class, QMember.member.username, QMember.member.age))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                getter, setter가 없어도 필드에 자동으로 세팅됨.        필드이름이 안맞으면 안됨. 정 안되면          @Test      public void findDtoByField(){          JPAQueryFactory query = new JPAQueryFactory(em);          List&lt;MemberDto&gt; result = query              .select(Projections.fields(MemberDto.class,                   QMember.member.username.as(\"username\"),                   QMember.member.age.as(\"age\")              ))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                아래처럼 as를 통해 별칭을 지정해주면 됨          @Test      public void findDtoByField2(){          JPAQueryFactory query = new JPAQueryFactory(em);          QMember membersub = new QMember(\"memberSub\");          List&lt;MemberDto&gt; result = query              .select(Projections.fields(MemberDto.class,                   QMember.member.username.as(\"username\"),                   ExpressionUtils.as(JPAExpressions                  .select(membersub.age.max())                  .from(membersub)                  , \"age\") //최고령자 나이만 찍힘              ))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                이런식으로 응용도 가능함.                    생성자를 통한 사용방법          @Test      public void findDtoByField(){          JPAQueryFactory query = new JPAQueryFactory(em);          List&lt;MemberDto&gt; result = query              .select(Projections.constructor(MemberDto.class, QMember.member.username, QMember.member.age))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                타입이 정확히 일치해야함. 타입으로 들어가는거라서 필드이름이 다른건 상관없음            @QueryProjectionDTO 생성자에 @QueryProjection어노테이션을 달아서 gradle로 Qentity를 재 생성해주면 QDTO도 생성됨package com.kyh.querydsl2.dto;import com.querydsl.core.annotations.QueryProjection;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructorpublic class MemberDto {    private String username;    private int age;    @QueryProjection    public MemberDto(String username, int age){        this.username=username;        this.age = age;    }}이렇게하면 DTO의 생성자로 바로 반환가능함@Testpublic void findDto(){  JPAQueryFactory query = new JPAQueryFactory(em);  List&lt;MemberDto&gt; member = query      .select(new QMemberDto(QMember.member.username, QMember.member.age))      .from(QMember.member)      .fetch();  for(MemberDto m : member){      System.out.println(m.getUsername());      System.out.println(m.getAge());      System.out.println(\"=====\");  }}위의 생성자를 통한 방법보다 나은방법. 엔티티의 생성자를 통하면 컴파일시점에서 오류를 잡아낼 수 없지만 이건 컴파일시점에서 오류를 알 수 있음. 파라미터 숫자나 개수가 안맞으면 에러뜸.그러나 DTO가 querydsl에 의존된다는 단점이 있음.동적 쿼리  BooleanBuilder@Test    public void dynamicQuery_BooleanBuilder(){        String username = \"member1\";        Integer ageParam = 10;        List&lt;Member&gt; result = searchMember1(username, ageParam);        Assertions.assertThat(result.size()).isEqualTo(1);    }    private List&lt;Member&gt; searchMember1(String usernameCond, Integer ageCond){        JPAQueryFactory query = new JPAQueryFactory(em);        //null이 아닌게 보장이 된다면 이렇게 해도됨.         // BooleanBuilder builder = new BooleanBuilder(QMember.member.username.eq(usernameCond));        BooleanBuilder builder = new BooleanBuilder();        if(usernameCond!=null){            builder.and(QMember.member.username.eq(usernameCond));        }        if(ageCond!=null){            builder.and(QMember.member.age.eq(ageCond));        }        return query.selectFrom(QMember.member)                                .where(builder)                                .fetch();    }A값이 있다면 A조건을, B값이 잇다면 B조건을 검색하는 방법으로 활용됨. or조건도 가능함  Where 다중 파라미터@Test    public void dynamicQuery_WhereParam(){        String username = \"member1\";        Integer ageParam = 10;        List&lt;Member&gt; result = searchMember2(username, ageParam);        Assertions.assertThat(result.size()).isEqualTo(1);    }    private List&lt;Member&gt; searchMember2(String usernameCond, Integer ageCond){        JPAQueryFactory query = new JPAQueryFactory(em);        return query.selectFrom(QMember.member)                                .where(usernameEq(usernameCond), ageEq(ageCond))                                .fetch();    }    private Predicate ageEq(Integer ageCond) {        if(ageCond==null){            return null;        }        return QMember.member.age.eq(ageCond);        //삼항 연산자 써도 됨. ageCond==null?null:QMember.member.age.eq(ageCond);    }    private Predicate usernameEq(String usernameCond) {        if(usernameCond==null){            return null;        }        return QMember.member.username.eq(usernameCond);    }where(null)이되면 null은 무시한채로 쿼리문이 날아감날아가는 쿼리문에 where없음가독성이 더 좋다는 장점이 있음@Test    public void dynamicQuery_WhereParam(){        String username = \"member1\";        Integer ageParam = 10;        List&lt;Member&gt; result = searchMember2(username, ageParam);        Assertions.assertThat(result.size()).isEqualTo(1);    }    private List&lt;Member&gt; searchMember2(String usernameCond, Integer ageCond){        JPAQueryFactory query = new JPAQueryFactory(em);        return query.selectFrom(QMember.member)                                .where(allEq(usernameCond, ageCond))                                .fetch();    }    private BooleanExpression ageEq(Integer ageCond) {        if(ageCond==null){            return null;        }        return QMember.member.age.eq(ageCond);        //삼항 연산자 써도 됨. ageCond==null?null:QMember.member.age.eq(ageCond);    }    private BooleanExpression usernameEq(String usernameCond) {        if(usernameCond==null){            return null;        }        return QMember.member.username.eq(usernameCond);    }        private BooleanExpression allEq(String usernameCond, Integer ageCond){        return usernameEq(usernameCond).and(ageEq(ageCond));    }이런식으로 활용이 가능함. 코드가 깔끔해지고 재활용이 가능함수정, 삭제 벌크연산@Testpublic void bulkUpdate(){    JPAQueryFactory query = new JPAQueryFactory(em);    long count = query            .update(QMember.member)            .set(QMember.member.username, \"비회원\")            .where(QMember.member.age.lt(16))            .execute();    //영향을 받은 로우 수가 나옴    Assertions.assertThat(count).isEqualTo(2L);}저 뒤에 select문을 날리면 변경 전 데이터가 나옴, 쿼리문은 나가지만 영속성 컨텍스트가 가져온 값을 버리고 기존 값을 쓰기때문이라고 함.근데 난 왜 변경된게 나오는거지..?아무튼 변경하고 em.clear, em.flush하라고함spring data jpa라서 그런거같음~long count = query    .update(QMember.member)    .set(QMember.member.age, QMember.member.age.add(1))    .where(QMember.member.age.lt(16))    .execute();더하기는 이렇게하면됨. 곱하기는 multiply, 빼기는 add(-1) 이렇게해야함 마이너스함수는 없음long count = query        .delete(QMember.member)        .where(QMember.member.age.gt(16))        .execute();삭제 쿼리SQL function@Testpublic void sql(){  JPAQueryFactory query = new JPAQueryFactory(em);  List&lt;String&gt; result = query      .select(Expressions.stringTemplate(          \"function('replace',{0},{1},{2})\",          QMember.member.username, \"member\",\"M\"))          .from(QMember.member)          .fetch();  //영향을 받은 로우 수가 나옴  // Assertions.assertThat(count).isEqualTo(2L);  em.flush();  em.clear();  for(String m : result){      System.out.println(m);      System.out.println(\"===\");  }}registerFunction에 있는 거만 쓸 수 있음없으면 mysqlDialect에서 등록해서 써야함List&lt;String&gt; result = query            .select(QMember.member.username)            .from(QMember.member)            .where(QMember.member.username.eq(                // Expressions.stringTemplate(\"function('lower',{0})\", QMember.member.username)))                QMember.member.username.lower()))            .fetch();어지간한건 다 지원중이라서 그냥 저렇게쓰면될듯"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 웹 애플리케이션 이해",
    "url": "/posts/%EC%9B%B9%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%ED%95%B4/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-02-05 00:00:00 +0900",
    





    
    "snippet": "웹서버 : HTTP기반으로 동작. 정적 리소스 제공, 기타 부가기능. ex) NGINX, APACHE웹 애플리케이션 서버(WAS) : HTTP기반으로 동작, 웹 서버 기능 포함+(정적 리소스 제공 기능), 프로그램코드를 실행해서 애플리케이션 로직을 수행(동적 HTML, HTTP API[JSON], 서블릿, JSP, 스프링 MVC), ex)톰캣 Jett...",
    "content": "웹서버 : HTTP기반으로 동작. 정적 리소스 제공, 기타 부가기능. ex) NGINX, APACHE웹 애플리케이션 서버(WAS) : HTTP기반으로 동작, 웹 서버 기능 포함+(정적 리소스 제공 기능), 프로그램코드를 실행해서 애플리케이션 로직을 수행(동적 HTML, HTTP API[JSON], 서블릿, JSP, 스프링 MVC), ex)톰캣 Jetty, Undertow— 웹 서버, 웹 애플리케이션 서버의 차이  웹서버          정적 리소스(파일[HTML, CSS, JS, 이미지, 영상])      그러나 프로그램을 실행하는 기능을 포함하기도함        웹 애플리케이션 서버(WAS)          프로그램코드를 실행해서 애플리케이션 로직을 수행                  동적 HTML, HTTP API(JSON)          서블릿, JSP, 스프링 MVC          ex) 톰캣 Jetty, Undertow                    그러나 웹 서버의 기능을 제공함              JAVA는 서블릿 컨테이너 기능을 제공하면 WAS  그러나 서블릿없이 자바코드를 실행하는 서버 프레임워크도 있음            애플리케이션코드를 실행하는데 더 특화됨      ⇒ 결론 : 용어도 경계도 애매함. 개인적으로 이해하기로는 요청이왔을때 파일로 응답하면 웹서버, 코드로 응답하면 was라는거같음— 웹 시스템 구성 - WAS, DB  WAS, DB 만으로 시스템 구성이 가능함.  WAS는 정적 리소스, 애플리케이션 로직 모두 제공가능함.  그러나 WAS가 너무 많은 역할을 담당(애플리케이션 로직, html, css, js, 이미지 등), 서버과부화 우려있음  가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수도 있음 (싼거 처리한다고 비싼거 처리못함)  WAS장애시 오류 화면(죄송합니다~~하는 에러창)도 노출 불가능함. (생각보다 잘 죽음)→ 웹 시스템 구성 - WEB, WAS, DE  정적 리소스는 웹 서버가 처리  웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임  WAS는 중요한 애플리케이션 로직 처리 전담  시스템 리소스를 효율적으로 사용 가능  정적 리소스가 많이 사용되면 Web서버 증설 → 잘 죽지않음(계산하는 로직이 없음)  애플리케이션 리소스가 많이 사용되면 WAS서버 증설  WAS, DB 장애시 WEB서버가 오류 화면을 송출 가능함(==오류화면 HTML==)서블릿위의 의미없는 로직을 자동화 하기위해 나온 것이 서블릿.서블릿을 지원하는 WAS를 사용하면 의미있는 비즈니스 로직만 실행됨. 그외업무는 자동화되는거임.  urlPatterns의 URL이 호출되면 서블릿 코드가 실행됨.      HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest        위 메소드에 파라미터로 받으면 이걸 자동으로 만들어준다는거임 request.getusername하면 kim이 나옴        HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse        위 메소드의 파라미터로 받으면 이걸 만들어준다는거임    개발자는 HTTP 스펙을 매우 편리하게 사용— HTTP 요청, 응답 흐름서블릿 컨테이너가 서블릿 객체를 자동으로 생성, 호출, 생명주기 관리(WAS종료시 함께 종료됨)  HTTP 요청시          WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체를 호출      개발자는 Request 객체에서 HTTP 요청정보를 편리하게 꺼내서 사용함.      개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력함      WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답정보를 생성함.      서블릿 컨테이너  톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함  서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리함  서블릿 객체는 싱글톤으로 관리됨          고객의 요청이 올때마다 새 객체를 생성하는 것이 비효율임  위 그림에서 request와 response는 매번 새로 생성되는것이 맞으나(고객마다, request마다 정보가 다름) helloServlet이 계속 새로 생성될 필요는 없다는 뜻임. 고객의 요청이올때마다 helloservlet을 생성하는것은 비효율적이기때문  → 들어온 request를 가지고 이미 만들어진 helloservlet에서 작업을 처리, response에 처리결과를 세팅 후 내보냄      최초 로딩 시점에 서블릿 객체를 미리 만들고 재활용함      모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근  같은 서버라면 어떤 사용자가 요청해도 같은 서블릿 인스턴스에 접근됨.      공유 변수 사용 주의  → 같은 서블릿 인스턴스를 사용하다가 다른 회원의 정보가 보인다면 대참사가 일어남!!      서블릿 컨테이너 종료 시 함께 종료됨        JSP도 서블릿으로 변환되어서 사용  동시요청을 위한 멀티 쓰레드 처리 지원동시요청 - 멀티 쓰레드⭐매우 중요!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!위 그림에서 서블릿 객체는 누가 호출하나? ⇒ 쓰레드쓰레드: 애플리케이션 코드를 하나하나 순차적으로 실행하는 것  java main 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행됨  쓰레드가 없다면 자바 애플리케이션 실행이 불가능함.  쓰레드는 한번에 하나의 코드 라인만 수행가능  동시 처리가 필요하다면 쓰레드를 추가로 생성해야함  쓰레드 하나 사용시 단일 요청          요청이 오면 연결이 쓰레드를 할당해서 servlet을 호출함 응답이 끝나면 쓰레드는 휴식        쓰레드 하나 사용시 다중 요청          요청이 와서 스레드가 요청을 처리중일때 다른 요청이 들어오면 쓰레드가 할일을 끝낼때까지 대기함. 1차 요청이 처리지연이라도 되면 둘다 터지는 사태가 발생함.  ⇒ 요청마다 쓰레드를 생성하는 방법으로 해결                  요청1이 들어오면 쓰레드1이 처리를 하고 요청2가 들어오면 쓰레드2가 처리를 하는 방식 → 처리가 지연되도 상관없음.          장점                          동시요청 처리가능, 리소스(CPU, 메모리)가 허용할 때까지 처리가능함.              하나의 쓰레드가 지연되도 나머지는 정상작동함                                단점                          쓰레드 생성 비용이 비싸고 요청이 올때마다 쓰레드를 생성하면 응답속도가 늦어짐                              쓰레드는 컨텍스트 스위칭 비용이 발생함  사실 코어 하나가 쓰레드 두개를 동시 실행할 수 없으나 속도가 빠르니까 동시에 처리하는 것처럼 보이는거임. 그래서 이 두 쓰레드를 전환할때 비용이 발생함. 이걸 콘텍스트 스위칭 비용이라고 부름(쓰레드가 많아지면 비용이 커짐)                            쓰레드 생성에 제한이 없어 요청이 너무 많이오면 CPU, 메모리 임계정을 넘어 서버가 죽을 수도 있음(CPU와 메모리 성능상 생성가능한 쓰레드 1000개라도 10000개의 요청이 들어오면 모든 쓰레드를 생성하다가 서버가 죽어버린다는 뜻임)  ⇒ 단점 보완을 위해 쓰레드 풀 도입                쓰레드 풀                                                        쓰레드를 담아놓는 풀을 생성. 요청이 들어오면 쓰레드 풀에 쓰레드를 요청함.(위처럼 200개의 쓰레드가 담긴 쓰레드 풀에 요청이 2개 들어오면 쓰레드 풀에는 198개의 쓰레드가 남음. 응답까지 끝나면 쓰레드풀에 쓰레드 반납함. 그럼 다시 200개됨)쓰레드를 다썼다고 쓰레드를 죽이지 않음!!만약!! 쓰레드 200개가 모두 사용중이라면?? 새로 들어온 요청은 쓰레드 대기상태가 되거나 거절됨.한 10개까지는 대기시키고 나머지는 거절하는 것도 가능함  쓰레드풀에 생성가능한 쓰레드의 최대치는 톰켓에서 기본 200개임(변경가능함)  쓰레드가 미리 생성되어있어서 쓰레드를 생성, 종료하는 비용(CPU)가 절약되고 응답시간이 빠름  너무 많은 요청이 들어와도 기존 요청은 안전하게 처리 가능함  [!important]WAS의 주요 튜닝 포인트는 최대 쓰레드의 수임.이 값을 너무 낮게 설정하면 서버 리소스는 여유롭지만 클라이언트는 응답지연이 금방옴.너무 높게 설정하면 CPU, 메모리 리소스 임계점 초과로 서버가 다운될 가능성이 높아짐실무에서 장애가 발생하면 일단 서버부터 늘리고 이후에 튜닝하는 것이 좋음. 클라우드가 아니면 열심히 튜닝할것.쓰레드 적정숫자는 애플리케이션 로직 복잡도, CPU, 메모리, IO리소스 상황에 따라 모두 다름. 성능테스트 후 결정하는 것이 가장 좋음.— 핵심 정리  멀티 쓰레드에대한 부분은 WAS가 처리함  개발자가 멀티쓰레드 관련 코드를 신경안써도 됨  개발자는 싱글쓰레드 프로그래밍을 하듯이 편리하게 소스코드를 개발하면됨  그러나 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용해야함. (일단 멀티쓰레드환경이니까)용어 정리  정적 리소소 : 고정된 HTML파일, CSS, JS, 이미지, 영상 등을 제공. 주로 웹브라우저      HTTP 페이지          동적으로 필요한 HTML파일을 생성해서 전달      웹 브라우저 : HTML 해석            HTTP API          HTML이 아니라 데이터를 전달(주로 JSON)      다양한 시스템에서 호출함      데이터만 주고받음. UI화면이 필요하면 클라이언트가 별도처리함      앱, 웹 클라이언트, 서버 to 서버      UI클라이언트 접점                  앱 클라이언트(아이폰, 안드로이드, PC앱)          웹 브라우저에서 자바 스크립트를 통한 HTTP API 호출          React, Vue.js 같은 웹 클라이언트                    서버 to 서버                  주문서버 → 결제서버          기업간 데이터 통신                      서버사이드 렌더링 (SSR) - 백엔드 필수서버에서 최종 HTML을 생성해서 클라에 전달. 주로 정적인 화면에 사용.(쉬움^^..)관련기술 : JSP, 타임리프 → 백엔드개발자가 사용  클라이언트 사이드 렌더링(CSR) - 프론트 분야HTML 결과를 자바스크립트를 사용해서 웹 브라우저에서 동적으로 생성해서 적용함. 주로 동적인 화면에 사용, 웹 환경을 앱처럼 필요한 부분부분 변경 가능함.ex) 구글 지도, Gmail, 구글 캘린더 등관련 기술 : React, Vue.js → 웹 프론트엔드 개발자가 사용  [!important]React, Vue.js를 CSR+SSR 동시에 지원하는 웹 프레임워크도 있음. SSR을 사용해도 자바스크립트를 사용해서 화면 일부를 동적으로 변경 가능함.❗백엔드 개발자에게 CSR은 옵션. 원래는 프론트개발자의 전문분야임.자바 웹 기술 역사  서블릿 - HTML 생성의 어려움  JSP - HTML생성은 편리하지만 비즈니스로직까지 너무 많은 역할 담당  서블릿 + JSP 조합 MVC 패턴 사용  MVC 패턴자동화, 다양한 기술지원, 스트럿츠, 웹워크, 스프링 MVC(과거버전)          was설치후 war파일을 만들어서 설치한 was에 배포        어노테이션기반의 스프링 MVC 등장      스프링부트 등장          서버 내장      빌드 결과 jar에 was서버 포함 → 빌드 배포 단순화        ⇒ MVC 프레임워크 시대 종료(모든 단점 해결)    Web servlet(Spring MVC), Web Reactive(Spring WebFlux)로 분화          Web servlet(위에 설명한걸 말함)      Web Reactive(최신기술)                  특징                          비동기 넌 블러킹 처리              최소 쓰레드로 최대 성능 - 쓰레드 컨텍스트 스위칭 비용 효율화              함수형 스타일로 개발 - 동시처리 코드 효율화              서블릿 기술 사용x                                그런데                          난이도 매우 높음              아직은 RDB 지원 부족 - nosql을 사용하면 좋은듯?              일반 MVC 쓰레드 모델도 충분히 빠름              실무에서 아직 많이 쓰이지는 않음(한 1%이하)                                          자바 뷰 템플릿의 역사HTML을 편리하게 생성하는 뷰 기능  JSP          속도 느림. 기능 부족        프리마커(FreeMarker), 벨로시티(Velocity)          속도 문제 해결, 다양한 기능        타임리프(Thymeleaf)          내추럴 템플릿 : HTML의 모양을 유지하면서 뷰 템플릿 적용가능      스프링 MVC와 강력한 기능 통합      최선의 선택, 단 성능은 프리마커, 벨로시티가 더 빠름      "
  },
  
  {
    "title": "[김영한 스프링 핵심원리 기본편] 스프링 컨테이너와 빈",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80_%EB%B9%88/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리기본편",
    "date": "2023-01-29 00:00:00 +0900",
    





    
    "snippet": "스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);ApplicationContext(인터페이스임)를 스프링 컨테이너라고 부름 - 정확히는 BeanFactory, ApplicationContext로 구분해서 부르는...",
    "content": "스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);ApplicationContext(인터페이스임)를 스프링 컨테이너라고 부름 - 정확히는 BeanFactory, ApplicationContext로 구분해서 부르는데 BeanFactory를 사용하는 경우가 거의 없음XML기반이나 어노테이션 기반의 자바 설정 클래스로 만들 수 있음. 직전 강의에서 사용한 AppConfig가 어노테이션기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것.new AnnotationConfigApplicationContext(Appconfig.class); 이게 ApplicationContext 인터페이스의 구현체임저상태로 실행하면 메소드 이름이 key값이 되서 스프링 컨테이너에 빈 객체가 저장됨. key값으로 bean객체를 꺼내올 수 있는 상태가 되는거임@Bean(name=”memberService2”) 이런식으로 이름을 따로 지정해줄수도 있음.빈 이름은 겹치면 안됨~ 덮어쓰기되거나 오류남]빈을 먼저 생성하고 의존관계를 주입하나 위처럼 자바코드로 빈을 등록하면 빈을 등록하면서 생성자를 호출해 의존관계 주입도 함께 됨.(그니까 위 사진처럼 orderService를 등록하려고보는데 discountPolicy()가 있어서 실행되는 과정에서 의존관계가 등록된다는 말인거같음)모든 빈 출력package com.hello.core.beanfind;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.hello.core.Appconfig;public class binfindTest {    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class);    @Test    @DisplayName(\"모든 빈 출력하기\")    void findAllBean(){        String[] beanDefinitionNames = ac.getBeanDefinitionNames();        for(String beanDefinitionName : beanDefinitionNames){            Object bean = ac.getBean(beanDefinitionName);            System.out.println(beanDefinitionName);            System.out.println(bean);            System.out.println(\"---------------\");        }    }}위에껀 스프링 자체의 빈. memberService부터가 내가 등록한 빈임만약 내가 등록한 빈만 보고싶다@Test    @DisplayName(\"애플리케이션 빈 출력하기\")    void findApplicationBean(){        String[] beanDefinitionNames = ac.getBeanDefinitionNames();        for(String beanDefinitionName : beanDefinitionNames){            BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);            if(beanDefinition.getRole()==BeanDefinition.ROLE_APPLICATION){                Object bean = ac.getBean(beanDefinitionName);                System.out.println(beanDefinitionName);                System.out.println(bean);                System.out.println(\"---------------\");            }        }    }  ROLE_APPLICATION : 직접 등록한 애플리케이션 빈  ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈  getBean() : 빈 이름으로 객체를 가져옴.스프링 빈 조회@Test@DisplayName(\"빈 이름으로 조회\")void findBeanByName(){    MemberService memberService = ac.getBean(\"memberService\", MemberService.class);    System.out.println(memberService);    System.out.println(memberService.getClass());    Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);}@Test@DisplayName(\"타입으로 조회\")void findBeanByType(){    MemberService memberService = ac.getBean(MemberService.class);    System.out.println(memberService);    System.out.println(memberService.getClass());    Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);}위와 동일한 결과@Test@DisplayName(\"구체타입으로 조회\")void findBeanByType2(){    MemberService memberService = ac.getBean(MemberServiceImpl.class);    System.out.println(memberService);    System.out.println(memberService.getClass());    Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);}이것도 동일함. 그러나 좋은방법은 아님. 이상적으로 돌아가지 않을때 사용하는 방법@Test@DisplayName(\"빈 이름 조회 실패\")void findBeanByName2(){    org.junit.jupiter.api.Assertions.assertThrows(        NoSuchBeanDefinitionException.class,         ()-&gt;ac.getBean(\"xxxx\",MemberService.class)    );}조회 실패 케이스동일타입 bean이 여러개일때@Test    @DisplayName(\"타입조회. 같은타입 둘 이상-&gt;중복오류발생\")    void sameType(){        MemberRepository member = ac.getBean(MemberRepository.class);    }    @Configuration    static class SameBeanConfig{        @Bean        public MemberRepository memberRepository1(){            return new MemoryMemberRepository();        }        @Bean        public MemberRepository memberRepository2(){            return new MemoryMemberRepository();        }    }오류남@Test    @DisplayName(\"타입조회. 같은타입 둘 이상-&gt;빈이름지정하면됨\")    void sameType2(){        MemberRepository memberRepository = ac.getBean(\"memberRepository1\", MemberRepository.class);        System.out.println(memberRepository);        Assertions.assertThat(memberRepository).isInstanceOf(MemberRepository.class);    }    @Test    @DisplayName(\"모든 타입 조회\")    void sameType3(){        Map&lt;String,MemberRepository&gt; memberRepository = ac.getBeansOfType(MemberRepository.class);        System.out.println(memberRepository);                for(String key : memberRepository.keySet()){            System.out.println(key);            System.out.println(memberRepository.get(key));            System.out.println(\"=====\");        }        Assertions.assertThat(memberRepository.size()).isEqualTo(2);    }이런식으로 해결하면됨.상속관계package com.hello.core.beanfind;import static org.junit.jupiter.api.Assertions.assertThrows;import java.util.Map;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.NoUniqueBeanDefinitionException;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.FixdiscountPolicy;import com.hello.core.discount.RateDiscountPolicy;public class ApplicationContextExtendsFIndTest {        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);    @Test    @DisplayName(\"부모타입 조회시 자식이 둘이상이면 중복오류\")    void findBeanByParentTypeDuplication(){        assertThrows(NoUniqueBeanDefinitionException.class, ()-&gt;ac.getBean(DiscountPolicy.class));    }    @Test    @DisplayName(\"부모타입 조회시 자식이 둘이상이면 빈이름 지정\")    void findBeanByParentTypeDuplication2(){        DiscountPolicy rateDiscountPolicy = ac.getBean(\"rateDiscountPolicy\", DiscountPolicy.class);        Assertions.assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class);    }    @Test    @DisplayName(\"특정 하위타입으로 조회\") //안좋은방법    void findBeanByParentTypeDuplication3(){        RateDiscountPolicy rateDiscountPolicy = ac.getBean(RateDiscountPolicy.class);        Assertions.assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class);    }    @Test    @DisplayName(\"부모타입으로 모두 조회\")     void findBeanByParentTypeDuplication4(){        Map&lt;String, DiscountPolicy&gt; beans = ac.getBeansOfType(DiscountPolicy.class);        Assertions.assertThat(beans).isEqualTo(2);        for(String key : beans.keySet()){            System.out.println(key);            System.out.println(beans.get(key));            System.out.println(\"====\");        }    }    @Test    @DisplayName(\"부모타입으로 모두 조회(Object)\")     void findBeanByParentTypeDuplication5(){        Map&lt;String, Object&gt; beans = ac.getBeansOfType(Object.class); //spring 내부적으로 등록된 bean까지 모두 출력됨        for(String key : beans.keySet()){            System.out.println(key);            System.out.println(beans.get(key));            System.out.println(\"====\");        }    }    @Configuration    static class TestConfig{        @Bean        public DiscountPolicy rateDiscountPolicy(){            return new RateDiscountPolicy();        }        @Bean        public DiscountPolicy fixDiscountPolicy(){            return new FixdiscountPolicy();        }    }}이것만 알아두면 됨"
  },
  
  {
    "title": "[김영한 모든 개발자를 위한 HTTP 웹 기본 지식] - HTTP 헤더 - 캐시와 조건부 요청",
    "url": "/posts/HTTP-%ED%97%A4%EB%8D%94-%EC%BA%90%EC%8B%9C%EC%99%80-%EC%A1%B0%EA%B1%B4%EB%B6%80-%EC%9A%94%EC%B2%AD/",
    "categories": "HTTP",
    "tags": "HTTP, 김영한모든개발자를위한HTTP웹기본지식",
    "date": "2023-01-24 00:00:00 +0900",
    





    
    "snippet": "캐시 기본 동작60초동안 캐시가 유효함2번째 요청 시 유효기간 이내라면 다운로드 없이 캐시의 이미지를 가져옴유효기간 초과 시 재 다운로드 함(네트와크 다운로드 발생)재 다운한걸 캐시에 저장(캐시 갱신)❗근데 데이터에 변경이 없는데 유효기간이 지났다면 재다운로드를 받을 필요가 있는가? → 검증 요청 필요(클라이언트와 서버의 데이터가 같은지 확인할 수 있...",
    "content": "캐시 기본 동작60초동안 캐시가 유효함2번째 요청 시 유효기간 이내라면 다운로드 없이 캐시의 이미지를 가져옴유효기간 초과 시 재 다운로드 함(네트와크 다운로드 발생)재 다운한걸 캐시에 저장(캐시 갱신)❗근데 데이터에 변경이 없는데 유효기간이 지났다면 재다운로드를 받을 필요가 있는가? → 검증 요청 필요(클라이언트와 서버의 데이터가 같은지 확인할 수 있는 방법)검증 헤더 추가재요청0.1M 전송은 헤더의 용량임→ 검증 헤더와 조건부 요청을 동시에 사용함  캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면 304 Not Modified + 헤더 메타 정보만 응답(바디X)  클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신 + 캐시에 저장되어 있는 데이터 재활용  결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드위 사진에서 status의 숫자 색이 회색인거는 캐시에서 불러온 데이터임!!!!!!!!! 짱신기이미지만 연 상태에서 새로고침하면 status가 304로 뜬다!!!!!!!!!!!!!!  검증 헤더          캐시 데이터와 서버 데이터가 같은지 검증하는 데이터      Last-Modified, ETag        조건부 요청 헤더          검증 헤더로 조건에 따른 분기      if-Modified-Since, if-Unmodified-Since : Last-Modified 사용      if-Match, if-None-Match : ETag 사용      조건이 만족하면 200 OK      조건이 만족하지 않으면 304 Not Modified      — 예시 - If-Modified-Since : 이후에 데이터가 수정되었으면?  데이터 미변경 예시          캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 10:00:00      304 Not Modified, 헤더 데이터만 전송(BODY 미포함)      전송 용량 0.1M (헤더 0.1M, 바디 1.0M)        데이터 변경 예시          캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 ==11==:00:00      200 OK, 모든 데이터 전송(BODY 포함)      전송 용량 1.1M (헤더 0.1M, 바디 1.0M)      — 검증헤더와 조건부 요청의 단점  1초 미만(0.x초) 단위로 캐시 조정이 불가능  날짜 기반의 로직 사용  데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우  서버에서 별도의 캐시 로직을 관리하고 싶은 경우(스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우)⇒ ETag(Entity Tag) 사용  캐시용 데이터에 임의의 고유한 버전 이름을 달아둠 - ETag: “v1.0”, ETag: “a2jiodwjekjl3”  데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성) - ETag: “aaaaa” -&gt; ETag: “bbbbb”  진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!  캐시 제어 로직을 서버에서 완전히 관리  클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)  Ex) 서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지, 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신캐시 제어 헤더  Cache-Control : 캐시 제어          Cache-Control: max-age : 캐시 유효 시간, 초 단위      Cache-Control: no-cache : 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용      Cache-Control: no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)        Pragma : 캐시 제어(하위 호환)          Pragma: no-cache      HTTP 1.0 하위호환        Exoires : 캐시 유효 기간(하위 호환). 캐시 만료일 지정  expires: Mon, 01 Jan 1990 00:00:00 GMT          캐시 만료일을 정확한 날짜로 지정      HTTP 1.0 부터 사용      지금은 더 유연한 Cache-Control: max-age 권장      Cache-Control: max-age와 함께 사용하면 Expires는 무시      프록시 캐시  캐시 지시어          Cache-Control: public - 응답이 public 캐시에 저장되어도 됨(공용 이미지 등)      Cache-Control: private - 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본값) (로그인 정보 등)      Cache-Control: s-maxage - 프록시 캐시에만 적용되는 max-age      Age: 60 (HTTP 헤더) - 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)      캐시 무효화Cache-Control: no-cache, no-store, must-revalidatePragma: no-cache (HTTP 1.0 하위호환)통장잔고같이 절대 캐시화되면 안되는 정보들      캐시 지시어(directives) - 확실한 캐시 무효화          Cache-Control: no-cache : 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용          원 서버에 접근할 수 없을 때 프록시에서 옛날 데이터라도 꺼내서 줌          Cache-Control: no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)              Cache-Control: must-revalidate                  캐시 만료후 최초 조회시 원 서버에 검증해야함          원 서버 접근 실패시 반드시 오류가 발생해야함 - 504(Gateway Timeout)          must-revalidate는 캐시 유효 시간이라면 캐시를 사용함                        원 서버에 접근할 수 없을 때 그냥 에러처리를 해버림            Pragma: no-cache      "
  },
  
  {
    "title": "[김영한 모든 개발자를 위한 HTTP 웹 기본 지식] - HTTP 일반헤더",
    "url": "/posts/HTTP-%EC%9D%BC%EB%B0%98-%ED%97%A4%EB%8D%94/",
    "categories": "HTTP",
    "tags": "HTTP, 김영한모든개발자를위한HTTP웹기본지식",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "field-name은 대소문자 구문 없음  HTTP 전송에 필요한 모든 부가정보      예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐  시 관리 정보…    표준 헤더가 너무 많음          https://en.wikipedia.org/wiki/List_of_HTTP_header_fields  ...",
    "content": "field-name은 대소문자 구문 없음  HTTP 전송에 필요한 모든 부가정보      예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐  시 관리 정보…    표준 헤더가 너무 많음          https://en.wikipedia.org/wiki/List_of_HTTP_header_fields        필요시 임의의 헤더 추가 가능          helloworld: hihi        과거 분류 방법(RFC2616) - 폐기          헤더 분류                  General 헤더: 메시지 전체에 적용되는 정보, 예) Connection: close          Request 헤더: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh; ..)          Response 헤더: 응답 정보, 예) Server: Apache          Entity 헤더: 엔티티 바디 정보, 예) Content-Type: text/html, Content-Length: 3423                    HTTP BODY                  메시지 본문(message body)은 엔티티 본문(entity body)을 전달하는데 사용함          엔티티 본문은 요청이나 응답에서 전달할 실제 데이터임          엔티티 헤더는 엔티티 본문의 데이터를 해석할 수 잇는 정보 제공                          데이터 유형(HTML, JSON), 데이터 길이, 압축 정보                                            2014년 RFC7230~7235 등장          엔티티(Entity) -&gt; 표현(Representation)      표현 (Representation) = representation Metadata(표현 메타데이터) + Representation Data(표현 데이터)      메세지 본문                  메시지 본문(message body)을 통해 표현 데이터 전달          메시지 본문 = 페이로드(payload)          표현은 요청이나 응답에서 전달할 실제 데이터          표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공                          데이터 유형(html, json), 데이터 길이, 압축 정보 등등                                참고: 표현 헤더는 표현 메타데이터와, 페이로드 메시지를 구분해야 하지만, 여기서는 생략                    표현표현 헤더는 전송, 응답 둘다 사용함.  Content-Type: 표현 데이터의 형식          미디어 타입, 문자 인코딩                  text/html; charset=utf-8          application/json          image/png                      Content-Encoding: 표현 데이터의 압축 방식          표현 데이터를 압축하기 위해 사용      데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가      데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제                  gzip          deflate          identity                      Content-Language: 표현 데이터의 자연 언어(ko, en, en-US 등)  Content-Length: 표현 데이터의 길이(바이트 단위). transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨콘텐츠 협상(콘텐츠 네고시에이션)  Accept : 클라이언트가 선호하는 미디어 타입 전달  Accept-Charset : 클라이언트가 선호하는 문자 인코딩  Accept-Encoding : 클라이언트가 선호하는 압축 인코딩  Accept-Languge : 클라이언트가 선호하는 자연 언어요청시에만 사용함!!그니까 구글 기본언어가 영어인데 내가 한국어로 검색하면 한국어 검색결과가 나오는 원리라는거같음근데 독일 회사에서 기본언어가 독일어고 영어도 지원하는 서비스에서 한국어로 요청을 했을때 독일어로 결과가 나오면 좀;;차라리 영어가 나음→ 우선순위 적용      협상과 우선순위(Quality Values(q))          Quality Values(q) 값 사용      0~1, 클수록 높은 우선순위      생략하면 1      Accept-Language : ko-KR, ko;q=0.9, en-US;q=0.8,en;q=0.7                  ko-KR;q=1(q=1은 생략해서 표시함)          ko;q=0.9          en-US;1=0          en;q=0.7                    구체적인 것이 우선함      Accept : text/*, text/plain, text/plain;format=flowed, /                  text/plain;format=flowed          text/plain          text/*          /                    구체적인 것을 기준으로 미디어 타입을 맞춤              Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,text/html;level=2;q=0.4, /;q=0.5                      물론 100프로 맞추지는 못하지만 최대한 맞춰서 제공해줌. 지원하지않는걸 제공할수는 없으니까  전송방식  단순 전송 : 요청하면 content-Length를 지정해서 응답해줌.  압축 전송 : 압축해서 보냄. 단, Content-Encoding으로 압축정보를 줘야함      분할 전송 : 분할해서 보냄. Transfer-Encoding: chunked 로 보내줘야함        \\r\\n이 나오면 끝임.        범위 전송 : 요청할때 범위를 지정해서 요청함. 만약 다운로드 중 종료됐다면 종료된부분부터 범위를 시작하면되는 식임      일반정보  Form : 유저 에이전트의 이메일 정보          일반적으로 잘 사용되지 않음      검색엔진 같은곳에서 주로 사용      요청에서 사용        Referer : 이전 웹 페이지 주소          현재 요청된 페이지의 이전 웹 페이지 주소      A→B로 이동하는 경우 B를 요청할 떄 Referer: A를 포함해서 요청      Referer를 사용해서 유입 경로 분석 가능      요청에서 사용      참고 : referer는 referrer를 오타낸거임        User-Agent : 유저 에이전트 애플리케이션 정보          user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36      클리이언트의 애플리케이션 정보(웹 브라우저 정보, 등등)      통계 정보      어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능 - 오류가 난 브라우저의 정보를 보고 문제 파악가능함. 특정 브라우저에서 문제가나는지 확인가능      요청에서 사용        Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보          Server: Apache/2.2.22 (Debian)      server: nginx      응답에서 사용        Date : 메세지가 생성된 날짜특별한 정보      HOST(요청한 호스트 정보-도메인)          요청에서 사용      필수      하나의 서버가 여러 도메인 처리      하나의 IP주소에 여러 도메인이 적용되었을때      여러 도메인이 한번에 처리되고있을때(한 서버안에 여러 애플리케이션이 구동) GET HELLO라는 요청이 들어갔을때 어느 애플리케이션에게 한 요청인지 구분할 수 있는 방법이 필요함            Location(페이지 리다이렉션)          웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)      응답코드 3xx에서 설명      201 (Created): Location 값은 요청에 의해 생성된 리소스 URI      3xx (Redirection): Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킴        Allow(허용 가능한 HTTP 메소드)          405(Method Not Allowed)에서 응답에 포함해야함      Allow : GET, HEAD, PUT      별로 안씀        Retry-After(유저 에이전트가 다음요청을 하기까지 기다려야하는 시간)          503(Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있음      Retry-After: Fri, 31 Dec 1999 23:59:59 GMT (날짜 표기)      Retry-After: 120 (초단위 표기)      인증  Authorization : 클라이언트 인증 정보를 서버에 전달          Authorization: Basic xxxxxxxxxxxxxxxx (인증과 관련된 값이 들어감)        WWW-Authenticate : 리소스 접근 시 필요한 인증 방법 정의          401 Unauthorized 응답과 함께 사용      WWW-Authenticate: Newauth realm=”apps”, type=1, title=”Login to \"apps\"”, Basic realm=”simple” (401오류가 나면 이걸 넣어줘야함)      쿠키HTTP는 무상태(Stateless) 프로토콜임. 클라이언트와 서버가 요청과 응답을 주고받으면 연결이 끊어짐. 클라이언트가 재요청을 해도 서버는 이전 요청을 기억하지 못함!! → 클라이언트와 서버는 서로 상태를 유지하지 않음— 대안 1  모든 정보에 사용자 정보를 포함함  GET /welcom?user=사용자 HTTP/1.1 이런식으로  모은 요청과 링크에 사용자 정보가 포함되어야한다는 단점이 있음  브라우저 완전 종료 후 재 실행하면 정보가 날아감— 대안2. 쿠키- Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)  Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달  모든 정보에 쿠키가 나온다면 보안에 문제가 있음  사용처          사용자 로그인 세션 관리      광고 정보 트래킹        쿠키 정보는 항상 서버에 전송됨          네트워크 트래픽 추가 유발      최소한의 정보만 사용(세션 id, 인증 토큰)      서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 (localStorage, sessionStorage) 참고        주의!          보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 번호 등등)        예) set-cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure          쿠키 생명 주기                  Set-Cookie: expires=Sat, 26-Dec-2020 04:39:21 GMT - 만료일이 되면 쿠키 삭제          Set-Cookie: max-age=3600 (3600초) - 0이나 음수를 지정하면 쿠키 삭제          세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지          영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지                    쿠키 - 도메인                  Ex) domain=example.org/          명시: 명시한 문서 기준 도메인 + 서브 도메인 포함                          domain=example.org를 지정해서 쿠키 생성                                  example.org는 물론이고                  dev.example.org도 쿠키 접근                                                              생략: 현재 문서 기준 도메인만 적용                          example.org 에서 쿠키를 생성하고 domain 지정을 생략                                  example.org에서만 쿠키 접근                  dev.example.org는 쿠키 미접근                                                                        쿠키 - 경로(Path)                  Ex) path=/home          이 경로를 포함한 하위 경로 페이지만 쿠키 접근          일반적으로 path=/ 루트로 지정          Ex)                          path=/home 지정              /home → 가능              /home/level1 → 가능              /home/level1/level2 → 가능              /hello → 불가능                                          쿠키 - 보안                  Secure                          원래 쿠키는 http, https를 구분하지 않고 전송하나 Secure를 적용하면 https인 경우에만 전송                                HttpOnly                          XSS 공격 방지              자바스크립트에서 접근 불가(document.cookie)              HTTP 전송에만 사용                                            SameSite                          XSRF 공격 방지              요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송                                          "
  },
  
  {
    "title": "[김영한 모든 개발자를 위한 HTTP 웹 기본 지식] - HTTP 상태코드",
    "url": "/posts/HTTP-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C/",
    "categories": "HTTP",
    "tags": "HTTP, 김영한모든개발자를위한HTTP웹기본지식",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "상태 코드: 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능  1xx (Informational): 요청이 수신되어 처리중 - 거의 안씀  2xx (Successful): 요청 정상 처리          200 OK - 요청 성공      201 created - 요청 성공, 새로운 리소스 생성됨(생성된 리소스는 응답의 Location헤더...",
    "content": "상태 코드: 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능  1xx (Informational): 요청이 수신되어 처리중 - 거의 안씀  2xx (Successful): 요청 정상 처리          200 OK - 요청 성공      201 created - 요청 성공, 새로운 리소스 생성됨(생성된 리소스는 응답의 Location헤더 필드로 식별)      202 Accepted - 요청 성공, 그러나 처리는 안됨(ex.요청 접수 후 1시간뒤 처리되는시스템)      204 - No Content - 요청 성공, 그러나 보낼 데이터가 없음.(ex.웹문서 편집기. save 후 같은화면유지 or 결과내용없음)            3xx (Redirection): 요청을 완료하려면 유저 에이전트(보통 웹브라우저)의 추가 행동이 필요  웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면, Location 위치로 자동 이동함(리다이렉트)        이벤트 페이지 경로 바뀜          영구 리다이렉션 - 특정 리소스의URI가 영구이동(ex. /members→/users). 기존 URI사용안함                  301 Moved Permanently - 리다이렉트 요청 시 요청 메소드가 GET으로 변하고 본문이 제거될 수도 있음(MAY) [정보를 새로입력해야함]          308 Permanent Redirect - 301과 기능은 같으나 리다이렉트 시 요청 메소드와 본문을 유지함(처음 POST를 보내면 리다이렉트도 POST로 보냄) [정보를 그냥 새 URI에서 바로 등록해버림. 보통 URI가 변경되면 필요 정보도 바뀜. 잘안씀]                            일시 리다이렉션(PRG : Post/Redirect/Get) - 일시적인 변경(주문완료 후 주문 내역화면으로 이동[POST/Redirect/GET])  post로 주문 후 웹브라우저를 새로고침하면(재요청) 주문이 중복될 수도 있어서 GET으로 리다이렉트 하는거임. 새로고침해도 결과화면을 GET으로 조회함.(새로고침 시 결과화면만 GET으로 다시 요청됨)                  302 Found - 리다이렉트 시 GET 으로 변하고 본문이 제거될 수 있음          307 Temporary Redirect - 302와 기능은 같으나 요청 메소드와 본문이 유지됨                      303 See Other - 302와 기능은 같으나 요청메소드만 GET으로 변경됨                    307, 303을 권장하나 다들 302를 많이 씀                    특수 리다이렉션 - 결과대신 캐시 사용                  300 Multiple Choices - 안씀          304 Not Modified                          캐시를 목적으로 사용. 클라이언트에게 리소스가 수정되지 않았음을 알려줌. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용함.(캐시로 리다이렉트)              304응답은 응답에 메세지 바디를 포함하면 안됨(로컬캐시를 사용해야함)              조건부 GET, HEAD 요청 시 사용                                            4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음          400 Bad Request - 클라이언트의 잘못된 요청으로 서버가 요청을 처리할 수 없음.                  요청 구문, 메세지 오류          클라이언트는 요청 내용을 다시 검토하고 보내야함          ex. 파라미터 잘못, API 스펙 안맞음                    401 Unauthorized - 클라이언트가 해당 리소스에대한 인증이 필요함                  인증(Authentication) 되지 않음          401 오류 발생 시 응답에 WWW-Authenticate 헤더와 함께 인증 방법 설명          참고                          인증(Authorization) : 본인 확인(로그인)              인가(Authorization) : 권한 부여(ADMIN권한 등 특정 리소스에 접근할 수 있는 권한. 인증없는 인가는 없음)              오류 메세지가 Unauthorized이지만 인증이 되지 않음                                          403 Forbidden - 요청은 이해함. 승인은 거부함                  인증자격증명은 있찌만 접근 권한이 불충분함          ex.admin이 아닌 사용자가 admin등급 리소스에 접근함                    404 Not Found - 요청 리소스 없음 or 클라이언트가 권한이 부족한 리소스에 접근해서 해당 리소스를 숨김            5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함(재시도시 복구되면 성공할 수도 있음)          500 Internal Server Error - 서버문제 오류. 애매하면 500으로 내면됨      503 Service Unavaulable - 서비스 이용 불가. 서버 과부화 또는 예정된 작업으로 요청 처리 불가. Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수 있음        ❗어지간 하면 500에러가 나면 안되게 해야함!!!!  "
  },
  
  {
    "title": "[김영한 모든 개발자를 위한 HTTP 웹 기본 지식] - 인터넷 네트워크",
    "url": "/posts/%EC%9D%B8%ED%84%B0%EB%84%B7-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/",
    "categories": "HTTP",
    "tags": "HTTP, 김영한모든개발자를위한HTTP웹기본지식",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "인터넷 통신클라이언트와 서버 컴퓨터가 인터넷으로 통신할때 인터넷 망을 통해 통신을함.그럼 통신 시 필요한 규칙은? → IP(인터텟 프로토콜)IP(인터텟 프로토콜)클라이언트와 서버 컴퓨터의 아이피 주소를 이용해 통신을 함.  역할          지정한 IP주소(IP Address)에 데이터를 전달              패킷(Packet)이라는 통신 ...",
    "content": "인터넷 통신클라이언트와 서버 컴퓨터가 인터넷으로 통신할때 인터넷 망을 통해 통신을함.그럼 통신 시 필요한 규칙은? → IP(인터텟 프로토콜)IP(인터텟 프로토콜)클라이언트와 서버 컴퓨터의 아이피 주소를 이용해 통신을 함.  역할          지정한 IP주소(IP Address)에 데이터를 전달              패킷(Packet)이라는 통신 단위로 데이터를 전달                  ip패킷이라는 규칙(출발지IP, 목적지 IP, 데이터, 기타)에 맞게 데이터를 싸서 전달. 이 패킷이 노드들을 거처 서버 컴퓨터에 도달, 서버컴퓨터에서 다시 패킷을 클라이언트 서버로 보냄                      한계          비연결성 - 패킷을 받을 대상이 없거나 서비스 불능 상태일때도 패킷이 전송됨(=클라이언트 컴퓨터는 서버컴퓨터의 상태를 알 수 없음)      비신뢰성 - 중간에 패킷이 사라질 가능성(=노드의 오류 가능성. 소실되도 알 수 없음), 패킷이 보낸 순서대로 도착하지 않을 가능성      프로그램 구분 - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 가능성      ⇒ TCP를 사용해서 해결  인터넷 프로토콜 스택의 4계층                               애플리케이션 계층 - HTTP, FTP              전송 계층 - TCP, UDP              인터넷 계층 - IP              네트워크 인터페이스 계층        포로토콜 계층애플리케이션웹브라우저, 네트워크 게임, 채팅 프로그램                               SOCKET 라이브러리      OS                               TCP                                     UDP                                     IP(Internet Protocol)      네트워크 인터페이스                               LAN 드라이버  LAN 장비      LAN 카드 —인터넷—&gt; 🖥️(서버)TCP로 인해 IP로는 해결이 안됐던 문제들이 해결됨TCP(Transmission Control Protocol : 전송 제어 프로토콜)현재 대부분이 TCP를 사용함  특징                  연결 지향 - TCP 3 way handshake(가상 연결)                클라이언트에서 접속요청 → 서버에서 요청수락, 데이터보내기위해 접속 요청 → 클라에서 접속 수락 → 데이터 전달 ⇒ 클라이언트가 서버컴퓨터의 상태를 알 수 있음. 응답이 없다면 데이터 전송이안됨  사실 요즘은 기술이 좋아져서 3번째 단계에서 데이터도 같이 보냄  물리적으로 연결이 된 것이 아니라 연결이 됐다고가정하자. 논리적으로만 연결된 상태 같은 느낌이라서 가상 연결이라고 함            데이터 전달 보증 - 데이터 받았다는 것을 응답해줌      순서 보장 - 순서대로 패킷이 도착하지 않았다면 꼬인 순서부터 다시 보내라고 요청함. (1,2,3순서인데 1,3,2로 왔으면 2부터 다시 보내라고 함)      신뢰할 수 있는 프로토콜      UDP(User Datagram Protocol : 사용자 데이터그램 포로토콜)  기능이 거의 없음(하얀 도화지에 비유)  연결 지향 - TCP 3 way handshake ❌  데이터 전달 보증 ❌  순서 보장 ❌  단순하고 빠름⇒ IP와 거의 같음. IP + PORT + 체크섬 = UDP ⇒ 에플리케이션에서 추가 작업 필요함PORT항구동시에 여러 서버와 통신중일때 도착하는 패킷들이 어느 서버에서 필요한 패킷인지 구분하려면? → TCP의 PORT를 이용해서 찾음결론적으로 port는 같은 IP내에서 프로세스를 구분하는 기준.아이피가 아파트면 포트는 동호수0~65535 까지 할당 가능하나 0~1023은 잘알려진 포트라 사용하지 않는 것이 좋음  FTP - 20,21  TELNET - 23  HTTP - 80  HTTPS - 443DNSip를 기억하기 어려움 + 아이피가 변경되기도 함 ⇒ DNS(Domain Name System:도메인 네임 시스템)사용 - 전화번호부 같은 느낌. 도메인 명을 IP주소로 변환함도메인은 돈주고 사야함."
  },
  
  {
    "title": "[김영한 모든 개발자를 위한 HTTP 웹 기본 지식] - URI와 웹 브라우저의 요청 흐름",
    "url": "/posts/URI%EC%99%80-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9A%94%EC%B2%AD-%ED%9D%90%EB%A6%84/",
    "categories": "HTTP",
    "tags": "HTTP, 김영한모든개발자를위한HTTP웹기본지식",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "URI(Uniform Resource Identifier)URL - resource의 위치(변할 수 있음)URN - resource의 이름(변하지 않음)그니까 URL이 주소고 URN이 상세주소(~~ 아파트)인거같음. 상세주소만으로 그 위치를 찾아갈 수는 없지만 주소만 있으면 찾아갈 수 있는 느낌? URN은 잘 사용하지 않음URN이름만으로 실제 리소스를...",
    "content": "URI(Uniform Resource Identifier)URL - resource의 위치(변할 수 있음)URN - resource의 이름(변하지 않음)그니까 URL이 주소고 URN이 상세주소(~~ 아파트)인거같음. 상세주소만으로 그 위치를 찾아갈 수는 없지만 주소만 있으면 찾아갈 수 있는 느낌? URN은 잘 사용하지 않음URN이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지않음이 밑으로는 URL과 URI를 같은 의미로 이야기함  [!important]scheme://[userinfo@]host[:port][/path][?query][#fragment]→ https://www.google.com:443/search?q=hello&amp;hl=ko      프로토콜(https)    호스트명(https://www.google.com)    포트 번호(443)    패스(/search)    쿼리 파라미터(q=hello&amp;hl=ko)    scheme          주로 프로토콜 사용              프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙                  ex) http, https, ftp 등등                    http는 80 포트, https는 443 포트를 주로 사용, 포트는 생략 가능      https는 http에 보안 추가 (HTTP Secure)        userInfo          URL에 사용자정보를 포함해서 인증      거의 사용하지 않음        host          호스트명      도메인명 또는 IP 주소를 직접 사용가능        port          포트(PORT)      접속 포트      일반적으로 생략, 생략시 http는 80, https는 443        path                  리소스 경로(path), 계층적 구조                              ex)                    /home/file1.jpg          /members          /members/100, /items/iphone12                      query          key=value 형태      ?로 시작, &amp;로 추가 가능 ?keyA=valueA&amp;keyB=valueB      query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터, 문자 형태        fragment          html 내부 북마크 등에 사용      서버에 전송하는 정보 아님      웹 브라우저 요청 흐름https://www.google.com/search?q=hello&amp;hl=ko위 주소를 입력했을때  DNS서버 찾음 -google의 IP주소 찾음  생략된 port주소 찾음 → 443  HTTP 요청 메세지 생성 → GET /search?q=hello&amp;hl=ko HTTP/1.1 Host: www.google.com 간략하게 보면 이렇게 생김  HTTP에 메세지를 전송함.2번 과정에서 syn, ack 이 일어남3번에 패킷 생성할때 전달 할 데이터가 HTTP메세지임!!!!!  구글 서버에 요청 패킷 도착  패킷 안의 데이터 분석 → hello의 한국어 검색결과를 요청한 것을 알아냄      구글에서 HTTP 응답 메세지를 만들어냄                                                                   HTTP/1.1 200 OK    Content-Type: text/html;charset=UTF-8    Content-Length: 3423  &lt;html&gt;  &lt;body&gt;…&lt;/body&gt;  &lt;/html&gt;                      응답 패킷 전달  클라이언트에 응답 패킷 도착  결과 출력"
  },
  
  {
    "title": "[김영한 모든 개발자를 위한 HTTP 웹 기본 지식] - HTTP 메소드",
    "url": "/posts/HTTP-%EB%A9%94%EC%86%8C%EB%93%9C/",
    "categories": "HTTP",
    "tags": "HTTP, 김영한모든개발자를위한HTTP웹기본지식",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "HTTP API중요한 것은 리소스 식별— 회원 정보 관리 API→ 회원이 리소스!!! 기능에 초점을 두지 말것!!!⇒ 회원 리소스를 URI에 매핑 그 후에 행위를 분리(HTTP 메소드)  HTTP 메소드          GET - 리소스 조회.                  서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리스트링)를 통해 ...",
    "content": "HTTP API중요한 것은 리소스 식별— 회원 정보 관리 API→ 회원이 리소스!!! 기능에 초점을 두지 말것!!!⇒ 회원 리소스를 URI에 매핑 그 후에 행위를 분리(HTTP 메소드)  HTTP 메소드          GET - 리소스 조회.                  서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리스트링)를 통해 전달          메세지 바디를 통해 전달이 가능하지만 지원하는 곳이 많지않아서 권장하지 않음                            POST - 요청 데이터 처리, 주로 등록에 사용                          메세지 바디를 통해 서버로 요청 데이터 전달          서버는 요청 데이터를 처리                          메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행                                주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용                — 사용 예시                  HTML양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공          게시판, 블로그, 뉴스그룹 등 기사 그룹에 메세지 게시          서버가 아직 식별하지 않은 새 리소스 생성(등록)          기존자원에 데이터 추가          단순히 데이터를 생성, 변경하는 것을 넘어 프로세스를 처리해야하는 경우.(ex.결제완료, 배달시작, 배달완료 처럼 프로세스 상태가 변경됨)          새로운 리소스가 생성되지않을 수도 있음          다른 메소드로 처리하기 애매한경우(JSON으로 넘겨야하는데 GET을 사용하기 어려울때)          그냥!!!애매하면 POST!!!!!                    PUT - 리소스를 대체, 해당 리소스가 없으면 생성(덮어쓰기)                              클라이언트가 리소스를 식별함                          클라이언트가 리소스 위치를 알고 URI를 지정함. POST와의 차이점                                    리소스의 전체 위치를 알고 URI를 지정함                                만약 위 예시에서 age만 수정해서 PUT을 날리면 username은 null값이 됨                              PATCH - 리소스 부분 변경. 만약 지원이 안되면 POST쓰면됨      DELETE - 리소스 삭제      — 기타 메소드  HEAD : GET과 동일하지만 메세지 부분 제외, 상태줄과 헤더만 반환  OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메소드)를 설명 (주로 CORS에서 사용)  CONNECT : 대상 자원으로 식별되는 서버베 대한 터널 설정 - 안씀  TRACE : 대상 리소스에 대한 경로를 따라 메세지 루프백 테스트를 수행 - 안씀  안전          호출해도 리소스를 변경하지 않음 - GET, HEAD      안전은 해당 리소스만 고려함. 뭐..로그가 어쩌고 까지는 고려안함            멱등(Idempotent)          몇번을 호출해도 결과가 같음      GET - 몇번을 조회해도 결과가 같음      PUT - 결과 대체. 같은 요청을 여러번해도 최종 결과는 같음      DELETE - 결과 삭제. 같은 요청을 여러번해도 삭제결과는 같음      자동 복구 매커니즘으로 활용      서버가 TIMEOUT 등으로 정상 응답을 못주었을때 클라이언트가 같은 요청을 다시해도 되는지 판단하는 근거임.        ❓혹시 중간에 외부요인으로 리소스가 바뀌면? - 그거까지는 고려안함    캐시가능(Cacheable)          응답결과 리소스를 캐시해서 사용해도 되는가?      GET, HEAD, POST, PATCH 캐시 가능              실제로는 GET, HEAD 정도만 캐시로 가능                  POST, PATCH는 본문 내용까지 캐시키로 고려해야해서 구현이 쉽지 않음                    "
  },
  
  {
    "title": "[김영한 모든 개발자를 위한 HTTP 웹 기본 지식] - HTTP 메소드 활용",
    "url": "/posts/HTTP-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%99%9C%EC%9A%A9/",
    "categories": "HTTP",
    "tags": "HTTP, 김영한모든개발자를위한HTTP웹기본지식",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "클라이언트 서버로 데이터 전송  쿼리 파라미터를 통한 데이터 전송          GET      주로 정렬 필터(검색어)        메시지 바디를 통한 데이터 전송          POST, PUT, PATCH      회원 가입, 상품 주문, 리소스 등록, 리소스 변경      4가지 상황 예시  정적 데이터 조회          쿼리 파라미터 ...",
    "content": "클라이언트 서버로 데이터 전송  쿼리 파라미터를 통한 데이터 전송          GET      주로 정렬 필터(검색어)        메시지 바디를 통한 데이터 전송          POST, PUT, PATCH      회원 가입, 상품 주문, 리소스 등록, 리소스 변경      4가지 상황 예시  정적 데이터 조회          쿼리 파라미터 미사용. 일반적으로 리소스 경로로 단순하게 조회가능함      이미지, 정적 텍스트 문서      조회는 GET사용        동적 데이터 조회          쿼리 파라미터를 사용      GET사용      검색, 게시판 목록에서 정렬 필터(검색어), 조회조건을 줄이는 필터, 조회결과 정렬 조건 등에 주로 사용        HTML Form을 통한 데이터 전송                  Content-Type: application/x-www-form-urlencoded 사용                만약 method를 GET으로 했으면 GET은 메시지바디를 사용하지않기때문에 username=kim&amp;age=20을 쿼리파라미터에 넣어버림. GET /save?username=kim&amp;age=20로 나가는거임. 그러나 GET은 조회에만 사용하는거라 리소스가 변경되면 안됨. 위 상황에서는 이름이 kim이고 나이가 20인사람을 조회하는 서비스를 제공해야함                  form의 내용을 메시지 바디를 통해 전송. (key=value, 쿼리파라미터형식)          전송 데이터를 url encoding 처리(abc김 → avc%EA%E9%80 이런식)                            Content-Type: multipart/form-data;                          파일업로드 같은 바이너리 데이터 전송시 사용          다른종류의 여러 파일과 폼의 내용 함께 전송 가능(그래서 이름이 multipart)                ⚠️HTML Form 전송은 GET, POST만 지원가능                  HTTP API를 통한 데이터 전송        JSON으로 형식 전달          서버 to 서버 → 백엔드 시스템 통신      앱클라이언트 → 아이폰, 안드로이드      웹 클라이언트                  HTML에서 Form전송 대신 자바 스크립트를 통한 통신에 사용          React, VueJs 같은 웹 클라이언트와 API 통신                    POST, PUT, PATCH - 메시지 바디를 통해 데이터 전송      GET - 조회, 쿼리파라미터로 데이터 전송      Content-Type: application/json 을 주로 사용(사실상 표준)                  TEXT, XML, JSON(거의 표준) 등등                    HTTP API 설계 예시— 회원 관리 시스템→ 클라이언트는 등록될 리소스의 URI를 모음 → 서버가 신규 리소스의 URI를 생성해줌.  API 설계(POST 기반 등록)          회원 목록 - /members → GET      회원 등록 - /members → POST      회원 조회 - /members/{id} → GET      회원 수정 - /members/{id} → PATCH, PUT, POST      회원 삭제 - /members/{id} → DELETE      ❗POST로 신규 등록시 서버에서 신규 리소스의 식별자(기본키)를 생성한뒤 응답할때 URI를 만들어서 전송해줌  [!important]컬렉션(Collection)- 서버가 관리하는 리소스 디렉토리- 서버가 리소스의 URI를 생성하고 관리함- 위 예시에서 컬렉션은 /members— 파일 관리 시스템  API설계(PUT기반 등록)  → 클라이언트가 리소스의 URI를 알고있고 직접 지정함.          파일 목록 - /files → GET      파일 조회 - /files{filename} → GET      파일 등록 - /files{filename} → PUT → 기존 파일이 있다면 지우고 다시 올려야하기때문에 PUT을 사용. 단, 클라리언트가 리소스 URI를 알고있어야함      파일 삭제 - /files{filename} → DELETE      파일 대량 등록 - /files → POST        [!important]스토어(Store)- 클라이언트가 관리하는 리소스 저장소- 클라이언트가 리소스의 URI를 알고 관리- 위 예시에서 스토어는 /files실무에서는 거의 POST기반으로 사용함— HTML FORM 사용  HTML FORM는 GET, POST만 지원함 → 제약있음  AJAX같은 기술을 사용해서 해결 가능함. → 회원API 참고  여기서는 순수 HTML, HTML FORM 이야기임  API 설계          회원 목록 - /members → GET      회원 등록 폼 - /members/new → GET      회원 등록 - /members/new, /members → POST      회원 조회 - /members/{id} → GET      회원 수정 폼 - /members/{id}/edit → GET      회원 수정 - /members/{id}/edit, /members/{id} → POST      회원 삭제 - /members/{id}/delete → POST  — delete를 쓰지못함. 이럴때는 컨트롤 URI를 사용해야함        [!important]컨트롤 URI, 컨트롤러(controller)- 문서, 컬렉션, 스토어로 해결하지 어려운 추가 프로세스 실행- 동사를 직접 사용- GET, POST만 지원하는 제약을 해결하기 위해 동사로된 리소스 경로를 사용함- POST의 /new, /edit, /delete가 컨트롤 URI임- HTTP 메소드로 해결하기 애매한 경우 사용함(HTTP API포함)  [!info]  REST API - URL Naming ConventionsIn REST, the primary data representation is called resource.https://restfulapi.net/resource-naming/위 사이트 참고  [!important]문서(document)- 단일개념(파일 하나, 객체 인스턴스, 데이터페이스 row)      ex)/member/100, /file/star.jpg  "
  },
  
  {
    "title": "[김영한 모든 개발자를 위한 HTTP 웹 기본 지식] - HTTP 기본",
    "url": "/posts/HTTP-%EA%B8%B0%EB%B3%B8/",
    "categories": "HTTP",
    "tags": "HTTP, 김영한모든개발자를위한HTTP웹기본지식",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "HTTP(HyperText[HTML] Transfer Protocol)처음에는 HTML을 담아 전송하는 것이었으나 지금은 모든 것을 담아서 전송 가능함.HTML, TEXT, 이미지, 음성, 영상, JSON, XML(API) 등등 모든 형태의 데이터, 서버간의 데이터를 주고받을때도 사용함TCP프로토콜을 사용하는 경우는 거의 없고 HTTP를 사용함. 게임...",
    "content": "HTTP(HyperText[HTML] Transfer Protocol)처음에는 HTML을 담아 전송하는 것이었으나 지금은 모든 것을 담아서 전송 가능함.HTML, TEXT, 이미지, 음성, 영상, JSON, XML(API) 등등 모든 형태의 데이터, 서버간의 데이터를 주고받을때도 사용함TCP프로토콜을 사용하는 경우는 거의 없고 HTTP를 사용함. 게임에나 TCP를 쓰는데 요즘은 모바일게임에도 HTTP를 사용함1997년에 나온 HTTP/1.1을 가장 많이 사용함.  기반 프로토콜          TCP: HTTP/1.1, HTTP/2 - 속도가 빠르지않음      UDP: HTTP/3 - 속도보완을 위해 나옴      현재 HTTP/1.1 주로 사용                  HTTP/2, HTTP/3 도 점점 증가                      특징          클라이언트 서버 구조                  request, response 구조          클라이언트는 서버에 요청을 보내고, 응답을 대기          서버가 요청에 대한 결과를 만들어서 응답                    무상태 프로토콜(스테이리스), 비연결성                  서버가 클라이언트의 상태를 보존x(stateless)                                          stateful(상태보존)와 stateless(무상태)의 차이                서버가 클라이언트의 값을 유지하냐 유지하지 않냐의 차이.                                                      statefull - 어떤 상품을 선택했는지, 어떤 결제 수단을 선택했는지 다음 단계에도 계속 값을 유지중임                    → 중간에 직원이 바뀌지 않는다고 가정하고 로직을 짜기때문에 직원이 바뀌면 문제가 생김                                        서버 장애 시 문제 발생                                                        stateless - 어떤 상품을 선택했는지, 어떤 결제 수단을 선택했는지 다음 단계에서 값을 날림. 결제수단을 선택할때 의식적으로 어떤 상품을 선택했는지 알려줘야하는 것                    → 중간에 직원이 바뀌어도 문제가 되지않도록 로직을 짜기때문에 직원이 바뀌어도 상관없음                    ⇒ 갑자기 클라이언트의 요청이 증가해도 서버를 대거 투입가능함.  응답 서버를 쉽게 바꿀수 있기때문에 무한한  서버 증걸이 가능함.                                        서버 1에 문제가 생기면 그대로 서버2로 요청을 보내면된다.                    그러나 로그인 같은 경우는 상태를 유지해야하기때문에 브라우저의 쿠키와 서버 세션 등을 사용해서 상태를 유지함                                                                                장점 - 서버 확장성이 높음(스케일 아웃)          단점 - 클라이언트가 추가 데이터를 전송해줘야함                    HTTP 메세지      단순함, 확장가능      비 연결성(connectionless)  연결을 유지할 때          여러 클라이언트와 연결 시 각 클라이언트마다 서버가 연결을 유지한 상태임 → 서버 자원 소모        연결을 유지하지 않을 때          여러 클라이언트와 연결 시 각 요청이 끝나면 연결을 종료시켜버림 → 서버가 연결을 유지하지 않아 최소한의 자원 유지      ⇒ 연결을 유지 하지 않는 것이 효율적임  HTTP는 기본이 연결을 유지하지 않음.  일반적으로 초단위 이하의 빠른 속도로 응답함  1시간동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적음(웹 브라우저에서 연속으로 검색 버튼만 누르는 일은 거의 없음)  한계와 극복          TCP/IP연결을 새로 맺어야 함 → 3 way handshake(syn, ack) 시간 추가      웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드 됨              지금은 HTTP 지속 연결(Persistent Connerctions)로 문제 해결                    HTTP/2, HTTP/3에서 더 많은 최적화      ❗최대한 stateless로 개발해야 동시에 여러 사람이 몰리는 이벤트에서 서버가 터지지 않을 가능성이 높음!!!!!!!!!!!!!!!!!!!!!!!!보통 최대한 풀기 위해 첫 페이지는 아무런 요청이없는 순수 html로 만들고 이벤트를 접수할 수 있도록 처리함HTTP 메세지공식 스펙https://tools.ietf.org/html/rfc7230#section-3  시작라인          요청 메세지(request-line)                  start-line = request-line / status-line          request-line = method SP(공백) request-target[요청대상] SP HTTP-version CRLF(엔터)          HTTP 메서드 (GET, POST, PUT, DELETE…) - 서버가 수행해야 할 동작 지정          요청 대상 (/search?q=hello&amp;hl=ko) - (절대경로[?쿼리])          HTTP Version                    응답 메세지(status-line)                  start-line = request-line / status-line          status-line = HTTP-version SP status-code[상태코드] SP reason-phrase CRLF          HTTP 버전          HTTP 상태 코드: 요청 성공, 실패를 나타냄                          200: 성공              400: 클라이언트 요청 오류              500: 서버 내부 오류              이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글                                            HTTP 헤더          header-field = field-name “:” OWS field-value OWS (OWS:띄어쓰기 허용)      field-name은 대소문자 구문 없음      HTTP 전송에 필요한 모든 부가정보                  Ex) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보,서버 애플리케이션 정보, 캐시 관리 정보…                    표준 헤더가 너무 많음                  https://en.wikipedia.org/wiki/List_of_HTTP_header_fields                    필요시 임의의 헤더 추가 가능                  helloworld: hihi                    Host : www. 이건안됨. host귀에 OWS가 없음  HTTP 메세지 바디          실제 전송할 데이터      HTML 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터 전송 가능      "
  },
  
  {
    "title": "[김영한 Querydsl] 환경설정",
    "url": "/posts/%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-01-21 00:00:00 +0900",
    





    
    "snippet": "build.gradle의 plugins에 id \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10”설정 추가dependencies에 implementation 'com.querydsl:querydsl-jpa’ 라이브러리 추가맨 하단에(test밑에)def querydslDir = “$buildDir/generat...",
    "content": "build.gradle의 plugins에 id \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10”설정 추가dependencies에 implementation 'com.querydsl:querydsl-jpa’ 라이브러리 추가맨 하단에(test밑에)def querydslDir = “$buildDir/generated/querydsl”querydsl {jpa = truequerydslSourcesDir = querydslDir}sourceSets {main.java.srcDir querydslDir}configurations {querydsl.extendsFrom compileClasspath}compileQuerydsl {options.annotationProcessorPath = configurations.querydsl}추가plugins {\tid 'java'\tid 'org.springframework.boot' version '3.0.1'\tid 'io.spring.dependency-management' version '1.1.0'\tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\"}group = 'com.kyh'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\timplementation 'org.springframework.boot:spring-boot-starter-webflux'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\tcompileOnly 'org.projectlombok:lombok'\truntimeOnly 'com.mysql:mysql-connector-j'\tannotationProcessor 'org.projectlombok:lombok'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\ttestImplementation 'io.projectreactor:reactor-test'\timplementation 'com.querydsl:querydsl-jpa'}tasks.named('test') {\tuseJUnitPlatform()}//querydsl 추가 시작def querydslDir = \"$buildDir/generated/querydsl\"querydsl {\tjpa = true\tquerydslSourcesDir = querydslDir}sourceSets {\tmain.java.srcDir querydslDir}configurations {\tquerydsl.extendsFrom compileClasspath}compileQuerydsl {\toptions.annotationProcessorPath = configurations.querydsl}//querydsl 추가 끝저거 실행❗❗ 스프링부트 3.0이상 일때buildscript {   ext {      queryDslVersion = \"5.0.0\"   }}plugins {\tid 'java'\tid 'war'\tid 'org.springframework.boot' version '3.0.1'\tid 'io.spring.dependency-management' version '1.1.0'\tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\"}group = 'com.kyh'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-data-jdbc'\timplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\timplementation 'org.springframework.boot:spring-boot-starter-web'\tcompileOnly 'org.projectlombok:lombok'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\truntimeOnly 'com.mysql:mysql-connector-j'\tannotationProcessor 'org.projectlombok:lombok'\tprovidedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\timplementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'\tannotationProcessor \"com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta\"}tasks.named('test') {\tuseJUnitPlatform()}//querydsl 추가 시작def querydslDir = \"$buildDir/generated/querydsl\"querydsl {   jpa = true   querydslSourcesDir = querydslDir}sourceSets {   main.java.srcDir querydslDir}compileQuerydsl{   options.annotationProcessorPath = configurations.querydsl}configurations {   compileOnly {      extendsFrom annotationProcessor   }   querydsl.extendsFrom compileClasspath}//querydsl 추가 끝이렇게 추가해야함위에 설정해준 폴더에 Qentity가 생겼는지 확인. 생겨야 된거임package com.kyh.querydsl2.entity;import static com.querydsl.core.types.PathMetadataFactory.*;import com.querydsl.core.types.dsl.*;import com.querydsl.core.types.PathMetadata;import javax.annotation.processing.Generated;import com.querydsl.core.types.Path;/** * QHello is a Querydsl query type for Hello */@Generated(\"com.querydsl.codegen.DefaultEntitySerializer\")public class QHello extends EntityPathBase&lt;Hello&gt; {    private static final long serialVersionUID = -1622153575L;    public static final QHello hello = new QHello(\"hello\");    public final NumberPath&lt;Long&gt; id = createNumber(\"id\", Long.class);    public QHello(String variable) {        super(Hello.class, forVariable(variable));    }    public QHello(Path&lt;? extends Hello&gt; path) {        super(path.getType(), path.getMetadata());    }    public QHello(PathMetadata metadata) {        super(Hello.class, metadata);    }}빌드하면 자동으로 만들어준다고함깃에 Qentity는 올리면 안된다고함!!!!!!!!!!!!!!!!!!!!!!!!!보통 build폴더를 ignore하고 쓰기때문에 ignore하고 여기만들면 안올라가긴함.— 근데 위 방법으로 하면 컴파일에 문제가 생기는거같아서buildscript {   ext {      queryDslVersion = \"5.0.0\"   }}plugins {\tid 'java'\tid 'war'\tid 'org.springframework.boot' version '3.0.1'\tid 'io.spring.dependency-management' version '1.1.0'\tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\"}group = 'com.kyh'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-data-jdbc'\timplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\timplementation 'org.springframework.boot:spring-boot-starter-web'\tcompileOnly 'org.projectlombok:lombok'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\truntimeOnly 'com.mysql:mysql-connector-j'\tannotationProcessor 'org.projectlombok:lombok'\tprovidedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\timplementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'\tannotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'}tasks.named('test') {\tuseJUnitPlatform()}//querydsl 추가 시작def querydslDir = \"$buildDir/generated/querydsl\"querydsl {   jpa = true   querydslSourcesDir = querydslDir}sourceSets {   main.java.srcDir querydslDir}compileQuerydsl{   options.annotationProcessorPath = configurations.querydsl}configurations {   compileOnly {      extendsFrom annotationProcessor   }   querydsl.extendsFrom compileClasspath}//querydsl 추가 끝이 방법으로 수정함. 이렇게하니까 JPAQueryFactory도 사용가능함(학원에서는 위버전이 됨)"
  },
  
  {
    "title": "[김영한 Querydsl] 기본문법",
    "url": "/posts/%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-01-21 00:00:00 +0900",
    





    
    "snippet": "@Testpublic void TestJPQL(){    Member findJPQL = em.createQuery(\"select m from Member m where m.username=:username\", Member.class).setParameter(\"username\", \"member1\").getSingleResult();    Asserti...",
    "content": "@Testpublic void TestJPQL(){    Member findJPQL = em.createQuery(\"select m from Member m where m.username=:username\", Member.class).setParameter(\"username\", \"member1\").getSingleResult();    Assertions.assertThat(findJPQL.getUsername()).isEqualTo(\"member1\");}@Testpublic void testQuerydsl(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember m = new QMember(\"m\");    Member member = query.select(m).from(m).where(m.username.eq(\"member1\")).fetchOne();    System.out.println(member);    Assertions.assertThat(member.getUsername()).isEqualTo(\"member1\");}파라미터 바인딩을 안해줬는데 자동으로 해줌.기본 Q-Type@Testpublic void testQuerydsl(){  JPAQueryFactory query = new JPAQueryFactory(em);  // QMember m = new QMember(\"m\");  Member member = query.select(QMember.member).from(QMember.member).where(QMember.member.username.eq(\"member1\")).fetchOne();  System.out.println(member);  // Assertions.assertThat(member.getUsername()).isEqualTo(\"member1\");}이렇게 써도됨. import를 static으로 해주면 member만 써줘도 됨Qentity에 이렇게 정의되있어서 터미널에뜨는 sql문에는 테이블 별칭이 member1로 되있음. 미리 QMember m = new QMember(“m”);이런식으로 설정해주면 테이블별칭이 m으로 바뀜. 셀프조인할때 진짜 간혹 한번씩 쓰기도하는듯검색조건 쿼리Member member = query.select(QMember.member)            .from(QMember.member)            .where(QMember.member.username.eq(\"member1\").and(QMember.member.age.eq(10)))            .fetchOne();이런식으로 가능함. and말고 or조건도 가능함Member member = query.select(QMember.member)            .from(QMember.member)            .where(                QMember.member.username.eq(\"member1\"),                QMember.member.age.eq(10)            )            .fetchOne();위랑 같은결과가 나옴. and를 쓰지않더라도 콤마로 구분가능member.username.eq(\"member1\") // username = 'member1'member.username.ne(\"member1\") //username != 'member1'member.username.eq(\"member1\").not() // username != 'member1'member.username.isNotNull() //이름이 is not nullmember.age.in(10, 20) // age in (10,20)member.age.notIn(10, 20) // age not in (10, 20)member.age.between(10,30) //between 10, 30member.age.goe(30) // age &gt;= 30member.age.gt(30) // age &gt; 30member.age.loe(30) // age &lt;= 30member.age.lt(30) // age &lt; 30member.username.like(\"member%\") //like 검색member.username.contains(\"member\") // like ‘%member%’ 검색member.username.startsWith(\"member\") //like ‘member%’ 검색이거 외에도 많음. sql에 있는건 거의 다 있다고 보면됨결과조회위에서는 fetchOne()을 썼는데 fetch()를 쓰면 결과가 List로 나옴.  fetchOne() - 단건조회  fetch() - 리스트 조회, 데이터가 없다면 빈 리스트 반환  fetchFirst() - limit(1).fetchOne()과 같은 결과  fetchResults() - 페이징 정보 포함, total count 쿼리 추가 실행 - 성능이 중요할땐 가급적 사용 하지말것  fetchCount() - count쿼리로 변경해서 count 수 조회JPAQueryFactory query = new JPAQueryFactory(em);//ListList&lt;Member&gt; fetch = query.selectFrom(QMember.member).fetch();//단 건Member findMember1 = query.selectFrom(QMember.member).fetchOne();//처음 한 건 조회Member findMember2 = query.selectFrom(QMember.member).fetchFirst();//페이징에서 사용QueryResults&lt;Member&gt; results = query.selectFrom(QMember.member).fetchResults(); //페이징 정보 포함되있음List&lt;Member&gt; content = results.getResults();//컨텐츠만 꺼내옴. results.getTotal(); //페이징을 위한 총 컨텐츠의 수 //쿼리 2번 날아감//count 쿼리로 변경(위 getTotal이랑 같은결과임)long count = query.selectFrom(QMember.member).fetchCount();정렬em.persist(new Member(null, 100));em.persist(new Member(\"member5\", 100));em.persist(new Member(\"member6\", 100));List&lt;Member&gt; result = queryFactory\t.selectFrom(member)\t.where(member.age.eq(100))\t.orderBy(member.age.desc(), member.username.asc().nullsLast())\t.fetch();Member member5 = result.get(0);Member member6 = result.get(1);Member memberNull = result.get(2);assertThat(member5.getUsername()).isEqualTo(\"member5\");assertThat(member6.getUsername()).isEqualTo(\"member6\");assertThat(memberNull.getUsername()).isNull();페이징@Testpublic void paging1() { List&lt;Member&gt; result = queryFactory\t .selectFrom(member)\t .orderBy(member.username.desc())\t .offset(1) //0부터 시작(zero index)\t .limit(2) //최대 2건 조회\t .fetch(); assertThat(result.size()).isEqualTo(2);}전체가 필요하다면@Testpublic void paging2() { QueryResults&lt;Member&gt; queryResults = queryFactory\t .selectFrom(member)\t .orderBy(member.username.desc())\t .offset(1)\t .limit(2)\t .fetchResults(); assertThat(queryResults.getTotal()).isEqualTo(4); assertThat(queryResults.getLimit()).isEqualTo(2); assertThat(queryResults.getOffset()).isEqualTo(1); assertThat(queryResults.getResults().size()).isEqualTo(2);}단, count쿼리도 같이 실행되니 성능 상 주의해야함집합@Testpublic void aggregation() throws Exception { List&lt;Tuple&gt; result = queryFactory\t .select(member.count(),\t\t member.age.sum(),\t\t member.age.avg(),\t\t member.age.max(),\t\t member.age.min())\t .from(member)\t .fetch(); Tuple tuple = result.get(0); assertThat(tuple.get(member.count())).isEqualTo(4); assertThat(tuple.get(member.age.sum())).isEqualTo(100); assertThat(tuple.get(member.age.avg())).isEqualTo(25); assertThat(tuple.get(member.age.max())).isEqualTo(40); assertThat(tuple.get(member.age.min())).isEqualTo(10);}tuple은 프로젝션과 결과반환에서 설명함. Querydsl이 제공함. 타입이 여러개일때 꺼내올 수 있는 기능을 하는거같음. 실무에선 DTO로 반환하는걸 더 많이쓴다고함  groupBy@Testpublic void group() throws Exception { List&lt;Tuple&gt; result = queryFactory\t .select(team.name, member.age.avg())\t .from(member)\t .join(member.team, team)\t .groupBy(team.name)\t .fetch(); Tuple teamA = result.get(0); Tuple teamB = result.get(1); assertThat(teamA.get(team.name)).isEqualTo(\"teamA\"); assertThat(teamA.get(member.age.avg())).isEqualTo(15); assertThat(teamB.get(team.name)).isEqualTo(\"teamB\"); assertThat(teamB.get(member.age.avg())).isEqualTo(35);  [!important]having가능함. .groupBy(item.price).having(item.price.gt(1000))이런식으로 쓰면됨조인@Testpublic void testQuerydsl2(){    JPAQueryFactory query = new JPAQueryFactory(em);    List&lt;Member&gt; result =query.selectFrom(QMember.member)        .join(QMember.member.team, QTeam.team)        .where(QTeam.team.name.eq(\"teamA\"))        .fetch();}left join, right join 가능함. join뒤에 on도 가능theta join(크로스 조인)도 가능@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    //회원이름과 팀이름이 같은 경우    List&lt;Member&gt; result =query.select(QMember.member)        .from(QMember.member, QTeam.team) //연관관계 없는 team과 member를 조인 가능함        .where(QMember.member.username.eq(QTeam.team.name))        .fetch();}외부조인은 on을 사용해야 가능함  on절                  조인 대상 필터링          List&lt;Tuple&gt; result = query.select(QMember.member, QTeam.team)              .from(QMember.member)              .leftJoin(QMember.member.team, QTeam.team).on(QTeam.team.name.eq(\"teamA\"))              .fetch();                ]]        내부조인을 하면 where절에서 필터링하는 것과 동일함(where t.team.name.eq(”teamA”)). 내부조인이면 where로 해결하고 외부조인이 필요할때만 사용하는 것을 권장함                    연관관계 없는 엔티티 외부조인          em.persist(new Member(\"teamA\"));  em.persist(new Member(\"teamB\"));  em.persist(new Member(\"teamC\"));          List&lt;Tuple&gt; result = query.select(QMember.member, QTeam.team)      .from(QMember.member)      .leftJoin(QTeam.team).on(QMember.member.username.eq(QTeam.team.name))       //leftjoin에 team만 적어줬기때문에 FK로 join하는 것이 아니라 on절을 기준으로 join함      .fetch();                                  페치 조인                  적용 전          @PersistenceUnit  EntityManagerFactory emf;  @Test  public void fetchJoinNo() throws Exception {  \t em.flush();  \t em.clear();          \t Member findMember = queryFactory  \t\t .selectFrom(member)  \t\t .where(member.username.eq(\"member1\"))  \t\t .fetchOne();             boolean loaded =\temf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());  \t\t//team이 로드되었는지를 확인함          \t assertThat(loaded).as(\"페치 조인 미적용\").isFalse();  }                        @Test  public void fetchJoinUse() throws Exception {  \t em.flush();  \t em.clear();      \t Member findMember = queryFactory  \t\t .selectFrom(member)  \t\t .join(member.team, team).fetchJoin()  \t\t .where(member.username.eq(\"member1\"))  \t\t .fetchOne();      \t boolean loaded =\temf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());  \t\t//team이 로드되었는지를 확인함      \t assertThat(loaded).as(\"페치 조인 적용\").isTrue();  }      서브쿼리com.querydsl.jpa.JPAExpressions 사용— 나이가 가장 많은 회원@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember memberSub = new QMember(\"memberSub\");    List&lt;Member&gt; result = query        .selectFrom(QMember.member)        .where(QMember.member.age.eq(            JPAExpressions                .select(memberSub.age.max())                .from(memberSub)        ))        .fetch();    assertThat(result).extracting(\"age\").containsExactly(20);}— 나이가 평균 이상인 회원@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember memberSub = new QMember(\"memberSub\");    List&lt;Member&gt; result = query        .selectFrom(QMember.member)        .where(QMember.member.age.goe(            JPAExpressions                .select(memberSub.age.avg())                .from(memberSub)        ))        .fetch();    assertThat(result).extracting(\"age\").containsExactly(18,15,17);}— 나이가 10살 초과인 회원@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember memberSub = new QMember(\"memberSub\");    List&lt;Member&gt; result = query        .selectFrom(QMember.member)        .where(QMember.member.age.in(            JPAExpressions                .select(memberSub.age)                .from(memberSub)                .where(memberSub.age.gt(10))        ))        .fetch();    for(Member member : result){        System.out.println(member);    }}— select 절에 서브쿼리@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember memberSub = new QMember(\"memberSub\");    List&lt;Tuple&gt; result = query        .select(QMember.member.username,                JPAExpressions                    .select(memberSub.age.avg())                    .from(memberSub))        .from(QMember.member)        .fetch();    for(Tuple member : result){        System.out.println(member);    }}JPAExpressions도 static으로 import해주면 더 깔끔하게 쓸 수 있음⚠️from절의 서브쿼리는 지원하지 않음. jpq, jpql과 마찬가지로 하이버네이트 구현체를 사용하면 querydsl도 select절의 서브쿼리를 사용가능함.→ from절의 서브쿼리 해결방안  서브쿼리를 join으로 변경  애플리케이션에서 쿼리를 2분 분리해서 실행  native SQL문을 사용쿼리문으로 모든 것을 해결하려는 것은 나쁜습관이라고 함. 쿼리문은 데이터만 가져오도록 할 것.SQL AntiPatterns이 책 참고case문select, where에서 사용 가능@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    List&lt;String&gt; result = query        .select(QMember.member.age            .when(10).then(\"열살\")            .when(18).then(\"열여덟살\")            .otherwise(\"기타\"))        .from(QMember.member)        .fetch();    for(String member : result){        System.out.println(member);    }}같은값이 두번나오면 저렇게 2로 표시가 되는건가..?그런가보네List&lt;String&gt; result = queryFactory\t .select(new CaseBuilder()\t .when(member.age.between(0, 20)).then(\"0~20살\")\t .when(member.age.between(21, 30)).then(\"21~30살\")\t .otherwise(\"기타\")).from(member).fetch()좀더 복잡한 case문은 이렇게 짜면됨그러나 쿼리문은 DB에서 최소한의 데이터를 가져오는 작업만하고 애플리케이션에서 바꾸는 것이 더 효율적임— 다음과 같은 임의의 순서로 회원을 출력하고 싶다면?  0 ~ 30살이 아닌 회원을 가장 먼저 출력  0 ~ 20살 회원 출력  21 ~ 30살 회원 출력NumberExpression&lt;Integer&gt; rankPath = new CaseBuilder() .when(member.age.between(0, 20)).then(2) .when(member.age.between(21, 30)).then(1) .otherwise(3);List&lt;Tuple&gt; result = queryFactory .select(member.username, member.age, rankPath) .from(member) .orderBy(rankPath.desc()) .fetch();for (Tuple tuple : result) { String username = tuple.get(member.username); Integer age = tuple.get(member.age); Integer rank = tuple.get(rankPath); System.out.println(\"username = \" + username + \" age = \" + age + \" rank = \"+ rank);}복잡한 조건을 변수로 지정해서 사용 가능함상수@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    List&lt;Tuple&gt; result = query        .select(QMember.member.username, Expressions.constant(\"A\"))        .from(QMember.member)        .fetch();    for(Tuple member : result){        System.out.println(member);    }}sql문에는 따로 추가되서 날아가는것은 아니나 A가 찍혀나옴concat@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    List&lt;String&gt; result = query        .select(QMember.member.username.concat(\"_\").concat(QMember.member.age.stringValue()))        .from(QMember.member)        .fetch();            for(String member : result){        System.out.println(member);    }}Enum처리할때 자주 사용함"
  },
  
  {
    "title": "[김영한 실전! 스프링 데이터 JPA] 그 외 기능",
    "url": "/posts/%EA%B7%B8%EC%99%B8%EA%B8%B0%EB%8A%A5/",
    "categories": "JPA",
    "tags": "jpa, 실전스프링데이터JPA, ORM",
    "date": "2023-01-19 00:00:00 +0900",
    





    
    "snippet": "복잡도에 비해서 실무에서 쓰기에는 약간 애매한 기능들Specifications(명세) - 안씀DDD(도메인 주도 설계)는 SPECIFICATION(명세)라는 개념을 소개. spring data jpa는 JPA Criteria(가독성구리다고하심)를 활용해 이 개념을 사용할 수 있도록 지원함  술어(predicate)          참 또는 거짓으로 평...",
    "content": "복잡도에 비해서 실무에서 쓰기에는 약간 애매한 기능들Specifications(명세) - 안씀DDD(도메인 주도 설계)는 SPECIFICATION(명세)라는 개념을 소개. spring data jpa는 JPA Criteria(가독성구리다고하심)를 활용해 이 개념을 사용할 수 있도록 지원함  술어(predicate)          참 또는 거짓으로 평가      AND/OR 같은 연산자로 조합해서 다양한 검색조건을 쉽게 생성함(컴포지트 패턴) - ex.검색 조건 하나하나      org.springframework.data.jpa.domain.Specification 클래스로 정의          package com.spring.datajpa.repository;      import java.util.Collection;  import java.util.List;      import org.springframework.data.domain.Page;  import org.springframework.data.domain.Pageable;  import org.springframework.data.domain.Slice;  import org.springframework.data.jpa.repository.EntityGraph;  import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.data.jpa.repository.JpaSpecificationExecutor;  import org.springframework.data.jpa.repository.Lock;  import org.springframework.data.jpa.repository.Modifying;  import org.springframework.data.jpa.repository.Query;  import org.springframework.data.jpa.repository.QueryHints;  import org.springframework.data.repository.query.Param;      import com.spring.datajpa.entity.Member;      import jakarta.persistence.LockModeType;  import jakarta.persistence.QueryHint;      public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;,   MemberRepositoryCustom, JpaSpecificationExecutor&lt;Member&gt;{      ...  }          @Test  public void specBasic() throws Exception {  \t //given  \t Team teamA = new Team(\"teamA\");  \t em.persist(teamA);  \t Member m1 = new Member(\"m1\", 0, teamA);  \t Member m2 = new Member(\"m2\", 0, teamA);  \t em.persist(m1);  \t em.persist(m2);  \t em.flush();  \t em.clear();  \t //when  \t Specification&lt;Member&gt; spec =\tMemberSpec.username(\"m1\").and(MemberSpec.teamName(\"teamA\"));  \t List&lt;Member&gt; result = memberRepository.findAll(spec);  \t //then  \t Assertions.assertThat(result.size()).isEqualTo(1);  }          public class MemberSpec {  \t public static Specification&lt;Member&gt; teamName(final String teamName) {  \t\t return (Specification&lt;Member&gt;) (root, query, builder) -&gt; {  \t\t\t if (StringUtils.isEmpty(teamName)) {  \t\t\t return null;  \t\t }  \t\t Join&lt;Member, Team&gt; t = root.join(\"team\", JoinType.INNER); //회원과 조인  \t\t return builder.equal(t.get(\"name\"), teamName);  \t\t };  \t }  \t public static Specification&lt;Member&gt; username(final String username) {  \t\t return (Specification&lt;Member&gt;) (root, query, builder) -&gt;  \t\t builder.equal(root.get(\"username\"), username);  \t }  }        ..안씀. 그냥 querydsl쓰는게 나음  Query By Example - 애매함동적쿼리를 편리하게 처리 가능함@SpringBootTest@Transactionalpublic class QueryByExampleTest {\t @Autowired MemberRepository memberRepository;\t @Autowired EntityManager em;\t @Test\t public void basic() throws Exception {\t\t //given\t\t Team teamA = new Team(\"teamA\");\t\t em.persist(teamA);\t\t em.persist(new Member(\"m1\", 0, teamA));\t\t em.persist(new Member(\"m2\", 0, teamA));\t\t em.flush();\t\t //when\t\t //Probe 생성\t\t Member member = new Member(\"m1\");\t\t Team team = new Team(\"teamA\"); //내부조인으로 teamA 가능\t\t member.setTeam(team);\t\t //ExampleMatcher 생성, age 프로퍼티는 무시\t\t ExampleMatcher matcher = ExampleMatcher.matching().withIgnorePaths(\"age\"); //age라는 속성이 있다면 무시\t\t Example&lt;Member&gt; example = Example.of(member, matcher);\t\t List&lt;Member&gt; result = memberRepository.findAll(example);\t\t //then\t\t assertThat(result.size()).isEqualTo(1);\t }}  Probe: 필드에 데이터가 있는 실제 도메인 객체  ExampleMatcher: 특정 필드를 일치시키는 상세한 정보 제공, 재사용 가능  Example: Probe와 ExampleMatcher로 구성, 쿼리를 생성하는데 사용outer join이 안됨!! 중첩 제약조건도 안됨!!매칭조건이 너무 단순함(거의 =조건만)그냥 querydsl쓰자Projections - 꽤 도움됨엔티티대신 DTO를 편리하게 조회인터페이스만 정의해두면 실제 구현체는 spring data jpa가 만들어서 데이터를 담아서 반환함  open projections      public interface UsernameOnly {  \t @Value(\"#{target.username + ' ' + target.age + ' ' + target.team.name}\")  \t String getUsername();  }        이름 20 1팀 이런식으로 나옴. 모든 데이터가 조회된다는 단점이 있음.    클래스 기반 Projections      public class UsernameOnlyDto {  \t private final String username;      \t public UsernameOnlyDto(String username) {  \t\t this.username = username;  \t }      \t public String getUsername() {  \t\t return username;  \t }  }        생성자의 파라미터 이름으로 매핑됨    동적 Projections      &lt;T&gt; List&lt;T&gt; findProjectionsByUsername(String username, Class&lt;T&gt; type);          List&lt;UsernameOnly&gt; result = memberRepository.findProjectionsByUsername(\"m1\",UsernameOnly.class);        중접구조      &lt;T&gt; List&lt;T&gt; findProjectionsByUsername(String username, Class&lt;T&gt; type);          public interface NestedClosedProjection {  \t String getUsername();  \t TeamInfo getTeam();      \t interface TeamInfo {  \t\t String getName();  \t }  }          List&lt;NestedClosedProjections&gt; result = memberRepository.findProjectionsByUsername(\"m1\",NestedClosedProjections.class);        중첩구조일때는 약간 애매해짐.  — 결론  프로젝션 대상이 root 엔티티면 유용함  프로젝션 대상이 root 엔티티를 넘어가면 JPQL SELECT 최적화가 안됨  실무의 복잡한 쿼리를 해결하기에는 한계가있음  단순할 때만 사용하고 복잡해지면 QueryDSL쓸것네이티브 쿼리sql문을 직접 짜는 거. 사용하지않는것이 좋으나 최수의 수단으로 어쩔수없을때 사용하면됨.@Query(value = \"select * from member where username = ?\", nativeQuery = true)Member findByNativeQuery(String username)보통 DTO로 조회하고싶을때 사용함반환타입이 몇개 지원이 되지않음(Object[], Tuple, DTO). 동적쿼리도 불가능.— projections를 활용해서 효율적으로 쓸 수 있음@Query(value = \"SELECT m.member_id as id, m.username, t.name as teamName \" + \"FROM member m left join team t ON m.team_id = t.team_id\", countQuery = \"SELECT count(*) from member\", //페이징때문에 만든거임 nativeQuery = true)Page&lt;MemberProjection&gt; findByNativeProjection(Pageable pageable)interface DTO로 반환+page기능동적쿼리는 잘 안되니까 알아둘것. 동적쿼리는 하이버네이트를 직접 활용하거나 스프링 jdbcTemplate, myBatis, jooq같은 외부 라이브러리 사용하면됨"
  },
  
  {
    "title": "[김영한 실전! 스프링 데이터 JPA] Spring Data Jpa 분석",
    "url": "/posts/spring_data_jpa_%EB%B6%84%EC%84%9D/",
    "categories": "JPA",
    "tags": "jpa, 실전스프링데이터JPA, ORM",
    "date": "2023-01-19 00:00:00 +0900",
    





    
    "snippet": "구현체 분석  @Repository 적용: JPA 예외를 스프링이 추상화한 예외로 변환  @Transactional 트랜잭션 적용 - jpa에서는 붙여야했으나 spring data jpa에서는 안붙여도됨          JPA의 모든 변경은 트랜잭션 안에서 동작      스프링 데이터 JPA는 변경(등록, 수정, 삭제) 메서드를 트랜잭션 처리     ...",
    "content": "구현체 분석  @Repository 적용: JPA 예외를 스프링이 추상화한 예외로 변환  @Transactional 트랜잭션 적용 - jpa에서는 붙여야했으나 spring data jpa에서는 안붙여도됨          JPA의 모든 변경은 트랜잭션 안에서 동작      스프링 데이터 JPA는 변경(등록, 수정, 삭제) 메서드를 트랜잭션 처리      서비스 계층에서 트랜잭션을 시작하지 않으면 리파지토리에서 트랜잭션 시작      서비스 계층에서 트랜잭션을 시작하면 리파지토리는 해당 트랜잭션을 전파 받아서 사용      그래서 스프링 데이터 JPA를 사용할 때 트랜잭션이 없어도 데이터 등록, 변경이 가능했음(사실은 트랜잭션이 리포지토리 계층에 걸려있는 것임)        @Transactional(readOnly = true)          데이터를 단순히 조회만 하고 변경하지 않는 트랜잭션에서 readOnly = true 옵션을 사용하면 플러시를 생략해서 약간의 성능 향상을 얻을 수 있음        save() 메서드          새로운 엔티티면 저장(persist) - isNew(entity)가 true면      새로운 엔티티가 아니면 병합(merge) - isNew(entity)가 false면  — 새로운 엔티티 구분 방법      식별자가 객체일 때 null 로 판단      식별자가 자바 기본 타입일 때 0 으로 판단 - int처럼 null이 올 수 없는 경우      Persistable 인터페이스를 구현해서 판단 로직 변경 가능        기본키가 없으면 엔티티고 있으면 기존에있던 엔티티로 판단하는 듯.        근데 만약 임의로 기본키를 지정했는데 DB에 해당하는 기본키가 존재하지 않으면? insert구문으로 바꿔서 날림. = 비효율적    데이터 변경을 변경감지 기능을 하용하고 저장은 persist를 사용하는게 나음. merge를 쓰지않겠다고 가정하고 코드를 짜면 됨.    근데 만약! 기본키를 임의로 지정해줘야하는 순간이 온다면?      package com.spring.datajpa.entity;      import java.time.LocalDateTime;      import org.springframework.data.annotation.CreatedDate;  import org.springframework.data.domain.Persistable;  import org.springframework.data.jpa.domain.support.AuditingEntityListener;      import jakarta.persistence.Entity;  import jakarta.persistence.EntityListeners;  import jakarta.persistence.Id;  import lombok.AccessLevel;  import lombok.NoArgsConstructor;      @Entity  @NoArgsConstructor(access = AccessLevel.PROTECTED)  @EntityListeners(AuditingEntityListener.class)  public class Item implements Persistable&lt;String&gt;{      @Id      private String id;          @CreatedDate       private LocalDateTime createdDate;          public Item(String id){          this.id=id;      }          @Override      public String getId(){          return id;      }          @Override      public boolean isNew(){          return createdDate==null;      }  }          package com.spring.datajpa.repository;      import org.junit.jupiter.api.Test;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.boot.test.context.SpringBootTest;      import com.spring.datajpa.entity.Item;      @SpringBootTest  public class ItemRepositoryTest {      @Autowired ItemRepository itemRepository;          @Test      public void save(){          Item item = new Item(\"a\");          itemRepository.save(item);      }  }        저장 값의 등록일을 기준으로 판단하도록 오버라이딩함.  "
  },
  
  {
    "title": "[김영한 실전! 스프링 데이터 JPA] 확장 기능",
    "url": "/posts/%ED%99%95%EC%9E%A5%EA%B8%B0%EB%8A%A5/",
    "categories": "JPA",
    "tags": "jpa, 실전스프링데이터JPA, ORM",
    "date": "2023-01-17 00:00:00 +0900",
    





    
    "snippet": "사용자 리포지토리 구현리포지토리는 인터페이스만 정의하고 구현체는 자동으로 생성하는 spring data jpa에서 인터페이스의 메소드를 직접 구현하고싶다면?  JPA 직접 사용  스프링 JDBC Template사용  Mybatis사용  데이터베이스 커넥션 직접 사용  Querydsl 사용package com.spring.datajpa.repositor...",
    "content": "사용자 리포지토리 구현리포지토리는 인터페이스만 정의하고 구현체는 자동으로 생성하는 spring data jpa에서 인터페이스의 메소드를 직접 구현하고싶다면?  JPA 직접 사용  스프링 JDBC Template사용  Mybatis사용  데이터베이스 커넥션 직접 사용  Querydsl 사용package com.spring.datajpa.repository;import java.util.List;import com.spring.datajpa.entity.Member;public interface MemberRepositoryCustom {    List&lt;Member&gt; findMemberCustom();}package com.spring.datajpa.repository;import java.util.List;import com.spring.datajpa.entity.Member;import jakarta.persistence.EntityManager;import lombok.RequiredArgsConstructor;@RequiredArgsConstructorpublic class MemberRepositoryImpl implements MemberRepositoryCustom{    private final EntityManager em; //순수 JPA 사용    @Override    public List&lt;Member&gt; findMemberCustom() {        return em.createQuery(\"select m from Member m\").getResultList();    }}package com.spring.datajpa.repository;import java.util.Collection;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Slice;import org.springframework.data.jpa.repository.EntityGraph;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Lock;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.jpa.repository.QueryHints;import org.springframework.data.repository.query.Param;import com.spring.datajpa.entity.Member;import jakarta.persistence.LockModeType;import jakarta.persistence.QueryHint;public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepositoryCustom{    ...}잘 실행됨됨QueryDSL이나 SpringJdbcTemplate을 함께 사용할 때 사용자 정의 리포지토리 기능 자주 사용함단, 인터페이스 이름은 상관 없으나 구현 클래스는 꼭 ~~~impl로 맞춰줘야함. 그래야 스프링이 자동으로 맞춰줌. 다른이름으로 하려면 설정할수있으나 어지간하면 그냥 쓰자그냥 임의의 리포지토리를 만들어도 됨. MemberQueryRepository를 인터페이스가 아닌 클래스로 만들고 스프링 빈으로 등록해서 그냥 직접 사용해도 된다는 뜻. 그럼 스프링 데이터 JPA와는 아무런 관계 없이 별도로 동작함Auditing엔티티 생성, 변경 시 변경인과 시간을 추적하고싶을때 사용  등록일(기본)  수정일(기본)  등록자(추가)  수정자(추가)등록자, 수정자가 없을수도 있으나 거의 4개는 기본으로 사용하는 분위기인듯?— 순수 jpapackage com.spring.datajpa.entity;import java.time.LocalDateTime;import jakarta.persistence.Column;import jakarta.persistence.PrePersist;import jakarta.persistence.PreUpdate;@MappedSuperclass //진짜 상속하는건 아니고 속성만 상속받는거임. 데이터만 공유하는 느낌public class JapBaseEntity {    @Column(updatable=false)    private LocalDateTime createdDate;    private LocalDateTime updatedDate;    @PrePersist //persist하기전에 수행    public void perPersist(){        LocalDateTime now = LocalDateTime.now();        createdDate = now;        updatedDate = now;      }    @PreUpdate //업데이트 전에 실행    public void preUpdate(){        updatedDate = LocalDateTime.now();    }}public class Member extends JapBaseEntity {...}@MappedSuperclass를 붙이면 spring.jpa.hibernate.ddl-auto=create를 했을때 멤버테이블에 수정일도 추가됨.@Testpublic void jpabaseTest() throws InterruptedException{    Member member = new Member(\"member1\");    memberRepo.save(member); //@PrePersist 발생    Thread.sleep(100); //테스트에서 sleep쓰는거 좋은코드는 아니라고하심    member.setUsername(\"member2\");    em.flush();    em.clear();    Member findMember = memberRepo.findById(member.getId()).get();    System.out.println(findMember.getCreatedDate());    System.out.println(findMember.getUpdatedDate());}DB에 이렇게 저장됨. 다른 엔티티에도 jpabaseEntity를 상속해주면됨. 다시 만들필요없음— spring data jpapackage com.spring.datajpa;import java.util.Optional;import java.util.UUID;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.AuditorAware;import org.springframework.data.jpa.repository.config.EnableJpaAuditing;@EnableJpaAuditing@SpringBootApplicationpublic class DataJpaApplication {\tpublic static void main(String[] args) {\t\tSpringApplication.run(DataJpaApplication.class, args);\t}\t@Bean //등록자, 수정자 쓸때만 추가해주면\tpublic AuditorAware&lt;String&gt; auditorProvider(){\t\t// return new AuditorAware&lt;String&gt;() {\t\t// \t@Override\t\t// \tpublic Optional&lt;String&gt; getCurrentAuditor(){\t\t// \t\treturn Optional.of(UUID.randomUUID().toString());\t\t// \t}\t\t// };\t\treturn () -&gt; Optional.of(UUID.randomUUID().toString()); //위에랑 같은거임\t}}메인에 꼭 @EnableJpaAuditing붙여야함. 안붙이면 안됨. 밑에 @Bean은 등록자랑 수정자를 받을때만 만들어주면됨package com.spring.datajpa.entity;import java.time.LocalDateTime;import org.springframework.data.annotation.CreatedBy;import org.springframework.data.annotation.CreatedDate;import org.springframework.data.annotation.LastModifiedBy;import org.springframework.data.annotation.LastModifiedDate;import org.springframework.data.jpa.domain.support.AuditingEntityListener;import jakarta.persistence.Column;import jakarta.persistence.EntityListeners;import jakarta.persistence.MappedSuperclass;import lombok.Getter;@EntityListeners(AuditingEntityListener.class)@MappedSuperclass@Getterpublic class BaseEntity {    @CreatedDate    @Column(updatable = false)      private LocalDateTime createdDate;        @LastModifiedDate    private LocalDateTime lastModifiedDate;     @CreatedBy    @Column(updatable = false)    private String createdBy;      @LastModifiedBy    private String lastModifiedBy;}public class Member extends BaseEntity {...}@Testpublic void baseTest() throws InterruptedException{    Member member = new Member(\"member1\");    memberRepo.save(member); //@PrePersist 발생    Thread.sleep(100); //테스트에서 sleep쓰는거 좋은코드는 아니라고하심    member.setUsername(\"member2\");    em.flush();    em.clear();    Member findMember = memberRepo.findById(member.getId()).get();    System.out.println(findMember.getCreatedDate());    System.out.println(findMember.getLastModifiedDate());    System.out.println(findMember.getCreatedBy());    System.out.println(findMember.getLastModifiedBy());}⚠️보통 BaseTimeEntity를 만들어서 생성시간, 수정시간을 넣고, BaseEntity에 등록자와 수정자를 넣은다음, BaseEntity가 BaseTimeEntity를 상속받도록해서 엔티티마다 필요한 것을 상속받게함. 4개 다 필요하면 BaseEntity를 상속받고, 등록일과 수정일만 필요하면 BaseTimeEntity만 상속받으면되는거임!!web확장도메인 클래스 컨버터http파라미터로 넘어온 엔티티의 아이디로 엔티티 객체를 찾아서 바인딩@GetMapping(\"/members/{id}\")public String findMember(@PathVariable(\"id\") Long id){  Member member = memberRepo.findById(id).get();  return member.getUsername();}@GetMapping(\"/members2/{id}\")public String findMember2(@PathVariable(\"id\") Member member){  return member.getUsername();}둘다 같은 결과가 나옴…;;몰랐다..근데 권장하지않으신다고..간단할때만 쓸수있다고하심. 쓸거면 조회할때만 쓰기. 수정삭제도되긴하는데 복잡해진다고하심아 트랜잭션이 없는 범위에서 엔티티를 조회해서 그렇다고하심!!페이징과 정렬application.properties에spring.data.web.pageable.default-page-size=20 /# 기본 페이지 사이즈/spring.data.web.pageable.max-page-size=2000 /# 최대 페이지 사이즈설정하면 기본값 설정 가능함  접두사페이징 정보가 둘 이상일때 사용public String list( @Qualifier(\"member\") Pageable memberPageable, @Qualifier(\"order\") Pageable orderPageable,...)❗엔티티는 DTO를 의존하지않는게 좋음. 같은패키지가 아니면 괜찮으나 주의하는게좋음. 엔티티생성자에 DTO를 받지말라는 소리인듯..ㅜㅜ@GetMapping(\"/members\")public Page&lt;MemberDto&gt; list(Pageable pageable) { return memberRepository.findAll(pageable).map(MemberDto::new);}이렇게까지 줄일 수 있음— Page를 1부터 시작하려면?      pageable, page를 파라미터 응답값으로 받지말고 직접 클래스를 만들어서 처리.  PageRequest(Pageable 구현체)를 직접 만들어서 제공      PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC, \"username\"));      Page&lt;Member&gt; page = memberRepo.findByAge(10, pageRequest);  List&lt;Member&gt; content = page.getContent();      Long totalElement = page.getTotalElements();      Assertions.assertThat(content.size()).isEqualTo(3);  Assertions.assertThat(page.getTotalElements()).isEqualTo(4);  Assertions.assertThat(page.getNumber()).isEqualTo(0);  Assertions.assertThat(page.getTotalPages()).isEqualTo(2);  Assertions.assertThat(page.isFirst()).isTrue();  Assertions.assertThat(page.hasNext()).isTrue();  Assertions.assertThat(page.isLast()).isFalse();            spring.data.web.pageable.one-indexed-parameters 를 true 로 설정.  web에서 page 파라미터를 -1 처리 해서 받아옴. 따라서 응답값인 Page 에 모두 0 페이지 인덱스를 사용하게됨.  json으로 나간 page 정보들이 0으로 시작한다는 문제인거같음~  "
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용2] OSIV와 성능 최적화",
    "url": "/posts/OSIV%EC%99%80_%EC%84%B1%EB%8A%A5_%EC%B5%9C%EC%A0%81%ED%99%94/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용2, ORM",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "  Open Session In View : 하이버네이트  Open EntityManage In View : JPA  spring.jpa.open-in-view : true 기본값 - OSIV ON 상태트랜젝션 범위를 벗어나도 영속성 컨텍스트가 살아있음. 모든 작업이 끝날때까지 살아있다고 이해하면될거같음.실시간 트래픽이 중요한 애플리케이션에서는 커넥션...",
    "content": "  Open Session In View : 하이버네이트  Open EntityManage In View : JPA  spring.jpa.open-in-view : true 기본값 - OSIV ON 상태트랜젝션 범위를 벗어나도 영속성 컨텍스트가 살아있음. 모든 작업이 끝날때까지 살아있다고 이해하면될거같음.실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 말라버림.컨트롤러에서 외부 API를 호출하면 외부 API 대기시간만큼 커넥션 리소스를 반환하지 못하고 유지해야함.엔티티를 controller나 view에서 활용가능한 장점이 있음.  spring.jpa.open-in-view : false - OSIV OFF (종료 상태)트렌젝션 범위를 벗어나면 영속성 컨텍스트를 반환함. 대신 모든 지연로딩을 트랜잭션 안에서 처리해야함. 그리고 view template에서 지연로딩이 동작하지 않음. 트랜젝션이 끝나기 전에 지연로딩을 강제호출해야함. 프록시 에러 뜸아..그래서 지금까지 서비스랑 컨트롤러를 나눠서 햇구나…. 서비스에서 모든 작업을 하고 컨트롤러에서 반환 값을 가져와서 출력해주는 방식으로 해야한다는 것 같음.Command와 Query를 분리하면 복잡성을 관리하기 좋음. 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요하나 복잡성에 비해 핵심 비즈니스에 큰 영향을 주는 것은 아님단순하게  OrderService          OrderService : 핵심 비즈니스 로직      OrderQueryService : 화면이나 API에 맞춘 서비스 (주로 읽기 전용 트렌잭션 사용)으로 나누는 것을 추천.      고객서비스의 실시간 API는 OSIV를 끄고 Admin처럼 커넥션을 많이 사용하지 않는 곳에서는 키는걸 추천함."
  },
  
  {
    "title": "[김영한 실전! 스프링 데이터 JPA] 공통 인터페이스 - 쿼리 메소드",
    "url": "/posts/%EA%B3%B5%ED%86%B5%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%BF%BC%EB%A6%AC_%EB%A9%94%EC%86%8C%EB%93%9C/",
    "categories": "JPA",
    "tags": "jpa, 실전스프링데이터JPA, ORM",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "@Autowired MemberJpaRepository memberJpaRepository;세상에 이거 프록시였다………………………………………….! sysout으로 getclass찍었는데,,,,, 프록시 니가 왜 거기서나와..?상태됨JpaRepository는 JPA에 특화된 기능만 모아놓은 인터페이스임.  주요 메서드          save(S) : ...",
    "content": "@Autowired MemberJpaRepository memberJpaRepository;세상에 이거 프록시였다………………………………………….! sysout으로 getclass찍었는데,,,,, 프록시 니가 왜 거기서나와..?상태됨JpaRepository는 JPA에 특화된 기능만 모아놓은 인터페이스임.  주요 메서드          save(S) : 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합한다.      delete(T) : 엔티티 하나를 삭제한다. 내부에서 EntityManager.remove() 호출      findById(ID) : 엔티티 하나를 조회한다. 내부에서 EntityManager.find() 호출      getOne(ID) : 엔티티를 프록시로 조회한다. 내부에서 EntityManager.getReference() 호출      findAll(…) : 모든 엔티티를 조회한다. 정렬( Sort )이나 페이징( Pageable ) 조건을 파라미터로 제공할수 있다자세한 것은https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation여기서 확인 가능함        스프링 데이터 JPA가 제공하는 쿼리 메소드 기능          조회: find…By ,read…By ,query…By get…By,                  https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation          예:) findHelloBy 처럼 …에 식별하기 위한 내용(설명)이 들어가도 된다.                    COUNT: count…By 반환타입 long      EXISTS: exists…By 반환타입 boolean      삭제: delete…By, remove…By 반환타입 long      DISTINCT: findDistinct, findMemberDistinctBy      LIMIT: findFirst3, findFirst, findTop, findTop3                  https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.limit-query-result  실무에서는 메소드 이름이 너무 길어진다면 그냥 쿼리문을 작성해서 메소드 이름을 간략하게 만드는 것을 추천함                    JPA named Query거의 안씀~  jpa에서 사용      package com.spring.datajpa.entity;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.FetchType;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.JoinColumn;  import jakarta.persistence.ManyToOne;  import lombok.AccessLevel;  import lombok.Getter;  import lombok.NoArgsConstructor;  import lombok.Setter;  import lombok.ToString;      @Entity  @Getter @Setter  @NoArgsConstructor(access = AccessLevel.PROTECTED)  @ToString(of = {\"id\", \"username\", \"age\"}) //연관관계 필드는 가급적 toString 하지말것  @NamedQuery(      name=\"Member.findByUsername\",      query=\"select m from member m where m.username=:username\"  )  public class Member {              @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"member_id\")      private Long id;      private String username;      private int age;      @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"team_id\")      private Team team;          public Member(String userName){          this.username = userName;      }          public void changeTeam(Team team){          this.team = team;          team.getMembers().add(this);      }          public Member(String name, int age, Team team) {          this.username=name;          this.age = age;          if(team!=null){              changeTeam(team);          }      }  }          public class MemberRepository {  \t public List&lt;Member&gt; findByUsername(String username) {  \t\t List&lt;Member&gt; resultList =  \t\t em.createNamedQuery(\"Member.findByUsername\", Member.class)  \t\t .setParameter(\"username\", username)  \t\t .getResultList();  \t }  }        이렇게 사용함. 귀찮은게 문제임    spring data jpa에서 사용  엔티티에 @namedQuery 어노테이션 사용하고      package com.spring.datajpa.repository;      import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.data.jpa.repository.Query;  import org.springframework.data.repository.query.Param;      import com.spring.datajpa.entity.Member;      public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;{          @Query(name=\"Member.findByUsername\")      List&lt;Member&gt; findByUsername(@Param(\"username\") String username);  }        jpql이 entity에 작성된 쿼리문을 찾아서 날려줌  참고로      package com.spring.datajpa.repository;      import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.data.jpa.repository.Query;  import org.springframework.data.repository.query.Param;      import com.spring.datajpa.entity.Member;      public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;{      List&lt;Member&gt; findByUsername(@Param(\"username\") String username);  }        이렇게 해도 동작함. 네임드 쿼리를 찾아서 실행함. 만약 없으면 그냥 메소드 만들어서 실행됨  잘 안쓰니까 알아만두면될듯.    컬렉션 파라미터 바인딩  package com.spring.datajpa.repository;import java.util.Collection;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import com.spring.datajpa.entity.Member;public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;{    @Query(name=\"Member.findByUsername\")    List&lt;Member&gt; findByUsername(@Param(\"username\") String username);    @Query(\"select m from Member m where m.username in :names\")    List&lt;Member&gt; findByNames(@Param(\"names\") Collection&lt;String&gt; names); //Collection말고 List로 해도됨    }List&lt;Member&gt; list = memberRepo.findByNames(Arrays.asList(\"member4\", \"member1\"));이렇게 사용 사능함!! asList를 처음 알았다!!!in 쿼리로 나가는 것이 확인됨if≠null 쓰는거보다 optional을 쓰는게 더 낫다는데 아직 감이 잘 안잡힘ㅜㅜ 설명도 자세하게 해주신건 아니라서 일단 넘어감페이징Page - 추가 count 쿼리 결과를 포함하는 페이징 : Pageable 사용PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC, \"username\"));Page&lt;Member&gt; page = memberRepo.findByAge(10, pageRequest);List&lt;Member&gt; content = page.getContent();Long totalElement = page.getTotalElements();Assertions.assertThat(content.size()).isEqualTo(3);Assertions.assertThat(page.getTotalElements()).isEqualTo(4);Assertions.assertThat(page.getNumber()).isEqualTo(0);Assertions.assertThat(page.getTotalPages()).isEqualTo(2);Assertions.assertThat(page.isFirst()).isTrue();Assertions.assertThat(page.hasNext()).isTrue();Assertions.assertThat(page.isLast()).isFalse();Slice - 추가 count 쿼리 없이 다음 페이지만 확인가능(모바일의 더보기) : 내부적으로 limit+1조회PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC, \"username\"));Slice&lt;Member&gt; page = memberRepo.findByAge(10, pageRequest);List&lt;Member&gt; content = page.getContent();// Long totalElement = page.getTotalElements();Assertions.assertThat(content.size()).isEqualTo(3);// Assertions.assertThat(page.getTotalElements()).isEqualTo(4);Assertions.assertThat(page.getNumber()).isEqualTo(0);// Assertions.assertThat(page.getTotalPages()).isEqualTo(2);Assertions.assertThat(page.isFirst()).isTrue();Assertions.assertThat(page.hasNext()).isTrue();Assertions.assertThat(page.isLast()).isFalse();Slice는 totalPage 없음. repository에서 반환타입도 바꿔줘야함❗page쿼리는 DB의 모든 데이터를 카운트해야만 가져올수있기때문에 성능이 좋지않음. 그래서 조인이 많이 일어나면 한 테이블만 조회해서 카운트 값을 가져옴@Query(value=\"select m from Member m left join m.teat t\", countQuery = \"select count(m.username) from Member m\")    Page&lt;Member&gt; findByAge2(int age, Pageable page);이렇게 분리하는것이 가능함. 이렇게되면 카운트 쿼리는 간단하게 날아감.Page&lt; Entity &gt;를 DTO로 변환하려면page.map(member-&gt;new MemberDto(member.getId(), member.getUsername(), null));벌크성 수정 쿼리한번에 값을 바꾸는 거. (연봉 10퍼센트 인상)  jpa 방법      public int bulkAgePlus(int age) {   int resultCount = em.createQuery(   \"update Member m set m.age = m.age + 1\" +   \"where m.age &gt;= :age\")   .setParameter(\"age\", age)   .executeUpdate();   return resultCount;  }          @Test  public void bulkUpdate() throws Exception {   //given   memberJpaRepository.save(new Member(\"member1\", 10));   memberJpaRepository.save(new Member(\"member2\", 19));   memberJpaRepository.save(new Member(\"member3\", 20));   memberJpaRepository.save(new Member(\"member4\", 21));   memberJpaRepository.save(new Member(\"member5\", 40));   //when   int resultCount = memberJpaRepository.bulkAgePlus(20); //20살 이상이면   //then   assertThat(resultCount).isEqualTo(3);  }            spring data jpa  @Modifying어노테이션을 넣어야 update쿼리로 작동함      @Modifying  @Query(\"update Member m set m.age = m.age+1 where m.age&gt;=:age\")  int bulkAgePlus(@Param(\"age\") int age);          memberRepo.save(new Member(\"member1\", 10, teamA));  memberRepo.save(new Member(\"member5\", 10, teamA));  memberRepo.save(new Member(\"member6\", 10, teamA));  memberRepo.save(new Member(\"member7\", 10, teamA));  memberRepo.save(new Member(\"member2\", 15, teamB));  memberRepo.save(new Member(\"member3\", 18, teamA));  memberRepo.save(new Member(\"member4\", 12, teamB));      int resultCount = memberRepo.bulkAgePlus(15);      Assertions.assertThat(resultCount).isEqualTo(2);        근데 이렇게하면 바로 member3을 조회하면 18으로 나옴. ==반영이 안된거임. 벌크연산에서 주의해야할점.==    원래는 EntityManager을 가져왔었음.        그러나 요즘엔      @Modifying(clearAutomatically = true)  @Query(\"update Member m set m.age = m.age+1 where m.age&gt;=:age\")  int bulkAgePlus(@Param(\"age\") int age);        이렇게하면        자동으로 됨. 단순 값 바꾸기만 한다면 괜찮겠지만 연산을 한다던지 조회를 한다던지하면 꼭 영속성 컨텍스트에 반영하는 작업을 해주어야함  @EntityGraph: 연관된 엔티티들을 sql 한번에 조회하는 방법그냥 단순하게 findAll같은 메소드들을 페치조인으로 오버라이딩한다고 생각하면 될거같음@Override@EntityGraph(attributePaths = {\"team\"})List&lt;Member&gt; findAll();조회해보면 join문으로 나가는 것을 확인할 수 있음.@EntityGraph(attributePaths = {\"team\"})@Query(\"select m from Member m\")List&lt;Member&gt; findMember();이렇게해도됨. 위랑 같은 쿼리문이 나감@EntityGraph(attributePaths = {\"team\"})List&lt;Member&gt; findByUsername(@Param(\"username\") String username);이렇게도 가능함.페치조인을 편리하게 가능. jpa에서 제공하는 건데 @NamedQuery같이 @NamedEntityGraph 사용가능함. 이것도 잘 안씀쿼리가 복잡해지면 그냥 페치조인쓰신다고함. 진짜 간단한거만 이렇게 쓰기도한다 정도로만 정리하면될듯JPA Hint &amp; Lock  JPA Hint변경감지 기능을 사용하려면 결론적으로 객체가 2개 필요함(변경된 객체, 변경하기 전 원본 객체). 이게 메모리를 차지함. 그런데 그냥 조회만하고 변경을 하지않는다면? 굳이 원본 객체를 저장해놓을 필요가 없음. 그렇다면 순수 조회용 데이터 값을 들고오는 방법은?@QueryHints(value = @QueryHint(name=\"org.hibernate.readOnly\", value=\"true\"))Member findReadOnlyByUsername(String username);jpa는 지원하지않고 하이버네이트가 제공하는 기능임. 스냅샷 없이 조회가 돼서 변경이되도 감지가되지않음!!!사실 대부분의 성능문제는 쿼리를 잘못 작성해서 생기는 문제라 이걸로 크게 성능이 향상되지는..않음^^.. 진짜 중요하고 진짜 트래픽이 큰곳 몇군데만 넣게되지 많이 쓰지는 않음  JPA Lock          select for update를 jpa에서 지원함.        @Lock(LockModeType.PESSIMISTIC_WRITE)  List&lt;Member&gt; findLockByUsername(String username);                    자세한건 JPA책 마지막 챕터 참고. 좀 딥함.아마 쓸일없을거같음. 실시간 트래픽이 많은 서비스에서는 가급적 사용하지 말것. 다른방법으로 해결하는 것이 좋음.실시간트래픽이 많지않고 정확성이 중요한경우는 사용해도될듯?"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용2] 고급 - 컬렉션 조회 최적화",
    "url": "/posts/%EA%B3%A0%EA%B8%89_%EC%BB%AC%EB%A0%89%EC%85%98_%EC%A1%B0%ED%9A%8C_%EC%B5%9C%EC%A0%81%ED%99%94/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용2, ORM",
    "date": "2023-01-09 00:00:00 +0900",
    





    
    "snippet": "@GetMapping(\"/api/v2/orders\")    public List&lt;OrderDto&gt; orderV2(){        List&lt;Order&gt; orders = orderRepository.findAllByString(new OrderSearch());        List&lt;OrderDto&gt; collect = o...",
    "content": "@GetMapping(\"/api/v2/orders\")    public List&lt;OrderDto&gt; orderV2(){        List&lt;Order&gt; orders = orderRepository.findAllByString(new OrderSearch());        List&lt;OrderDto&gt; collect = orders.stream().map(o-&gt;new OrderDto(o)).collect(Collectors.toList());        return collect;    }    @Data     static class OrderDto{        private Long orderId;        private String name;        private LocalDateTime orderDate;        private OrderStatus orderStatus;        private Address address;        private List&lt;OrderItemDto&gt; orderItems;        public OrderDto(Order order){            this.orderId=order.getId();            this.name=order.getMember().getName();            this.orderDate = order.getOrderDate();            this.orderStatus=order.getStatus();            this.address = order.getDelivery().getAddress();            // this.orderItems = order.getOrderItems(); //이건 엔티티라서 이렇게 해봤자 안나옴            //그렇다고 여기서 for문을 돌려서 넣어준다고 해결된건아님. 엔티티가 json으로 나가고 있는 상태인것            //DTO로 변환 필요함            orderItems = order.getOrderItems().stream().map(OrderItem-&gt;new OrderItemDto(OrderItem)).collect(Collectors.toList());        }양방향 매핑에서 oneToMany인 경우의 예시. 쿼리문이 엄청나게 많이 나감이것을 해결하기위해 페치조인 최적화를 해야함@GetMapping(\"/api/v3/orders\")    public List&lt;OrderDto&gt; ordersV3(){        List&lt;Order&gt; orders = orderRepository.findAllWithItem();        List&lt;OrderDto&gt; collect = orders.stream().map(o-&gt;new OrderDto(o)).collect(Collectors.toList());        return collect;    }public List&lt;Order&gt; findAllWithItem() {        return em.createQuery(\"select o from Order o join fetch o.member m join fetch o.delivery d join fetch o.orderItems oi join fetch oi.item i\", Order.class).getResultList();    }위 예시를 실행하면 4번 order가 두번나오는걸 확인할 수 있음. 데이터 뻥튀기      상세 JSON      [      {          \"orderId\": 4,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:22.559742\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 4,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:22.559742\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 11,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:22.591641\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      },      {          \"orderId\": 11,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:22.591641\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      },      {          \"orderId\": 18,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:31.940847\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 18,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:31.940847\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 25,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:31.969452\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      },      {          \"orderId\": 25,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:31.969452\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      }  ]      데이터 뻥튀기 해결방법 ! → distinct사용public List&lt;Order&gt; findAllWithItem() {        return em.createQuery(\"select distinct o from Order o join fetch o.member m join fetch o.delivery d join fetch o.orderItems oi join fetch oi.item i\", Order.class).getResultList();    }쿼리문이 한번만 나감. 그러나 페이징 불가능. 데이터 뻥튀기가 일어난 후 중복을 제거하기떄문에 페이징을 하면 기준자체가 틀어져서 이상한 결과가 나옴(1을 기준으로 페이징을 해야하는데 다를 기준으로 페이징이 되는것이 문제임)      상세 JSON      [      {          \"orderId\": 4,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:22.559742\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 11,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:22.591641\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      },      {          \"orderId\": 18,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:31.940847\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 25,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:31.969452\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      }  ]      컬렉션 페치조인은 하나만 사용가능함. 컬렉션 둘 이상의 페치조인을 사용하면 데이터가 부정합하게 조회될수도있음한계 돌파페이징 + 컬렉션 엔티티 조회문제 해결  ToOne 관계를 모두 페치조인함. ToOne관계는 row수를 증가시키지 않아서 페이징 쿼리에 영향을 미치지 않음  컬렉션은 지연로딩으로 조회한다  지연로딩 최적화를 위해 hibernate.default_batch_fetch_size, @BetchSize를 적용시킨다 → 컬렉션, 프록시 객체를 한꺼번에 설정한 size만큼 IN쿼리로 조회한다application.properties에서 spring.jpa.properties.hibernate.default_batch_fetch_size=100설정public List&lt;Order&gt; findAllWithItem(int offset, int limit) {    return em.createQuery(\"select o from Order o join fetch o.member m join fetch o.delivery\", Order.class)        .setFirstResult(offset).setMaxResults(limit)    .getResultList();}@GetMapping(\"/api/v3.1/orders\")    public List&lt;OrderDto&gt; ordersV3_page(        @RequestParam(value=\"offset\", defaultValue = \"0\") int offset,        @RequestParam(value=\"limit\", defaultValue = \"100\") int limit    ){        List&lt;Order&gt; orders = orderRepository.findAllWithItem(offset, limit);        List&lt;OrderDto&gt; collect = orders.stream().map(o-&gt;new OrderDto(o)).collect(Collectors.toList());        return collect;    }이렇게 해두면 조회한 order의 값을 in쿼리로 찾아서옴. where orderId in(4,10) 이런식위에서 설정한 batch-fatch의 수가 in쿼리에 몇개의 개수로 할지 정한거임. (총 데이터가 100개인데 10으로 설정하면 쿼리가 10번나가는거임)⇒ 1+n+n문제를 1+1+1으로 해결한것. 위의 경우보다 쿼리문은 늘어났지만 데이터양이 많을 때는 중복제거를 하는것보다는 이것이 더 효율적일수도있음(DB데이터 전송량이 줄어듬). 상황과 데이터 양에 따라 달라짐public List&lt;Order&gt; findAllWithItem(int offset, int limit) {        return em.createQuery(\"select o from Order o\", Order.class)            .setFirstResult(offset).setMaxResults(limit)        .getResultList();    }이렇게 해도 되지만 페치조인 쓰는게 나음디테일하게 설정하고싶다면@BatchSize(size=1000)    @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL)    private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();이렇게 해주면됨@BatchSize(size=1000)@Entity@Getter @Setter@NoArgsConstructor(access = AccessLevel.PROTECTED) //기본생성자 쓰지말라는 의미.public class OrderItem {    @Id @GeneratedValue    @Column(name = \"order_item_id\")    private Long id;    @ManyToOne(fetch = FetchType.LAZY)    @JoinColumn(name=\"item_id\")    private Item item;컬렉션이 아닌경우는 이렇게페치조인은 페이징이 불가능하지만 이방법은 페이징이 가능함. 사이즈는 100~1000사이로 설정할것. 1000으로 잡으면 DB에 순간부하가 증가할수있음 애플리케이션은 100이든 1000이든 전체데이터를 로딩해야해서 메모리 사용량이 같으니까 1000으로 설정하는 것이 성능상 가장 좋으나 DB가 어디까지 순간부하를 견딜 수 있는지로 결정. 100으로해놓고 점점 늘리는것도 괜찮음JPA에서 DTO로 직접 조회package com.jpabook.jpashop.repository.order.query;import java.util.List;import javax.persistence.EntityManager;import org.springframework.stereotype.Repository;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class OrderQueryRepository {        private final EntityManager em;    public List&lt;OrderQueryDto&gt; findOrderQueryDtos(){        List&lt;OrderQueryDto&gt; result = findOrders();        result.forEach(o-&gt;{List&lt;OrderItemQueryDto&gt; orderItems = findOrderItems(o.getOrderId());            o.setOrderItems(orderItems);        });        return result;    }    private List&lt;OrderItemQueryDto&gt; findOrderItems(Long orderId) {        return em.createQuery(\"select new com.jpabook.jpashop.repository.order.query.OrderItemQueryDto(oi.order.id, i.name, oi.orderPrice, oi.count) from OrderItem oi join oi.item i where oi.order.id=:orderId\"        , OrderItemQueryDto.class).setParameter(\"orderId\", orderId).getResultList();    }    public List&lt;OrderQueryDto&gt; findOrders() {        return em.createQuery(\"select new com.jpabook.jpashop.repository.order.query.OrderQueryDto(o.id, m.name, o.orderDate, o.status, d.address) from Order o join o.member m join o.delivery d\"            , OrderQueryDto.class).getResultList();    }    }package com.jpabook.jpashop.repository.order.query;import java.time.LocalDateTime;import java.util.List;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.OrderStatus;import lombok.Data;@Datapublic class OrderQueryDto {    private Long orderId;    private String name;    private LocalDateTime orderDate;    private OrderStatus status;    private Address address;    private List&lt;OrderItemQueryDto&gt; orderItems;    public OrderQueryDto(Long orderId, String name, LocalDateTime order, OrderStatus status, Address address){        this.orderId = orderId;        this.name = name;        this.orderDate = order;        this.status=status;        this.address = address;    }    }package com.jpabook.jpashop.repository.order.query;import com.fasterxml.jackson.annotation.JsonIgnore;import lombok.Data;@Datapublic class OrderItemQueryDto {    @JsonIgnore    private Long orderId;    private String itemName;    private int orderPrice;    private int count;    public OrderItemQueryDto(Long orderId, String itemName, int orderPrice, int count){        this.orderId=orderId;        this.itemName=itemName;        this.orderPrice=orderPrice;        this.count=count;    }}@GetMapping(\"/api/v4/orders\")    public List&lt;OrderQueryDto&gt; ordersV4(){        return orderQueryRepository.findOrderQueryDtos();    }총 3번의 쿼리가 나감. 쿼리는 하나인데 여러개의 쿼리가 나갔으니 n+1임. 코드가 단순하고 유지보수가 쉬움.  컬렉션 조회 최적화public List&lt;OrderQueryDto&gt; findAllByDto_optimization() {        List&lt;OrderQueryDto&gt; result = findOrders();        List&lt;Long&gt; orderIds = result.stream().map(o-&gt;o.getOrderId()).collect(Collectors.toList());        List&lt;OrderItemQueryDto&gt; orderItems = em.createQuery(\"select new com.jpabook.jpashop.repository.order.query.OrderItemQueryDto(oi.order.id, i.name, oi.orderPrice, oi.count) from OrderItem oi join oi.item i where oi.order.id in :orderIds\"        , OrderItemQueryDto.class).setParameter(\"orderIds\", orderIds).getResultList();        Map&lt;Long, List&lt;OrderItemQueryDto&gt;&gt; orderItemMap = orderItems.stream().collect(Collectors.groupingBy(orderItemQueryDto-&gt;orderItemQueryDto.getOrderId())); //orderId를 기준으로 map으로 변경됨        result.forEach(o-&gt;o.setOrderItems(orderItemMap.get(o.getOrderId())));        return result;    }in으로 변경. 조회 시 쿼리가 2번 나감. 성능이 최적화되지만 코드가 복잡해짐.  플랫 데이터 최적화package com.jpabook.jpashop.repository.order.query;import java.time.LocalDateTime;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.OrderStatus;import lombok.Data;@Datapublic class OrderFlatDto {    private Long orderId;    private String name;    private LocalDateTime orderDate; //주문시간    private Address address;    private OrderStatus orderStatus;    private String itemName;//상품 명    private int orderPrice; //주문 가격    private int count;      //주문 수량    public OrderFlatDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address, String itemName, int orderPrice, int count) {        this.orderId = orderId;        this.name = name;        this.orderDate = orderDate;        this.orderStatus = orderStatus;        this.address = address;        this.itemName = itemName;        this.orderPrice = orderPrice;        this.count = count;    }}public List&lt;OrderFlatDto&gt; findAllByDto_flat() {        return em.createQuery(            \"select new com.jpabook.jpashop.repository.order.query.OrderFlatDto(o.id, m.name, o.orderDate, o.status, d.address, i.name, oi.orderPrice, oi.count)\" +                    \" from Order o\" +                    \" join o.member m\" +                    \" join o.delivery d\" +                    \" join o.orderItems oi\" +                    \" join oi.item i\", OrderFlatDto.class)            .getResultList();    }한번의 쿼리가 나가지만위와같이 데이터 중복이 일어남. order 4번이 두번나옴. 페이징도 불가능.package com.jpabook.jpashop.repository.order.query;import java.time.LocalDateTime;import java.util.List;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.OrderStatus;import lombok.Data;import lombok.EqualsAndHashCode;@Data@EqualsAndHashCode(of=\"orderId\") //얘를 기준으로 그룹화public class OrderQueryDto {    private Long orderId;    private String name;    private LocalDateTime orderDate;    private OrderStatus status;    private Address address;    private List&lt;OrderItemQueryDto&gt; orderItems;    public OrderQueryDto(Long orderId, String name, LocalDateTime order, OrderStatus status, Address address){        this.orderId = orderId;        this.name = name;        this.orderDate = order;        this.status=status;        this.address = address;    }    public OrderQueryDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address, List&lt;OrderItemQueryDto&gt; orderItems) {        this.orderId = orderId;        this.name = name;        this.orderDate = orderDate;        this.status = orderStatus;        this.address = address;        this.orderItems = orderItems;    }}@GetMapping(\"/api/v7/orders\")    public List&lt;OrderQueryDto&gt; ordersV7(){        List&lt;OrderFlatDto&gt; flats = orderQueryRepository.findAllByDto_flat();        return flats.stream()                .collect(groupingBy(o -&gt; new OrderQueryDto(o.getOrderId(), o.getName(), o.getOrderDate(), o.getOrderStatus(), o.getAddress()),                        mapping(o -&gt; new OrderItemQueryDto(o.getOrderId(), o.getItemName(), o.getOrderPrice(), o.getCount()), toList())                )).entrySet().stream()                .map(e -&gt; new OrderQueryDto(e.getKey().getOrderId(), e.getKey().getName(), e.getKey().getOrderDate(), e.getKey().getOrderStatus(), e.getKey().getAddress(), e.getValue()))                .collect(toList());    }이런식으로 DTO로 변환해서 내보내도 됨. 그럼 중복값없이 나옴. (근데 toList 메소드가 없다고 뜸.. 일아봐야함)일단 order로 그룹화해서 일치하는 부분을 orderitem list에 넣어서 출력하는 것만 알아두면될듯성능이 좋으나 order를 기준으로 페이징이 불가능. 페이징을 자주쓰기때문에 사용하기 애매하고 중복데이턱 많으면 컬렉션 조회 최적화가 성능이 더 잘나오기도 한다.권장순서  엔티티 조회 방식으로 우선 접근          페치조인으로 쿼리수 최적화      컬렉션 최적화                  페이징 필요 - hibernate.default_batch_fetch_size, @BatchSize로 최적화          페이징 필요x - 페치 조인 사용                      엔티티 조회 방식으로 해결이 안되면 DTO조회 방식 사용  DTO조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate 사용"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용2] 기본",
    "url": "/posts/%EA%B8%B0%EB%B3%B8/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용2, ORM",
    "date": "2023-01-07 00:00:00 +0900",
    





    
    "snippet": "패키지는 API(JSON)와 템플릿 엔진(HTML)을 사용하는 컨트롤러를 분리할것. 공통으로 예외처리를 할때 패키지나 구성단위로 많이함.회원가입package com.jpabook.jpashop.api;import javax.validation.Valid;import org.springframework.web.bind.annotation.PostMapp...",
    "content": "패키지는 API(JSON)와 템플릿 엔진(HTML)을 사용하는 컨트롤러를 분리할것. 공통으로 예외처리를 할때 패키지나 구성단위로 많이함.회원가입package com.jpabook.jpashop.api;import javax.validation.Valid;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.service.MemberService;import lombok.Data;import lombok.RequiredArgsConstructor;@RestController@RequiredArgsConstructorpublic class MemberApiController {    private final MemberService memberService;    @PostMapping(\"/api/v1/members\")    public CreateMemberResponse saveMemberV1(@RequestBody @Valid Member member){        Long id =  memberService.join(member);        return new CreateMemberResponse(id);    }    @Data    static class CreateMemberResponse{        private Long id;                public CreateMemberResponse(Long id) {            this.id = id;        }    }}json파일로 내보내면 id만 뜸.package com.jpabook.jpashop.domain;import java.util.ArrayList;import java.util.List;import javax.persistence.Embedded;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.OneToMany;import javax.validation.constraints.NotEmpty;import lombok.Getter;import lombok.Setter;@Entity@Getter@Setterpublic class Member {    @Id @GeneratedValue    private Long id;    @NotEmpty    private String name;    @Embedded    private Address address;    @OneToMany(mappedBy = \"member\")    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();}@NotEmpty때문에 이름이 비면이렇게 뜸중복값은 이렇게 뜸그런데 이렇게 검증로직이 엔티티에 들어가있으면 api마다 다른 조건에 대응하기가 힘듦.그리고 엔티티가 변경되면 api스펙자체가 변경됨. 엔티티와 api가 1대1로 매핑된 상태 → DTO를 만들어야함.요즘은 간편가입, 소셜로그인 가입 등 여러 케이스가 있어서 DTO가 많이 생김package com.jpabook.jpashop.api;import javax.validation.Valid;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.service.MemberService;import lombok.Data;import lombok.RequiredArgsConstructor;@RestController@RequiredArgsConstructorpublic class MemberApiController {    private final MemberService memberService;    @PostMapping(\"/api/v1/members\")    public CreateMemberResponse saveMemberV1(@RequestBody @Valid CreateMemberRequest request){        Member member = new Member();        member.setName(request.getName());        Long id =  memberService.join(member);        return new CreateMemberResponse(id);    }    @Data    static class CreateMemberRequest{        private String name;    }    @Data    static class CreateMemberResponse{        private Long id;                public CreateMemberResponse(Long id) {            this.id = id;        }    }}이렇게 만들라는 소리임회원 정보 수정@PutMapping(\"/api/v2/members/{id}\")    public UpdateMemberResponse updateMemberV2(@PathVariable(\"id\") Long id, @RequestBody @Valid UpdateMemberRequest request){        memberService.update(id, request.getName()); //바로 return Member를 해줘도 되긴하지만 일단 이렇게함        Member findMember = memberService.findOne(id);         return new UpdateMemberResponse(id, findMember.getName());    }    @Data    static class UpdateMemberRequest{        private String name;    }    @Data    @AllArgsConstructor    static class UpdateMemberResponse{        private Long id;        private String name;    }회원 조회// @GetMapping(\"/api/v1/members\")    // public List&lt;Member&gt; membersV1() {    //     return memberService.findMembers();    // } //안좋은 예시. 실제로 실행해보니 무한로딩이 남. 양방향 매핑때문에..일단 @JsonIgnore를 썼는데 좋은 방법이 아님    @GetMapping(\"/api/v2/members\")    public Result memberV2(){        List&lt;Member&gt; findMembers = memberService.findMembers();        List&lt;MemberDto&gt; collect = findMembers.stream().map(m-&gt;new MemberDto(m.getName())).collect(Collectors.toList());        return new Result(collect);    }    @Data    @AllArgsConstructor    static class Result&lt;T&gt;{        private T data;    }    @Data    @AllArgsConstructor    static class MemberDto{        private String name;    }내가 노출할거만 DTO에 필드로 만들면됨"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용2] 고급 - 지연로딩, 조회성능 최적화",
    "url": "/posts/%EA%B3%A0%EA%B8%89_%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9,-%EC%A1%B0%ED%9A%8C%EC%84%B1%EB%8A%A5_%EC%B5%9C%EC%A0%81%ED%99%94/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용2, ORM",
    "date": "2023-01-07 00:00:00 +0900",
    





    
    "snippet": "  @Component : 개발자가 직접 만든 객체를 bean으로 만드는 것.  @PostConstruct : 스프링이 bean을 초기화 한 후에 딱 한번만 실행함  선생님께서 저번에 뭘 만들어도 마스터 계정 하나는 만들고 시작해야한다고 하셨는데 그럴때 사용하는 것 같다.package com.jpabook.jpashop;import javax.anno...",
    "content": "  @Component : 개발자가 직접 만든 객체를 bean으로 만드는 것.  @PostConstruct : 스프링이 bean을 초기화 한 후에 딱 한번만 실행함  선생님께서 저번에 뭘 만들어도 마스터 계정 하나는 만들고 시작해야한다고 하셨는데 그럴때 사용하는 것 같다.package com.jpabook.jpashop;import javax.annotation.PostConstruct;import javax.persistence.EntityManager;import javax.transaction.Transactional;import org.springframework.stereotype.Component;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.Delivery;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.domain.Order;import com.jpabook.jpashop.domain.OrderItem;import com.jpabook.jpashop.domain.item.Book;import lombok.RequiredArgsConstructor;@Component @RequiredArgsConstructorpublic class InitDb {    private final InitService initService;    @PostConstruct    public void init(){        initService.dbInit1();        initService.dbInit2();    }        @Component    @Transactional    @RequiredArgsConstructor    static class InitService {        private final EntityManager em;        public void dbInit1() {            System.out.println(\"Init1\" + this.getClass());            Member member = createMember(\"userA\", \"서울\", \"1\", \"1111\");            em.persist(member);            Book book1 = createBook(\"JPA1 BOOK\", 10000, 100);            em.persist(book1);            Book book2 = createBook(\"JPA2 BOOK\", 20000, 100);            em.persist(book2);            OrderItem orderItem1 = OrderItem.createOrderItem(book1, 10000, 1);            OrderItem orderItem2 = OrderItem.createOrderItem(book2, 20000, 2);            Delivery delivery = createDelivery(member);            Order order = Order.createOrder(member, delivery, orderItem1, orderItem2);            em.persist(order);        }        public void dbInit2() {            Member member = createMember(\"userB\", \"진주\", \"2\", \"2222\");            em.persist(member);            Book book1 = createBook(\"SPRING1 BOOK\", 20000, 200);            em.persist(book1);            Book book2 = createBook(\"SPRING2 BOOK\", 40000, 300);            em.persist(book2);            OrderItem orderItem1 = OrderItem.createOrderItem(book1, 20000, 3);            OrderItem orderItem2 = OrderItem.createOrderItem(book2, 40000, 4);            Delivery delivery = createDelivery(member);            Order order = Order.createOrder(member, delivery, orderItem1, orderItem2);            em.persist(order);        }        private Member createMember(String name, String city, String street, String zipcode) {            Member member = new Member();            member.setName(name);            member.setAddress(new Address(city, street, zipcode));            return member;        }        private Book createBook(String name, int price, int stockQuantity) {            Book book1 = new Book();            book1.setName(name);            book1.setPrice(price);            book1.setStockQuantity(stockQuantity);            return book1;        }        private Delivery createDelivery(Member member) {            Delivery delivery = new Delivery();            delivery.setAddress(member.getAddress());            return delivery;        }    }}시작할때 데이터 넣고 시작양방향 연관관계 문제이문제.. 양방향 매핑이 걸린곳에 @JsonIgnore를 걸어줘도 이런 문제가 생김.LAZY를 걸어두면 null을 들고올 수는 없으니 그 자리에 proxy를 넣어둠@ManyToOne(fetch = FetchType.LAZY)@JoinColumn(name = \"member_id\")private Member member=new ByteBuddyInterceptor();이런 형태로 걸린다는 소리임. 저기서 ByteBuddyInterceptor가 proxy인듯그리고 member를 꺼내 쓸때 DB에 쿼리문을 날려서 member안에 진짜 객체를 넣어주는 듯근데 JSON이 ByteBuddyInterceptor를 사용할 수 없음!!그래서 에러가 나는 것임!!  [!info]  https://mvnrepository.com/artifact/com.fasterxml.jackson.datatype/jackson-datatype-hibernate5이거 gradle에 넣어줄것package com.jpabook.jpashop;import org.hibernate.Hibernate;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import com.fasterxml.jackson.datatype.hibernate5.Hibernate5Module;@SpringBootApplicationpublic class JpashopApplication {\tpublic static void main(String[] args) {\t\tSpringApplication.run(JpashopApplication.class, args);\t}\t@Bean\tHibernate5Module hibernate5Module(){\t\treturn new Hibernate5Module();\t}}근데 사실 엔티티를 내보내는 경우가 거의 없어서 이렇게까진 안해도된다고 하심..^^일단 null로 나옴@Bean\tHibernate5Module hibernate5Module() {\t\tHibernate5Module hibernate5Module = new Hibernate5Module();\t\t//강제 지연 로딩 설정\t\thibernate5Module.configure(Hibernate5Module.Feature.FORCE_LAZY_LOADING, true);\t\treturn hibernate5Module;이렇게 해주면 json내보낼때 지연로딩해놓은걸 조회하긴 함@GetMapping(\"/api/v1/simple-orders\")    public List&lt;Order&gt; ordersV1() {        List&lt;Order&gt; all = orderRepository.findAllByString(new OrderSearch());        for (Order order : all) {            order.getMember().getName(); //Lazy 강제 초기화            order.getDelivery().getAddress(); //Lazy 강제 초기화        }        return all;    }아니면 뭐 이렇게..어쨌든 이렇게 하면 안됨 DTO로 변환해서 반환할 것.@GetMapping(\"/api/v2/simple-orders\")    public List&lt;SimpleOrderDto&gt; orderV2(){        List&lt;Order&gt; orders = orderRepository.findAllByString(new OrderSearch());        List&lt;SimpleOrderDto&gt; result = orders.stream().map(o-&gt; new SimpleOrderDto(o)).collect(Collectors.toList());        return result;    }    @Data    static class SimpleOrderDto{        private Long orderId;        private String name;        private LocalDateTime orderDate;        private OrderStatus orderStatus;        private Address address;                public SimpleOrderDto(Order order){            orderId=order.getId();            name = order.getMember().getName(); //LAZY초기화            orderDate = order.getOrderDate();            orderStatus = order.getStatus(); //LAZY초기화            address = order.getDelivery().getAddress();        }    }  [!important]List&lt; SimpleOrderDto &gt; result = orders.stream().map(o-&gt; new SimpleOrderDto(o)).collect(Collectors.toList());orders를 가져와서 stream으로 돌린다음(컬렉션 안의 요소들을 순차접근) map(A를 B로 바꿈)최종적으로 쿼리가 5번나갔음. order한번 member2번 delivery 2번. n+1문제 발생⇒ 페치조인 사용 필요페치조인정말 자주 쓰임!!!  OneToOne, ManyToOne joinpublic List&lt;Order&gt; findAllWithMemberDelivery() {  return em.createQuery(\"select o from Order o join fetch o.member m join fetch o.delivery\", Order.class).getResultList();}repository에 만들어줬음@GetMapping(\"/api/v3/simple-orders\")public List&lt;SimpleOrderDto&gt; orderV3(){  List&lt;Order&gt; orders = orderRepository.findAllWithMemberDelivery();    List&lt;SimpleOrderDto&gt; result = orders.stream().map(o-&gt; new SimpleOrderDto(o)).collect(Collectors.toList());  return result;}한번의 쿼리로 완성가능쿼리문으로 바로 DTO 리스트를 가져오는 법도 있음package com.jpabook.jpashop.repository;import java.time.LocalDateTime;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.OrderStatus;import lombok.Data;@Datapublic class OrderSimpleQueryDto {    private Long orderId;    private String name;    private LocalDateTime orderDate; //주문시간    private OrderStatus orderStatus;    private Address address;    public OrderSimpleQueryDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address) {        this.orderId = orderId;        this.name = name;        this.orderDate = orderDate;        this.orderStatus = orderStatus;        this.address = address;    }}package com.jpabook.jpashop.repository.order.simpleQuery;import java.util.List;import javax.persistence.EntityManager;import org.springframework.stereotype.Repository;import com.jpabook.jpashop.repository.OrderSimpleQueryDto;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class OrderSimpleQueryRepository {    private final EntityManager em;        public List&lt;OrderSimpleQueryDto&gt; findOrderDto() {        return em.createQuery(\"select new com.jpabook.jpashop.repository.OrderSimpleQueryDto(o.id, m.name, o.orderDate, o.status, d.address) from Order o \"            +\"join o.member m join o.delivery d\", OrderSimpleQueryDto.class).getResultList();        //DTO가 매핑이 될 수가 없음!!자동으로 생성자에 넣어주는 기능은 없음        //DTO의 생성자는 엔티티 자체를 파라미터로 받으면 안되고 위 쿼리문에서 나올 컬럼을 하나하나 넣어줘야함    }}대신 다른식으로 활용하기 어렵지만 성능상 더 좋긴함. 그러나 애플리케이션 네트웍 용량 최적화는 생각보다 미비함. API스펙에 맞춘 코드가 repository에 들어가는 단점이 있음그럼 뭘 써야하냐..는 나중에 설명함query repository를 저장하는 패키지를 만들어두는 것을 추천함이렇게 해도 안되면 네이티브 SQL이나 스프링 JDBC template을 사용해서 SQL을 직접 사용함  OneToMany join엔티티를 DTO로 변환할때 엔티티를 DTO에 감싸서 보내게되면 아무런 의미가 없어짐. 엔티티안에 연관 엔티티도 DTO로 변환해서 내보내야함"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] JSP",
    "url": "/posts/jsp/",
    "categories": "Spring",
    "tags": "spring, jsp, 국비교육",
    "date": "2023-01-04 00:00:00 +0900",
    





    
    "snippet": "jar : java application runtimewar : web archive runtime프로젝트 생성시 빼먹은 패키지가있다면 메이븐에서 추가해도됨  [!info]  https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper/10.1.4이거 추가. 버전에 숫자말...",
    "content": "jar : java application runtimewar : web archive runtime프로젝트 생성시 빼먹은 패키지가있다면 메이븐에서 추가해도됨  [!info]  https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper/10.1.4이거 추가. 버전에 숫자말고 다른게있으면 테스트버전임 jasper가 jsp view resolver임server.port=80으로하면 localhost로 들어가도 접속됨. 포트기본번호라서. 원격배포할때 80으로 내보냄dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-web'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\tprovidedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\t// https://mvnrepository.com/artifact/org.projectlombok/lombok\tcompileOnly group: 'org.projectlombok', name: 'lombok', version: '1.18.24'\t// https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper\timplementation group: 'org.apache.tomcat.embed', name: 'tomcat-embed-jasper', version: '10.1.4'\timplementation 'jstl:jstl:1.2'}server.port=8989# jsp 사용spring.mvc.view.prefix=/WEB-INF/viewsspring.mvc.view.suffix=.jsp폴더 구성메인에 하위폴더를 만들어야함index.jsp&lt;%@page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;     &lt;h1&gt;index page&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 웹 계층 개발",
    "url": "/posts/%EC%9B%B9_%EA%B3%84%EC%B8%B5_%EA%B0%9C%EB%B0%9C/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-04 00:00:00 +0900",
    





    
    "snippet": "https://getbootstrap.com/docs/5.1/getting-started/download/다운받아서 resources의 static폴더 안에 넣으면됨버전문제로 잘 안되는듯 쌤이랑 같은버전까니까 됨회원 가입@NotEmpty - 필수값 표시스프링 부트 버전이 2.3 이상이라면 build.gredle에 implementation ‘org.s...",
    "content": "https://getbootstrap.com/docs/5.1/getting-started/download/다운받아서 resources의 static폴더 안에 넣으면됨버전문제로 잘 안되는듯 쌤이랑 같은버전까니까 됨회원 가입@NotEmpty - 필수값 표시스프링 부트 버전이 2.3 이상이라면 build.gredle에 implementation ‘org.springframework.boot:spring-boot-starter-validation’ 추가해줘야함html에서 &lt;form role=\"form\" action=\"/members/new\" th:object=\"${memberForm}\" method=\"post\"&gt;중 th:object=”${memberForm}” 은 이 form안에서는 memberForm을 사용하겠다는 의미임&lt;div class=\"form-group\"&gt;               &lt;label th:for=\"city\"&gt;도시&lt;/label&gt;               &lt;input type=\"text\" th:field=\"*{city}\" class=\"form-control\" placeholder=\"도시를 입력하세요\"&gt;&lt;/div&gt;이렇게쓰면&lt;div class=\"form-group\"&gt;     &lt;label for=\"city\"&gt;도시&lt;/label&gt;     &lt;input type=\"text\" class=\"form-control\" placeholder=\"도시를 입력하세요\" id=\"city\" name=\"city\" value=\"\"&gt;&lt;/div&gt;이렇게 나옴id랑 name이 중복이면 저렇게 표시하기도함 그냥써도됨package com.jpabook.jpashop.controller;import javax.validation.constraints.NotEmpty;import lombok.Getter;import lombok.Setter;@Getter @Setterpublic class MemberForm {     @NotEmpty(message=\"회원이름은 필수입니다.\")     private String name;     private String city;     private String street;     private String zipcode;}package com.jpabook.jpashop.controller;import javax.validation.Valid;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.service.MemberService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructorpublic class MemberController {          private final MemberService memberService;     @GetMapping(\"/members/new\")     public String createForm(Model model){          model.addAttribute(\"memberForm\", new MemberForm());          return \"/members/createMemberForm\";     }     @PostMapping(\"/members/new\")     public String create(@Valid MemberForm form, BindingResult result){          System.out.println(result.hasErrors());          if(result.hasErrors()){               return \"members/createMemberForm\";          }          Address address = new Address(form.getCity(), form.getStreet(), form.getZipcode());          Member member = new Member();          member.setName(form.getName());          member.setAddress(address);          memberService.join(member);          return \"redirect:/\";     }}그래도 @NotEmpty가 제대로 동작을 안함.. 재시도해봐야함..정보 수정@GetMapping(\"items/{itemId}/edit\")    public String updateItemForm(@PathVariable(\"itemId\") Long itemId, Model model){        Book item = (Book) itemService.findOne(itemId); //추천하지않는 방법이나 예시를 위해 사용        BookForm form = new BookForm();        form.setId(item.getId());        form.setName(item.getName());        form.setPrice(item.getPrice());        form.setStockQuantity(item.getStockQuantity());        form.setAuthor(item.getAuthor());        form.setIsbn(item.getIsbn());        model.addAttribute(\"form\", form);        return \"items/updateItemForm\";    }    @PostMapping(\"items/{itemId}/edit\")    public String updateItem(@PathVariable String itemId, @ModelAttribute(\"form\") BookForm form){        Book book = new Book();        book.setId(form.getId());        book.setName(form.getName());        book.setPrice(form.getPrice());        book.setStockQuantity(form.getStockQuantity());        book.setAuthor(form.getAuthor());        book.setIsbn(form.getIsbn());        itemService.saveItem(book);        return \"redirect:/items\";    }@ModelAttribute - 파라미터로 넘어온 값을 객체로 만들어주는 어노테이션인듯?변경감지와 병합(merge)준영속 - 새로운 객체를 만들었으나 setter를 통해 기본키를 설정해 준 경우 - DB를 한번 거친 상태 = 준영속 상태의 객체⇒ 영속성 컨텍스트가 더는 관리하지 않는 엔티티!!!@PostMapping(\"items/{itemId}/edit\")public String updateItem(@PathVariable String itemId, @ModelAttribute(\"form\") BookForm form){    Book book = new Book();    book.setId(form.getId());    book.setName(form.getName());    book.setPrice(form.getPrice());    book.setStockQuantity(form.getStockQuantity());    book.setAuthor(form.getAuthor());    book.setIsbn(form.getIsbn());    itemService.saveItem(book);    return \"redirect:/items\";}위 예시에서는 itemService.saveItem(book)에서 수정을 시도하는 Book객체를 의미함. Book객체는 이미 DB에 한번 저장되어 식별자가 존재하는 상태임. 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있음!!아무리 값을 수정해도 save를 해주지 않으면 DB가 바뀌지 않는 상태이런 상태의 준영속 엔티티의 값을 수정하는 방법?      변경감지(dirty checking) 기능 사용    변경을 감지해서 자동으로 update구문을 날려주는 것     @Transactional public void updateItem(Long id, Book param){   Item findItem = itemRepository.findOne(id);   findItem.setPrice(param.getPrice());   findItem.setName(param.getName());   findItem.setStockQuantity(param.getStockQuantity()); }        준영속 상태의 엔티티를 이용해 영속상태의 엔티티를 가져옴    사실 set을 사용하는 것이 아니라 값이 변경되는 메소드를 만드는 것이 좋음        병합(merge) 사용(사용하지않는편이 좋음)     public void save(Item item){   if(item.getId()==null){ //DB에 저장된적없는 순수한 객체이면       em.persist(item); //DB저장   }else{       em.merge(item); //업데이트같은 느낌   }    }            준영속 상태이던 member가 영속상태로 바뀌는것이 아니라 영속상태인 mergeMember를 반환해주는 것임.    ❗병합 사용시 모든 속성이 변경됨!! 병합 시 값이 없으면 null로 업데이트될 수도 있음!!!!!! 모든 필드를 교체한다는 점 기억해둘것!!    [!important]컨트롤러에서 엔티티를 남발하지 말 것@PostMapping(\"items/{itemId}/edit\")    public String updateItem(@PathVariable Long itemId, @ModelAttribute(\"form\") BookForm form){        itemService.updateItem(itemId, form.getName(), form.getPrice(), form.getStockQuantity());        return \"redirect:/items\";    }@Transactional    public void updateItem(Long id, String name, int price, int stock){        Item findItem = itemRepository.findOne(id);        findItem.setPrice(price);        findItem.setName(name);        findItem.setStockQuantity(stock);    }위 코드가 더 좋은 코드라는 소리임트랜젝션이 있는 서비스계층에 식별자(id)와 변경할 데이터를 명확하게 전달.(파라미터 or DTO)트랜젝션이 있는 서비스 계층에서 영속상태의 엔티티를 조회, 엔티티 데이터 직접 변경트랜젝션 커밋시점에 변경 감지가 실행됨주문 내역, 취소@GetMapping(\"/orders\")    public String orderList(@ModelAttribute(\"orderSearch\") OrderSearch orderSearch, Model model){        List&lt;Order&gt; orders = orderService.findOrders(orderSearch);        model.addAttribute(\"orders\", orders);        return \"order/orderList\";    }    @PostMapping(\"/orders/{orderId}/cancel\")    public String cancelOrder(@PathVariable(\"orderId\") Long orderId) {        orderService.cancelOrder(orderId);        return \"redirect:/orders\";    }"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 주문 도메인 개발",
    "url": "/posts/%EC%A3%BC%EB%AC%B8_%EB%8F%84%EB%A9%94%EC%9D%B8/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-03 00:00:00 +0900",
    





    
    "snippet": "구현기능  상품주문  주문내역 조회  주문 취소개발 순서      주문 엔티티, 주문상품 엔티티 개발     package com.jpabook.jpashop.domain;         import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List;     impor...",
    "content": "구현기능  상품주문  주문내역 조회  주문 취소개발 순서      주문 엔티티, 주문상품 엔티티 개발     package com.jpabook.jpashop.domain;         import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List;     import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.EnumType; import javax.persistence.Enumerated; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table;     import lombok.Getter; import lombok.Setter;     @Entity @Table(name=\"orders\") @Getter@Setter public class Order {     @Id @GeneratedValue     @Column(name=\"order_id\")     private Long id;             @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"member_id\")     private Member member;     @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL)     private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();     @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)     @JoinColumn(name=\"delivery_id\")     private Delivery delivery;         private LocalDateTime orderDate;     @Enumerated(EnumType.STRING)     private OrderStatus status;         //연관관계 메소드     public void setMember(Member member){         this.member = member;         member.getOrders().add(this);     }     public void addOrderItem(OrderItem orderItem){         orderItems.add(orderItem);         orderItem.setOrder(this);     }     public void setDelivery(Delivery delivery){         this.delivery = delivery;         delivery.setOrder(this);     }     //주문     public static Order createOrder(Member member, Delivery delivery, OrderItem...orderItems){         Order order = new Order();         order.setMember(member);         order.setDelivery(delivery);         for(OrderItem orderItem: orderItems){             order.addOrderItem(orderItem);         }         order.setStatus(OrderStatus.ORDER);         order.setOrderDate(LocalDateTime.now());         return order;     }     //주문 취소     public void cancel(){         if(delivery.getStatus()==DeliveryStatus.COMP){             throw new IllegalStateException(\"이미 배송 완료된 상품은 취소가 불가능합니다.\");         }         this.setStatus(OrderStatus.CANCLE);         for(OrderItem orderItem : orderItems){             orderItem.cancel();         }     }         //전체 주문 조회     public int getTotalPrice(){         int totalPrice=0;         for(OrderItem orderItem : orderItems){             totalPrice += orderItem.getTotalPrice();         }         return totalPrice;     } }         package com.jpabook.jpashop.domain;         import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne;     import com.jpabook.jpashop.domain.item.Item;     import lombok.Getter; import lombok.Setter;     @Entity @Getter @Setter public class OrderItem {     @Id @GeneratedValue     @Column(name = \"order_item_id\")     private Long id;     @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name=\"item_id\")     private Item item;         @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name=\"order_id\")     private Order order;         private int orderPrice;         private int count;         //비즈니스 로직     public void cancel() {         getItem().addStock(count);     }         public int getTotalPrice() {         return getOrderPrice() * getCount();     }        //생성 메소드     public static OrderItem createOrderItem(Item item, int orderPrice, int count){         OrderItem orderItem = new OrderItem();         orderItem.setItem(item);         orderItem.setOrderPrice(orderPrice);         orderItem.setCount(count);             item.removeStock(count);             return orderItem;     } }            주문 리포지토리 개발     package com.jpabook.jpashop.repository;     import javax.persistence.EntityManager;     import org.springframework.stereotype.Repository;     import com.jpabook.jpashop.domain.Order;     import lombok.RequiredArgsConstructor;     @Repository @RequiredArgsConstructor public class OrderRepository {     private final EntityManager em;         public void save(Order order){         em.persist(order);     }         public Order findOne(Long id){         return em.find(Order.class, id);     } }            주문 서비스 개발 @NoArgsConstructor(access = AccessLevel.PROTECTED) //기본생성자 쓰지말라는 의미.     package com.jpabook.jpashop.domain;         import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List;     import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.EnumType; import javax.persistence.Enumerated; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table;     import com.jpabook.jpashop.repository.OrderRepository; import com.jpabook.jpashop.service.OrderService;     import lombok.AccessLevel; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter;     @Entity @Table(name=\"orders\") @Getter@Setter @NoArgsConstructor(access = AccessLevel.PROTECTED) public class Order {     @Id @GeneratedValue     @Column(name=\"order_id\")     private Long id;             @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"member_id\")     private Member member;     @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL)     private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();     @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)     @JoinColumn(name=\"delivery_id\")     private Delivery delivery;         private LocalDateTime orderDate;     @Enumerated(EnumType.STRING)     private OrderStatus status;         //연관관계 메소드     public void setMember(Member member){         this.member = member;         member.getOrders().add(this);     }     public void addOrderItem(OrderItem orderItem){         orderItems.add(orderItem);         orderItem.setOrder(this);     }     public void setDelivery(Delivery delivery){         this.delivery = delivery;         delivery.setOrder(this);     }     //주문     public static Order createOrder(Member member, Delivery delivery, OrderItem...orderItems){         Order order = new Order();         order.setMember(member);         order.setDelivery(delivery);         for(OrderItem orderItem: orderItems){             order.addOrderItem(orderItem);         }         order.setStatus(OrderStatus.ORDER);         order.setOrderDate(LocalDateTime.now());         return order;     }     //주문 취소     public void cancel(){         if(delivery.getStatus()==DeliveryStatus.COMP){             throw new IllegalStateException(\"이미 배송 완료된 상품은 취소가 불가능합니다.\");         }         this.setStatus(OrderStatus.CANCLE);         for(OrderItem orderItem : orderItems){             orderItem.cancel();         }     }         //전체 주문 조회     public int getTotalPrice(){         int totalPrice=0;         for(OrderItem orderItem : orderItems){             totalPrice += orderItem.getTotalPrice();         }         return totalPrice;     }         //검색     // public List&lt;Order&gt; findOrders(OrderSearch orderSearch){     //     return OrderRepository.findAll(orderSearch);     // } }        주문, 주문취소 메소드를 보면 비지니스로직 대부분이 엔티티에 있음. 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 함. 이처럼 엔티티가 비지니스 로직을 가지고 객체 지향의 특성을 활용하는 것을 도메인 모델 패턴이라고 함 반대로 비지니스 로직이 거의 없고 서비스에서 대부분의 로직을 처리하는 것을 트랜잭션 스크립트 패턴이라고 함        주문 검색 기능 개발     package com.jpabook.jpashop.repository;     import java.util.List;     import javax.persistence.EntityManager; import javax.persistence.TypedQuery;     import org.springframework.stereotype.Repository; import org.springframework.util.StringUtils;     import com.jpabook.jpashop.domain.Order; import com.jpabook.jpashop.domain.OrderSearch;     import lombok.RequiredArgsConstructor;     @Repository @RequiredArgsConstructor public class OrderRepository {     private final EntityManager em;         public void save(Order order){         em.persist(order);     }         public Order findOne(Long id){         return em.find(Order.class, id);     }     public List&lt;Order&gt; findAll(OrderSearch orderSearch){         return em.createQuery(\"select o from Order o join o.member m where o.status = :status and m.name like :name\", Order.class)         .setParameter(\"status\", orderSearch.getOrderStatus()).setParameter(\"name\", orderSearch.getMemberName())         .setMaxResults(1000) //최대 1000건         .getResultList();     }         //비추방법     public List&lt;Order&gt; findAllByString(OrderSearch orderSearch) {             String jpql = \"select o from Order o join o.member m\";         boolean isFirstCondition = true;         //주문 상태 검색     if (orderSearch.getOrderStatus() != null) {         if (isFirstCondition) {             jpql += \" where\";             isFirstCondition = false;         } else {             jpql += \" and\";         }         jpql += \" o.status = :status\";     }          //회원 이름 검색(이것도 비추)     if (StringUtils.hasText(orderSearch.getMemberName())) {         if (isFirstCondition) {             jpql += \" where\";             isFirstCondition = false;         } else {             jpql += \" and\";         }         jpql += \" m.name like :name\";     }         TypedQuery&lt;Order&gt; query = em.createQuery(jpql, Order.class)             .setMaxResults(1000);         if (orderSearch.getOrderStatus() != null) {         query = query.setParameter(\"status\", orderSearch.getOrderStatus());     }     if (StringUtils.hasText(orderSearch.getMemberName())) {         query = query.setParameter(\"name\", orderSearch.getMemberName());     }         return query.getResultList(); } }            주문 기능 테스트  "
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 상품 도메인 개발",
    "url": "/posts/%EC%83%81%ED%92%88_%EB%8F%84%EB%A9%94%EC%9D%B8_%EA%B0%9C%EB%B0%9C/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-03 00:00:00 +0900",
    





    
    "snippet": "  setter를 이용하지 않고 재고 변경package com.jpabook.jpashop.exception;public class NotEnoughStockException extends RuntimeException{    public NotEnoughStockException(){        super();    }    public NotEn...",
    "content": "  setter를 이용하지 않고 재고 변경package com.jpabook.jpashop.exception;public class NotEnoughStockException extends RuntimeException{    public NotEnoughStockException(){        super();    }    public NotEnoughStockException(String message){        super(message);    }    public NotEnoughStockException(String message, Throwable cause){        super(message, cause);    }    public NotEnoughStockException(Throwable cause){        super(cause);    }}package com.jpabook.jpashop.domain.item;import java.util.ArrayList;import java.util.List;import javax.persistence.Column;import javax.persistence.DiscriminatorColumn;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Inheritance;import javax.persistence.InheritanceType;import javax.persistence.ManyToMany;import com.jpabook.jpashop.domain.Category;import com.jpabook.jpashop.exception.NotEnoughStockException;import lombok.Getter;import lombok.Setter;@Entity@Getter @Setter@Inheritance(strategy = InheritanceType.SINGLE_TABLE)@DiscriminatorColumn(name=\"dtype\")public abstract class Item {    @Id    @GeneratedValue    @Column(name = \"item_id\")    private Long id;    private String name;    private int price;    private int stockQuantity;    @ManyToMany(mappedBy = \"items\")    private List&lt;Category&gt; categories = new ArrayList&lt;&gt;();    //비지니스 로직    //재고 증가    public void addStock(int quantity){        this.stockQuantity+=quantity;    }    //재고 감소    public void removeStock(int quantity){        int restStock = this.stockQuantity-quantity;        if(restStock&lt;0){            throw new NotEnoughStockException(\"need more stock\");        }        this.stockQuantity = restStock;    }}재고를 가진 엔티티안에 재고 증감 메소드를 작성함  repositorypackage com.jpabook.jpashop.repository;import java.util.List;import javax.persistence.EntityManager;import org.springframework.stereotype.Repository;import com.jpabook.jpashop.domain.item.Item;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class ItemRepository {    private final EntityManager em;        public void save(Item item){        if(item.getId()==null){ //DB에 저장된적없는 순수한 객체이면            em.persist(item); //DB저장        }else{            em.merge(item); //업데이트같은 느낌        }       }    public Item findOne(Long id){        return em.find(Item.class, id);    }    public List&lt;Item&gt; findAll(){        return em.createQuery(\"select i from Item i\", Item.class).getResultList();    }}  servicepackage com.jpabook.jpashop.service;import java.util.List;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.jpabook.jpashop.domain.item.Item;import com.jpabook.jpashop.repository.ItemRepository;import lombok.RequiredArgsConstructor;@Service@Transactional(readOnly=true)@RequiredArgsConstructorpublic class ItemService {    private final ItemRepository itemRepository;    @Transactional //위에 readOnly설정때문에 다시 오버라이딩해줌    public void saveItem(Item item){        itemRepository.save(item);    }    public List&lt;Item&gt; findItems(){        return itemRepository.findAll();    }    public Item findOne(Long itemId){        return itemRepository.findOne(itemId);    }}"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 회원 도메인 개발",
    "url": "/posts/%ED%9A%8C%EC%9B%90_%EB%8F%84%EB%A9%94%EC%9D%B8_%EA%B0%9C%EB%B0%9C/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-02 00:00:00 +0900",
    





    
    "snippet": "repository@PersistenceContext스프링에서 영속성 관리를 위해 Entity Manager가 존재한다.그래서 스프링이 처음 시작할 때, entity manager를 만들어서 빈으로 등록을 해둔다.entity manager는 @Autowired가 아니고 특별하게 @PersistenceContext라는 어노테이션으로 주입을 해줄 수 있다...",
    "content": "repository@PersistenceContext스프링에서 영속성 관리를 위해 Entity Manager가 존재한다.그래서 스프링이 처음 시작할 때, entity manager를 만들어서 빈으로 등록을 해둔다.entity manager는 @Autowired가 아니고 특별하게 @PersistenceContext라는 어노테이션으로 주입을 해줄 수 있다.근데 최신 스프링부트에서는 @Autowired로도 할 수 있다고 한다.package com.jpabook.jpashop.repository;import java.util.List;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import org.springframework.stereotype.Repository;import com.jpabook.jpashop.domain.Member;@Repositorypublic class MemberRepository {    @PersistenceContext    private EntityManager em;    public void save(Member member){        em.persist(member);    }    public Member findOne(Long id){        return em.find(Member.class, id);    }    public List&lt;Member&gt; findAll(){        return em.createQuery(\"select m from Member m\", Member.class).getResultList();    }    public List&lt;Member&gt; findByName(String name){        return em.createQuery(\"select m from Member m where m.name=:name\", Member.class).setParameter(\"name\", name).getResultList();    }    }  @RequiredArgsConstructor사용방법package com.jpabook.jpashop.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.repository.MemberRepository;import lombok.RequiredArgsConstructor;@Service@RequiredArgsConstructor //final있는 필드의 생성자만 만들어줌@Transactional/* (readOnly = true) */ //spring어노테이션 사용 추천. 만약 모든 메소드가 읽기 전용이라면 여기서 붙여줘도됨public class MemberService {     private final MemberRepository memberRepository;      // @Autowired //최신버전에선 없어도됨 자동으로 넣어줌     // public MemberService(MemberRepository memberRepository){     //      this.memberRepository = memberRepository;     // } //생성자를 통해 설정하는 방법. 권장방법     //위에 @RequiredArgsConstructor를 써서 주석처리함. 같은거임     //회원가입     public Long join(Member member){          validateDuplicateMember(member);          memberRepository.save(member);             return member.getId();       }          private void validateDuplicateMember(Member member) {          List&lt;Member&gt; findMembers= memberRepository.findByName(member.getName());          if(!findMembers.isEmpty()){               throw new IllegalStateException(\"이미 존재하는 회원입니다.\");          }     }     //회원 전체 조회     @Transactional(readOnly = true) //읽기 모드. 데이터 변경안됨(성능상 좋음)     public List&lt;Member&gt; findMembers(){          return memberRepository.findAll();     }     @Transactional(readOnly = true) //읽기 모드. 데이터 변경안됨(성능상 좋음)     public Member findOne(Long memberId){          return memberRepository.findOne(memberId);     }}RequiredArgsConstructor : final이 붙은 필드만 생성자를 만들어줌package com.jpabook.jpashop.repository;import java.util.List;import javax.persistence.EntityManager;import org.springframework.stereotype.Repository;import com.jpabook.jpashop.domain.Member;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class MemberRepository {    // @PersistenceContext 스프링 부트 라이브러리를 사용하면 @Autowired로 변경가능 -&gt; @RequiredArgsConstructor 사용가능    private final EntityManager em;    public void save(Member member){        em.persist(member);    }    public Member findOne(Long id){        return em.find(Member.class, id);    }    public List&lt;Member&gt; findAll(){        return em.createQuery(\"select m from Member m\", Member.class).getResultList();    }    public List&lt;Member&gt; findByName(String name){        return em.createQuery(\"select m from Member m where m.name=:name\", Member.class).setParameter(\"name\", name).getResultList();    }    }위처럼 repository에도 사용가능함  테스트 코드package com.jpabook.jpashop;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.fail;import javax.persistence.EntityManager;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.annotation.Rollback;import org.springframework.transaction.annotation.Transactional;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.repository.MemberRepository;import com.jpabook.jpashop.service.MemberService;@SpringBootTest@Transactionalpublic class MemberRepositoryTest {    @Test    @Rollback(false) //rollback안하고 commit해버림    @Transactional    public void test() throws Exception{        Member member = new Member();    }    @Autowired MemberService memberService;    @Autowired MemberRepository memberRepository;    @Autowired EntityManager em;    @Test    // @Rollback(false)    public void 회원가입() throws Exception{        Member member = new Member();        member.setName(\"kim\");        Long saveId =memberService.join(member);        em.flush(); //rollback설정을 유지하면서 insert 쿼리문을 보기위해 확인        assertEquals(member, memberRepository.findOne(saveId));    }    @Test    public void 중복회원예외() throws Exception{        Member member1 = new Member();        member1.setName(\"kim\");        Member member2 = new Member();        member2.setName(\"kim\");        memberService.join(member1);        try{            memberService.join(member2);        }catch(IllegalStateException e){            return;        }        fail(\"예외가 발생해야한다\"); //위에서 예외가 발생하지않으면 실패처리됨    }}"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 들어가기 전에",
    "url": "/posts/%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0_%EC%A0%84%EC%97%90/",
    "categories": "JPA",
    "tags": "jpa, spring, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-01 00:00:00 +0900",
    





    
    "snippet": "다른건 다 똑같이 하면되고application.properties에 spring.jpa.hibernate.ddl-auto=create 추가해주면 실행 시 자동으로 테이블 만들어줌테스트 코드에서 @Transactional을 붙여도 rollback안하고 commit 하는 법@Test@Rollback(false) //rollback안하고 commit해버림@...",
    "content": "다른건 다 똑같이 하면되고application.properties에 spring.jpa.hibernate.ddl-auto=create 추가해주면 실행 시 자동으로 테이블 만들어줌테스트 코드에서 @Transactional을 붙여도 rollback안하고 commit 하는 법@Test@Rollback(false) //rollback안하고 commit해버림@Transactionalpublic void test() throws Exception{  Member member = new Member();  member.setUsername(\"memberA\");  Long savedId = memberRepository.sava(member);  Member find = memberRepository.find(savedId);  Assertions.assertThat(find.getId()).isEqualTo(member.getId());    Assertions.assertThat(find.getUsername()).isEqualTo(member.getUsername());\tAssertions.assertThat(find).isEqualTo(member);    }회원(Member): 이름과 임베디드 타입인 주소( Address ), 그리고 주문( orders ) 리스트를 가진다. 주문(Order): 한 번 주문시 여러 상품을 주문할 수 있으므로 주문과 주문상품( OrderItem )은 일대다 관계다. 주문은 상품을 주문한 회원과 배송 정보, 주문 날짜, 주문 상태( status )를 가지고 있다. 주문 상태는 열거형을 사용했는데 주문( ORDER ), 취소( CANCEL )을 표현할 수 있다.  주문상품(OrderItem): 주문한 상품 정보와 주문 금액( orderPrice ), 주문 수량( count ) 정보를 가지고  있다. (보통 OrderLine , LineItem 으로 많이 표현한다.)  상품(Item): 이름, 가격, 재고수량( stockQuantity )을 가지고 있다. 상품을 주문하면 재고수량이  줄어든다. 상품의 종류로는 도서, 음반, 영화가 있는데 각각은 사용하는 속성이 조금씩 다르다.  배송(Delivery): 주문시 하나의 배송 정보를 생성한다. 주문과 배송은 일대일 관계다.  카테고리(Category): 상품과 다대다 관계를 맺는다. parent , child 로 부모, 자식 카테고리를  연결한다.  주소(Address): 값 타입(임베디드 타입)이다. 회원과 배송(Delivery)에서 사용한다.  참고: 회원 엔티티 분석 그림에서 Order와 Delivery가 단방향 관계로 잘못 그려져 있다. 양방향 관계가 맞다.  참고: 회원이 주문을 하기 때문에, 회원이 주문리스트를 가지는 것은 얼핏 보면 잘 설계한 것 같지만, 객체 세상은 실제 세계와는 다르다. 실무에서는 회원이 주문을 참조하지 않고, 주문이 회원을 참조하는 것으로  충분하다. 여기서는 일대다, 다대일의 양방향 연관관계를 설명하기 위해서 추가했다  MEMBER: 회원 엔티티의 Address 임베디드 타입 정보가 회원 테이블에 그대로 들어갔다. 이것은  DELIVERY 테이블도 마찬가지다.  ITEM: 앨범, 도서, 영화 타입을 통합해서 하나의 테이블로 만들었다. DTYPE 컬럼으로 타입을 구분한다. 참고: 테이블명이 ORDER 가 아니라 ORDERS 인 것은 데이터베이스가 order by 때문에 예약어로 잡고  있는 경우가 많다. 그래서 관례상 ORDERS 를 많이 사용한다.  참고: 실제 코드에서는 DB에 소문자 + _(언더스코어) 스타일을 사용하겠다.  데이터베이스 테이블명, 컬럼명에 대한 관례는 회사마다 다르다. 보통은 대문자 + _(언더스코어)나 소문자  _(언더스코어) 방식 중에 하나를 지정해서 일관성 있게 사용한다. 강의에서 설명할 때는 객체와 차이를  나타내기 위해 데이터베이스 테이블, 컬럼명은 대문자를 사용했지만, 실제 코드에서는 소문자 +  _(언더스코어) 스타일을 사용하겠다.  연관관계 매핑 분석  회원과 주문: 일대다 , 다대일의 양방향 관계다. 따라서 연관관계의 주인을 정해야 하는데, 외래 키가 있는 주문을 연관관계의 주인으로 정하는 것이 좋다. 그러므로 Order.member 를 RDERS.MEMBER_ID 외래키와 매핑한다.  주문상품과 주문: 다대일 양방향 관계다. 외래 키가 주문상품에 있으므로 주문상품이 연관관계의 주인이다.  그러므로 OrderItem.order 를 ORDER_ITEM.ORDER_ID 외래 키와 매핑한다.  주문상품과 상품: 다대일 단방향 관계다. OrderItem.item 을 ORDER_ITEM.ITEM_ID 외래 키와  매핑한다.  주문과 배송: 일대일 양방향 관계다. Order.delivery 를 ORDERS.DELIVERY_ID 외래 키와 매핑한다.  카테고리와 상품: @ManyToMany 를 사용해서 매핑한다.(실무에서 @ManyToMany는 사용하지 말자. 여기서는 다대다 관계를 예제로 보여주기 위해 추가했을 뿐이다)  예제에서는 설명을 쉽게하기 위해 엔티티 클래스에 Getter, Setter를 모두 열고, 최대한 단순하게 설계  실무에서는 가급적 Getter는 열어두고, Setter는 꼭 필요한 경우에만 사용하는 것을 추천모든 연관관계 매핑은 LAZY로 세팅하고, 연관관계 메소드까지 작성한 상태로 시작  계층형 구조 사용          controller, web - 웹 계층      service - 비즈니스 로직, 트랜잭션 처리      repository - JPA를 직접 사용하는 계층, 엔티티 매니저 사용      domain - 엔티티가 모여있는 계층, 모든 계층에서 사용      "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 쿼리언어 - 중급 문법",
    "url": "/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EC%A4%91%EA%B8%89-%EB%AC%B8%EB%B2%95/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-31 00:00:00 +0900",
    





    
    "snippet": "경로 표현식.(점)을 찍어서 객체 그래프를 탐색함  [!important]select m.username -&gt; 상태 필드from Member mjoin m.team t -&gt; 단일 값 연관 필드(엔티티로 넘어감. ManyToOne or OneToOne)join m.orders o -&gt; 컬렉션 값 연관 필드(양방향 관계. 컬렉션으로 넘어감...",
    "content": "경로 표현식.(점)을 찍어서 객체 그래프를 탐색함  [!important]select m.username -&gt; 상태 필드from Member mjoin m.team t -&gt; 단일 값 연관 필드(엔티티로 넘어감. ManyToOne or OneToOne)join m.orders o -&gt; 컬렉션 값 연관 필드(양방향 관계. 컬렉션으로 넘어감)where t.name = ‘팀A’  상태 필드(state field): 단순히 값을 저장하기 위한 필드(ex: m.username). 경로 탐색의 끝(.찍어서 어디 못간다는 소리). 탐색x      연관 필드(association field): 연관관계를 위한 필드          단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티(ex: m.team). 묵시적 내부조인(inner join) 발생. 탐색O - m.team에서 m.team.name가능      컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션(ex: m.orders). 묵시적 내부 조인(inner join) 발생. 탐색X - t.members.get(0) 이런거 안됨!! t.members에서 더이상 탐색 불가능함(t.members.size는 가능함)                  from절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색가능  = select m.username from Team t join t.members m 이건 가능하다는 소리                    묵시적 내부 조인(조심해서 써야함. 가능하면 발생하지 않도록 해야함)  select m.team from Member m 쿼리를 날렸을때, 묵시적으로 team테이블과 join이 일어남        가급적 명시적조인으로 사용. 조인은 SQL튜닝에 중요 포인트임  걍 묵시적 조인 쓰지말것!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 걍신경안써도될듯  페치 조인(fetch join)매우중요!!SQL조인 종류x, JPQL에서 성능 최적화를 위해 제공하는 기능연관된 엔티티나 컬렉션을 SQL한번에 함께 조회하는 기능join fetch 명령어 사용페치 조인 ::= [left [OUTER] | inner ] join fetch 조인경로(SQL) select * from Member m inner join team t on m.team_id = t.id= (JPQL) select m from Member m join fetch m.team한번의 쿼리문으로 원하는 값을 모두 조회가능함그냥 m.getTeam().getName()을 쓰면 최악의 경우(회원끼리 겹치는 팀이 없을 경우) 100명의 회원을 조회하면 team을 조회하는 쿼리문도 100번이 나가서 비효율적임그러나 페치조인문을 날리면 영속성 컨텍스트에 모든값이 들어오기때문에 한번의 쿼리문으로 해결가능함      컬렉션 페치조인    일대 다 관계에서 사용    (SQL) select * from team t inner join member m on t.id = m.team_id where = ‘팀A’    = (JPQL) select t from team t join fetch t.members where t.name = ‘팀A’        위처럼 주의할 점!! 데이터 뻥튀기가 일어남        팀A에 속한 회원이 2명이라서 팀A가 2번 조회됨!!    → DISTINCT 사용 - select distinct t from Team t join fetch t.members          SQL에 DISTINCT를 추가      에플리케이션에서 엔티티 중복 제거            team의 중복이 제거됨!!  sql에서 distinct을 사용하면 데이터가 완전히 일치해야 중복이 제거된다는 한계가 있음  그래서 distinct가 애플리케이션에서 추가로 중복제거를 함. 같은 식별자를 가진 엔티티를 제거함  (위와같은 일대 다는 뻥튀기가 되지만 다대일은 뻥튀가안됨)  페치조인을 사용할때만 즉시조인이 일어남!!  페치조인은 객체 그래프를 SQL한번에 조회하는 개념임    대부분의 n+1의 문제를 해결할 수 있음                  한계                  페치 조인 대상에는 별칭을 줄 수 없음(하이버네이트는 가능하나 가급적 사용x)  select distinct t from Team t join fetch t.members m - 여기서 m이 안된다는 소리임  where문을 페치문에 가급적 사용하지 말라는 소리같음.. 차라리 여기서 where문을 사용하지말고 Member에서 값을 가져오라는..뜻인듯  페치 조인을 다중으로 사용할때는 어쩔수없이 쓸때도 있기는 하다고하심          둘 이상의 컬렉션은 페치조인할 수 없음 - 일대다대다같은 괴상한 상황이 일어남          컬렉션을 페치조인하면 페이징API를 이용할 수 없음                          다대일, 일대일 닽은 단일 값 연관 필드들은 페치조인해도 페이징이 가능함(걍 순서 바꾸란 소리)              하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험함!!!!!)                                              그러나 이방법은 성능이 안나옴(위 예시만봐도 3번 쿼리문이 날아감)        이럴때는 @BatchSize를 붙여서 (사이즈는 1000이하로 대충 정해줌)          @BatchSize(size=100)  @OneToMany(mappedBy = \"team\")  private List&lt;Member&gt; members = new ArrayList&lt;Member&gt;();                        teamA, teamb의 아이디가 둘다 들어간걸 확인할 수 있음!!        위에 BatchSize에 지정해준 숫자만큼 한번에 조회가능함! 지금은 팀이 2개라서 2개가 들어간거고 100개까지 가능한상황임                위와같이 설정해주면 기본값 설정 가능(한 1000이하로,,)                  결론          연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화      엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함      @OneToMany(fetch = FetchType.LAZY) //글로벌 로딩 전략      실무에서 글로벌 로딩 전략은 모두 지연 로딩      최적화가 필요한 곳은 페치 조인 적용(n+1이 일어나는 곳만 페치조인을 사용)      모든 것을 페치 조인으로 해결할 수 는 없음      페치 조인은 객체 그래프를 유지할 때 사용하면 효과적      여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적      다형성 쿼리]]조회 대상을 특정 자식으로 한정Ex) Item 중에 Book, Movie를 조회  (JPQL) select i from Item i where type(i) IN (Book, Movie)      (SQL) select i from i where i.DTYPE in (‘B’, ‘M’)        TREAT(JPA2.0)          자바의 타입 캐스팅과 유사      상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용      FROM, WHERE, SELECT(하이버네이트 지원) 사용      ex )부모인 Item과 자식 Book                  (JPQL) select i from Item i where treat(i as Book).auther = ‘kim’          (SQL) select i.* from Item i where i.DTYPE = ‘B’ and i.auther = ‘kim’                      item과 연관된 엔티티 중에서 book인 엔티티의 auther이 ‘kim’인것을 찾아오는 구문  엔티티 직접 사용      기본 키 값  select count(m) from Member m //엔티티를 직접 사용 - 이런경우  자동으로 JPA가 기본 키(m.id)로 변환해서 사용함  엔티티를 파라미터로 넘겨도 마찬가지임    java  String jpql = “select m from Member m where m = :member”;   List resultList = em.createQuery(jpql).setParameter(\"member\", member).getResultList(); =    최종적으로 select m.* from Member m where m.id=? 가 실행됨        외래 키 값  Team team = em.find(Team.class, 1L); String qlString = “select m from Member m where m.team = :team”; List resultList = em.createQuery(qlString).setParameter(\"team\", team).getResultList();select m.* from Member m where m.team_id=? 가 실행됨Named 쿼리  미리 정의해서 이름을 부여해두고 사용하는 JPQL  정적 쿼리  어노테이션, XML에 정의  애플리케이션 로딩 시점에 초기화 후 재사용  애플리케이션 로딩 시점에 쿼리를 검증(오타나면 정확하게 알려줌)@Entity@NamedQuery( name = \"Member.findByUsername\", query=\"select m from Member m where m.username = :username\")public class Member { ........}List&lt;Member&gt; resultList = em.createNamedQuery(\"Member.findByUsername\", Member.class).setParameter(\"username\", \"회원1\").getResultList();spring jpa에서 사용했던@Query(”select …………………….”) 그게 이거임벌크연산(update, delete문을 의미함)재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?  JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행          재고가 10개 미만인 상품을 리스트로 조회한다.      상품 엔티티의 가격을 10% 증가한다.      트랜잭션 커밋 시점에 변경감지가 동작한다.        변경된 데이터가 100건이라면 100번의 UPDATE SQL 실행int count = em.createQuery(\"update Member m set m.age = 20\").executeUpdate();System.out.println(count);걍 이게 다임update, delete, insert(jpa표준스택에는 없음. 하이버네이트가 지원) 됨. where문도 사용 가능  주의 사항  벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리(flush됨)          벌크 연산을 먼저 실행      벌크 연산 수행 후 영속성 컨텍스트 초기화            이런 대참사가 일어난다는 뜻임.    flush가 일어났을때 age는 20이 아니었기때문에 이런 대참사가 일어남      int count = em.createQuery(\"update Member m set m.age = 20\").executeUpdate();  m = em.find(Member.class, m.getId());  m2 = em.find(Member.class, m2.getId());  m3 = em.find(Member.class, m3.getId());  em.clear();  System.out.println(count);      System.out.println(m.getAge());  System.out.println(m2.getAge());  System.out.println(m3.getAge());        이렇게 해줘야함       ㅇㅇ    spring data jpa에는    @Modifying    @Query(”update……………..”) 가 있음 이거 쓰면 됨  "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 쿼리언어 기본문법",
    "url": "/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-31 00:00:00 +0900",
    





    
    "snippet": "JPAFactoryQuery query = new JPAQueryFactory(em);QMember m = QMember.member;JPA를 사용하면 엔티티 객체를 중심으로 개발을 함. 문제는 검색쿼리. 검색을 할때도 테이블이 아닌 객체를 대상으로 검색을 함. 모든 DB데이터를 객체로 변환해서 검색을 하는 것은 불가능함에플리케이션이 필요한 데이터만 ...",
    "content": "JPAFactoryQuery query = new JPAQueryFactory(em);QMember m = QMember.member;JPA를 사용하면 엔티티 객체를 중심으로 개발을 함. 문제는 검색쿼리. 검색을 할때도 테이블이 아닌 객체를 대상으로 검색을 함. 모든 DB데이터를 객체로 변환해서 검색을 하는 것은 불가능함에플리케이션이 필요한 데이터만 DB에 불러오려면 결국 검색조건이 포함된 SQL이 필요함.JPQL(Java Persistence Query Language)가장 단순한 조회 방법 - entityManager.find(), 객체 그래프 탐색(a.getB().getC())JPA는 SQL을 추상화 한 JPQL이라는 객체 지향 쿼리 언어를 제공함SQL과 문법이 유사함. select, from, where, goup by, having, join 지원JPQL은 엔티티객체를 대상으로 쿼리SQL은 DB를 대상으로 쿼리List&lt;Member&gt; list = em.createQuery(\"select m from Member m where m.username like '%kim%'\", Member.class).getResultList();for(Member m : list){    System.out.println(m);}이런식객체 지향 sql이라고 생각하면 됨. 동적쿼리를 짜기 어려움결국 SQL로 변환되어 실행됨!!엔티티와 속성은 대소문자 구분을 하지만 JPQL 키워드는 대소문자 구분을 하지 않음. 테이블 이름이 아닌 엔티티 이름을 사용함. 별칭 필수(as 생략 가능)  TypedQuery : 반환 타입이 명확할 때 사용  Query : 반환 타입이 명확하지 않을 때 사용Member m = new Member();m.setName(\"member1\");m.setAge(10);em.persist(m);//반환타입이 확실TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member m\", Member.class);TypedQuery&lt;String&gt; query2 = em.createQuery(\"select m.name from Member m\", String.class);//반환타입 불확실(String, int 두가지가 반환됨)Query query3 = em.createQuery(\"select m.name, m.age from Member m\");  반환 결과가 여러개일때 - getResultList()  반환 결과가 하나일때 - getSingleResult()          getSingleResult()를 사용했는데 만약 결과가 없을 때 -&gt; NoResultException - 별루임;; try-catch로 감싸줘야함      getSingleResult()를 사용했는데 결과가 둘 이상일때 -&gt; NonUniqueResultException      //결과가 여러개일때            TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member m\", Member.class);            List&lt;Member&gt; resultList = query.getResultList(); //받아온 값을 List로 가져옴. 결과가 여러개일경우            //결과가 없으면 빈리스트가 반환됨            //결과가 정확히 하나일때            TypedQuery&lt;Member&gt; query2 = em.createQuery(\"select m from Member m where m.id=10L\", Member.class);            Member resultMember = query2.getSingleResult();            //만약 결과가 하나일때 -&gt; NoResultException            //결과가 둘 이상일때 -&gt; NonUniqueResultException  파라미터 바인딩(이름기준)Member m = new Member();m.setName(\"member1\");m.setAge(10);em.persist(m);//TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member m where m.name = :username\", Member.class);//query.setParameter(\"username\", \"member1\"); //위 쿼리의 :username에 member1을 넣음//Member resultMember = query.getSingleResult();Member resultMember = em.createQuery(\"select m from Member m where m.name = :username\", Member.class).setParameter(\"username\", \"member1\").getSingleResult();//위 3줄이랑 같은거임System.out.println(resultMember);tx.commit();criteriaCriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class);Root&lt;Member&gt; m = query.from(Member.class);CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(\"name\"), \"kim\"));List&lt;Member&gt; resultList = em.createQuery(cq).getResultList();어렵지만 쿼리문에서 오타가났을때 잡아주고CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class);Root&lt;Member&gt; m = query.from(Member.class);CriteriaQuery&lt;Member&gt; cq = query.select(m);String userName=\"aaaa\";if(userName!=null){    cq = cq.where(cb.equal(m.get(\"name\"), \"kim\"));}List&lt;Member&gt; resultList = em.createQuery(cq).getResultList();이런식으로 활용이 가능함그러나 SQL스럽지가 않고 실용성이 없어서 잘 사용되지않음. 유지보수가 어려움..QueryDSL(실무사용권장)위의 대안으로 나옴JPAFactoryQuery query = new JPAQueryFactory(em);QMember m = QMember.member;List&lt;Member&gt; list =query.selectFrom(m)\t.where(m.age.gt(18))\t.orderBy(m.name.desc())\t.fetch()자바코드로 sql을 작성가능. SPQL빌더 역할컴파일 시점에 문법 오류를 찾을 수 있고 동적쿼리 작성이 편리함. 단순하고 쉬움JPQL을 알면 자동으로 따라옴!!네이티브 SQLJPA가 제공하는 SQL을 직접 하용. JPQL로 해결할 수 없는 특정 DB에 의존적인 기능 사용 가능(오라클의 connect By, 특정 DB에만 사용하는 SQL 힌트)String sql = “SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = ‘kim’\"; List&lt;Member&gt; resultList =  em.createNativeQuery(sql, Member.class).getResultList();잘안씀JDBC 직접 사용, SpringJdbcTemplate 등  JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등을 함께 사용 가능  단 원래는 쿼리를 날릴때 flush가 일어나 DB에 반영이되는데 이방법은 반영이되지않아서 수동으로 flush를 해줘야함프로젝션select절에 조회할 대상을 지정하는 것.대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자 등 기본데이터 타입)  select m from Member m → 엔티티 프로젝션  select m.team from Member m → 엔티티 프로젝션(Member와 연관된 엔티티를 가져옴)  select m.address from Member m → 임베디드 타입 프로젝션  select m.username, m.age from Member m → 스칼라 타입 프로젝션          여러 값 조회 하는 방법                  Query타입으로 조회 - 위에서 본 반환타입이 명확하지 않을때 방법          Object[] 타입으로 조회          new 명령어로 조회                          단순 값을 DTO로 조회  select new jpabook.jpql.UserDTO(m.username, m.age) from Member m              패키지 명을 포함한 전체 클래스명 입력              순서와 타입이 일치하는 생성자 필요                                            DISTINCT로 중복제거 가능  쿼리문을 통해 가져온 엔티티의 값을 수정해도 DB값이 수정됨! 영속성 컨텍스트에 의해 관리중이라는 소리임Member m = new Member();m.setName(\"member1\");m.setAge(10);em.persist(m);em.flush();em.clear();//join쿼리이나 join쿼리라는 것이 잘 보이지 않음. 비추천List&lt;Team&gt; result = em.createQuery((\"select m.team from Member m\"), Team.class).getResultList();//추천방법result = em.createQuery(\"select t from Member m join m.team t\", Team.class).getResultList();for(Team t : result){    System.out.println(t.getName());}//임베디드 타입 프로젝션List&lt;Address&gt; result2 = em.createQuery((\"select o.address from Order o\"), Address.class).getResultList();// List&lt;Address&gt; result2 = em.createQuery((\"select address from Address\"), Address.class).getResultList(); // -&gt; 불가능한 방법. Order안에 address가 소속되어있음//스칼라 타입 프로젝션 - 여러값 조회//Query사용방법 (비추)Query q = em.createQuery(\"select distinct m.name, m.age from Member m\");//Object[] 사용방법(비추)List result3 = em.createQuery(\"select distinct m.name, m.age from Member m\").getResultList();Object o = result3.get(0); //0이 위 쿼리문의 첫번째 칼럼인 name, 1이 두번째 칼럼인 age의 값을 받아옴Object[] result4 = (Object[]) o;System.out.println(result4[0]); //member1 출력System.out.println(result4[1]); //10 출력System.out.println(result4.length); //2 출력//위랑 같은 거임List&lt;Object[]&gt; result5 = em.createQuery(\"select distinct m.name, m.age from Member m\").getResultList();Object[] result6 = (Object[]) o;System.out.println(result6[0]); //member1 출력System.out.println(result6[1]); //10 출력System.out.println(result6.length); //2 출력//new 명령어로 조회 - DTO (가장깔끔함)List&lt;MemberDTO&gt; result7 = em.createQuery(\"select new com.kyhpractice.jpap.jpabook.jpashop.jpadomain.MemberDTO(m.name, m.age) from Member m\").getResultList();//경로 제대로 적기ㅜㅜ(나중에 QueryDSL을 사용하면 보안가능)//순서와 타입이 일치해야함MemberDTO memberDTO = result7.get(0);System.out.println(memberDTO.getName());System.out.println(memberDTO.getAge());tx.commit();페이징.setFirstResult(페이지[0부터 시작]).setMaxResults(한페이지에 표시할 갯수)조인      내부조인    select m from Member m join m.team t → inner join 실행        외부조인    select m from m left join m.team t → left outer join 실행        세타조인(연관관계가 없는 것을 조인시킴. 크로스조인에 where문을 붙이는듯?)    select count(m) from Member m, Team t where m.username = t.name        on절          join대상 필터링                  회원과 팀을 조회하면서 팀이름이 A인 팀만  jpql : select m, t from Member m left join m.team t on t.name=’A’  sql : select m., t. from Member m left join Team t on m.team_id = t.id and t.name=’A’                    연관 관계 없는 엔티티 외부조인(하이버네이트5.1부터)                  회원의 이름과 팀이름이 같은 대상 외부조인  jpql : select m, t from Member m left join team t on m.username = t.name  sql : select m. * , t. * from Member m left join team t on m.username = t.name                    서브 쿼리서브 쿼리 지원 함수      [not] exists(supquery) : 서브쿼리에 결과가 존재하면 참                                                      {all              any              some} (subquery)                                          ALL 모두 만족하면 참      any, some : 같은 의미. 조건을 하나라도 만족하면 참        ex) - 팀 a소속인 회원    select m from Member m where exists (select t from m.team t where t.name = ‘팀A’)                  전체 상품 각각의 재고보다 주문량이 많은 주문들  select o from Order o where o.orderAmount &gt; ALL (select p.stockAmount from Product p)                    어떤 팀이든 팀에 소속된 회원  select m from Member m where m.team = ANY (select t from Team t)              [not] in (subquery) : 서브쿼리 결과 중 하나라도 같은 것이 있으면 참  한계          where, having절에서만 서브쿼리 사용가능함.      select절도 가능(하이버네이트에서 지원)              **from절의 서브쿼리는 현재 jpql에서 불가능함!!        **→ 조인으로 풀수있으면 풀어서 해결(안되면 쿼리를 두번 날리기)            JPQL의 타입 표현  문자: ‘HELLO’, ‘She’’s’  숫자: 10L(Long), 10D(Double), 10F(Float)  Boolean: TRUE, FALSE      ENUM: jpabook.MemberType.Admin (패키지명 포함)    String query = “Select m.name from Member m where m.type= 패키지명.MemberType.ADMIN”    위와같이 enum의 패키지명까지 적어주어야함    엔티티 타입: TYPE(m) = Member (상속 관계에서 사용)  SQL과 문법이 같은 식  EXISTS, IN  AND, OR, NOT  =, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;  BETWEEN, LIKE, IS NULL조건식      기본 case 식    select      case           when m.age &lt;= 10 then ‘학생요금’          when m.age &gt;= 60 then ‘경로요금’          else ‘일반요금’      end  from Member m        단순 case 식  select      case t.name          when ‘팀A’ then ‘인센티브110%’          when ‘팀B’ then ‘인센티브120%’          else ‘인센티브105%’      end  from Team t        COALESCE: 하나씩 조회해서 null이 아니면 반환  ex ) 사용자 이름이 없으면 이름없는 회원 반환  select coalesce(m.username,’이름 없는 회원’) from Member m        NULLIF: 두 값이 같으면 null 반환, 다르면 첫번째 값 반환  ex ) 사용자 이름이 관리자면 null을 나머지는 본인의 이름을 반환  select NULLIF(m.username, ‘관리자’) from Member m  둘다 queryDSL에서 지원함기본함수  CONCAT  select concat(’a’,’b’) from Member m으로 써도 되지만 하이버네이트는  select ‘a’ || ‘b’ from Member m 으로 쓸수도 있음  SUBSTRING(문자열 잘라내기)  TRIM  LOWER, UPPER  LENGTH  LOCATE : 문자열 위치 찾기  ABS, SQRT, MOD  SIZE, INDEX(JPA 용도)사용자 정의 함수      하이버네이트는 사용전 방언에 추가해야함  사용하는 DB 방언을 상속받고 사용자 정의 함수를 등록  ❗그러나 MySQL57Dialect에 대부분이 등록되어있음. 등록안되어있으면 사용자 정의 함수를 등록해야함        사용자 정의 함수 등록하는 법      package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;      import org.hibernate.dialect.H2Dialect;  import org.hibernate.dialect.function.StandardSQLFunction;  import org.hibernate.type.StandardBasicTypes;      public class MyH2Dialect extends H2Dialect{      public MyH2Dialect(){          registerFunction(\"group_concat\", new StandardSQLFunction(\"group_concat\", StandardBasicTypes.STRING));      }  }        함수마다 등록하는 법은 다 다름. H2Dialect에서 확인      String query = \"select function('group_concat', m.name) from Member m\";      List&lt;String&gt; result = em.createQuery(query, String.class).getResultList();      for(String name : result){      System.out.println(name);  }        이미 등록된거라서      String query = \"select group_concat(m.name) from Member m\";      List&lt;String&gt; result = em.createQuery(query, String.class).getResultList();      for(String name : result){    System.out.println(name);  }        이렇게 써도 되긴함  "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 값 타입",
    "url": "/posts/%EA%B0%92%ED%83%80%EC%9E%85/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-31 00:00:00 +0900",
    





    
    "snippet": "JPA의 데이터 타입 분류  엔티티타입          @Entity로 정의하는 객체      데이터가 변해도 식별자로 지속해서 추적 가능(회원 엔티티의 키나 나이값을 변경해도 식별자로 인식 가능)        값 타입          int, Integer, String 처럼 단순히 값으로 사용하는 기본타입이나 객체      식별자가 없고 값만있어 ...",
    "content": "JPA의 데이터 타입 분류  엔티티타입          @Entity로 정의하는 객체      데이터가 변해도 식별자로 지속해서 추적 가능(회원 엔티티의 키나 나이값을 변경해도 식별자로 인식 가능)        값 타입          int, Integer, String 처럼 단순히 값으로 사용하는 기본타입이나 객체      식별자가 없고 값만있어 변경시 추적 불가(숫자 100을 200으로 교체하면 완전히 다른값으로 대체)      분류                  기본값 타입(항상 값을 복사함)  — 생명주기를 엔티티에 의존하는 타입(회원삭제 = 이름, 나이필드도 삭제)  — 공유 불가(회원이름변경시 다른회원 이름이 변경되면 안됨)                          자바 기본 타입(int, double) - 원래 절대 공유안됨              래퍼 클래스(Integer, Long) - 공유가능한 객체이지만 변경x              String - 공유가능한 객체이지만 변경x                                임베디드 타입(embedded type, 복합 값 타입)                          새로운 값 타입 직접 정의가능              주로 기본 값 타입(int, String 등)을 모아서 만들어서 복합 값 타입이라고 함  ex) 근무시작시간, 근무종료시간 두개로 나타내지 않고 근무시간으로 나타냄  — 사용법              @Embeddable : 값 타입을 정의하는 곳에 표시              @Embedded : 값 타입을 사용하는 곳에 표시              기본 생성자 필수                          @Entity  public class Member  {      @Id @GeneratedValue      @Column(name=\"MEMBER_ID\")      private Long id;      private String name;      // @ManyToOne @JoinColumn(name = \"TEAM_ID\", insertable = false, updatable = false)      // private Team team;      //기간      @Embedded      private Period workPeriod;      //주소      @Embedded      private Address homeAddress;  }                          package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;              import java.time.LocalDateTime;              import javax.persistence.Embeddable;  @Embeddable  public class Period {      private LocalDateTime startDate;      private LocalDateTime endDate;                  public LocalDateTime getStartDate() {          return this.startDate;      }                  public void setStartDate(LocalDateTime startDate) {          this.startDate = startDate;      }                  public LocalDateTime getEndDate() {          return this.endDate;      }                  public void setEndDate(LocalDateTime endDate) {          this.endDate = endDate;      }              }                          package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;              import javax.persistence.Embeddable;              @Embeddable  public class Address {      private String city;      private String street;      private String zipcode;                  public String getCity() {          return this.city;      }                  public void setCity(String city) {          this.city = city;      }                  public String getStreet() {          return this.street;      }                  public void setStreet(String street) {          this.street = street;      }                  public String getZipcode() {          return this.zipcode;      }                  public void setZipcode(String zipcode) {          this.zipcode = zipcode;      }      public Address(){}      public Address(String city, String street, String zipcode){          this.city=city;          this.street = street;          this.zipcode= zipcode;      }              }                                    클래스를 나눴지만 한 테이블로 저장되는것을 확인할 수 있음            — 장점                          재사용 가능              높은 응집도              Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음              임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함                                    임베디드 타입을 쓰든 안쓰든 DB에 저장되는 값은 같음!!! = 임베디드 타입은 엔티티의 값일 뿐 사용하나 안하나 매핑하는 테이블은 같다. 객체와 테이블을 아주 세밀하게(find-greined) 매핑하는 것이 가능  잘 살계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음!!            —임베디드 타입과 연관관계                          엔티티의 임베디드 타입의 값이 안에 또 엔티티를 가질수도 있음                          @Embeddable  public class Address {      private String city;      private String street;  \t\t@Column(name=\"ZIPCODE\")      private String zipcode;                  private Member member;  }                        이런 식의 구조가 가능하다는 소리                                          @AttributeOverried 속성 재정의(잘 안씀)                                  만약 한 엔터티에서 같은 값 타입을 사용하려면?(회원 엔티티에서 집주소, 회사주소 등 여러 값을 가지는 경우. 한 클래스를 여러 값으로 표현가능한지?)                                  @Embedded      private Period workPeriod;      //주소      @Embedded      private Address homeAddress;      @Embedded      @AttributeOverrides({          @AttributeOverride(name=\"city\", column = @Column(name=\"WORK_CITY\")),          @AttributeOverride(name=\"street\", column = @Column(name=\"WORK_STREET\")),          @AttributeOverride(name=\"zipcode\", column = @Column(name=\"WORK_ZIPCODE\"))      })      private Address workAddress;                                                                            임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 side effect 발생 가능성 있음(회원 테이블이 주소 임베디드 타입 값을 보유중이라면 1번 회원이 주소를 변경했을때 2번 회원도 바뀔수도 있음)                  Address a = new Address(\"대구 서구\", \"북비산로 67길\", \"12300\");              Member m = new Member();              m.setName(\"hello\");              m.setHomeAddress(a);              em.persist(m);              Member m2 = new Member();              m2.setName(\"hello2\");              m2.setHomeAddress(a);              em.persist(m2);              m.getHomeAddress().setCity(\"서울\");              tx.commit();                                                이런식으로  만약 같은 값을 써야한다면 위의 예시에서는  a2 = new Address(a.getCity, a.getStreet, a.getZipcode) 로 새 객체를 만든 다음(복사)에 m2에 넣어줘야함.  그러나 객체 타입은 참조값을 직접 대입하는 것을 막을 수 없음 = 객체의 공유참조를 피할 수 없음 → 불변 객체 사용                            불변객체(immutable object) : 생성 시점 이후 절대 값을 변경할 수 없음.                                  객체 타입을 수정할 수 없게 만들어 부작용 원천 차단                  생성자로만 값을 설정하고 수정자(setter)를 만들지 않으면 됨(아니면 private로 만들기)                  Integer, String은 자바가 제공하는 대표적인 불변객체                                            값 비교 - 동등성 비교(equals()사용)                                  값 타입의 equals()메소드를 적절하게 재정의(주로 모든 필드 사용)                                  @Override      public boolean equals(Object o){          if(this==o) return true;          if(o == null || getClass() != o.getClass()) return false;          Address address = (Address) o;          return Objects.equals(city, address.city) &amp;&amp;                   Objects.equals(street, address.getStreet()) &amp;&amp;                  Objects.equals(zipcode, address.getZipcode());       }                                                              값 타입 컬렉션(collection value type) - 잘안씀. 차라리 엔티티로 승격화함                          값 타입을 하나이상 저장할 때 사용              @ElementCollection, @CollectionTable 사용              데이터 베이스는 컬렉션을 같은 테이블에 저장할 수 없음(별도 테이블 생성)              값 타입 컬렉션은 영속성 전이(Cascade) + 고아객체 제거 기능을 필수로 가져감              컬렉션을 저장하기 위한 별도의 테이블 필요                          @Entity  public class Member  {      @Id @GeneratedValue      @Column(name=\"MEMBER_ID\")      private Long id;      private String name;      // @ManyToOne @JoinColumn(name = \"TEAM_ID\", insertable = false, updatable = false)      // private Team team;      //기간      @Embedded      private Period workPeriod;      //주소      @Embedded      private Address homeAddress;                  @ElementCollection      @CollectionTable(name=\"FAVORITE_FOOD\", joinColumns = @JoinColumn(name=\"MEMBER_ID\"))      @Column(name=\"FOOD_NAME\") //값이 하나라 사용가능      private Set&lt;String&gt; favoriteFoods = new HashSet&lt;String&gt;();                      @ElementCollection      @CollectionTable(name=\"ADDRESS\", joinColumns = @JoinColumn(name=\"MEMBER_ID\"))      //값이 여러개라 @Column사용 불가능      private List&lt;Address&gt; addressHistory = new ArrayList&lt;Address&gt;();  }                          Address a = new Address(\"대구 서구\", \"북비산로 67길\", \"12300\");                  Member m = new Member();                  m.setName(\"hello\");                  m.setHomeAddress(a);                  m.getFavoriteFoods().add(\"치킨\");                  m.getFavoriteFoods().add(\"족발\");                  m.getFavoriteFoods().add(\"피자\");                  m.getFavoriteFoods().add(\"떡볶이\");                  m.getAddressHistory().add(new Address(\"1\", \"1\", \"1111\"));                  m.getAddressHistory().add(new Address(\"2\", \"2\", \"2222\"));                                    이런식  컬렉션은 전부 지연로딩임                          조회, 수정                  //조회  List&lt;Address&gt; list = find.getAddressHistory();  for(Address address : list){  System.out.println(address.getCity());  }  Set&lt;String&gt; set = find.getFavoriteFoods();  for(String food : set){  System.out.println(food);  }  //수정  find.setHomeAddress(new Address(\"newCity\", find.getHomeAddress().getStreet(), find.getHomeAddress().getZipcode()));  //수정  find.getFavoriteFoods().remove(\"치킨\");  find.getFavoriteFoods().add(\"한식\");                                                      — 제약사항                          값 타입은 엔티티와 다르게 식별자 개념이 없음              값 변경시 추적이 어려움              값 타입 컬렉션에 변경사항이 발생하면 주인 엔티티와 연관된 모든 데이터(멤버아이디가 동일한 것)를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장              값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성함(null x, 중복 x)                        ⇒ 실무에서는 값타입 컬렉션 대신 일대다 관계를 사용하는 것이 나음. 일대다 관계를 위한 엔티티를 만들고 여기서 값 타입 사용.(영속성 전이(Cascade)+고아객체 제거를 사용해 값타입 컬렉션처럼 사용)              package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;              import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;              @Entity  public class AddressEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      private Long id;      private Address address;  }                          @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)      @JoinColumn(name=\"MEMBER_ID\")      private List&lt;AddressEntity&gt; addressHistory = new ArrayList&lt;AddressEntity&gt;();                        값 타입을 엔티티로 승격시켜줌(실무사용방법)                              "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 프록시와 연관관계 관리",
    "url": "/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80_%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84_%EA%B4%80%EB%A6%AC/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-30 00:00:00 +0900",
    





    
    "snippet": "FK가 걸린 다른 객체를 각 상황에따라 같이조회할때도있고 조회하지않을때도 있을때, 조회하지 않을때 프록시와 지연로딩을 사용.프록시  em.find() : 데이터 베이스를 통해 실제 엔티티 객체 조회      em.getReference() : 데이터 베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회        위 코드 아래에 다시 findMembe...",
    "content": "FK가 걸린 다른 객체를 각 상황에따라 같이조회할때도있고 조회하지않을때도 있을때, 조회하지 않을때 프록시와 지연로딩을 사용.프록시  em.find() : 데이터 베이스를 통해 실제 엔티티 객체 조회      em.getReference() : 데이터 베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회        위 코드 아래에 다시 findMember.getName()을 하면 쿼리문 없이 바로 hello가 출력됨    em.getReference를 해서 가져온 findMember는 가짜 객체(껍데기만 같고 속은 텅텅빈상태)임. 실제 객체의 값을 조회할 때, sql문을 날려 DB에서 조회하는 것.    이론상 이 객체가 진짜인지 프록시 객체인지 구분하지 않고 사용가능함. 실제 클래스를 상속받아서 만들어지는 객체    프록시는 실제 객체의 참조(target)을 보관. 프록시 객체를 호출하면서 프록시 객체는 실제 객체의 메소드를 호출. 그런데 처음 호출하는거면 target이 없음 → 초기화 요청 작업 필요      — 특징  처음 사용할때 한번만 초기화  프록시 객체 초기화시 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화하면 프록시 객체를 통해 실제 인티티에 접근가능한것.  원본 엔티티를 상속받음. 따라서 타입체크시 주의.( == 비교 안됨, instance of 사용할것)      영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환(이미 em.find로 찾은 객체를 em.getReference로 찾으면 이미 찾아놓은 객체를 가져옴. 그래서 == 비교해도 true임  같은 원리고 em.getReference()로 호출하고 뒤에 em.find()로 같은 객체를 가져오면 == 비교를 해도 true가 나옴. em.find도 프록시를 가져오기 때문임. 실무에서 이렇게 복잡하게쓰일 일은 거의 없음)    영속성 컨텍스트의 도움을 받을수 없는 상태(준영속상태)일때 프록시 초기화하면 문제 발생          영속성 컨텍스트의 도움을 받을수 없는 상태(준영속상태)?  em.detach(proxy)를 사용했거나 em.close(), em.clear()를 사용했을 경우      영속성이 제거된 상태이기때문에 영속성 초기화를 할 수 없음      — 프록시 확인 방법  emf.getPersistenceUnitUtill.isLoaded(Object entity) - 프록시 인스턴스 초기화 여부 확인  entity.getClass().getName() 출력 - 프록시 클래스 확인 방법  org.hibernate.initialize(entity) - 프록시 강제 초기화  → JPA표준은 강제 초기화 없음  member.getName() - 강제 호출프록시는 잘 사용되지않으나 지연로딩과 즉시로딩이 자주 사용됨지연로딩(LAZY)@ManyToOne(fetch=FetchType.LAZY) - 연관 클래스 불러오기 전에는 연관 클래스 제외 조회지연로딩으로 만들면 연관 클래스를 프록시로 가지고옴실제 연관 클래스를 사용하는 시점에 초기화 됨연관 클래스를 자주 함께 조회한다면 성능상 손해임. → 즉시로딩 사용실무에서는 가급적 지연로딩만 사용할것!!@ManyToOne, @OneToOne은 기본이 즉시 로딩임 → LAZY로 설정해주어야함@OneToMany, @ManyTOMany는 기본이 지연로딩임즉시로딩(EAGER)@ManyToOne(fetch=FetchType.EAGER) - 처음부터 연관 클래스를 같이 가지고옴예상치 못한 SQL이 발생함. JPQL에서 N+1문제를 일으킴.  N+1문제?  하나의 테이블에 쿼리문을 날렸는데 다른 테이블 쿼리문도 실행되는 상황. 엔티티에 다른 엔티티가 연관되어있어서 한 테이블에 select문을 날렸는데 연관 테이블도 select되는 상황을 의미함— 결론모두 지연로딩으로 세팅 후 fetch join 사용 - 원하는 애들만 선택해서 가져오는 기법select m from Member m join fetchm.team 같이 사용, 뒤에 자세히 설명영속성 전이(CASCADE)@OneToMany(mappedBy=”parent”, cascade=CascadeType.XXX)특정 엔티티를 영속상태로 만들때 연관 엔티티도 영속상태로 만들어줌.(=부모 엔티티 저장 시, 자식 엔티티도 저장)연관관계 매핑과는 아무 관련이 없음. 엔티티를 영속화 할때 연관관계 엔티티도 함께 영속화되는 편리함때문에 사용됨하나의 부모가 자식들을 관리할때 효과가 있음. 자식의 연관관계가 여러개일때는 사용하지말것.— 종류  ALL : 모두 적용  PERDIDT : 영속  REMOVE : 삭제  MERGE : 병합  REFRESH : REFRESH  DETACH : DETACH고아객체고아객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제orphanRemoval = true부모의 List에서 자식을 remove해버리면 자식 데이터 자체가 삭제가 됨CascadeType.REMOVE처럼 동작함  주의점          참조하는 곳이 하나일때만 사용      특정 엔티티가 개인 소유일때만 사용      @OneToOne, @OneToMany만 사용 가능      ❗영속성 전이 + 고아객체, 생명주기  CascadeType.ALL + orphanRemovel = true  스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove로 제거  두 옵션을 모두 활성화 하면 부모 엔티티를 통해 자식의 생명주기 관리 가능  도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 떄 유"
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 고급매핑",
    "url": "/posts/%EA%B3%A0%EA%B8%89%EB%A7%A4%ED%95%91/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-29 00:00:00 +0900",
    





    
    "snippet": "DB에는 상속이라는 개념이 없음. 상속을 DB에서는 각각의 테이블로 변환(조인), 통합테이블 변환(단일테이블), 서브타입 테이블(구현클래스마다 테이블)로 변환 3가지가 있음  주요 어노테이션          @Inheritance(strategy= InheritanceType.XXX)                  JOINED : 조인전략(기본) - ...",
    "content": "DB에는 상속이라는 개념이 없음. 상속을 DB에서는 각각의 테이블로 변환(조인), 통합테이블 변환(단일테이블), 서브타입 테이블(구현클래스마다 테이블)로 변환 3가지가 있음  주요 어노테이션          @Inheritance(strategy= InheritanceType.XXX)                  JOINED : 조인전략(기본) - 정규화되어있음. 외래키 참조 제약조건 사용가능, 저장공간 효율화, 조인으로 인한 성능 저하, 쿼리 복잡, 저장시 insert 쿼리 2번          SINGLE_TABLE : 단일 테이블 전략(단순, 확장가능성 낮을때) - 조인필요없음, 쿼리 단순, 자식 엔티티가 매핑한 컬럼은 모두 null 허용, 상황에 따라 테이블이 커지면 성능이 떨어질수도 있음          TABLE_PER_CLASS : 구현 클래스마다 테이블 전략(쓰지말것) -                      @DiscriminatorColumn(name=”DTYPE”)  @DiscriminatorValue(”XXX”)      @MappedSuperclass - 공통 매핑 정보가 필요할때 사용(id, name)        공통되는 부분을 새 클래스로 만들고, 각각의 클래스들이 새 클래스를 extents 하면 됨    공통 되는 부분을 뽑아 만든 클래스에는 @MappedSuperclass를 써줘야함          상속 관계 매핑x      엔티티x, 테이블과 매핑 x      부모클래스를 상속받는 자식클래스에 매핑 정보만 제공      조회, 검색 불가(em.find(BaseEntity)불가)      직접 생성해서 사용할 일이 없으므로 추상 클래스 권장(abstract)          @Entity  @Inheritance(strategy = InheritanceType.SINGLE_TABLE)  @DiscriminatorColumn //기본이 DTYPE  public abstract class Item {      @Id @GeneratedValue      @Column(name = \"ITEM_ID\")      private Long id;      private String name;      private int price;      private int stockQuantity;      @ManyToMany(mappedBy = \"items\")      private List&lt;Category&gt; child = new ArrayList&lt;Category&gt;();  }      "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 연관관계 매핑",
    "url": "/posts/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84_%EB%A7%A4%ED%95%91/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-27 00:00:00 +0900",
    





    
    "snippet": "  방향(Direction)                  단방향          package com.kyhJPA.practice;          import javax.persistence.*;  @Entity  public class Member {      @Id @GeneratedValue      @Column(name = \"MEMBER_...",
    "content": "  방향(Direction)                  단방향          package com.kyhJPA.practice;          import javax.persistence.*;  @Entity  public class Member {      @Id @GeneratedValue      @Column(name = \"MEMBER_ID\")      private Long id;      @Column(name = \"USERNAME\")      private String username;                  // @Column(name = \"TEAM_ID\")      // private Long teamId;              @ManyToOne      @JoinColumn(name=\"TEAM_ID\")      private Team team;              public Team getTeam() {          return this.team;      }              public void setTeam(Team team) {          this.team = team;      }              // public Long getTeamId() {      //     return this.teamId;      // }              // public void setTeamId(Long teamId) {      //     this.teamId = teamId;      // }              public Long getId() {          return this.id;      }              public void setId(Long id) {          this.id = id;      }              public String getUsername() {          return this.username;      }              public void setUsername(String username) {          this.username = username;      }                  public Member(){              }              }                  {              \"bookSeq\": 3,              \"booktitle\": \"NestJS로 배우는 벡엔드 프로그래밍,NestJS로 배우는 벡엔드 프로그래밍\",              \"bookPrice\": 27000,              \"bookdiscount\": 0.1,              \"bookDelivery\": \"무료배송\",              \"publisherSeq\": {                  \"publisherSeq\": 3,                  \"publisherName\": \"제이펍\"              },              \"translatorSeq\": null,              \"bookSales\": 0,              \"bookRegDt\": \"2022-12-19T15:00:00.000+00:00\"          }                            양방향        위 단방향 매핑에서 team에서 member를 찾아올수없음!!          package com.kyhJPA.practice;          import java.util.ArrayList;  import java.util.List;          import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.Id;  import javax.persistence.OneToMany;          @Entity  public class Team {      @Id @GeneratedValue      @Column(name=\"TEAM_ID\")      private Long id;      private String name;              @OneToMany(mappedBy = \"team\") //Member클래스의 멤버변수 team과 연결되어있      private List&lt;Member&gt; members = new ArrayList&lt;Member&gt;();              public List&lt;Member&gt; getMembers() {          return this.members;      }              public void setMembers(List&lt;Member&gt; members) {          this.members = members;      }                  public Long getId() {          return this.id;      }              public void setId(Long id) {          this.id = id;      }              public String getName() {          return this.name;      }              public void setName(String name) {          this.name = name;      }                  }                team에 memberList를 생성해서 mappedBy를 사용                  객체와 테이블이 관계를 맺는 차이                          객체 연관관계 2개                                  회원 → 팀 연관관계 1개(단방향)                  팀→ 회원 연관관계 1개(단방향)                                            테이블 연관관계 1개                                  회원 ←→ 팀의 연관관계 1개(양방향)                                                                    → 객체의 양방향 관계 = 서로다른 단방향 관계 2개        ❗외래키 관리는 단방향 연관관계 2개중 하나로만 관리를 해야함 - 연관관계 주인(Owner)                              자주하는 실수                          연관관계 주인에 값을 입력하지 않음 - 항상 양쪽에 값을 설정해야함(편의 메소드를 작성하는 것을 추천함 - 양쪽에 모두 존재하면 문제발생 가능성있음)                          public void changeTeam(Team team) {          this.team = team;          team.getMembers().add(this); //여기서 this는 Member 클래스를 의미함      }                                      무한루프 - toString, lombok, JSON에서 무한루프에 빠짐!!  ⇒ lombok에서 toString만드는거 쓰지말것. json은.. entity를 바로 내보내지말것..!!!ㅜㅜㅠDTO(VO)를 생성해서 순수 자바 객체를 내보내는 것을 추천함,,,!!                        ⚠️ 단방향 매핑으로도 연관관계 매핑은 완료됨!!!!!양방향 매핑은 반대방향 조회기능이 추가된것뿐임!!!! 일단 단방향으로 매핑을 완료한 후 필요할때 양방향을 추가하면 됨                                다중성(Multiplicity)          다대일(N:1) - 가장 많이 사용              일대다(1:N) - 권장하지 않음                  항상 다(N)쪽에 외래키가 있어 반대편 테이블의 외래키를 관리하는 특이한 구조. @joinColumn을 꼭 사용해야함. 아니면 중간에 조인테이블을 추가해서 사용                  @OneToMany() @JoinColumn(name=\"TEAM_ID\") //Member클래스의 멤버변수 team과 연결되어있음      private List&lt;Member&gt; members = new ArrayList&lt;Member&gt;();                  Member member = new Member();              member.setUsername(\"member0\");              em.persist(member);                      Team team = new Team();              team.setName(\"Team0\");              team.getMembers().add(member); //team테이블이 아닌 member테이블의 team_id에 값이 들어감 update구문               //권장하지 않는 이유. team을 보냈는데 member테이블이 update됨                      em.persist(team);                          연관관계 관리를 위해 추가로 UPDATE SQL이 실행되어 비효율적임.                      일대다 양방향 - 공식x                          @JoinColumn(insertable = false, updatable = false) 를 사용              그냥 다대일 양방향을 사용할것.                          @ManyToOne      @JoinColumn(name=\"TEAM_ID\", insertable = false, updatable = false) //읽기전      private Team team;                                                  일대일(1:1)                  주테이블이나 대상 테이블중에 외래키 선택 가능                          주 테이블 외래키                                  객체지향 개발자 선호                  JPA매핑 편리                  주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능하나 값이 없으면 외래키에 null 허용                                            대상 테이블 외래키                                  대상 테이블에 외래키가 존재                  전통적인 DB개발자 선호                  주테이블과 대상테이블을 일대일에서 일대다로 바꿀때 테이블 구조는 유지되나 프록시 기능의 한계로 지연로딩으로 설정해도 항상 즉시 로딩됨                                                              다대일, 단방향 매핑과 유사함                  @Entity  public class Locker {       @Id @GeneratedValue       private Long id;               private String name;               @OneToOne(mappedBy = \"locker\")       private Member member;  }                  @Entity  public class Member {      @Id @GeneratedValue      @Column(name = \"MEMBER_ID\")      private Long id;      @Column(name = \"USERNAME\")      private String username;              @ManyToOne      @JoinColumn(name=\"TEAM_ID\")      private Team team;              @OneToOne @JoinColumn(name=\"LOCKER_ID\")      private Locker locker;  }                    다대다(N:M) - 쓰지말것. 연결 테이블을 하나 생성해서 다대일, 일대다로 풀어내야함        연관관계 주인(Owner)          객체 양방향 연관관계(단방향 2개)에서 하나를 연관관계 주인으로 지정      연관관계 주인만이 외래키를 관리(등록, 수정)      주인이 아닌쪽은 읽기만 가능      주인은 mappedBy속성을 이용하지x(mappedBy가 있다면 주인이 아님)      주인은 외래키가 있는곳으로 정할것(반대편을 가짜매핑이라고 편의상 부름. 전문용어는 아닌듯) - DB 입장에서는 외래키가 있는곳이 다, 없는곳이 1.        @JoinColumn : 외래 키를 매핑할 때 사용          name : 매핑할 외래키 이름. 필드명_참조할 테이블의 기본키 컬럼명      referencedColumnName : 외래키가 참조하는 대상 테이블의 컬럼명. 참조하는 테이블의 기본키 컬럼명      foreignKey(DDL) - 외래 키 제약조건을 직접 지정가능. 테이블 생성할때만 사용가능      @Column속성과 같은것                  unique          nullable insertable          updateable          columnDefinition          table                      @ManyToOne 주요 속성          optional : false로 설정하면 연관된 엔티티가 항상 있어야 함 - 기본값 true      fetch - 글로벌 페치 전략을 설정                  @ManyToOne=FetchType.EAGER          @OneToMany=FetchType.LAZY                    cascade - 영속성 전이 기능 사용      targetEntity - 연관된 엔티티의 타입정보를 설정. 거의 사용 안함.(컬렉션을 사용해도 제네릭으로 타입정보를 알수있음)        @OneToMany 주요 속성          mappedBy - 연관관계 주인 필드 선택      fetch - 글로벌 페치 전략을 설정                  @ManyToOne=FetchType.EAGER          @OneToMany=FetchType.LAZY                    cascade - 영속성 전이 기능 사용      targetEntity - 연관된 엔티티의 타입정보를 설정. 거의 사용 안함.(컬렉션을 사용해도 제네릭으로 타입정보를 알수있음)      "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] MVC패턴 실습",
    "url": "/posts/MVC/",
    "categories": "Spring",
    "tags": "spring, mvc, 국비교육",
    "date": "2022-12-26 00:00:00 +0900",
    





    
    "snippet": "클라이언트사이드 렌더링(CSR) : 사용자의 컴퓨터 성능에따라 달라짐. (지금까지 한 방법)서버사이드 렌더링(SSR) : 서버의 성능에 따라 움직임?(새로 시도할 방법)jdk버전 17.0.4.1로 업데이트함환경변수 JAVA_HOME 경로 변경해주기. vscode에서도 자바버전 확인해보기스프링 프로젝트 생성시 자바 3.0.1, 17버전으로 선택appli...",
    "content": "클라이언트사이드 렌더링(CSR) : 사용자의 컴퓨터 성능에따라 달라짐. (지금까지 한 방법)서버사이드 렌더링(SSR) : 서버의 성능에 따라 움직임?(새로 시도할 방법)jdk버전 17.0.4.1로 업데이트함환경변수 JAVA_HOME 경로 변경해주기. vscode에서도 자바버전 확인해보기스프링 프로젝트 생성시 자바 3.0.1, 17버전으로 선택application.properties에서 공백이 들어가면 안됨. 종료를 의미하는 ;을 사용하지 않아서 제대로 써줘야함controller(사용자와의 연결을 관리)에서 날아온 medel을 viewResolver가 파일을 찾아서 view에 표시함callback(프로그램이 메소드를 실행)개념과도 맞물림 - 자바스크립트의 event, click, spring의 getMapping 등 IOC와 동일함resource의 static폴더에는 아이콘 같이 잘 변하지않는 것들을 넣음  html에서 입력받은 정보를 객체에 저장하는 방법&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;회원가입&lt;/h1&gt;    &lt;form action=\"/member/join\" method=\"post\"&gt;        &lt;table&gt;            &lt;tbody&gt;                &lt;tr&gt;                    &lt;td&gt;아이디&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"id\"&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;비밀번호&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"password\" name=\"pwd\"&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;이름(닉네임)&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"nickname\"&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan=\"2\"&gt;                        &lt;input type=\"submit\" value=\"회원가입\"&gt;                        &lt;a href=\"/\"&gt;메인으로&lt;/a&gt;                    &lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;package com.green.demo.VO;import lombok.Data;@Datapublic class UserInfoVO {    private String id;    private String pwd;    private String nickname;}package com.green.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import com.green.demo.VO.UserInfoVO;@Controller@RequestMapping(\"/member\")public class MemberController {    @GetMapping(\"/join\")    public String getMemberJoin(){        return \"/member/join\";    }    @PostMapping(\"/join\")    public String postMemberJoin(UserInfoVO data){        System.out.println(data);        return \"member/join\";    }}여기서 회원가입하면출력됨package com.green.demo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import com.green.demo.VO.UserInfoVO;import com.green.demo.entity.UserEntity;import com.green.demo.repository.UserRepository;@Controller@RequestMapping(\"/member\")public class MemberController {    @Autowired UserRepository uRepo;    @GetMapping(\"/join\")    public String getMemberJoin(){        return \"/member/join\";    }    @PostMapping(\"/join\")    public String postMemberJoin(UserInfoVO data){        System.out.println(data);        UserEntity entity = new UserEntity(null, data.getId(), data.getPwd(), data.getNickname());        System.out.println(entity);        uRepo.save(entity);        return \"member/join\";    }}받은 값은 repository에 save()해주면 DB에 저장됨물론 이런방법으로 하면 안됨  가입 후 성공메세지@PostMapping(\"/join\")    public String postMemberJoin(UserInfoVO data){        System.out.println(data);        UserEntity entity = new UserEntity(null, data.getId(), data.getPwd(), data.getNickname());        System.out.println(entity);        uRepo.save(entity);        return \"member/joined\";    }&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;성공적으로 가입되었습니다.&lt;/h1&gt;    &lt;a href=\"/\"&gt;메인으로&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;  중복가입 메세지@PostMapping(\"/join\")    public String postMemberJoin(UserInfoVO data, Model model){        System.out.println(data);        if(uRepo.countByUiId(data.getId())&gt;0){            model.addAttribute(\"dup_id\", data.getId());            return \"/member/duplicated\";        }        UserEntity entity = new UserEntity(null, data.getId(), data.getPwd(), data.getNickname());        System.out.println(entity);        uRepo.save(entity);        return \"member/joined\";    }&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&lt;u th:text=\"${dup_id}\"&gt;&lt;/u&gt;은/는 이미 가입된 아이디입니다.&lt;/h1&gt;    &lt;a href=\"/\"&gt;메인으로&lt;/a&gt;    &lt;a href=\"/member/join\"&gt;회원가입&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;책application.properties 설정server.port=8044\\#DB설정  jdbc:mysql://jdbc연결 프로토콜(http://, ftp://, smtp://)spring.datasource.url=jdbc:mysql://localhost:3306/book_info_dbspring.datasource.username=rootspring.datasource.password=1234\\#thymeleaf(출력화면) 설정spring.thymeleaf.enabled=true\\#application.properties입장에서의 소속 패키지(폴더경로)# classpath : src/main/resources 경로를 의미spring.thymeleaf.prefix=classpath:/templates/#최종적으로 src/main/resources/templates/ 경로를 의미spring.thymeleaf.suffix=.html\\#File Transfer Settingsspring.servlet.multipart.enabled=truespring.servlet.multipart.max-file-size=100MBspring.servlet.multipart.max-request-size=110MB      일부 값만 적어서 객체 생성하는 방법 - @Builder      package com.greenart.book_info.entity;              import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Builder;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"admin_account\")  @DynamicInsert //입력이 안된 null값은 default값을 입력  @Builder //입력한 값만 입력. 객체 생성 시 없는 값은 제외하고 입력  public class AdminAccountEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"ai_seq\")                            private Long aiSeq;       @Column(name=\"ai_id\")                             private String aiId;       @Column(name=\"ai_pwd\")                            private String aiPwd;       @Column(name=\"ai_name\")                           private String aiName;       @Column(name=\"ai_grade\")  @ColumnDefault(\"1\")     private Integer aiGrade;       @Column(name=\"ai_status\") @ColumnDefault(\"0\")     private Integer aiStatus;  }          package com.greenart.book_info;      import org.junit.jupiter.api.Test;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.boot.test.context.SpringBootTest;  import org.springframework.transaction.annotation.Transactional;      import com.greenart.book_info.entity.AdminAccountEntity;  import com.greenart.book_info.repository.AdminAccountRepository;      @SpringBootTest  class BookInfoApplicationTests {      \t@Autowired AdminAccountRepository aRepo;      \t@Test  \t@Transactional  \tvoid addAdmin() {  \t\tAdminAccountEntity account = AdminAccountEntity.builder().aiId(\"admin\").aiPwd(\"1234\").aiName(\"관리자\").build();  \t\taRepo.save(account);  \t\tSystem.out.println(account);  \t}      }        모든 값을 입력하지 않고도 생성가능함.(생성자와 동일한 역할이나 입력하지 않을 멤버변수에 null을 사용하지않고 생성가능)        중복아이디시 입력값 살리는 법      package com.greenart.book_info.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PostMapping;  import org.springframework.web.bind.annotation.RequestMapping;      import com.greenart.book_info.entity.AdminAccountEntity;  import com.greenart.book_info.repository.AdminAccountRepository;      @Controller  @RequestMapping(\"/member\")  public class MemberController {           @Autowired AdminAccountRepository aRepo;           @GetMapping(\"/join\") //requestMapping       public String getMemberJoin(){            return \"/member/join\"; //application.properties prefix, suffix기준       }       @PostMapping(\"/join\")       public String postMemberJoin(String id, String pwd, String name, Model model){            if(aRepo.countByAiId(id)&gt;0){                 model.addAttribute(\"id\", id);                 model.addAttribute(\"name\", name);                 model.addAttribute(\"status\", \"duplicated\");                 return \"/member/join\";             }else{                 AdminAccountEntity data = AdminAccountEntity.builder().aiId(id).aiPwd(pwd).aiName(name).build();                 aRepo.save(data);            }            return \"/login\"; //가입 성공하면 바로 로그인페이지로       }  }          &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;관리자 등록&lt;/h1&gt;        &lt;form action=\"/member/join\" method=\"post\"&gt;            &lt;!-- table&gt;tbody&gt;(tr&gt;td*2)*3 입력하면 자동으로 틀 만들어줌--&gt;            &lt;table&gt;                 &lt;tbody&gt;                      &lt;tr&gt;                           &lt;td&gt;아이디&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"text\" name=\"id\" th:value=\"${id}\"&gt;&lt;/td&gt;                           &lt;td&gt;&lt;span th:if=\"${status=='duplicated'}\" style=\"color: red;\"&gt;중복 아이디 입니다.&lt;/span&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;비밀번호&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"password\" name=\"pwd\"&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;이름&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"text\" name=\"name\" th:value=\"${name}\"&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td colspan=\"2\"&gt;                                &lt;input type=\"submit\" value=\"관리자 등록\"&gt;                           &lt;/td&gt;                      &lt;/tr&gt;                 &lt;/tbody&gt;            &lt;/table&gt;       &lt;/form&gt;  &lt;/body&gt;  &lt;/html&gt;        중복아이디 입력으로 실패처리돼도 아이디와 이름의 값이 유지가 되고 메세지가 뜸          공백검사      String replacedId = id.replaceAll(\" \", \"\"); //문자열 공백 제거            if(id.length()!=replacedId.length()){ //공백이 있었다면 문자열의 길이가 달라짐                 model.addAttribute(\"status\", \"whitespaceId\");                 return \"/member/join\";             }            String replacedPwd = pwd.replaceAll(\" \", \"\"); //문자열 공백 제거            if(pwd.length()!=replacedPwd.length()){ //공백이 있었다면 문자열의 길이가 달라짐                 model.addAttribute(\"status\", \"whitespacePwd\");                 return \"/member/join\";             }        메소드에 추가 후 html에 if문 추가        영문, 숫자만 가능하도록 추가 - 정규표현식 사용      String kor_pattern = \"^[a-zA-Z0-9]*$\"; //영어, 숫자만 가능            Pattern p = Pattern.compile(kor_pattern);            if(!p.matcher(id).matches()){                 model.addAttribute(\"status\", \"invalidId\");                 return \"/member/join\";             }        메소드에 추가 후 html에 if문 추가    이메일, 전화번호 형식 등 검색하면 정규표현식 뜸. 복붙해서 쓰면됨    정규표현식으로 공백도 걸러지니 정규표현식을 사용한다면 위의 공백검사는 안해줘도됨        로그인      @GetMapping(\"/login\")  public String getLogin(HttpServletResponse response){      response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");      response.setHeader(\"Pragma\", \"no-cache\");      response.setHeader(\"Expires\", \"0\"); //로그인 후 뒤로가기했을때 비밀번호가 뜨지않도록 캐시를 날림      return \"/login\";  }  @PostMapping(\"/login\")  public String postLogin(String id, String pwd, Model model, HttpSession session){       //session - 값들을 저장하는 저장소(전체서비스에서 한개 = 전역적임[전체영역에서 접근 가능])      System.out.println(id);      System.out.println(pwd);      AdminAccountEntity loginUser = adminAccountRepository.findByAiIdAndAiPwd(id, pwd);      //다른 URL로 들어가면 loginUser는 사용할 수 없음      if(loginUser==null){           model.addAttribute(\"loginStatus\", \"failed\");           model.addAttribute(\"message\", \"아이디 또는 비밀번호 오류입니다.\");           return \"/login\";      }      session.setAttribute(\"loginUser\", new LoginUserVO(loginUser));      //session은 다른 URL로 들어가도 사용가능      return \"redirect:/\"; //로그인성공하면 메인화면으로(파일경로아니고 매핑경로 기준.)  }          &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;login&lt;/h1&gt;       &lt;form action=\"/login\" method=\"post\"&gt;            &lt;table&gt;                 &lt;tr&gt;                      &lt;td&gt;아이디&lt;/td&gt;                      &lt;td&gt;&lt;input type=\"text\" name=\"id\"&gt;&lt;/td&gt;                 &lt;/tr&gt;                 &lt;tr&gt;                      &lt;td&gt;비밀번호&lt;/td&gt;                      &lt;td&gt;&lt;input type=\"password\" name=\"pwd\"&gt;&lt;/td&gt;                 &lt;/tr&gt;                 &lt;tr&gt;                      &lt;td colspan=\"2\"&gt;                      &lt;button&gt;로그인&lt;/button&gt;                 &lt;/tr&gt;                 &lt;tr&gt;                      &lt;td colspan=\"2\"&gt;                           &lt;a href=\"/member/join\"&gt;관리자 등록&lt;/a&gt;                      &lt;/td&gt;                 &lt;/tr&gt;            &lt;/table&gt;       &lt;/form&gt;       &lt;div th:if=\"${loginStatus == 'failed'}\"&gt;            &lt;p th:text=\"${message}\" style=\"color: red; font-weight: bold; font-size: 14px;\"&gt;&lt;/p&gt;       &lt;/div&gt;  &lt;/body&gt;  &lt;/html&gt;            계정 조회 후 상태값 변경, 계정 삭제    영속성 조심(수정했다가 원본 테이블 수정될까봐)!! 새 객체 만들어줌      package com.greenart.book_info.VO;      import com.greenart.book_info.entity.AdminAccountEntity;      import lombok.Data;  @Data  public class AdminAccountVo {       private Long seq;       private String id;       private String name;       private Integer grade;       private Integer status;           public AdminAccountVo(AdminAccountEntity account){            this.seq = account.getAiSeq();            this.id = account.getAiId();            this.name = account.getAiName();            this.grade = account.getAiGrade();            this.status = account.getAiStatus();       }  }          @GetMapping(\"/list\")  public String getMemberList(Model model, Pageable pageable  ){      Page&lt;AdminAccountEntity&gt; page = aRepo.findAll(pageable);      List&lt;AdminAccountVo&gt; result = new ArrayList&lt;&gt;();      for(AdminAccountEntity a : page.getContent()){           result.add(new AdminAccountVo(a));      }      model.addAttribute(\"accountList\", result);      model.addAttribute(\"totalPage\", page.getTotalPages());      model.addAttribute(\"totalCount\", page.getTotalElements());      model.addAttribute(\"getMemberJoin()\", page.getNumber());      return \"member/list\";  }  @GetMapping(\"/status\")  public String getMemberStatusUpdate(@RequestParam Long seq, @RequestParam Integer status){      AdminAccountEntity entity = aRepo.findByAiSeq(seq); //select문      entity.setAiStatus(status); //값 변경      aRepo.save(entity); //ctrl + s      // -&gt; update      return \"redirect:/member/list\";  }  @GetMapping(\"/delete\")  public String getMemberDelete(@RequestParam Long seq){      AdminAccountEntity entity = aRepo.findByAiSeq(seq);      aRepo.delete(entity); //삭제      return \"redirect:/member/list\";  }        result에 new를 써서 새로운 객체를 만들어준것이 영속성 제거를 위해 사용한 것임    @{URL}(param=${value}) 형식으로    @{/member/status(seq=${admin.seq})} 이런식.    admin.seq에 해당 멤버의 seq값이 자동으로 들어감 최종적으로    /member/status?seq=7 이런식으로 주소가 생성됨    — 파라미터 추가 @{/member/status(seq=${admin.seq}, status=1)} 이런식      &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;Admin Account List&lt;/h1&gt;       &lt;!-- &lt;p th:text=\"${accountList}\"&gt;&lt;/p&gt; --&gt;       &lt;table&gt;            &lt;thead&gt;                     &lt;tr&gt;                      &lt;th&gt;번호&lt;/th&gt;                      &lt;th&gt;아이디&lt;/th&gt;                      &lt;th&gt;이름&lt;/th&gt;                      &lt;th&gt;등급&lt;/th&gt;                      &lt;th&gt;상태&lt;/th&gt;                 &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                 &lt;tr th:each=\"admin, i : ${accountList}\"&gt; &lt;!-- 반복문 --&gt;                      &lt;td th:text=\"${admin.seq}\"&gt;&lt;/td&gt;                      &lt;td th:text=\"${admin.id}\"&gt;&lt;/td&gt;                      &lt;td th:text=\"${admin.name}\"&gt;&lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:switch=\"${admin.grade}\"&gt;                                &lt;span th:case=\"1\"&gt;일반&lt;/span&gt;                                &lt;span th:case=\"99\"&gt;슈퍼유저&lt;/span&gt;                           &lt;/th&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:switch=\"${admin.status}\"&gt;                                &lt;span th:case=\"0\"&gt;등록대기&lt;/span&gt;                                &lt;span th:case=\"1\"&gt;사용가능&lt;/span&gt;                                &lt;span th:case=\"2\"&gt;사용정지&lt;/span&gt;                           &lt;/th&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:if=\"${admin.status==0}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=1)}\"&gt;사용 승인&lt;/a&gt;                           &lt;/th:block&gt;                           &lt;th:block th:if=\"${admin.status==1}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=2)}\"&gt;사용 정지&lt;/a&gt;                           &lt;/th:block&gt;                           &lt;th:block th:if=\"${admin.status==2}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=1)}\"&gt;사용 승인&lt;/a&gt;                           &lt;/th:block&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block&gt;                                &lt;a th:href=\"@{/member/delete(seq=${admin.seq})}\"&gt;삭제&lt;/a&gt;                           &lt;/th:block&gt;                      &lt;/td&gt;                 &lt;/tr&gt;            &lt;/tbody&gt;       &lt;/table&gt;       &lt;div&gt;            &lt;span th:each=\"num : ${\\#numbers.sequence(1, totalPage)}\"&gt;                 &lt;a th:href=\"@{/member/list(page=${num-1},size=10,sort=aiSeq,desc)}\" th:text=\" ${num}\"&gt;&lt;/a&gt;            &lt;/span&gt;       &lt;/div&gt;  &lt;/body&gt;  &lt;/html&gt;                              페이지 기능 추가. 페이지 누르면 이동됨        슈퍼유저만 관리자리스트페이지 접근가능      @GetMapping(\"/list\")  public String getMemberList(      Model model,       @PageableDefault(size=10, sort=\"aiSeq\", direction =Sort.Direction.DESC) Pageable pageable,      HttpSession session  ){      LoginUserVO login = (LoginUserVO)session.getAttribute(\"loginUser\");      if(login == null){           return \"redirect:/login\";      }      Page&lt;AdminAccountEntity&gt; page = aRepo.findAll(pageable);      List&lt;AdminAccountVo&gt; result = new ArrayList&lt;&gt;();      for(AdminAccountEntity a : page.getContent()){           result.add(new AdminAccountVo(a));      }      model.addAttribute(\"accountList\", result);      model.addAttribute(\"totalPage\", page.getTotalPages());      model.addAttribute(\"totalCount\", page.getTotalElements());      model.addAttribute(\"getMemberJoin()\", page.getNumber());      return \"member/list\";  }                &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;            &lt;script th:inline=\"javascript\"&gt;            /* &lt;![CDATA[ */                 const grade = /*[[${session.loginUser.grade}]]*/;                 if(grade==1){                      alert(\"마스터 관리자만 접근 가능한 메뉴입니다.\");                      location.href=\"/\";                 }            /* ]] */       &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;Admin Account List&lt;/h1&gt;       &lt;!-- &lt;p th:text=\"${accountList}\"&gt;&lt;/p&gt; --&gt;       &lt;table&gt;            &lt;thead&gt;                     &lt;tr&gt;                      &lt;th&gt;번호&lt;/th&gt;                      &lt;th&gt;아이디&lt;/th&gt;                      &lt;th&gt;이름&lt;/th&gt;                      &lt;th&gt;등급&lt;/th&gt;                      &lt;th&gt;상태&lt;/th&gt;                 &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                 &lt;tr th:each=\"admin, i : ${accountList}\"&gt; &lt;!-- 반복문 --&gt;                      &lt;td th:text=\"${admin.seq}\"&gt;&lt;/td&gt;                      &lt;td th:text=\"${admin.id}\"&gt;&lt;/td&gt;                      &lt;td th:text=\"${admin.name}\"&gt;&lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:switch=\"${admin.grade}\"&gt;                                &lt;span th:case=\"1\"&gt;일반&lt;/span&gt;                                &lt;span th:case=\"99\"&gt;슈퍼유저&lt;/span&gt;                           &lt;/th&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:switch=\"${admin.status}\"&gt;                                &lt;span th:case=\"0\"&gt;등록대기&lt;/span&gt;                                &lt;span th:case=\"1\"&gt;사용가능&lt;/span&gt;                                &lt;span th:case=\"2\"&gt;사용정지&lt;/span&gt;                           &lt;/th&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:if=\"${admin.status==0}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=1)}\"&gt;사용 승인&lt;/a&gt;                           &lt;/th:block&gt;                           &lt;th:block th:if=\"${admin.status==1}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=2)}\"&gt;사용 정지&lt;/a&gt;                           &lt;/th:block&gt;                           &lt;th:block th:if=\"${admin.status==2}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=1)}\"&gt;사용 승인&lt;/a&gt;                           &lt;/th:block&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block&gt;                                &lt;a th:href=\"@{/member/delete(seq=${admin.seq})}\"&gt;삭제&lt;/a&gt;                           &lt;/th:block&gt;                      &lt;/td&gt;                 &lt;/tr&gt;            &lt;/tbody&gt;       &lt;/table&gt;       &lt;div&gt;            &lt;span th:each=\"num : ${\\#numbers.sequence(1, totalPage)}\"&gt;                 &lt;a th:href=\"@{/member/list(page=${num-1})}\" th:text=\" ${num}\"&gt;&lt;/a&gt;            &lt;/span&gt;       &lt;/div&gt;  &lt;/body&gt;  &lt;/html&gt;                로그아웃      @GetMapping(\"/logout\")       public String getLogout(HttpSession session){            // session.invalidate(); //세션 정보 모두 삭제            session.setAttribute(\"loginUser\", null); //session에 다른정보가 있다면            return \"redirect:/\";         }            책 DB 생성      create table writer_info(  \twi_seq int not null auto_increment primary key,  \twi_name varchar(100) not null,  \twi_introduce text null,  \twi_img varchar(255) default 'writer_default.jpg'  );  create table translator_info(  \tti_seq int not null auto_increment primary key,  \tti_name varchar(100) not null,  \tti_introduce text null,  \tti_img varchar(255) default 'translator_default.jpg'  );  create table publish_company(  \tpc_seq int not null auto_increment primary key,  \tpc_name varchar(255) not null  );      create table book_info(  \tbi_seq int not null auto_increment primary key,  \tbi_title varchar(255) not null,  \tbi_sub_title varchar(255) null,  \tbi_price int not null default 0,  \tbi_discount double not null default 0.1,  \tbi_point double not null default 0.05,  \tbi_pub_dt datetime not null,  \tbi_wi_seq int null,  \tbi_ti_seq int null,  \tbi_pub_seq int null,  \tforeign key (bi_wi_seq) references writer_info(wi_seq) on delete set null on update cascade, -- 작가 삭제시 책정보 null, 작가변경시 책도 변경  \tforeign key (bi_ti_seq) references translator_info(ti_seq) on delete set null on update cascade, -- 번역가 삭제시 책정보 null, 번역가 변경시 책도 변경  \tforeign key (bi_pub_seq) references publish_company(pc_seq) on delete set null on update cascade -- 출판사 삭제시 책정보 null, 출판사 변경시 책도 변경  );        foreign key 설정함.      package com.greenart.book_info.entity;      import java.time.LocalDate;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"book_info\")  @DynamicInsert  public class BookInfoEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"bi_seq\")         private Long biSeq;       @Column(name=\"bi_title\")       private String biTitle;       @Column(name=\"bi_sub_title\")   private String biSubTitle;            @Column(name=\"bi_price\")       private Integer biPrice;            @Column(name=\"bi_discount\") @ColumnDefault(\"0.1\")   private Double biDiscount;            @Column(name=\"bi_point\")    @ColumnDefault(\"0.05\")   private Integer biPoint;            @Column(name=\"bi_pub_dt\")      private LocalDate biPubDt;            @Column(name=\"bi_wi_seq\")      private Long biWiSeq;            @Column(name=\"bi_ti_seq\")      private Long biTiSeq;            @Column(name=\"bi_pub_seq\")     private Long biPubSeq;           }          package com.greenart.book_info.entity;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"publish_company\")  public class PublishCompanyEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"pc_seq\")        private Long pcSeq;       @Column(name=\"pc_name\")       private String pcName;    }          package com.greenart.book_info.entity;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"translator_info\")  @DynamicInsert  public class TranslatorInfoEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"ti_seq\")        private Long tiSeq;       @Column(name=\"ti_name\")       private String tiName;       @Column(name=\"ti_introduce\")  private String tiIntroduce;            @Column(name=\"ti_img\") @ColumnDefault(\"translator_default.jpg\") private String tiImg;  }          package com.greenart.book_info.entity;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"writer_info\")  @DynamicInsert  public class WriterInfoEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name = \"wi_seq\")           private Long wiSeq;       @Column(name = \"wi_name\")          private String wiName;       @Column(name = \"wi_introduce\")     private String wiIntroduce;            @Column(name = \"wi_img\") @ColumnDefault(\"writer_default.jpg\") private String wiImg;  }            책 추가(연관관계매핑)      package com.greenart.book_info.entity;      import java.time.LocalDate;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;  import org.springframework.beans.factory.annotation.Autowired;      import com.greenart.book_info.VO.BookAddVO;  import com.greenart.book_info.repository.PublishCompanyRepository;  import com.greenart.book_info.repository.TranslatorInfoRepository;  import com.greenart.book_info.repository.WriterInfoRepository;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.JoinColumn;  import jakarta.persistence.ManyToOne;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Builder;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"book_info\")  @DynamicInsert  @Builder  public class BookInfoEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"bi_seq\")         private Long biSeq;       @Column(name=\"bi_title\")       private String biTitle;       @Column(name=\"bi_sub_title\")   private String biSubTitle;            @Column(name=\"bi_price\")       private Integer biPrice;            @Column(name=\"bi_discount\") @ColumnDefault(\"0.1\")   private Double biDiscount;            @Column(name=\"bi_point\")    @ColumnDefault(\"0.05\")   private Double biPoint;            @Column(name=\"bi_pub_dt\")      private LocalDate biPubDt;        @ManyToOne @JoinColumn(name=\"bi_wi_seq\") WriterInfoEntity writer;       @ManyToOne @JoinColumn(name = \"bi_ti_seq\") TranslatorInfoEntity translator;       @ManyToOne @JoinColumn(name = \"bi_pub_seq\") PublishCompanyEntity publisher;           public BookInfoEntity(BookAddVO data){            this.biTitle = data.getTitle();            this.biSubTitle   = data.getSub_title();            this.biPrice  = data.getPrice();            this.biDiscount   = data.getDiscount()/100.0;            this.biPoint  = data.getPoint()/100.0;            this.biPubDt  = data.getPub_dt();       }  }          package com.greenart.book_info.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PostMapping;  import org.springframework.web.bind.annotation.RequestMapping;      import com.greenart.book_info.VO.BookAddVO;  import com.greenart.book_info.entity.BookInfoEntity;  import com.greenart.book_info.repository.BookInfoRepository;  import com.greenart.book_info.repository.PublishCompanyRepository;  import com.greenart.book_info.repository.TranslatorInfoRepository;  import com.greenart.book_info.repository.WriterInfoRepository;      @Controller  @RequestMapping(\"/book\")  public class BookInfoController {           @Autowired TranslatorInfoRepository tRepo;       @Autowired WriterInfoRepository wRepo;       @Autowired BookInfoRepository bRepo;       @Autowired PublishCompanyRepository pRepo;           @GetMapping(\"/add\")       public String getBookAdd(Model model){            model.addAttribute(\"writerList\", wRepo.findAll());            model.addAttribute(\"translatorList\", tRepo.findAll());            model.addAttribute(\"publisherList\", pRepo.findAll());            return \"/book/add\";       }       @PostMapping(\"/add\")       public String postBookAdd(BookAddVO data){            BookInfoEntity entity = BookInfoEntity.builder()                 .biTitle(data.getTitle())                 .biSubTitle(data.getSub_title())                 .biPrice(data.getPrice())                 .biDiscount(data.getDiscount()/100.0)                 .biPoint(data.getPoint()/100.0)                 .biPubDt(data.getPub_dt())                 .writer(wRepo.findByWiSeq(data.getWriter()))                 .translator(tRepo.findByTiSeq(data.getTranslator()))                 .publisher(pRepo.findByPcSeq(data.getPublisher()))                 .build();            bRepo.save(entity);            return \"redirect:/\";       }               }          &lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;       &lt;style&gt;            body {text-align: center;}            \\#input_form_table {margin: 0 auto; border-collapse: collapse;}             \\#input_form_table input {width: 70%;}            \\#input_form_table td {padding: 10px;}       &lt;/style&gt; &lt;!-- css --&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;책 정보 추가&lt;/h1&gt;       &lt;form action=\"/book/add\" method=\"post\"&gt;            &lt;table border=\"1\" id=\"input_form_table\"&gt;                 &lt;tbody&gt;                      &lt;tr&gt;                           &lt;td&gt;책 제목&lt;/td&gt;                           &lt;td colspan=\"2\"&gt;&lt;input type=\"text\" name=\"title\"&gt;&lt;/td&gt;                           &lt;td&gt;출간일&lt;/td&gt;                           &lt;td colspan=\"2\"&gt;&lt;input type=\"text\" name=\"pub_dt\"&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;부제목&lt;/td&gt;                           &lt;td colspan=\"5\"&gt;&lt;input type=\"text\" name=\"sub_title\"&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;작가&lt;/td&gt;                           &lt;td&gt;                                &lt;select name=\"writer\"&gt;                                     &lt;option value=\"0\"&gt;선택안함&lt;/option&gt;                                     &lt;option th:each=\"writer, i : ${writerList}\" th:text=\"${writer.wiName}\" th:value=\"${writer.wiSeq}\"&gt;&lt;/option&gt;                                &lt;/select&gt;                           &lt;/td&gt;                           &lt;td&gt;번역가&lt;/td&gt;                           &lt;td&gt;                                &lt;select name=\"translator\"&gt;                                     &lt;option value=\"0\"&gt;선택안함&lt;/option&gt;                                     &lt;option th:each=\"translator, i : ${translatorList}\" th:text=\"${translator.tiName}\" th:value=\"${translator.tiSeq}\"&gt;&lt;/option&gt;                                &lt;/select&gt;                           &lt;/td&gt;                           &lt;td&gt;출판사&lt;/td&gt;                           &lt;td&gt;                                &lt;select name=\"publisher\"&gt;                                     &lt;option value=\"0\"&gt;선택안함&lt;/option&gt;                                     &lt;option th:each=\"publisher, i : ${publisherList}\" th:text=\"${publisher.pcName}\" th:value=\"${publisher.pcSeq}\"&gt;&lt;/option&gt;                                &lt;/select&gt;                           &lt;/td&gt;                           &lt;td&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;가격&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"number\" name=\"price\" min=\"0\"&gt;원&lt;/td&gt;                           &lt;td&gt;할인률&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"number\" name=\"discount\" min=\"0\" max=\"100\"&gt;%&lt;/td&gt;                           &lt;td&gt;적립율&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"number\" name=\"point\" min=\"0\" max=\"100\"&gt;%&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td colspan=\"6\"&gt;                                &lt;button&gt;저장&lt;/button&gt;                                &lt;a href=\"/\"&gt;돌아가기&lt;/a&gt;                           &lt;/td&gt;                      &lt;/tr&gt;                 &lt;/tbody&gt;            &lt;/table&gt;       &lt;/form&gt;  &lt;/body&gt;  &lt;/html&gt;      package com.greenart.book_info.entity;import jakarta.persistence.CascadeType;import jakarta.persistence.Column;import jakarta.persistence.Entity;import jakarta.persistence.GeneratedValue;import jakarta.persistence.GenerationType;import jakarta.persistence.Id;import jakarta.persistence.JoinColumn;import jakarta.persistence.ManyToOne;import jakarta.persistence.Table;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity@Table(name=\"student_info\")public class StudentInfoEntity {     @Id @GeneratedValue(strategy = GenerationType.IDENTITY)     @Column(name=\"stu_seq\") private Long stuSeq;     @Column(name=\"stu_name\") private String stuName;     // @Column(name=\"stu_major_seq\") private Long stuMajorSeq;     @ManyToOne(cascade = CascadeType.PERSIST) @JoinColumn(name=\"stu_major_seq\") private StudentMajorEntity major;}@Test\tvoid addStudent(){\t\tStudentInfoEntity stu = new StudentInfoEntity();\t\tstu.setStuName(\"박학생\");\t\tstu.setMajor(new StudentMajorEntity(null, \"컴퓨터 공학과\")); //Major도 함께 insert됨\t\tstuRepo.save(stu);\t}cascade = CascadeType.PERSIST때문에 가능함. 학과테이블에 중복을 허용하지않아서 이미 있는 값으로 테스트하면 에러남.연계되는 정보를 같이 지정하겠다는 의미setMajor를 할때 student_major테이블에도 자동으로 insert됨cascade = CascadeType.PERSIST를 붙이지 않고도 하려면 테스트코드를 이런식으로짜야함@Test\tvoid addStudent2(){\t\tStudentInfoEntity stu = new StudentInfoEntity();\t\tstu.setStuName(\"최학생\");\t\tstu.setMajor(majorRepo.findById(3L).get()); //Major도 함께 insert됨\t\tstuRepo.save(stu);\t}직접 찾아서 넣겠다는 의미라 cascade가 붙으면 에러남사용자 →(요청)→ 컨트롤러 →(데이터)→ 모델+뷰 → HTML ⇒(응답)⇒ 사용자      session, Model 설명    endpoint        이거말하는거임    영문이아니면 한글자에 길이가 2로 계산하는 시스템도있으니 주의할것                  세션초기화        session.invalidate(); 사용                package com.greenart.testproject.main.controller;      import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.GetMapping;      import jakarta.servlet.http.HttpSession;      @Controller  public class MainController {       @GetMapping(\"/\")       public String getMain(Model model, HttpSession session){            //Model - 데이터를 실어나르는 박스(데이터 컨텍스트)            model.addAttribute(\"hello\", \"Hello World!!\");            //웹페이지 파일이 로드되기전에 생성됨            session.setAttribute(\"sessionValue\", \"세션에 추가된 값\");            //백엔드 시스템에서, 세션무효화를 실행했을때 세션을 다시만든다.                return \"/index\";       }           @GetMapping(\"/index\")       public String getIndex(Model model){            model.addAttribute(\"hello\", \"@GetMapping(\\\"index\\\")를 통한 응답\");            return \"/index\";       }       @GetMapping(\"/invalidate\")       public String getInvalidate(HttpSession session){            session.invalidate(); //세션 초기화            return \"redirect:/index\";            //index는 endpoint에서 찾음       }  }        엔티티에 기본키값이 설정되어있다면 save를 했을때 업데이트로 적용됨          회원탈퇴          &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;회원탈퇴&lt;/h1&gt;       &lt;h2 style=\"color: red;\"&gt;정말 탈퇴하시겠습니까?&lt;/h2&gt;       &lt;form action=\"member/leave\" method=\"post\" id=\"leave_form\"&gt;            &lt;input type=\"checkbox\" id=\"agree\"&gt;            &lt;label for=\"agree\"&gt;회원탈퇴시 발생하는 손해에대해서 책임지겠습니다.&lt;/label&gt;            &lt;button id=\"leave\"&gt;회원탈퇴&lt;/button&gt;            &lt;a href=\"/\"&gt;메인으로&lt;/a&gt;       &lt;/form&gt;       &lt;script&gt;            document.getElementById(\"leave\").addEventListener(\"click\", function(e){                 e.preventDefault();                 if(!document.getElementById(\"agree\").checked){                      alert(\"체크박스에 체크를 해주셔야 탈퇴 진행이 가능합니다.\")                      return;                 }                 if(confirm(\"진짜 탈퇴하시겠습니까?\")){                      alert(\"탈퇴\");                      document.getElementById(\"leave_Form\").submit();                 }            })       &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;        스크립트를 써야 탈퇴 메세지창이 뜸      package com.greenart.testproject.main.repository;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.greenart.testproject.main.entity.User;      @Repository  public interface UserRepository extends JpaRepository&lt;User, Long&gt; {       Integer countByUserId(String userId);       public User findByUserIdAndUserPwd(String userId, String userPwd);       //delete from user_info where user_id = 'user_id'       public void deleteByUserId(String UserId);  }                      서버 여는 코드(SQL)        use mysql;        create user ‘root’@’%’ identified by ‘1234’;        grant all privileges on . to ‘root’@’%’;        flush privileges;              히스토리 테이블은 서비스가 정상 작동하는것을 확인한 후에 독립적인 테이블을 만들어주면됨    (FK없이 순수데이터로만 들어가야함)  "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 엔티티 매핑",
    "url": "/posts/%EC%97%94%ED%8B%B0%ED%8B%B0_%EB%A7%A4%ED%95%91/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-26 00:00:00 +0900",
    





    
    "snippet": "객체와 테이블 매핑  객체와 테이블 매핑          @Entity                  JPA가 관리          기본 생성자 필수(파라미터가 없는 public 또는 protected생성자)          final 클래스, enum, interface, inner 클래스 사용 x          저장할 필드에 final 사용 x ...",
    "content": "객체와 테이블 매핑  객체와 테이블 매핑          @Entity                  JPA가 관리          기본 생성자 필수(파라미터가 없는 public 또는 protected생성자)          final 클래스, enum, interface, inner 클래스 사용 x          저장할 필드에 final 사용 x                    @Table        필드와 컬럼 매핑 - @Column  기본 키 매핑 - @Id  연관관계 매핑 - @ManyToOne, @JoinColumn      데이터베이스 스키마 자동 생성 (persistence.xml에서 설정)          DDL을 애플리케이션 실행시점에 자동 생성      테이블 중심 → 객체 중심      DB방언을 사용해 DB에 더 적합한 DDL 생성      이미 생성된 DDL은 개발장비에만 사용(운영에 사용 x)      생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용        (entity 클래스 생성 후 실행하면 자동으로 만들어준다는 얘기같음)                                                                              create          기존 테이블 삭제 푸 다시 생성 (drop + create)                          create-drop          create와 같으나 종료시점에서 테이블 drop                          update          변경문만 반영(운영 DB에서는 사용x, 칼럼삭제x)                          vaildate          엔티티와 테이블이 정상 매핑되었는지만 확인                          none          사용x                      이미 운영중인 장비에 create, create-drop, update를 사용하면 대참사 가능성.    개발 초기 - create or update    테스트 서버 - update or vaildate    스테이징, 운영 - vaildate or none    DDL 생성기 : 멤버 변수 위에 @Column(unique=true, length=10)처럼 지정가능, DDL 자동 생성할때만 사용, JPA실행로직에는 영향을 주지않          유니크 제약조건 - @Column(unique=true, length=10)      필수 조건 - @Column(nullable=false, length=10)      필드와 컬럼 매핑  @Column - 컬럼 매핑(그냥 @Column(name=’dd’, nullable=false, columnDefinition=’….’)이런식으로 쓰면됨)          name - 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름      insertable, updatable - 등록, 변경 가능 여부 TRUE              nullable(DDL) - null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시에  not null 제약조건이 붙는다.                    unique(DDL) - @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제  약조건을 걸 때 사용한다.(잘안씀.. 이름이 이상하게나옴 차라리 @table에서 거는게 나음)                    columnDefinition(DDL) - 데이터베이스 컬럼 정보를 직접 줄 수 있다.  ex) varchar(100) default ‘EMPTY’  필드의 자바 타입과 방언 정보를 사용해서 적절한 컬럼 타입 length(DDL) 문자 길이 제약조건, String 타입에만 사용한다. (기본값 255)            precision, scale(DDL) - BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다).  precision은 소수점을 포함한 전체 자 릿수를, scale은 소수의 자릿수다. 참고로 double, float 타입에는 적용되지 않는다. 아주 큰 숫자나 정밀한 소수를 다루어야 할 때만 사용한다.  (기본값 precision=19, scale=2)        @Temporal - 날짜 타입 매핑          TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑(예: 2013–10–11)      TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑(예: 11:11:11)      TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(예: 2013–10–11 11:11:11)        @Enumerated - enum 타입 매핑          EnumType.ORDINAL : enum의 순서를 DB에 저장 - enum에 적은 순서대로 integer값으로 저장. enum의 순서가 꼬이면 대참사 우려(쓰지말것)      EnumType.STRING : enum의 이름을 DB에 저장        @Lob - BLOB, CLOB 매핑            특정 필드를 컬럼에 매핑하지 않음(매핑 무시)      기본키 매핑@Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id ← 이거  IDENTITY - 기본키 생성을 DB에 위임. DB에 insert를 해야 값을 알 수 있있어서 예외로 JPA가 em.persist한 순간 바로 DB에 쿼리를 날려버려서 기본키를 찾아옴!!!  SEQUENCE - 오라클 기본키  TABLE 전략 : 키 전용 테이블을 하나 만들어서 DB 시퀀스를 흉내내는 전략(모든 DB에 적용가능하나 성능이 떨어짐. 잘안씀)package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;import java.time.LocalDateTime;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.EnumType;import javax.persistence.Enumerated;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name=\"ORDERS\")public class Order {    @Id @GeneratedValue    @Column(name=\"ORDER_ID\")    private Long id;    @Column(name=\"MEMBER_ID\")    private Long memberId;    private LocalDateTime orderDate;    @Enumerated(EnumType.STRING)    private OrderStatus status;    public Long getId() {        return this.id;    }    public void setId(Long id) {        this.id = id;    }    public Long getMemberId() {        return this.memberId;    }    public void setMemberId(Long memberId) {        this.memberId = memberId;    }    public LocalDateTime getOrderDate() {        return this.orderDate;    }    public void setOrderDate(LocalDateTime orderDate) {        this.orderDate = orderDate;    }    public OrderStatus getStatus() {        return this.status;    }    public void setStatus(OrderStatus status) {        this.status = status;    }    }위 예제 코드에서 private Long memberId; 부분!! 객체지향스럽지 않음!! Member member로 받아오는것이 정확한것이아닌지??테이블의 외래키를 객체에 그대로 가져오는것이 문제임! 객체 그래프 탐색도 불가능하고 참조가 없으므로 UML도 잘못⇒ 연관관계 매핑"
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 영속성 관리",
    "url": "/posts/%EC%98%81%EC%86%8D%EC%84%B1_%EA%B4%80%EB%A6%AC/",
    "categories": "JPA",
    "tags": "김영한자바ORM표준JPA, jpa, ORM",
    "date": "2022-12-25 00:00:00 +0900",
    





    
    "snippet": "영속성 컨텍스트  JPA를 이해하는데 가장 중요한 용어  “엔티티를 영구 저장하는 환경”  EntityManager.persist(entity) - DB에 저장하는 것이 아니라 영속성 컨텍스트에 저장함  논리적인 개념(눈에보이지 않음)  엔티티 메니저를 통해서 영속성 컨텍스트에 접근  엔티티의 생명주기          비영속(new/transient)...",
    "content": "영속성 컨텍스트  JPA를 이해하는데 가장 중요한 용어  “엔티티를 영구 저장하는 환경”  EntityManager.persist(entity) - DB에 저장하는 것이 아니라 영속성 컨텍스트에 저장함  논리적인 개념(눈에보이지 않음)  엔티티 메니저를 통해서 영속성 컨텍스트에 접근  엔티티의 생명주기          비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 - em.persist 하기 전 entity      영속(managed) : 영속성 컨텍스트에 관리되는 상태 - em.persist 한 상태 or em.find한 상(DB저장상태아님. 1차 캐시에 저장된상태)      준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태. 영속성 컨텍스트가 제공하는 기능을 사용하지 못함.(더이상 JPA가 관리하지 않음.)                  em.detach(entity) : 특정 엔티티만 준영속 상태로 전환.          em.clear() : 영속성 컨텍스트를 완전히 초기화          em.close() : 영속성 컨텍스트를 종                    삭제(removed) : 삭제된 상태 - em.remove(entity)      → em.persist단계에서 entity가 1차캐시에 저장됨. 이후 조회할때 DB접근 필요없이 1차캐시만 조회하면 되서 효율적임. 그러나 1차캐시에서 찾지못한다면 DB를 조회해서 1차캐시를 재로딩?함이렇게 1차캐시에서 조회해오기때문에 각 두 변수에 같은 조건으로 조회를 한다면 동일성 비교를 했을때 true가 나옴em.persist(entity)를 하면 1차 캐시에 entity가 저장되고 insert SQL이 쓰기지연 저장소에 저장됨 → 이 후 transaction.commit()을 하면 DB에 쓰기지연 저장소에 저장되어있던 SQL문이 flush됨위 처럼 수정해주면 변경 값을 DB에 자동으로 수정해줌. 변경감지기능이 있어서 따로 DB를 수정해줄 필요가 없음!!! 1차 캐시에서 entity의 초기값을 스냅샷으로 저장해뒀다가 스냅샷과 entity를 비교해서 다른게 있다면 DB를 수정함. 삭제도 마찬가지로 1차캐시에서 지워지면 DB도 지워짐  플러시 : 영속성 컨텍스트의 변경내용(쓰기지연 저장소)을 데이터베이스에 반영(DB 바로 반영)          em.flush() - 직접 호출      트랜잭션 커밋 - 플러시 자동 호출      JPQL 쿼리 실행 - 플러시 자동 호출(DB반영 안된상태에서 SQL문을 날리면 오류발생가능성있음)      영속성 컨텍스트를 비우지는 않음      영속성 컨텍스트의 변경내용을 DB에 동기화      트랜잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화하면      ❗1차캐시는 고객이 10명이 접속하면 10개가 생김. 성능상 이점이 그렇게 크지는 않"
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 설정",
    "url": "/posts/%EC%84%A4%EC%A0%95/",
    "categories": "JPA",
    "tags": "김영한자바ORM표준JPA, jpa, ORM",
    "date": "2022-12-23 00:00:00 +0900",
    





    
    "snippet": "maven을 이용한 강의.수업시간에 gradle을 사용하였으나 강사님의 댓글을 보니 실무에서는 maven도 활용할 줄 아는 것이 더 좋다고 해서 (gradle로 설정하기엔 너무 까다롭고, spring이 들어오면 다 해결될 문제라고 하심)일단 maven으로 따라해보려고 한다.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;...",
    "content": "maven을 이용한 강의.수업시간에 gradle을 사용하였으나 강사님의 댓글을 보니 실무에서는 maven도 활용할 줄 아는 것이 더 좋다고 해서 (gradle로 설정하기엔 너무 까다롭고, spring이 들어오면 다 해결될 문제라고 하심)일단 maven으로 따라해보려고 한다.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;groupId&gt;jpa-basic&lt;/groupId&gt;\t&lt;artifactId&gt;ex1-hello-jpa&lt;/artifactId&gt;\t&lt;version&gt;1.0.0&lt;/version&gt;\t&lt;dependencies&gt;\t\t&lt;!-- JPA 하이버네이트 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.hibernate&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;\t\t\t&lt;version&gt;5.3.10.Final&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- H2 데이터베이스 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.h2database&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;h2&lt;/artifactId&gt;\t\t\t&lt;version&gt;1.4.199&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- 실행했더니 작동하지 않아서 구글링 후 추가해줌 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;\t\t\t&lt;version&gt;2.3.0&lt;/version&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;&lt;/project&gt;resources폴더 - META-INF 속에 persistence파일 생성&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence version=\"2.2\" xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\"&gt;    &lt;persistence-unit name=\"hello\"&gt;        &lt;properties&gt;            &lt;!-- 필수 속성 --&gt;            &lt;property name=\"javax.persistence.jdbc.driver\" value=\"org.h2.Driver\" /&gt;            &lt;property name=\"javax.persistence.jdbc.user\" value=\"sa\" /&gt;            &lt;property name=\"javax.persistence.jdbc.password\" value=\"\" /&gt;            &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:h2:tcp://localhost/~/test\" /&gt;            &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.H2Dialect\" /&gt;            &lt;!-- 옵션 --&gt;            &lt;property name=\"hibernate.show_sql\" value=\"true\" /&gt;            &lt;property name=\"hibernate.format_sql\" value=\"true\" /&gt;            &lt;property name=\"hibernate.use_sql_comments\" value=\"true\" /&gt;            &lt;!--&lt;property name=\"hibernate.hbm2ddl.auto\" value=\"create\" /&gt;--&gt;        &lt;/properties&gt;    &lt;/persistence-unit&gt;&lt;/persistence&gt;데이터베이스 생성 후 entity 매핑을 해주고package com.kyhJPA.practice;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JpaMain {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");        EntityManager em = emf.createEntityManager();        Member member = new Member();        EntityTransaction tx = em.getTransaction();        tx.begin();        member.setId(1L);        member.setName(\"helloA\");        em.persist(member);        tx.commit();        em.close();        emf.close();    }}아래 코드를 실행하면 데이터 베이스에 저장됨실행 후 터미널에 뜬 sql문.package com.kyhJPA.practice;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JpaMain {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");        EntityManager em = emf.createEntityManager();                EntityTransaction tx = em.getTransaction();        tx.begin();        try{            Member member = new Member();            member.setId(2L);            member.setName(\"helloB\");            em.persist(member);            tx.commit();        }catch(Exception e){            tx.rollback();        }finally{            em.close();        }        emf.close();    }}정석적인 코드이나 스프링이 대신해주기때문에 작성할 필요없음]]조회업데이트❗ 주의 사항  엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유  엔티티 매니저는 쓰레드 간의 공유x (사용하고 버려야함)  JPA의 모든 데이터 변경은 트랜잭션 안에서 실JPQL  엔티티 객체를 대상으로 쿼리  SQL은 데이터베이스 테이블을 대상으로 쿼리 = 객체지향 쿼리"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 기본편] 객체지향 설계",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리기본편",
    "date": "2022-12-21 00:00:00 +0900",
    





    
    "snippet": "  비즈니스 요구사항과 설계          회원                              회원을 가입하고 조회할 수 있다.  회원은 일반과 VIP 두 가지 등급이 있다.                    회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)                      주문과 할인...",
    "content": "  비즈니스 요구사항과 설계          회원                              회원을 가입하고 조회할 수 있다.  회원은 일반과 VIP 두 가지 등급이 있다.                    회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)                      주문과 할인 정책  회원은 상품을 주문할 수 있다.  회원 등급에 따라 할인 정책을 적용할 수 있다.                    할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)          할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)                    순수 자바 코드 구현package com.hello.core.Member;public enum Grade {    BASIC,    VIP}package com.hello.core.Member;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Member {    private Long id;    private String name;    private Grade grade;}package com.hello.core.Member;public interface MemberRepository {    void save(Member member);    Member findById(Long memberid);}package com.hello.core.Member;import java.util.HashMap;import java.util.Map;public class MemoryMemberRepository implements MemberRepository {    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();    //Hash맵을 사용하면 동시성 이유발생 위험 있음. 콘커러테이션맵?을 쓰라고함    @Override    public void save(Member member) {        store.put(member.getId(), member);    }    @Override    public Member findById(Long memberid) {        return store.get(memberid);    }    }package com.hello.core.Member;public interface MemberService {        void join(Member member);    Member findMember(Long memberId);}package com.hello.core.Member;// impl = 구현체가 하나만있을때 관례로 많이 쓰임public class MemberServiceImpl implements MemberService{    private MemberRepository memberRepository = new MemoryMemberRepository();    @Override    public void join(Member member) {        memberRepository.save(member);//MemoryMemberRepository의 save가 호출됨    }    @Override    public Member findMember(Long memberId) {        return memberRepository.findById(memberId); //MemoryMemberRepository의 findById가 호출    }    }package com.hello.core;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;public class MemberApp {    public static void main(String[] args) {        MemberService mService = new MemberServiceImpl();        Member member = new Member(1L,\"MemberA\",Grade.VIP);        mService.join(member);        System.out.println(mService.findMember(1L));        System.out.println(member);        // 순수 자바 코드 구현방법            }}의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음. → 주문까지 만들고나서 해결방안 설명= MemberRepository는 인터페이스에 의존하지만 MemoryMemberRepository(실제 할당하는 부분)는 구현체를 의존관심사 분리해결방법package com.hello.core.order;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.FixdiscountPolicy;public class Appconfig {    public MemberService memberService(){ //생성자 주입        return new MemberServiceImpl(new MemoryMemberRepository());    }    public OrderService orderService(){        return new OrderServiceImpl(new MemoryMemberRepository(), new FixdiscountPolicy());    }}package com.hello.core.member;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.order.Appconfig;public class MemberServiceTest {    MemberService mService;        @BeforeEach //각 테스트 실행 전 무조건 실행되는 테스트    public void BeforeEach(){        Appconfig a = new Appconfig();        mService = a.memberService();    }    @Test    void join(){        Member member = new Member(1L, \"MemberA\", Grade.VIP);        mService.join(member);        Member findMember = mService.findMember(1L);        Assertions.assertThat(member).isEqualTo(findMember);    }}package com.hello.core;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;import com.hello.core.order.Appconfig;public class MemberApp {    public static void main(String[] args) {        Appconfig appconfig = new Appconfig();        // MemberService mService = new MemberServiceImpl(null);        MemberService mService = appconfig.memberService();        Member member = new Member(1L,\"MemberA\",Grade.VIP);        mService.join(member);        System.out.println(mService.findMember(1L));        System.out.println(member);        // 순수 자바 코드 구현방법            }}package com.hello.core.order;import com.hello.core.Member.Member;import com.hello.core.Member.MemberRepository;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.FixdiscountPolicy;import com.hello.core.discount.RateDiscountPolicy;public class OrderServiceImpl implements OrderService {    // private final MemberRepository memberRepository = new MemoryMemberRepository();    // private final DiscountPolicy discountPolicy = new FixdiscountPolicy();    //만약 할인 정책이 변경된다면 new FixdiscountPolicy()만 고쳐주면 전체 변경 가능    // private final DiscountPolicy discountPolicy = new RateDiscountPolicy();    //그러나 이 방식은 RateDicountPolicy에도 의존중인 상태로 DIP위반    //코드를 바꿔줘야한다는 자체가 OCP 위반임.    //인터페이스에만 의존하도록 의존관계를 변경해야함.        private DiscountPolicy discountPolicy; //인터페이스에만 의존중임. 그러나 이대로면 NullPointerException 발생    private final MemberRepository memberRepository;    //OrderServiceImlp에 구현객체를 대신 생성해주어야함    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy){        this.discountPolicy = discountPolicy;        this.memberRepository = memberRepository;    }    @Override    public Order createOrder(Long memberId, String itemName, int itemPrice) {        Member member = memberRepository.findById(memberId);        int discountPrice = discountPolicy.discount(member, itemPrice);        return new Order(memberId, itemName, itemPrice, discountPrice);    }}이런식으로 작성해주어야함선생님께서 너무 좋은 강의이나 실무에서 이런 객체 지향적인 설계를 실제로 구현하기가 꽤나 까다롭다고..하시면서 실무관련 강의를 먼저 듣는것도 좋은방법이라고 말씀해주셨다..!이쪽이 더 기초 이론쪽 로드맵인거같아서 들었는데 실무관련 로드맵 부터 완성해보기로 했다AppConfig 리팩터링중복이있고 역할에 따른 구현이 잘 안보인다는 문제가 있음이런 구조가 되어야함.package com.hello.core;import com.hello.core.Member.MemberRepository;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.FixdiscountPolicy;import com.hello.core.order.OrderService;import com.hello.core.order.OrderServiceImpl;public class Appconfig {    public MemberService memberService(){ //생성자 주입        return new MemberServiceImpl(memberRepository());    }    private MemberRepository memberRepository(){        return new MemoryMemberRepository();    }    // public MemberService memberService(){ //생성자 주입    //     return new MemberServiceImpl(new MemoryMemberRepository());    // } //아래와 중복코드가 있음. new MemoryMemberRepository부분. 위의 코드로 수정해줌    public OrderService orderService(){        return new OrderServiceImpl(memberRepository(), discountPolicy());    }    public DiscountPolicy discountPolicy(){        return new FixdiscountPolicy();    } //할인정책도 메소드를 만들어줌}수정한 Appconfig. 이렇게하면 메소드명으로 역할 구분이 가능해짐새로운 구조와 할인정책 적용현재 사용영역과 구성 영역이 분리되어있음구성영역만 고치면 됨package com.hello.core;import com.hello.core.Member.MemberRepository;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.RateDiscountPolicyimport com.hello.core.discount.RateDiscountPolicy;;import com.hello.core.order.OrderService;import com.hello.core.order.OrderServiceImpl;public class Appconfig {    public MemberService memberService(){ //생성자 주입        return new MemberServiceImpl(memberRepository());    }    private MemberRepository memberRepository(){        return new MemoryMemberRepository();    }    // public MemberService memberService(){ //생성자 주입    //     return new MemberServiceImpl(new MemoryMemberRepository());    // } //아래와 중복코드가 있음. new MemoryMemberRepository부분. 위의 코드로 수정해줌    public OrderService orderService(){        return new OrderServiceImpl(memberRepository(), discountPolicy());    }    public DiscountPolicy discountPolicy(){        // return new FixdiscountPolicy();        return new RateDiscountPolicy();    } //할인정책도 메소드를 만들어줌}discountPolicy에서 return만 달라짐IoC(Inversion of Control) : 제어의 역전내가 호출하는 것이 아니라 프레임워키가 대신 호출해주는 것.위 예시에서 Appconfig 등장 이후 구현 객체는 실행만 담당함. 프로그램 제어 흐름은 Appconfig가 가져감.프로그램의 제어 흐름을 외부에서 관리하는 것을 IoC라고 함.  프레임워크 vs 라이브러리          프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 프레임워크 맞음(JUnit)      내가 작성한 코드가 직접 제어의 흐름을 담당한다면 프레임워크가 아니라 라이브러리임      DI(Dependency Injection) : 의존관계 주입위 예시에서 OrderServiceImpl은 DiscountPolicy 인터페이스만 알고있지 DiscountPolicy의 어떤 구현체(FixDiscountPolicy, RateDiscountPolicy)가 들어올지는 알고있지 않음!!  정적인 의존관계          클래스가 사용하는 inport코드만 보고 의존관계를 쉽게 판단 가능함      애플리케이션을 실행하지 않아도 분석가능함      OrderServiceImpl을 보면 OrderService가 상위 인테페이스인것을 알 수 있고 MemberRepository와 DiscountPolicy를 참고하고있음을 알 수 있음        동적인 의존관계          애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계임      애플리케이션을 실행하지 않으면 어떤 객체가 OrderServiceImpl에 주입될지는 알 수 없음        결론          실행시점(런타임)에 외부에서 실제 구현객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라함      객체 인스턴스를 생성해서 그 참조값을 전달해서 연결함      클라이언트코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경 가능함      정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경가능함      컨테이너AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것 → IoC컨테이너 또는 DI컨테이너라고 부름의존관계 주입에 초점을 맞춰서 요즘은 주로 DI컨테이너라고 함. 아샘블러, 오브젝트 팩토리 등으로 불리기도함스프링으로 변경  AppConfig : 설정정보package com.hello.core;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.hello.core.Member.MemberRepository;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.RateDiscountPolicy;import com.hello.core.order.OrderService;import com.hello.core.order.OrderServiceImpl;@Configurationpublic class Appconfig {    @Bean    public MemberService memberService(){ //생성자 주입        return new MemberServiceImpl(memberRepository());    }    @Bean    private MemberRepository memberRepository(){        return new MemoryMemberRepository();    }    // public MemberService memberService(){ //생성자 주입    //     return new MemberServiceImpl(new MemoryMemberRepository());    // } //아래와 중복코드가 있음. new MemoryMemberRepository부분. 위의 코드로 수정해줌    @Bean    public OrderService orderService(){        return new OrderServiceImpl(memberRepository(), discountPolicy());    }    @Bean    public DiscountPolicy discountPolicy(){        // return new FixdiscountPolicy();        return new RateDiscountPolicy();    } //할인정책도 메소드를 만들어줌}이렇게하면 스프링컨테이너에 들어감@Bean이 붙을 메소드는 모두 public이여야함. 아니면 컴파일 오류남.  MemberApppackage com.hello.core;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;public class MemberApp {    public static void main(String[] args) {        // Appconfig appconfig = new Appconfig();        // MemberService mService = appconfig.memberService();        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);        MemberService mService = applicationContext.getBean(\"memberService\", MemberService.class); //일치하는 메소드 이름을 찾아내서 가져옴        Member member = new Member(1L,\"MemberA\",Grade.VIP);        mService.join(member);        System.out.println(mService.findMember(1L));        System.out.println(member);        // 순수 자바 코드 구현방법            }}  OrderApppackage com.hello.core.order;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.hello.core.Appconfig;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;public class OrderApp {    public static void main(String[] args) {        // Appconfig a = new Appconfig();        // MemberService memberService = a.memberService();        // OrderService orderService = a.orderService();        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);        MemberService memberService = applicationContext.getBean(\"memberService\", MemberService.class);        OrderService orderService = applicationContext.getBean(\"orderService\", OrderService.class);        Long memberid = 1L;        Member member = new Member(memberid, \"memberA\", Grade.VIP);        memberService.join(member);        Order order = orderService.createOrder(memberid, \"itemA\", 10000);        System.out.println(order);        System.out.println(order.calculatePrice());    }}"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 기본편] 객체지향 설계와 스프링",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84%EC%99%80_%EC%8A%A4%ED%94%84%EB%A7%81/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리기본편",
    "date": "2022-12-20 00:00:00 +0900",
    





    
    "snippet": "스프링 - 여러가지 기술의 모음배치처리 : 실무에서 많은 데이터를 업데이트해야할경우 일부만 먼저처리하고 저장하고 다시 일부를 처리하고 저장하기를 반복함. 스프링배치가 이것을 효율적으로 할수있게 도와줌스프링부트- 다른기능을 편리하게 사용할수있게 도와주는 기술이라 제체적으로는 별기능이없음.스프링은 객체지향 언어가 가진 특징을 살려낼수있는 프레임워크임. 클...",
    "content": "스프링 - 여러가지 기술의 모음배치처리 : 실무에서 많은 데이터를 업데이트해야할경우 일부만 먼저처리하고 저장하고 다시 일부를 처리하고 저장하기를 반복함. 스프링배치가 이것을 효율적으로 할수있게 도와줌스프링부트- 다른기능을 편리하게 사용할수있게 도와주는 기술이라 제체적으로는 별기능이없음.스프링은 객체지향 언어가 가진 특징을 살려낼수있는 프레임워크임. 클라이언트를 변경하지않고, 서버의 구현기능을 유연하게 변경 가      SOLID : 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리          SRP : 단일 책임 원칙(single responsibility principle)                  한 클래스는 하나의 책임만 가져야한다.          하나의 책임이라는 것은 모호하다                          클수있고, 작을수있다.              문맥과 상황에 따라 다르다                                중요한 기능은 변경이다. 변경이있을때 파급효과가 적으면 단일책임 원칙을 잘 따른것          예) UI변경, 객체의 생성과 사용을 분                            OCP : 개방-폐쇄 원칙(Open/closed principle)                  소프트 웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다                → 다형성 활용.                  인터페이스를 구현한 새로운 클래스를 하나 만들어 새로운 기능을 구현          역할과 구현의 분리를 생각해볼것          문제점                                          구현 객체를 변경하려면 클라이언트 코드를 변경해야함.  MemberRepository m = new MemoryMemberRepository(); (변경전)  MemberRepository m = new JdbcMemberRepository(); (변경)                                            다형성을 사용했지만 OCP원칙을 지킬수 없음(코드를 변경해야함)                ⇒객체를 생성, 연관관계를 맺어주는 별도의 조립, 생성자가 필요(스프링 컨테이너)                                                        LSP : 리코스트 치환원칙 (Liskov substitution principle)                  프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야한다.          다영성에서 하위 클래스는 인터페이스 규약을 다 지켜야한다는 것, 다형성을 지원하기 위한 원칙. 인터페이스를 구현한 구현체를 믿고 사용하려면 필요한 원칙          단순히 컴파일을 넘어서는 이야기          예) 자동차의 엑셀을 밟았을때 뒤로가는 것은 LSP위반. 느리더라도 앞으로 가야                    ISP : 인터페이스 분리 원칙 (Interface segregation principle)                  특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다          자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리          사용자 클라리언트 → 운전자 클라이언트, 정비사 클라이언트로 분리          분리하면정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.          인터페이스가 명확해지고 대체가능성이 높아진다.                    DIP : 의존관계 역전 원칙 (Dependency inversion principle)                              프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.            = 클라이언트 코드가 구현클래스말고 인터페이스만 보라는 의미                    쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻          앞에서 얘기한 역할(Role)에 의존하게 해야한다는 것과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게되면 변경이 아주 어려워진다.          그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만 구현클래스도 동시에 의존함                      MemberService 클라이언트가 구현클래스를 직접 선택함  MemberRepository m = new  MemoryMemberRepository();            ⇒ DIP 위반(구체화에도 의존중임)                                — 다형성만으로는 OCP, DIP를 지킬 수 없음  ⇒ 스프링 컨테이너 필요(이상적으로는 모든 설계에 인터페이스를 부여해야하나 추상화라는 비용이 발생함)    기능 확장 가능성이 없다면 구체 클래스를 직접 사용하고 향후 꼭 필요할 때 리팩터링해서 인터페이스 도입하는것도 하나의 방법    토비의 스프링 강의 듣고 한번 보는것을 추천  "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] jpql",
    "url": "/posts/jpql/",
    "categories": "Spring",
    "tags": "spring, jqpl, ORM, 국비교육",
    "date": "2022-12-16 00:00:00 +0900",
    





    
    "snippet": "  sql문 지정방법 - @Query 어노테이션 사용(오타가 하나라도 있으면 리포지토리가 생성이 안됨)package com.nunnunnu.jpql.entity;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;imp...",
    "content": "  sql문 지정방법 - @Query 어노테이션 사용(오타가 하나라도 있으면 리포지토리가 생성이 안됨)package com.nunnunnu.jpql.entity;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity@Table(name=\"category_info\") //이렇게해야 @Query에서 클래스 이름으로 쿼리문 사용가능public class CategoryEntity {    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name=\"ci_seq\")  private Long ciSeq;    @Column(name=\"ci_name\") private String ciName;    }package com.nunnunnu.jpql.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;import com.nunnunnu.jpql.entity.CategoryEntity;@Repositorypublic interface CategoryRepository extends JpaRepository&lt;CategoryEntity, Long&gt; {    @Query(value = \"SELECT c.ciSeq FROM CategoryEntity c WHERE c.ciName LIKE %:key%\")    List&lt;Long&gt; selectCategoryByKeyword(@Param(\"key\") String keyword);        @Query(value = \"SELECT c from CategoryEntity c where c.ciName like %:key%\")    public List&lt;CategoryEntity&gt; selectCategoryNameLikeKeyword(@Param(\"key\") String keyword);}      화이트 리스트 설정(프론트와 작업시 필요) - 아래 코드는 프론트만 허용하는 것이아니라 모두를 허용하겠다는 것이라 실제로는 이렇게하면안됨        cors 해결      package com.green.flo.config;      import org.springframework.context.annotation.Configuration;  import org.springframework.web.servlet.config.annotation.CorsRegistry;  import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;      @Configuration  public class WebConfig implements WebMvcConfigurer {       @Override       public void addCorsMappings(CorsRegistry registry){            registry.addMapping(\"/**\") //모든 매핑 경로에 대해(특정 메핑만 허용이면 /api/* 이런식으로 적어주면됨)            .allowedOrigins(\"*\") //모든 사용자에 대해 (특정아이피만 허용이면 여기 아이피넣으면됨)            .allowedMethods(\"*\"); //GET, POST, PUT, DELETE, PATCH, OPTION 모든 메소드를 허용함.       }  }      "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] JPA2",
    "url": "/posts/green_jpa2/",
    "categories": "JPA",
    "tags": "jpa, 국비교육, spring, ORM",
    "date": "2022-12-13 00:00:00 +0900",
    





    
    "snippet": "— API명세서 작성  회원 정보 조회시 비밀번호 빼고 조회하는 법package com.green.jpa_test.member.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Generate...",
    "content": "— API명세서 작성  회원 정보 조회시 비밀번호 빼고 조회하는 법package com.green.jpa_test.member.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import com.fasterxml.jackson.annotation.JsonIgnore;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.annotation.JsonProperty;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity(name = \"member_info\")@JsonIgnoreProperties(    value = {\"pwd\"}, allowSetters = true, allowGetters = false //setter는 권한허용, getter는 권한비허용.     //불러올때는 비번안나온다는소리)public class MemberInfoVO {    //jpa가 _는 제대로 인식을 못함    //mi_seq;mi_id;mi_pwd;mi_name;mi_nickname;mi_reg_dt;mi_status    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) //MYSQL의 AUTO_INCREMENT    @Column(name=\"mi_seq\") //기본키의 이름이 mi_seq임    private Long seq;         @Column(name=\"mi_id\")    private String id;    // @JsonIgnore //json형식으로 내보낼때 빠져서 나오나 입력할때도 빼고입력해야해서 적절하지않음    @JsonProperty(\"pwd\")    @Column(name=\"mi_pwd\")    private String pwd;    @Column(name=\"mi_name\")    private String name;    @Column(name=\"mi_nickname\")    private String nickname;    @Column(name=\"mi_reg_dt\")    private Date regDt;    @Column(name=\"mi_status\")    private Integer status;}      제품등록      package com.green.jpa_test.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name=\"product_info\")  public class ProductInfoVo {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"pi_seq\")      private Integer seq;          @Column(name=\"pi_name\")      private String name;      @Column(name=\"pi_price\")      private Integer price;      @Column(name=\"pi_discount\")      private Double discount;      @Column(name=\"pi_reg_dt\")      private Date regDt;      @Column(name=\"pi_status\")      private Integer stauts;      @Column(name=\"pi_stock\")      private Integer stock;  }          package com.green.jpa_test.repository;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.green.jpa_test.entity.ProductInfoVo;      @Repository  public interface ProductRepository extends JpaRepository&lt;ProductInfoVo, Long&gt; {      // public Long countByName(String name);  }          @Test  \t@Transactional  \tpublic void productAdd(){  \t\tProductInfoVo p = new ProductInfoVo();  \t\tp.setName(\"제품명\");  \t\tp.setPrice(15000);  \t\tp.setDiscount(0.0);  \t\tp.setRegDt(new Date());  \t\tp.setStauts(1);  \t\tp.setStock(100);  \t\tprodRepo.save(p);  \t}  \t// @Test  \t// public void nameDupChkTest(){  \t// \tLong cnt = prodRepo.countByName(\"제품명\");  \t// \tassertEquals(cnt, 1);  \t// } //제품이름은 동일할수도있음          package com.green.jpa_test.api;      import java.util.LinkedHashMap;  import java.util.Map;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.http.ResponseEntity;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PutMapping;  import org.springframework.web.bind.annotation.RequestBody;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RestController;      import com.green.jpa_test.entity.ProductInfoVo;  import com.green.jpa_test.repository.ProductRepository;      @RestController  @RequestMapping(\"/api/product\")  public class ProductAPICountroller {          @Autowired ProductRepository prodRepo;          @PutMapping(\"/\")      public ResponseEntity&lt;Object&gt; addProduct(@RequestBody ProductInfoVo data){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          // if(prodRepo.countByName(data.getName())==1){          //     map.put(\"status\", false);          //     map.put(\"message\", data.getName()+\"가 이미 등록되었습니다.\");          //     return new ResponseEntity&lt;&gt;(map, HttpStatus.NOT_ACCEPTABLE);          // }          prodRepo.save(data);          map.put(\"status\", true);          map.put(\"message\", \"제품이 등록되었습니다.\");          return new ResponseEntity&lt;&gt;(map, HttpStatus.OK);      }  }        ]]        페이지기능      package com.green.jpa_test.repository;      import java.util.List;      import org.springframework.data.domain.Page;  import org.springframework.data.domain.Pageable;  import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.green.jpa_test.entity.ProductInfoVo;      @Repository  public interface ProductRepository extends JpaRepository&lt;ProductInfoVo, Long&gt; {      // public Long countByName(String name);      // public List&lt;ProductInfoVo&gt; findAll(); //DB안의 데이터 모두 조회 가능      public Page&lt;ProductInfoVo&gt; findAll(Pageable pageable);  }          @GetMapping(\"/list\")      public ResponseEntity&lt;Object&gt; getProductList(Pageable pageable){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();                      map.put(\"list\", prodRepo.findAll(pageable));              return new ResponseEntity&lt;&gt;(map, HttpStatus.OK);      }            http://localhost:8999/api/product/list?page=0&amp;size=10&amp;sort=seq,desc    1페이지 10개, 최신등록순 정렬        로그인      package com.green.jpa_test.member.vo;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  public class LoginVO {      private String id;      private String pwd;  }          package com.green.jpa_test.member.repository;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.green.jpa_test.member.entity.MemberInfoVO;      @Repository  public interface MemberRepository extends JpaRepository&lt;MemberInfoVO, Long&gt; { //repository의 기본키 값이 Long이라 Long을 넣음      // MemberInfoVO findById(String id);      public Long countById(String id); //select count(*) from member_info where mi_id = \"\"; 자동생성해줌.       //이미 만들어진것은 커스텀하기까다로움      public MemberInfoVO findByIdAndPwd(String id, String pwd); //0아니면 1로 값이 나옴.      //member_info db의 id, pwd를 조회함. findByMi_IdAndMi_Pwd를 spring이 인식하기 못하기때문에 MemberInfo에서 이름지정을 해줌  }          @PostMapping(\"/login\")      public ResponseEntity&lt;Object&gt; userLogin(@RequestBody LoginVO data){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          MemberInfoVO loginUser = repo.findByIdAndPwd(data.getId(),data.getPwd());          if(loginUser ==null){              map.put(\"status\", false);              map.put(\"message\", \"아이디 또는 비밀번호 오류입니다.\");              return new ResponseEntity&lt;&gt;(map, HttpStatus.UNAUTHORIZED);          }          map.put(\"status\", true);          map.put(\"message\", \"로그인 되었습니다.\");          return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);      }          package com.green.jpa_test.member.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import com.fasterxml.jackson.annotation.JsonIgnore;  import com.fasterxml.jackson.annotation.JsonIgnoreProperties;  import com.fasterxml.jackson.annotation.JsonProperty;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name = \"member_info\")  @JsonIgnoreProperties(      value = {\"pwd\"}, allowSetters = true, allowGetters = false //setter는 권한허용, getter는 권한비허용.       //불러올때는 비번안나온다는소리  )  public class MemberInfoVO {      //jpa가 _는 제대로 인식을 못함      //mi_seq;mi_id;mi_pwd;mi_name;mi_nickname;mi_reg_dt;mi_status      @Id @GeneratedValue(strategy=GenerationType.IDENTITY) //MYSQL의 AUTO_INCREMENT      @Column(name=\"mi_seq\") //기본키의 이름이 mi_seq임      private Long seq;               @Column(name=\"mi_id\")      private String id;      // @JsonIgnore //json형식으로 내보낼때 빠져서 나오나 입력할때도 빼고입력해야해서 적절하지않음      @JsonProperty(\"pwd\")      @Column(name=\"mi_pwd\")      private String pwd;      @Column(name=\"mi_name\")      private String name;      @Column(name=\"mi_nickname\")      private String nickname;      @Column(name=\"mi_reg_dt\")      private Date regDt;      @Column(name=\"mi_status\")      private Integer status;  }            한개 조회      @GetMapping(\"/detail\")      public ResponseEntity&lt;Object&gt; getProductDetail(@RequestParam Integer prodNo){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          map.put(\"detail\", prodRepo.findBySeq(prodNo));          return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);      }          @Repository  public interface ProductRepository extends JpaRepository&lt;ProductInfoVo, Long&gt; {      // public Long countByName(String name);      // public List&lt;ProductInfoVo&gt; findAll(); //DB안의 데이터 모두 조회 가능      public Page&lt;ProductInfoVo&gt; findAll(Pageable pageable);      public ProductInfoVo findBySeq(Integer seq);  }            default 지정      \t\t@Column(name=\"pi_name\")      private String name;      @Column(name=\"pi_price\")      private Integer price=0;      @Column(name=\"pi_discount\")      private Double discount=0.0;      @Column(name=\"pi_reg_dt\")      private Date regDt= new Date();      @Column(name=\"pi_status\")      private Integer stauts=1;      @Column(name=\"pi_stock\")      private Integer stock=0;        가장 간단한 방법      package com.green.jpa_test.product.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import org.hibernate.annotations.DynamicInsert;  import org.hibernate.annotations.DynamicUpdate;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name=\"product_info\")  @DynamicInsert  @DynamicUpdate  public class ProductInfoVo {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"pi_seq\")      private Integer seq;          @Column(name=\"pi_name\")      private String name;      @Column(name=\"pi_price\")      private Integer price;//=0;      @Column(name=\"pi_discount\")      private Double discount;//=0.0;      @Column(name=\"pi_reg_dt\")      private Date regDt;//= new Date();      @Column(name=\"pi_status\")      private Integer stauts;//=1;      @Column(name=\"pi_stock\")      private Integer stock;//=0;  }        확실한 방법        제품 삭제      package com.green.jpa_test.product.repository;      import java.util.List;      import org.springframework.data.domain.Page;  import org.springframework.data.domain.Pageable;  import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.green.jpa_test.product.entity.ProductInfoVo;      @Repository  public interface ProductRepository extends JpaRepository&lt;ProductInfoVo, Long&gt; {      // public Long countByName(String name);      // public List&lt;ProductInfoVo&gt; findAll(); //DB안의 데이터 모두 조회 가능      public Page&lt;ProductInfoVo&gt; findAll(Pageable pageable);      public ProductInfoVo findBySeq(Integer seq);      public void deleteBySeq(Integer seq);  }          @DeleteMapping(\"\")      @Transactional  //sql실행시 오류가 발생한다면 실행이전으로 되돌림      public ResponseEntity&lt;Object&gt; deleteProduct(@RequestParam Integer prodNo){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          prodRepo.deleteBySeq(prodNo); //delete from product_info where pi_seq=\"\";          map.put(\"status\", true);          map.put(\"message\", \"제품 정보를 삭제했습니다.\");          return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);  \t  }            제품 수정      package com.green.jpa_test.product.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import org.hibernate.annotations.DynamicInsert;  import org.hibernate.annotations.DynamicUpdate;      import lombok.AllArgsConstructor;  import lombok.Builder;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name=\"product_info\")  @DynamicInsert  @DynamicUpdate  @Builder  public class ProductInfoVo {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"pi_seq\")      private Integer seq;          @Column(name=\"pi_name\")      private String name;      @Column(name=\"pi_price\")      private Integer price;//=0;      @Column(name=\"pi_discount\")      private Double discount;//=0.0;      @Column(name=\"pi_reg_dt\")      private Date regDt;//= new Date();      @Column(name=\"pi_status\")      private Integer stauts;//=1;      @Column(name=\"pi_stock\")      private Integer stock;//=0;  }        Builder 추가    save시 기본값이 없이 세팅되면 insert, 기본값이 있으면 update      @PatchMapping(\"/update/{type}\")      @Transactional  //sql실행시 오류가 발생한다면 실행이전으로 되돌림      public ResponseEntity&lt;Object&gt; updateProduct(          @RequestParam Integer prodNo,           @PathVariable String type,          @RequestParam String value          ){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          ProductInfoVo data = prodRepo.findBySeq(prodNo);          if(data==null){              map.put(\"status\", false);              map.put(\"message\", \"해당 제품이 존재하지 않습니다. 제품번호를 확인해주세요.\");              return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);          }          if(type.equals(\"name\")){               data.setName(value);          }else if(type.equals(\"price\")){              data.setPrice(Integer.parseInt(value));          }else if(type.equals(\"discount\")){              data.setDiscount(Double.parseDouble(value));          }else if(type.equals(\"regDt\")){              SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMddHHmmss\");              try{data.setRegDt(format.parse(value));}              catch(Exception e){e.printStackTrace();}                          }else if(type.equals(\"status\")){              data.setStauts(Integer.parseInt(value));                          }else if(type.equals(\"stock\")){              data.setStock(Integer.parseInt(value));                          }else{              map.put(\"status\", false);              map.put(\"message\", \"타입이 잘못되었습니다. {name, price, discount, regDt}\");              return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);          }          prodRepo.save(data);          map.put(\"status\", true);          map.put(\"message\", \"제품 정보를 수정했습니다.\");          return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);      }        http://localhost:8999/api/product/update/stock?prodNo=44&amp;value=100    주소예시  todolist— rest client 사용법파일 생성 후작성 후 send Request 또는 ctrl+alt+R 누르면이런식으로 뜸— 파일파일 저장 경로(꼭 이렇게해야하는건아니나 이걸 추천)application.properties에서 관리함.파일 경로 지정. 사용자 정의 설정값(여기 주석 #이라서 사진 그대로 쓰면 안됨;;. 주소치고 띄어쓰기해도 오류남.)  파일 업로드 메소드package com.jh_project.todo.todoList.file.api;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;import java.util.LinkedHashMap;import java.util.Map;import javax.servlet.http.HttpServletRequest;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.Resource;import org.springframework.core.io.UrlResource;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestPart;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;@RestControllerpublic class FileAPIController {    // 파일 업로드, 다운로드는 어느 프로젝프든 거의 동일함. 복붙추천    @Value(\"${file.image.todo}\") String todo_img_path; //springframework.beans임    @Value(\"${file.image.member}\") String member_img_path;     //이것도 DI임. 이미지 파일의 경로가 바뀌어도 application.properties만 고쳐주면 됨    @PutMapping(\"/{type}/upload\") //todo이미지를 올릴것인지 file이미지를 올릴것인지    public ResponseEntity&lt;Object&gt; putImageUpload(        @PathVariable String type,        @RequestPart MultipartFile file //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함        ){            Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();            System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력            //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스            Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.            if(type.equals(\"todo\")){                folderLocation = Paths.get(todo_img_path);                            }else if(type.equals(\"member\")){                folderLocation = Paths.get(member_img_path);            }else{                map.put(\"status\", false);                map.put(\"message\", \"타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload\");                return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);            }            Path targerFile = folderLocation.resolve(file.getOriginalFilename()); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성            try{                //Files는 파일 처리에 대한 유틸리티 클래스                //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비                //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.                Files.copy(file.getInputStream(), targerFile, StandardCopyOption.REPLACE_EXISTING);             }catch(Exception e){e.printStackTrace();}            return new ResponseEntity&lt;&gt;(map, HttpStatus.OK);        } //파일 업로드 메소드postman에서 key File로 만들고 file이라고 파라미터 적어주고(메소드의 파라미터 변수명과 동일하게 작성) value에 파일을 첨부 send하면 위에 지정해둔 폴더에 파일이 저장된걸 확인할 수 있음      파일 업로드 수정버전      @PutMapping(\"/{type}/upload\") //todo이미지를 올릴것인지 file이미지를 올릴것인지      public ResponseEntity&lt;Object&gt; putImageUpload(          @PathVariable String type,          @RequestPart MultipartFile file, //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함          @RequestParam Long seq           ){              Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();              System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력              //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스              Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.              if(type.equals(\"todo\")){                  folderLocation = Paths.get(todo_img_path);                                  }else if(type.equals(\"member\")){                  folderLocation = Paths.get(member_img_path);              }else{                  map.put(\"status\", false);                  map.put(\"message\", \"타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload\");                  return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);              }                  String originFileName = file.getOriginalFilename();              String[] split = originFileName.split((\"\\\\.\")); //.을 기준으로 나눔              String ext = split[split.length-1]; //확장자              String fileName = null;              for(int i=0;i&lt;split.length-1;i++){                  fileName += split[i]; //원래 split[i]+\".\" 이렇게 해줘야함              }              String saveFileName = type+\"_\"; //보통 원본 이름을 저장하는것이아니라 시간대를 입력함              Calendar c = Calendar.getInstance();              saveFileName+=c.getTimeInMillis()+\".\"+ext; // todo_161310135.png 이런식으로 저장됨                      Path targerFile = folderLocation.resolve(saveFileName); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성              try{                  //Files는 파일 처리에 대한 유틸리티 클래스                  //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비                  //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.                  Files.copy(file.getInputStream(), targerFile, StandardCopyOption.REPLACE_EXISTING);               }catch(Exception e){e.printStackTrace();}              return new ResponseEntity&lt;&gt;(map, HttpStatus.OK);          } //파일 업로드 메소드           파일이름 member_1671076931157으로 저장됨        url접속시 파일다운 메소드  @GetMapping(\"/image/{filename}\")        public ResponseEntity&lt;Resource&gt; putImageUpload( //core.io.Resource import해야함        @PathVariable String filename, HttpServletRequest request        ){            //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스            Path folderLocation = Paths.get(todo_img_path); //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.            Path targerFile = folderLocation.resolve(filename); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성            //다운로드 가능한 형태로 변환하기 위해 Resource객체 생성함            Resource r = null;             try{                //일반파일 -&gt; Url로 첨부 가능한 형태로 변환                r = new UrlResource(targerFile.toUri());            }catch(Exception e){e.printStackTrace();} //fileNotFoundException이 많이 나옴            //첨부된 파일의 타입을 저장하기 위한 변수 생성            String contentType = null;            try{                //첨부할 파일의 타입정보 산출                contentType =  request.getServletContext().getMimeType(r.getFile().getAbsolutePath());                 if(contentType == null){ //산출한 파일의 타입이 null이면                     //일반 파일로 처리                    contentType = \"application/octet-stream\"; //파일종류에따라서 동작이 다름. 만약 contentType이 안들어오면 그냥 다운로드함.                }            }catch(Exception e){e.printStackTrace();}            return ResponseEntity.ok() // 200 OK가 나옴                .contentType(MediaType.parseMediaType(contentType)) //산출한 타입을 응답에 맞는 형태로 변환                //내보낼 내용의 타입을 설정(파일),                 // attachment; filename*=\\\"\"+r.getFilename()+\"\\\" - 요청한 쪽에서 다운로드한 파일의 이름을 결정(원본 파일 이름 그대로 결정)                .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename*=\\\"\"+r.getFilename()+\"\\\"\")                .body(r); //변환된 파일을 ResponseEntity에 추가        }http://localhost:9988/image/Fj8pPNYaAAAoWja.jpg 아래 주소로 가면 파일 다운됨. 파일이름을 확장자까지 정확하게 써줘야함.      멤버      package com.jh_project.todo.member.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import com.fasterxml.jackson.annotation.JsonIgnoreProperties;  import com.fasterxml.jackson.annotation.JsonProperty;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name = \"member_info\")  @JsonIgnoreProperties(      value = {\"pwd\"}, allowGetters = false, allowSetters = true  )  public class MemberInfoEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"mi_seq\")    private Long seq;          @Column(name=\"mi_email\")  private String email;      @JsonProperty(\"pwd\")      @Column(name=\"mi_pwd\")    private String pwd;      @Column(name=\"mi_name\")   private String name;      @Column(name=\"mi_birth\")  private Date birth;      @Column(name=\"mi_reg_dt\") private Date regDt;  }          package com.jh_project.todo.member.repository;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.jh_project.todo.member.entity.MemberInfoEntity;  @Repository  public interface memberRepository extends JpaRepository&lt;MemberInfoEntity, Long&gt; {      public Integer countByEmail(String email);      public MemberInfoEntity findByEmailAndPwd(String email, String pwd);          }          package com.jh_project.todo.member.data;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  public class LoginVO {      private String email;      private String pwd;      }          package com.jh_project.todo.member.service;      import java.util.LinkedHashMap;  import java.util.Map;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.stereotype.Service;      import com.jh_project.todo.member.data.LoginVO;  import com.jh_project.todo.member.entity.MemberInfoEntity;  import com.jh_project.todo.member.repository.memberRepository;  import com.jh_project.todo.utils.AESAlgorith;      @Service  public class MemberService {      @Autowired memberRepository m_repo;              public Map&lt;String, Object&gt; addMember(MemberInfoEntity data){          Map&lt;String, Object&gt; resultMap = new LinkedHashMap&lt;String, Object&gt;();          if(m_repo.countByEmail(data.getEmail())==1){              resultMap.put(\"status\", false);              resultMap.put(\"message\", data.getEmail()+\"은/는 이미 가입된 이메일입니다.\");              resultMap.put(\"code\", HttpStatus.BAD_REQUEST);          }else{              try{                  String encPwd = AESAlgorith.Encrypt(data.getPwd());                  data.setPwd(encPwd);              }catch(Exception e){e.printStackTrace();}                  resultMap.put(\"status\", true);              resultMap.put(\"message\", \"회원이 등록되었습니다.\");              resultMap.put(\"code\", HttpStatus.CREATED);              m_repo.save(data);          }          return resultMap;      }      public Map&lt;String, Object&gt; loginMember(LoginVO data){          Map&lt;String, Object&gt; resultMap = new LinkedHashMap&lt;String, Object&gt;();          MemberInfoEntity loginUser = null;          try{              loginUser = m_repo.findByEmailAndPwd(data.getEmail(), AESAlgorith.Encrypt(data.getPwd()));          }catch(Exception e){e.printStackTrace();}          if(loginUser==null){              resultMap.put(\"status\", false);              resultMap.put(\"message\", \"로그인 실패. 이메일 또는 비밀번호를 확인해주세요.\");              resultMap.put(\"code\", HttpStatus.BAD_REQUEST);          }else{              resultMap.put(\"status\", true);              resultMap.put(\"message\", \"로그인 성공\");              resultMap.put(\"code\", HttpStatus.ACCEPTED);              resultMap.put(\"loginUser\", loginUser);          }          return resultMap;      }  }          package com.jh_project.todo.member.api;      import java.util.Map;      import javax.servlet.http.HttpSession;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.http.ResponseEntity;  import org.springframework.web.bind.annotation.PostMapping;  import org.springframework.web.bind.annotation.PutMapping;  import org.springframework.web.bind.annotation.RequestBody;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RestController;      import com.jh_project.todo.member.data.LoginVO;  import com.jh_project.todo.member.entity.MemberInfoEntity;  import com.jh_project.todo.member.service.MemberService;      @RestController  @RequestMapping(\"/api/member\")  public class MemberAPIController {      @Autowired MemberService mService;      @PutMapping(\"/join\")      public ResponseEntity&lt;Object&gt; memberJoin(@RequestBody MemberInfoEntity data){          Map&lt;String, Object&gt; resultMap = mService.addMember(data);          return new ResponseEntity&lt;Object&gt;(resultMap, (HttpStatus)resultMap.get(\"code\"));      }      @PostMapping(\"/login\")      public ResponseEntity&lt;Object&gt; memberLogin(@RequestBody LoginVO data, HttpSession session){          Map&lt;String, Object&gt; resultMap = mService.loginMember(data);          session.setAttribute(\"loginUser\", resultMap.get(\"loginUser\"));           //실패하면 null이라 로그인 안됨.session의 값이 채워지면 로그인상태임. 모든 코드에서 사용가능(Html도 마찬가지임)          //프론트에서는 사용못함!!          return new ResponseEntity&lt;&gt;(resultMap, (HttpStatus)resultMap.get(\"code\"));      }  }            투두      package com.jh_project.todo.todoList.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data@AllArgsConstructor@NoArgsConstructor  @Entity(name = \"todo_info\")  public class TodoInfoEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name = \"ti_seq\") private Long seq;      @Column(name = \"ti_mi_seq\") private Long miSeq;      @Column(name = \"ti_content\") private String content;      @Column(name = \"ti_status\") private Integer status;      @Column(name = \"ti_start_dt\") private Date startDt;      @Column(name = \"ti_end_dt\") private Date endDt;              }          package com.jh_project.todo.todoList.repository;      import java.util.Date;  import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.jh_project.todo.todoList.entity.TodoInfoEntity;  @Repository  public interface TodoRepository extends JpaRepository&lt;TodoInfoEntity, Long&gt; {      public List&lt;TodoInfoEntity&gt; findAllByMiSeq(Long miSeq);      public TodoInfoEntity findBySeq(Long seq);      public void deleteBySeqAndMiSeq(Long seq, Long miSeq);      public TodoInfoEntity findBySeqAndMiSeq(Long seq, Long miSeq);      //select * from todo_info where ti_end_dt between [start] and [end] and ti_mi_seq=[miSeq]      public List&lt;TodoInfoEntity&gt; findByEndDtBetweenAndMiSeq(Date start, Date end, Long miSeq);  }          package com.jh_project.todo.todoList.service;      import java.text.SimpleDateFormat;  import java.util.Date;  import java.util.LinkedHashMap;  import java.util.List;  import java.util.Map;      import javax.servlet.http.HttpSession;  import javax.transaction.Transactional;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.stereotype.Service;      import com.jh_project.todo.member.entity.MemberInfoEntity;  import com.jh_project.todo.todoList.entity.TodoInfoEntity;  import com.jh_project.todo.todoList.repository.TodoRepository;      @Service  public class TodoInfoService {      @Autowired TodoRepository t_repo;          public Map&lt;String, Object&gt; addTodoList(TodoInfoEntity data, HttpSession session){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute(\"loginUser\");          if(loginUser==null){              map.put(\"status\", false);              map.put(\"message\", \"로그인이 필요합니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              data.setMiSeq(loginUser.getSeq());              t_repo.save(data);              map.put(\"status\", true);              map.put(\"message\", \"일정이 추가되었습니다.\");              map.put(\"code\", HttpStatus.CREATED);          }          return map;      }      public Map&lt;String, Object&gt; getTodoList(HttpSession session){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute(\"loginUser\");          if(loginUser==null){              map.put(\"status\", false);              map.put(\"message\", \"로그인이 필요합니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              map.put(\"list\", t_repo.findAllByMiSeq(loginUser.getSeq()));              map.put(\"status\", true);              map.put(\"message\", \"조회하였습니다.\");              map.put(\"code\", HttpStatus.OK);                          }          return map;      }      public Map&lt;String, Object&gt; updateTodoStatus(Integer status, Long seq){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          TodoInfoEntity todo = t_repo.findBySeq(seq);          if(todo==null){              map.put(\"status\", false);              map.put(\"message\", \"잘못된 todo번호입니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              todo.setStatus(status);              t_repo.save(todo);              map.put(\"status\", true);              map.put(\"message\", \"todo 상태가 변경되었습니다.\");              map.put(\"code\", HttpStatus.OK);          }                      return map;      }      public Map&lt;String, Object&gt; updateTodoContent(String content, Long seq){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          TodoInfoEntity todo = t_repo.findBySeq(seq);          if(todo==null){              map.put(\"status\", false);              map.put(\"message\", \"잘못된 todo번호입니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              todo.setContent(content);              t_repo.save(todo);              map.put(\"status\", true);              map.put(\"message\", \"todo 상태가 변경되었습니다.\");              map.put(\"code\", HttpStatus.OK);          }          return map;      }      @Transactional      public Map&lt;String, Object&gt; deleteTodo(Long seq, HttpSession session){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute(\"loginUser\");          if(loginUser==null){              map.put(\"status\", false);              map.put(\"message\", \"로그인 후 사용가능한 기능입니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);              return map;          }          TodoInfoEntity todo = t_repo.findBySeqAndMiSeq(seq, loginUser.getSeq());          if(todo==null){              map.put(\"status\", false);              map.put(\"message\", \"잘못된 Todo 번호입니다..\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              t_repo.deleteBySeqAndMiSeq(seq, loginUser.getSeq());              map.put(\"status\", true);              map.put(\"message\", \"todo가 삭제되었습니다.\");              map.put(\"code\", HttpStatus.OK);          }          return map;      }      public Map&lt;String, Object&gt; selectTodoListByTrem(HttpSession session, String start, String end){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute(\"loginUser\");          if(loginUser==null){              map.put(\"status\", false);              map.put(\"message\", \"로그인 후 사용가능한 기능입니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);              return map;          }          SimpleDateFormat format = new SimpleDateFormat(\"yyMMdd\");          Date startDt=null;          Date endDt=null;          try{              startDt = format.parse(start);              endDt = format.parse(end);          }catch(Exception e){              map.put(\"status\", false);              map.put(\"message\", \"날짜 형식을 확인해주세요(yyMMdd ex:221214)\");              map.put(\"code\", HttpStatus.BAD_REQUEST);              return map;                          }          List&lt;TodoInfoEntity&gt; list = t_repo.findByEndDtBetweenAndMiSeq(startDt, endDt, loginUser.getSeq());          if(list.size()==0){              map.put(\"status\", false);              map.put(\"message\", \"일치하는 Todo가 없습니다. 날짜를 확인해주세요\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              map.put(\"list\", list);              map.put(\"status\", true);              map.put(\"message\", \"조회완료되었습니다.\");              map.put(\"code\", HttpStatus.OK);          }          return map;      }  }          package com.jh_project.todo.todoList.api;      import java.text.SimpleDateFormat;  import java.util.LinkedHashMap;  import java.util.Map;      import javax.servlet.http.HttpSession;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.http.ResponseEntity;  import org.springframework.web.bind.annotation.DeleteMapping;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PatchMapping;  import org.springframework.web.bind.annotation.PathVariable;  import org.springframework.web.bind.annotation.PutMapping;  import org.springframework.web.bind.annotation.RequestBody;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RequestParam;  import org.springframework.web.bind.annotation.RestController;      import com.jh_project.todo.todoList.entity.TodoInfoEntity;  import com.jh_project.todo.todoList.service.TodoInfoService;      import net.bytebuddy.agent.builder.AgentBuilder.FallbackStrategy.Simple;      @RestController  @RequestMapping(\"/api/todo\")  public class TodoAPIController {      @Autowired TodoInfoService tService;      @PutMapping(\"/add\")      public ResponseEntity&lt;Object&gt; addTodo(@RequestBody TodoInfoEntity data, HttpSession session){          Map&lt;String, Object&gt; map = tService.addTodoList(data, session);                      return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      }      @GetMapping(\"/list\")      public ResponseEntity&lt;Object&gt; getTodoList(HttpSession session){          Map&lt;String, Object&gt; map = tService.getTodoList(session);          return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      }      @PatchMapping(\"/update/{type}\")      public ResponseEntity&lt;Object&gt; updateTodo(          @RequestParam Long seq,          @PathVariable String type,          @RequestParam String value      ){          if(type.equals(\"status\")){              Map&lt;String, Object&gt; map = tService.updateTodoStatus(Integer.parseInt(value), seq);              return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));          }else if(type.equals(\"content\")){              Map&lt;String, Object&gt; map = tService.updateTodoContent(value, seq);              return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));          }else{              Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();              map.put(\"stauts\", false);              map.put(\"message\", \"type은 status, content 둘 중 한가지만 가능합니다\");              return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);                          }      }      // @DeleteMapping(\"/delete\")      // @Transactional      // public ResponseEntity&lt;Object&gt; deleteTodo(@RequestParam Long seq, @RequestParam Long miSeq){      //     Map&lt;String, Object&gt; map = tService.deleteTodo(seq, miSeq);      //     return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      // }      @DeleteMapping(\"/delete\")      public ResponseEntity&lt;Object&gt; deleteTodo(@RequestParam Long seq, HttpSession session){          Map&lt;String, Object&gt; map = tService.deleteTodo(seq, session);          return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      }      @GetMapping(\"/list/term\")      public ResponseEntity&lt;Object&gt; getDetailTodoList(HttpSession session, String start, String end){          Map&lt;String, Object&gt; map = tService.selectTodoListByTrem(session, start, end);          return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      }          }          ###제품 추가  PUT http://localhost:9988/api/member/join HTTP/1.1  content-type : application/json      {      \"email\" : \"user002@service.com\",      \"pwd\" : \"1234\",      \"name\" : \"사용자2\",      \"birth\" : \"2022-12-14T00:00:00\",      \"regDt\" : \"2022-12-14T00:00:00\"  }  ###로그인  POST http://localhost:9988/api/member/login HTTP/1.1  content-type : application/json      {      \"email\" : \"user001@service.com\",      \"pwd\" : \"1234\"  }      ##\\#Todo 등록  PUT http://localhost:9988/api/todo/add HTTP/1.1  content-type : application/json      {      \"content\" : \"Todo5\",      \"status\" : 1,      \"startDt\" : \"2022-12-30T00:00:00\",      \"endDt\" : \"2022-12-30T00:00:00\"  }  ###내 TodoList 조회  GET http://localhost:9988/api/todo/list HTTP/1.1      ##\\#Todo 내용 수정  PATCH  http://localhost:9988/api/todo/update/content?&amp;value=sssss&amp;seq=1 HTTP/1.1  ##\\#Todo 상태 변경  PATCH  http://localhost:9988/api/todo/update/status?&amp;value=2&amp;seq=1 HTTP/1.1  ##\\#Todo 삭제  DELETE http://localhost:9988/api/todo/delete?seq=3 HTTP/1.1  ##\\#Todo 날짜범위 조회  GET http://localhost:9988/api/todo/list/term?start=221226&amp;end=221230 HTTP/1.1    restClient 사용 링크        파일관리      package com.jh_project.todo.todoList.entity;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name = \"todo_images_info\")  public class TodoImageEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name = \"tii_seq\")       private Long seq;      @Column(name = \"tii_ti_seq\")    private Long tiSeq;      @Column(name = \"tii_file_name\") private String fileName;      @Column(name = \"tii_uri\")       private String uri;  }          package com.jh_project.todo.member.entity;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name = \"member_images_info\")  public class MemberImageEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name = \"mii_seq\")       private Long seq;      @Column(name = \"mii_mi_seq\")    private Long miSeq;      @Column(name = \"mii_file_name\") private String fileName;      @Column(name = \"mii_uri\")       private String uri;  }          package com.jh_project.todo.member.repository;      import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.jh_project.todo.member.entity.MemberImageEntity;      @Repository  public interface MemberImageRepository extends JpaRepository&lt;MemberImageEntity, Long&gt; {      public List&lt;MemberImageEntity&gt; findByMiSeq(Long miSeq);      //select * from todo_image_info where tii_uri = uri order by tii_seq desc limit 1;      //가장 나중에 입력된 이미지를 가져옴.      public List&lt;MemberImageEntity&gt; findTopByUriOrderBySeqDesc(String uri);          }          package com.jh_project.todo.todoList.repository;      import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.jh_project.todo.todoList.entity.TodoImageEntity;      @Repository  public interface TodoImageRepository extends JpaRepository&lt;TodoImageEntity, Long&gt; {      public List&lt;TodoImageEntity&gt; findByTiSeq(Long tiSeq);      //select * from todo_image_info where tii_uri = uri order by tii_seq desc limit 1;      //가장 나중에 입력된 이미지를 가져옴.      public List&lt;TodoImageEntity&gt; findTopByUriOrderBySeqDesc(String uri);  }          @Autowired TodoImageRepository tiRepo;          public Map&lt;String, Object&gt;  addTodoImage(TodoImageEntity data, Long tiSeq){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          data.setTiSeq(tiSeq);          tiRepo.save(data);          map.put(\"status\", true);          map.put(\"message\", \"이미지가 저장되었습니다.\");          map.put(\"code\", HttpStatus.OK);          return map;      }          @Autowired MemberImageRepository mi_repo;              public Map&lt;String, Object&gt;  addMemberImage(MemberImageEntity data, Long miSeq){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          data.setMiSeq(miSeq);          mi_repo.save(data);          map.put(\"status\", true);          map.put(\"message\", \"이미지가 저장되었습니다.\");          map.put(\"code\", HttpStatus.OK);          return map;      }      public String getFileNameByUri(String uri){          List&lt;MemberImageEntity&gt; data = mi_repo.findTopByUriOrderBySeqDesc(uri);          return data.get(0).getFileName();      }          package com.jh_project.todo.todoList.file.api;      import java.net.URLEncoder;  import java.nio.file.Files;  import java.nio.file.Path;  import java.nio.file.Paths;  import java.nio.file.StandardCopyOption;  import java.util.Calendar;  import java.util.LinkedHashMap;  import java.util.Map;      import javax.servlet.http.HttpServletRequest;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.beans.factory.annotation.Value;  import org.springframework.core.io.Resource;  import org.springframework.core.io.UrlResource;  import org.springframework.http.HttpHeaders;  import org.springframework.http.HttpStatus;  import org.springframework.http.MediaType;  import org.springframework.http.ResponseEntity;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PathVariable;  import org.springframework.web.bind.annotation.PutMapping;  import org.springframework.web.bind.annotation.RequestParam;  import org.springframework.web.bind.annotation.RequestPart;  import org.springframework.web.bind.annotation.RestController;  import org.springframework.web.multipart.MultipartFile;      import com.jh_project.todo.member.entity.MemberImageEntity;  import com.jh_project.todo.member.service.MemberService;  import com.jh_project.todo.todoList.entity.TodoImageEntity;  import com.jh_project.todo.todoList.service.TodoInfoService;      @RestController  public class FileAPIController {      // 파일 업로드, 다운로드는 어느 프로젝프든 거의 동일함. 복붙추천      @Value(\"${file.image.todo}\") String todo_img_path; //springframework.beans임      @Value(\"${file.image.member}\") String member_img_path;      //이것도 DI임. 이미지 파일의 경로가 바뀌어도 application.properties만 고쳐주면 됨      @Autowired TodoInfoService tService;      @Autowired MemberService mService;          @PutMapping(\"/{type}/upload\") //todo이미지를 올릴것인지 file이미지를 올릴것인지      public ResponseEntity &lt; Object &gt; putImageUpload(          @PathVariable String type,          @RequestPart MultipartFile file, //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함          @RequestParam Long seq      ) {          Map &lt; String, Object &gt; map = new LinkedHashMap &lt; &gt; ();          System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력          //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스          Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.          if (type.equals(\"todo\")) {              folderLocation = Paths.get(todo_img_path);              } else if (type.equals(\"member\")) {              folderLocation = Paths.get(member_img_path);          } else {              map.put(\"status\", false);              map.put(\"message\", \"타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload\");              return new ResponseEntity &lt; &gt; (map, HttpStatus.BAD_REQUEST);          }          String originFileName = file.getOriginalFilename();          String[] split = originFileName.split((\"\\\\.\")); //.을 기준으로 나눔          String ext = split[split.length - 1]; //확장자          String fileName = \"\";          for (int i = 0; i &lt; split.length - 1; i++) {              fileName += split[i]; //원래 split[i]+\".\" 이렇게 해줘야함          }          String saveFileName = type + \"_\"; //보통 원본 이름을 저장하는것이아니라 시간대를 입력함          Calendar c = Calendar.getInstance();          saveFileName += c.getTimeInMillis() + \".\" + ext; // todo_161310135.png 이런식으로 저장됨              Path targetFile = folderLocation.resolve(saveFileName); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성          try {              //Files는 파일 처리에 대한 유틸리티 클래스              //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비              //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.              Files.copy(file.getInputStream(), targetFile, StandardCopyOption.REPLACE_EXISTING);          } catch (Exception e) {              e.printStackTrace();          }          if (type.equals(\"todo\")) {              TodoImageEntity data = new TodoImageEntity();              data.setFileName(saveFileName);              data.setUri(fileName);              tService.addTodoImage(data, seq);          } else if (type.equals(\"member\")) {              MemberImageEntity data = new MemberImageEntity();              data.setFileName(saveFileName);              data.setUri(fileName);              mService.addMemberImage(data, seq);              }          return new ResponseEntity &lt; &gt; (map, HttpStatus.OK);      } //파일 업로드 메소드          @GetMapping(\"/images/{type}/{uri}\")      public ResponseEntity getImage(          @PathVariable String uri, HttpServletRequest request,          @PathVariable String type      ) throws Exception {          // todo_img_path 문자열로부터 실제 폴더 경로를 가져온다.           Path folderLocation = null;          if (type.equals(\"todo\")) {              folderLocation = Paths.get(todo_img_path);          } else if (type.equals(\"member\")) {              folderLocation = Paths.get(member_img_path);          }          String filename = null;          if (type.equals(\"todo\")) {              filename = tService.getFileNameByUri(uri);          } else if (type.equals(\"member\")) {              filename = mService.getFileNameByUri(uri);          }          String[] split = filename.split(\"\\\\.\");          String ext = split[split.length - 1];          String exportName = uri + \".\" + ext;          // 내보낼 파일의 이름을 만든다.           // 폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로를 만든다.           Path targetFile = folderLocation.resolve(filename);          // 다운로드 가능한 형태로 변환하기 위한 Resource 객체 생성           Resource r = null;          try {              // 일반파일 -&gt; Url로 첨부 가능한 형태로 변환               r = new UrlResource(targetFile.toUri());          } catch (Exception e) {              e.printStackTrace();          }          // 첨부된 파일의 타입을 저장하기위한 변수 생성           String contentType = null;          try {              // 첨부할 파일의 타입 정보 산출               contentType = request.getServletContext().getMimeType(r.getFile().getAbsolutePath());              // 산출한 파일의 타입이 null 이라면               if (contentType == null) {                  // 일반 파일로 처리한다.                   contentType = \"application/octet-stream\";              }          } catch (Exception e) {              e.printStackTrace();          }          return ResponseEntity.ok()              // 응답의 코드를 200 OK로 설정하고               // 산출한 타입을 응답에 맞는 형태로 변환               .contentType(MediaType.parseMediaType(contentType))              // 내보낼 내용의 타입을 설정 (파일),               // attachment; filename*=\\\"\"+r.getFilename()+\"\\\" 요청한 쪽에서 다운로드 한               // 파일의 이름을 결정               .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"\" + URLEncoder.encode(exportName, \"UTF-8\") + \"\\\"\")              .body(r);          // 변환된 파일을 ResponseEntity에 추가 }                  }  }      "
  },
  
  {
    "title": "[권오흠 영리한 프로그래밍을 위한 알고리즘 강좌] 트리와 이진트리",
    "url": "/posts/%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/",
    "categories": "알고리즘",
    "tags": "알고리즘, 권오흠알고리즘강좌",
    "date": "2022-12-13 00:00:00 +0900",
    





    
    "snippet": "링크(Link) : 노드와 노드를 연결하는 선트리는 노드들과 노드들을 연결하는 링크들로 구성— 노드의 개수가 n개면 링크의 개수는 n-1개임리프(leaf) 노드 : 자식이 없는 노드내부(internal) 노드 : 리프노드가 아닌 도부트리(subtree) : 트리의 일부분만 잘라서 보아도 트리구조임.— 트리에서 어떤 노드로 가는 경로는 유일하다, 또한 ...",
    "content": "링크(Link) : 노드와 노드를 연결하는 선트리는 노드들과 노드들을 연결하는 링크들로 구성— 노드의 개수가 n개면 링크의 개수는 n-1개임리프(leaf) 노드 : 자식이 없는 노드내부(internal) 노드 : 리프노드가 아닌 도부트리(subtree) : 트리의 일부분만 잘라서 보아도 트리구조임.— 트리에서 어떤 노드로 가는 경로는 유일하다, 또한 임의의 두 노드간의 경로도 유일하다(같은 노드를 두번 방문하지 않는 조건)이진 트리(binary tree) : 각 노드가 최대 2개의 자식을 가짐. 각각의 자식노드는 자신이 부모의 왼쪽자식인지 오른쪽 자식인지 지정됨.(자식이 하나여도 동일)  Expression Tree      Huffman code    파일압축 관련 알고리즘. 각각의 알파벳을 링크에 적힌 숫자를 이어 표현함?        Full Binary Trees : 모든 자식이 차있는 상태의 이진트리. 높이가 h라면 2의h제곱-1개의 노드를 가짐(O(logN))  Complete Binary Tree : 맨 오른쪽 자식노드가 비어있는 상태의 이진트리.(O(logN))      이진트리의 표현          연결구조(Linked Structure) : 각 노드가 다음노드의 주소를 가지고 있음. 각 노드의 하나의 데이터 필드와 왼쪽자식, 오른쪽 자식 그리고 부모노드의 주소를 저장함.(부모노드의 주소는 반드시 필요한경우가 아니면 생략)                                    ![[IMG-20240910163800.png          IMG-20240910163800.png]]                          이진트리의 순회(traversal)                  순회 : 이진 트리의 모든 노드 방문                            중순위(inorder) 순회                  TL을 먼저 inorder로 순회          r을 순회          TR을 inorder로 순회                → recursion, 시간복잡도 O(n)                    선순위(preorder) 순회                  r을 먼저 순회          TL을 순회          TR을 순회                    후순위(postorder) 순회                  TL순회          TR순회          r순회                      — 연산식을 만들때 각 부트리를 순회할때마다 괄호를 추가하면 올바른 수식이 만들어          레벨오더(level-order) 순 : 레벨 순(오름차순, 높은곳부터)으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서. queue를 이용해 표현      Dynamic Set내용물이 변환될수있는 집합  여러개의 key를 저장  다음과 같은 연산들을 지원하는 자료구조(정렬되거나 안된 배열 혹은 연결리스트 사용시 insert, search, delete 중 적어도 하나는 O(n))          INSERT      SEARCH      DELETE        이진 탐색 트리(Binary Search Tree), 레드-블랙 트리, AVL-트리 등의 트리에 기반한 구조들  Direct Address Table, 해쉬 테이블  검색 트리          Dynamic set을 트리형태로 구현      일반적으로 search, insert, delete 연산이 트리의 높이(height)에 비례하는 시간복잡도를 가짐              이진검색트리(BST : Binary Search Tree)                  이진트리          각 노드에 하나의 키를 저장          각 노드 v에 대해 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같음                        binary tree면 트리의 모양은 상관없음. heap과 혼동하지말것.                  search                        시간복잡도 - O(h[트리높이])                  최소값 - 가장 왼쪽에 위치한 값(자식이 없어야함, 오른쪽 subtree에 있으면안됨.) = 노드의 왼쪽자식이 존재하지 않을때까지 따라내려가면          최대값 - 가장 오른쪽에 위치한                      Successor : 노드 x의 successor란 key[x]보다 크면서 가장 작은 키를 가진 노드(모든 키가 서로 다르다고 가정)                        노드 x의 오른쪽 부트리가 존재할경우, 오른쪽 부트리의 최소값,  오른쪽 부트리가 없을경우 첫 왼쪽 링크를 탄다면 만나는 노드가 successor임.(만약 없다면 successor가 없는거임. 위 그림에선 20)                                predecessor : successor의 반대                    Insert : 새로운 노드 추가. 기존 노드보다 작다면 왼쪽, 크다면 오른쪽에 위치하면됨. 기존 노드의 위치는 바뀌지 않음.          delete(search필요)                          삭제할 노드의 자식노드가 없는 경우 - 그냥 삭제                              삭제할 노드의 자식이 하나인 경우                                삭제할 노드만 떼서보면 부모-노드-자식의 관계는 연결리스트와 같음. 유일한 자식을 삭제한 자리로 붙여버리면 됨.                                            삭제할 노드의 자식이 둘인 경우                                구조를 바꾸는것이아니라 13의 데이터만 삭제하고 13의 successor인 15(왼쪽자식이 없음이 보장되어있는상태임. 오른쪽 부트리의 가장 작은값이기때문)의 데이터를 13자리에 넣음. successor의 자식이 있다면 15자리에 대신 넣어주면 됨.                                                                레드-블랙 트리                          이진 탐색트리의 일종          높이가 O(log2n)도록 유지, 최악의 경우에도 O(log2n)시간에 지원          각 노드는 하나의 키, 왼쪽 자식, 오른쪽 자식, 부모노드의 주소를 저장함.                      자식노드가 존재하지 않을경우 NIL 노드(위 그림에서 네모)라고 부르는 특수노드가 있다고 가정함.  = 모든 리프노드는 NIL노드. 루트의 부모도 NIL노드. 노드는 내부노드와 NIL노드로 분류됨                    정의                          각 노드는 red(연속해서 등장하지 않음) 또는 black(루트노드, 리프노트[NIL노드], red노드의 자식, )임              모든 노드에 대해 그 노드로부터 자손인 리프노드에 이르는 모든 경로에는 동일한 개수의 black노드가 있음                                특징                          노드 x의 높이 h(x)는 자신으로부터 리프노드까지의 가장 긴 경로에 포함된 에지의 개수                              노드 x의 블랙 - 높이 bh(x)는 x으로부터 리프노드까지의 경로상의 블랙노드의 개수(노드x 자신은 불포함)                                                                          left and right rotation                        베타는 x보다는 크고 y보다는 작음. 감마는 y보다 큼. left rotation을 하든 right rotation을 하든 규칙은 변경되지않음                                search                          보통의 bst에서처럼 노드를 insert              새로운 노드 z를 red노드로 함              RB-INSERT-FIXUP(만약 z의 부모노드가 red라면 조건 위반. 수정필요) 호출                                                      z가 루트 노드이면서 red인 경우                    ⇒ z를 black으로 바꿔주고 종료                                                        z와 그의 부모가 둘다 red인 경우                    ⇒ 부모노드가 black이 되면 종료.                                          z의 삼촌이 red인 경우 : 부모노드가 black이 되면 조상도 red가 되어야함. = 부모와 조상의 색을 바꿔줌)                                                              z의 삼촌이 black인 경우                                                  z가 오른쪽 자식인경우 : z에 대해 left-rotation(3경우로 변경) 후 부모 노드를 z로 변경시킨 후 b경우의 해결법 실행                          z가 왼쪽 자식인 경우 : 부모를 black으로, 부모의 부모를 red로 변경. 부모의 부모에 대해 right-rotation → 부모가 맨 위로, 할아버지가 오른쪽 자식으로 변경됨                                                                                                                                                                      delete : 보통의 BST에서처럼 delete함. 실제로 삭제된 노드가 red였으면 종료. black이었을경우 RB-DELETE-FIXUP 호출  x-삭제할 노드, y - 실제로 삭제된 노드(x or x의 successor)                          RB-DELETE-FIXUP                                  y가 루트였고 x가 red인 경우                  p[y]와 x가 모두 red인 경우                                      원래 y를 포함했던 모든 경로는 이제 black노드 하나가 부족                                          노드 x에 “extra black”을 부여해서 일단 조건 5 만족[근본적으로 문제가 해결된 것은 아님]                      노드 x는 “double black”혹은 “red &amp; black”                                        → extra black을 트리 위쪽으로 올려보냄. x가 red&amp;black상태가 되면 그냥 black노드로 만들고 종료, x가 루트가 되면(모두 black이었을 경우) 그냥 extra black을 제거  x는 루트가 아닌 double-black노드이고 w는 x의 형제노드. w는 NIL노드가 될수없음                                          w가 red인경우                                                  w의 자식들은 black. w를 black으로, x의 부모를 red로.                          x의 부모에 대해 lefy-rotation 적용                          x의 새로운 형제노드는 원래 w의 자식노드, 따라서 black노드임                                                                    w는 black, w의 자식들도 black일 경우                                                  x의 extra-black을 뺏고, w를 red로 바꿈                          x의 부모에게 뺏은 extra-black을 주고 x의 부모를 새로운 x로 지정.                          만약 경우 1에서 이 경우에 도달했다면 x의 부모는 red였고, 따라서 새로운 x는 red&amp;black이 되어 종료됨.                                                                    w는 black, w의 왼쪽자식이 red                                                  w를 red로, w의 왼자식을 black으로                          w에 대해서 right-rotation 적용                          x의 새로운 형제 w는 오른자식이 red(경우 4 해당)                                                                    w는 black, w의 오른자식이 red                                                  w의 색을 현재                                                                                                                                                            B-트리      "
  },
  
  {
    "title": "[김영한 스프링 입문] AOP",
    "url": "/posts/AOP/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링입문, AOP",
    "date": "2022-12-12 00:00:00 +0900",
    





    
    "snippet": "public Long join(Member member) {\t long start = System.currentTimeMillis();\t try {\t\t validateDuplicateMember(member); //중복 회원 검증\t\t memberRepository.save(member);\t\t return member.getId();\t } finally...",
    "content": "public Long join(Member member) {\t long start = System.currentTimeMillis();\t try {\t\t validateDuplicateMember(member); //중복 회원 검증\t\t memberRepository.save(member);\t\t return member.getId();\t } finally {\t\t long finish = System.currentTimeMillis();\t\t long timeMs = finish - start;\t\t System.out.println(\"join \" + timeMs + \"ms\");\t } }터미널보면 시간 나와있음. 모든 메소드에 이 코드를 추가하기엔 너무 많음AOP를 사용하지 않고 모든 코드를 입력할 때 문제  핵심관심사항이 아니고(핵심기능아님) 공통관심사항(공통기능)임  여러 기능이 섞여있어서 유지보수가 힘들다.  공통로직으로 만들기 힘듦  하나를 변경하면 모두 변경해줘야함⇒ AOP 사용AOP(Aspect Oriented Programming) : 모든 메소드의 호출시간 측정 가능.  공통 관심사항과 핵심관심사항 분리(시간측정 로직을 한군데에 모아서 원하는 곳에 적용)package com.greenart.practice.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Component@Aspectpublic class TimeTraceAop {    @Around(\"execution(* com.greenart.practice..*(..))\")    /* ↑ 아니면 Springconfig에 아래 코드 추가     @Bean    public TimeTraceAop timeTraceAop(){        return new TimeTraceAop();    } */    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {        long start = System.currentTimeMillis();        System.out.println(\"START: \" + joinPoint.toString());        try {            return joinPoint.proceed();        } finally {            long finish = System.currentTimeMillis();            long timeMs = finish - start;            System.out.println(\"END: \" + joinPoint.toString() + \" \" + timeMs + \"ms\");        }    }}@Around(“execution(* com.greenart.practice..*(..))”)에서 com.greenart.practice는 패키지명. 이걸 변경하면 대상 지정 가능"
  },
  
  {
    "title": "[김영한 스프링 입문] 웹 MVC",
    "url": "/posts/%EC%9B%B9_MVC/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링입문, mvc",
    "date": "2022-12-10 00:00:00 +0900",
    





    
    "snippet": "package com.greenart.practice.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframew...",
    "content": "package com.greenart.practice.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import com.greenart.practice.domain.Member;import com.greenart.practice.service.MemberService;@Controllerpublic class MemberController {    private final MemberService memberservice;    @Autowired//Spring 컨테이너의 memberservice와 연결시켜줌.    public MemberController(MemberService memberservice){        this.memberservice = memberservice;    }        @GetMapping(\"/members/new\")    public String createForm(){        return \"members/createMemberForm\";    }    @PostMapping(\"/members/new\")    public String createForm(MemberForm form){        Member member = new Member();        member.setName(form.getName());                MemberService.join(member);        return \"redirect:/\";    }    @GetMapping(\"/members\")    public String list(Model model){        List&lt;Member&gt; members = memberservice.findMembers();        model.addAttribute(\"members\", members);        return \"members/memberList\";    }}&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class =\"container\"&gt;        &lt;div&gt;            &lt;h1&gt;hello Spring&lt;/h1&gt;            &lt;p&gt;회원 기능&lt;/p&gt;            &lt;p&gt;                &lt;a href=\"/members/new\"&gt;회원 가입&lt;/a&gt;                &lt;a href=\"/members/\"&gt;회원 목록&lt;/a&gt;            &lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class =\"container\"&gt;        &lt;form action = \"/members/new\" method =\"post\"&gt;            &lt;div class=\"form-group\"&gt;                &lt;label for = \"name\"&gt;이름&lt;/label&gt;                &lt;input type=\"text\" id=\"name\" name =\"name\" placeholder=\"이름을 입력하세요\"&gt;            &lt;/div&gt;            &lt;button type=\"submit\"&gt;등록&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class =\"container\"&gt;        &lt;div&gt;            &lt;table&gt;                &lt;thead&gt;                    &lt;tr&gt;                        &lt;th&gt;#&lt;/th&gt;                        &lt;th&gt;이름&lt;/th&gt;                    &lt;/tr&gt;                &lt;/thead&gt;                &lt;tbody&gt;                    &lt;tr th:each=\"member:${members}\"&gt;                        &lt;td th:text=\"${member.id}\"&gt;&lt;/td&gt;                        &lt;td th:text=\"${member.name}\"&gt;&lt;/td&gt;                    &lt;/tr&gt;                &lt;/tbody&gt;            &lt;/table&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "[김영한 스프링 입문] 스프링 DB 접근",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81_DB_%EC%A0%91%EA%B7%BC/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링입문",
    "date": "2022-12-10 00:00:00 +0900",
    





    
    "snippet": "순수 JDBCh2 사용package com.greenart.practice.repository;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;im...",
    "content": "순수 JDBCh2 사용package com.greenart.practice.repository;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import java.util.Optional;import javax.sql.DataSource;import org.springframework.jdbc.datasource.DataSourceUtils;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;public class jdbcMemberRepository implements MemberRepository {    private final DataSource dataSource;    public jdbcMemberRepository(DataSource dataSource) {        this.dataSource = dataSource;    }    @Override    public Member save(Member member) {        String sql = \"insert into member(name) values(?)\";        Connection conn = null;        PreparedStatement pstmt = null;        ResultSet rs = null;        try {            conn = getConnection();            pstmt = conn.prepareStatement(sql,                Statement.RETURN_GENERATED_KEYS);            pstmt.setString(1, member.getName());            pstmt.executeUpdate();            rs = pstmt.getGeneratedKeys();            if (rs.next()) {                member.setId(rs.getLong(1));            } else {                throw new SQLException(\"id 조회 실패\");            }            return member;        } catch (Exception e) {            throw new IllegalStateException(e);        } finally {            close(conn, pstmt, rs);        }    }    @Override    public Optional &lt; Member &gt; findById(Long id) {        String sql = \"select * from member where id = ?\";        Connection conn = null;        PreparedStatement pstmt = null;        ResultSet rs = null;        try {            conn = getConnection();            pstmt = conn.prepareStatement(sql);            pstmt.setLong(1, id);            rs = pstmt.executeQuery();            if (rs.next()) {                Member member = new Member();                member.setId(rs.getLong(\"id\"));                member.setName(rs.getString(\"name\"));                return Optional.of(member);            } else {                return Optional.empty();            }        } catch (Exception e) {            throw new IllegalStateException(e);        } finally {            close(conn, pstmt, rs);        }    }    @Override    public List &lt; Member &gt; findAll() {        String sql = \"select * from member\";        Connection conn = null;        PreparedStatement pstmt = null;        ResultSet rs = null;        try {            conn = getConnection();            pstmt = conn.prepareStatement(sql);            rs = pstmt.executeQuery();            List &lt; Member &gt; members = new ArrayList &lt; &gt; ();            while (rs.next()) {                Member member = new Member();                member.setId(rs.getLong(\"id\"));                member.setName(rs.getString(\"name\"));                members.add(member);            }            return members;        } catch (Exception e) {            throw new IllegalStateException(e);        } finally {            close(conn, pstmt, rs);        }    }    @Override    public Optional &lt; Member &gt; findByName(String name) {        String sql = \"select * from member where name = ?\";        Connection conn = null;        PreparedStatement pstmt = null;        ResultSet rs = null;        try {            conn = getConnection();            pstmt = conn.prepareStatement(sql);            pstmt.setString(1, name);            rs = pstmt.executeQuery();            if (rs.next()) {                Member member = new Member();                member.setId(rs.getLong(\"id\"));                member.setName(rs.getString(\"name\"));                return Optional.of(member);            }            return Optional.empty();        } catch (Exception e) {            throw new IllegalStateException(e);        } finally {            close(conn, pstmt, rs);        }    }    private Connection getConnection() {        return DataSourceUtils.getConnection(dataSource);    }    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) {        try {            if (rs != null) {                rs.close();            }        } catch (SQLException e) {            e.printStackTrace();        }        try {            if (pstmt != null) {                pstmt.close();            }        } catch (SQLException e) {            e.printStackTrace();        }        try {            if (conn != null) {                close(conn);            }        } catch (SQLException e) {            e.printStackTrace();        }    }    private void close(Connection conn) throws SQLException {        DataSourceUtils.releaseConnection(conn, dataSource);    }}과거에 사용했던…수업시간에도 들었음. 일단 알아만 두기package com.greenart.practice;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.repository.jdbcMemberRepository;import com.greenart.practice.service.MemberService;@Configurationpublic class SpringConfig {    DataSource dataSource;    @Autowired    public SpringConfig(DataSource dataSource){        this.dataSource = dataSource;    }    @Bean    public MemberService memberService(){        return new MemberService(memberRepository());    }    @Bean    public MemberRepository memberRepository(){        // return new MemoryMemberRepository();        return new jdbcMemberRepository(dataSource);    }}MemoryMemberRepository → jdbcMemberRepository 변경, SpringConfig 생성자 생스프링 아님. 순수 자바코드로 jdbc설정spring 통합 테스트package com.greenart.practice.service;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.transaction.annotation.Transactional;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;@SpringBootTest@Transactional //테스트 실행 후 데이터 바로 삭제.(같은 값 계속 입력 가능함) = 실제 DB에 반영이 안class MemberServiceIntegrationTest {    @Autowired MemberService memberService;    @Autowired MemberRepository memberRepository;    @Test    public void 회원가입() throws Exception {        //Given        Member member = new Member();        member.setName(\"hello\");        //When        Long saveId = memberService.join(member);        //Then        Member findMember = memberRepository.findById(saveId).get();        assertEquals(member.getName(), findMember.getName());    }    @Test    public void 중복_회원_예외() throws Exception {        //Given        Member member1 = new Member();        member1.setName(\"spring\");        Member member2 = new Member();        member2.setName(\"spring\");        //When        memberService.join(member1);        IllegalStateException e = assertThrows(IllegalStateException.class,        () -&gt; memberService.join(member2));//예외가 발생해야 한다.        assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");    }}assertThat import가 잘 안됨검색해보니 import static org.junit.Assert.*;를 지우고 import org.assertj.core.api.Assertions_;_를 수동으로 넣으라는데 안돼서 걍 껏다키니까 됨;;순수한 단위테스트(순수 자바코드로 최소한의 단위로 하는 테스트)가 더 효율적임. 미리 연습 많이할것..jdbcTemplateJDBC API의 반복적인 코드 대부분 제거. SQL은 직접 작성해야함package com.greenart.practice.repository;import java.sql.ResultSet;import java.sql.SQLException;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Optional;import javax.sql.DataSource;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;import org.springframework.jdbc.core.simple.SimpleJdbcInsert;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;public class JdbcTemplateMemberRepository implements MemberRepository {    private final JdbcTemplate jdbcTemplate;    // @Autowired //생성자 하나일시 생략 가능    public JdbcTemplateMemberRepository(DataSource dataSource){        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    @Override    public Member save(Member member) throws Exception {        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);        jdbcInsert.withTableName(\"member\").usingGeneratedKeyColumns(\"id\"); //sql문 작성할 필요없음. member테이블의 id에 insert해        Map&lt;String, Object&gt; parameters = new HashMap&lt;&gt;();        parameters.put(\"name\", member.getName());        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));        member.setId(key.longValue());        return member;    }    @Override    public Optional&lt;Member&gt; findById(Long id) throws Exception {        List&lt;Member&gt; result = jdbcTemplate.query(\"select * from member where id=?\",memberRowMapper(), id );        return result.stream().findAny(); //순수 jdbc와 같은 코드    }    @Override    public Optional&lt;Member&gt; findByName(String name) {        List&lt;Member&gt; result = jdbcTemplate.query(\"select * from member where name=?\",memberRowMapper(), name );        return result.stream().findAny(); //순수 jdbc와 같은 코드    }    @Override    public List&lt;Member&gt; findAll() {        return jdbcTemplate.query(\"select * from member\",memberRowMapper() );    }    private RowMapper&lt;Member&gt; memberRowMapper(){        // return new RowMapper&lt;Member&gt;(){        //     @Override        //     public Member mapRow(ResultSet rs, int rowNum) throws SQLException{        //         Member member = new Member();        //         member.setId(rs.getLong(\"id\"));        //         member.setName(rs.getString(\"name\"));        //         return member;        //     } //람다로 변환 가능            return (rs, rowNum) -&gt; {                Member member = new Member();                member.setId(rs.getLong(\"id\"));                member.setName(rs.getString(\"name\"));                return member;        };    }}package com.greenart.practice;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.repository.JdbcTemplateMemberRepository;import com.greenart.practice.repository.jdbcMemberRepository;import com.greenart.practice.service.MemberService;@Configurationpublic class SpringConfig {    DataSource dataSource;    @Autowired    public SpringConfig(DataSource dataSource){        this.dataSource = dataSource;    }    @Bean    public MemberService memberService(){        return new MemberService(memberRepository());    }    @Bean    public MemberRepository memberRepository(){        // return new MemoryMemberRepository();        // return new jdbcMemberRepository(dataSource);        return new JdbcTemplateMemberRepository(dataSource);    }}jdbcMemberRepository → JdbcTemplateMemberRepository 변경JPA반복코드 제거 + sql문도 JPA가 직접 만들어줌build.gradle에 dependencies안에implementation ‘org.springframework.boot:spring-boot-starter-data-jpa’추가application에spring.jpa.show-sql=truespring.jpa.hibernate.ddl-auto=none추가저장, 업데이트, 단건 조회문은 sql문을 짤 필요 없음여러 값을 가져오는 경우에는 sql문을 짜줘야함. Spring data jpa를 사용하면 이것도 안짜줘도 됨.package com.greenart.practice.repository;import java.util.List;import java.util.Optional;import javax.persistence.EntityManager;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;public class JpaMemberRepository implements MemberRepository {    private final EntityManager em;    public JpaMemberRepository(EntityManager em) {    this.em = em;    } //자동으로 만들어짐    @Override    public Member save(Member member) {        em.persist(member);        return member;    }    @Override    public Optional&lt;Member&gt; findById(Long id) {        Member member = em.find(Member.class, id);        return Optional.ofNullable(member);        }    @Override    public Optional&lt;Member&gt; findByName(String name) {        List&lt;Member&gt; result = em.createQuery(\"select m from Member m where m.name = :name\", Member.class).setParameter(\"name\", name).getResultList();        return result.stream().findAny();        }    @Override    public List&lt;Member&gt; findAll() {        return em.createQuery(\"select m from Member m\", Member.class).getResultList();         //\"select m from Member m\" - jpql 쿼리 언어. 테이블대상이아니고 객체 대상으로 쿼리를 날림.         //member entity를 향해 쿼리를 날림. member m은 member as m의 줄임말. 그래서 select m은 member entity 객체 자체를 가져온다는 말임. *랑 같은말인듯?    }     }package com.greenart.practice.service;import java.util.List;import java.util.Optional;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.transaction.annotation.Transactional;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;@Transactionalpublic class MemberService {    private static MemberRepository memberRepository;        @Autowired    public MemberService(MemberRepository memberRepository){        this.memberRepository=memberRepository;    }    public static Long join(Member member) throws Exception{        //같은 이름x        // Optional&lt;Member&gt; result = memberRepository.findByName(member.getName());         //Optional을 바로 반환하는 것을 권장하지 않음(아래 메소드 참고)                validateDuplicateMember(member);        //null이 들어올 확률이 있어서 Optional로 감싸줌. .get으로 바로 꺼내도 되나 권장하지 않음        //.orElseGet(값이 있으면 꺼내고 값이 없으면 메소드를 실행하거나 디폴트값을 꺼냄)을 써도됨.                 // result.ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원입니다.\"); // - 위에써서 주석처리함        // })/; //일치하는 회원이 있다면 로직이 동작        memberRepository.save(member);        return member.getId();    } //jpa는 데이터 변경이 모두 Transactional안에서 이루어져야함. 여기선 @Transactional이 join메소드에만 붙어도 되지만 일단 class에 붙여줌    private static void validateDuplicateMember(Member member){        memberRepository.findByName(member.getName())            .ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원\");});               }    //전체회원 조회    public static List&lt;Member&gt; findMembers(){        return memberRepository.findAll();    }    public Optional&lt;Member&gt; findOne(Long memberId) throws Exception{        return memberRepository.findById(memberId);    }}Spring data jpa인터페이스만으로 개발 가능. CRUD도 JPA가 모두 제공함.package com.greenart.practice.repository;import java.util.Optional;import org.springframework.data.jpa.repository.JpaRepository;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;public interface SpringDataJpaMemverRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepository { //Member의 Id타입, 다중상    @Override    Optional&lt;Member&gt; findByName(String name); //..끝}package com.greenart.practice;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.service.MemberService;@Configurationpublic class SpringConfig {    // private final DataSource dataSource;    // private final EntityManager em;    // public SpringConfig(EntityManager em) {    //     // this.dataSource = dataSource;    //     this.em = em;    // }    private final MemberRepository memberRepository;    @Autowired //생성자가 하나라서 생략가    public SpringConfig(MemberRepository memberRepository){        this.memberRepository = memberRepository;    }    @Bean    public MemberService memberService() {        return new MemberService(memberRepository);    }    // @Bean    // public MemberRepository memberRepository() {        // return new MemoryMemberRepository();        // return new JdbcMemberRepository(dataSource);        // return new JdbcTemplateMemberRepository(dataSource);        // return new JpaMemberRepository(em);    // }}스프링 데이터 JPA가 SpringDataJpaMemberRepository를 보고 자동으로 bean을 만들어서 객체를 생성한 후 bean에 올려줌. JpaRepository안에 save, findById 등 만들어둔 메소드가 모두 있음. 기본적인 CRUD가 다 제공되어있는 상태임.그러나 만약 공통되지 않는 사항은 메소드를 만들어주어야함. email, phone같은 상황에따라 다른 경우를 뜻함.메소드 이름을 findByName(String name) 이라고 지으면 자동으로 select m from member m where m.name=?으로 sql문을 짜줌findByNameAndId(String name, Long id) 는 select m from member m where m.name=? and id = ?으로 짜줌. 인터페이스의 이름만으로 자동으로 만들어준다는 뜻임"
  },
  
  {
    "title": "[김영한 스프링 입문] 스프링 빈과 의존관계",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EB%B9%88%EA%B3%BC_%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링입문",
    "date": "2022-12-08 00:00:00 +0900",
    





    
    "snippet": "controller가 service를 이용해서 데이터 추가, 조회 등을 실행할 수 있어야함(=의존관계가 있어야함).Acontroller만 Aservice를 사용할 수 있어야함. Bcontroller는 Bservice만 사용가능. Aservice는 사용불가능.→— 스프링 빈 등록하는 방법  컴포넌트 스캔과 자동 의존관계 설정package com.gree...",
    "content": "controller가 service를 이용해서 데이터 추가, 조회 등을 실행할 수 있어야함(=의존관계가 있어야함).Acontroller만 Aservice를 사용할 수 있어야함. Bcontroller는 Bservice만 사용가능. Aservice는 사용불가능.→— 스프링 빈 등록하는 방법  컴포넌트 스캔과 자동 의존관계 설정package com.greenart.practice.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import com.greenart.practice.service.MemberService;@Controller //안에 component이 있음public class MemberController {    private final MemberService memberservice;    @Autowired//Spring 컨테이너의 memberservice와 연결시켜줌.\t\t// 단, 순수한 java클래스와는 연결이 안됨. @Service를 클래스앞에 붙여서 어떤 클래스인지 지정먼저 해줘야    public MemberController(MemberService memberservice){        this.memberservice = memberservice;    }        }package com.greenart.practice.service;import java.util.List;import java.util.Optional;import org.springframework.stereotype.Service;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.domain.MemoryMemberRepository;@Service //연결을 위해 이 클래스가 service인것을 알려줌.//service안에 component이 있음public class MemberService {    private MemberRepository memberRepository = new MemoryMemberRepository();        public MemberService(MemberRepository memberRepository){        this.memberRepository=memberRepository;    }    public Long join(Member member){        //같은 이름x        // Optional&lt;Member&gt; result = memberRepository.findByName(member.getName());         //Optional을 바로 반환하는 것을 권장하지 않음(아래 메소드 참고)                validateDuplicateMember(member);        //null이 들어올 확률이 있어서 Optional로 감싸줌. .get으로 바로 꺼내도 되나 권장하지 않음        //.orElseGet(값이 있으면 꺼내고 값이 없으면 메소드를 실행하거나 디폴트값을 꺼냄)을 써도됨.                 // result.ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원입니다.\"); // - 위에써서 주석처리함        // })/; //일치하는 회원이 있다면 로직이 동작        memberRepository.save(member);        return member.getId();    }    private void validateDuplicateMember(Member member){        memberRepository.findByName(member.getName())            .ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원\");});               }    //전체회원 조회    public List&lt;Member&gt; findMembers(){        return memberRepository.findAll();    }    public Optional&lt;Member&gt; findOne(Long memberId){        return memberRepository.findById(memberId);    }}package com.greenart.practice.domain;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Optional;import org.springframework.stereotype.Repository;@Repository //안에 component이 있음public class MemoryMemberRepository implements MemberRepository {    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();    private static long sequence = 0L;    public void clearStore(){        store.clear();    }    @Override    public Member save(Member member) {        member.setId(++sequence); //멤버 저장시 일련번호 값 1 증가        store.put(member.getId(), member);        return member;    }    @Override    public Optional&lt;Member&gt; findById(Long id) {        return Optional.ofNullable(store.get(id)); //null이라도 감싸서 반환가능    }    @Override    public Optional&lt;Member&gt; findByName(String name) {        return store.values().stream()                .filter(member -&gt; member.getName().equals(name)) //같은 name을 가지고 있는 객체를 찾으면 반환. 없으면 null반환                .findAny();    }    @Override    public List&lt;Member&gt; findAll() {        return new ArrayList&lt;&gt;(store.values());    }    }@controller - @Service - @Repository 세가지가 정형화된 패턴controller는 service가 필요하고 service는 repositry가 필요함.❗스프링 컨테이너에 스프링 빈 등록시 기본으로 싱글톤으로 등록함(설정으로 아니게 할수있지만 특별한경우아니면 다 싱글톤임)  자바 코드로 직접 스프링 빈 등록package com.greenart.practice;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.domain.MemoryMemberRepository;import com.greenart.practice.service.MemberService;@Configurationpublic class SpringConfig {    @Bean    public MemberService memberService(){        return new MemberService(memberRepository());    }    @Bean    public MemberRepository memberRepository(){        return new MemoryMemberRepository();    }}과거에는 XML을 사용했으나 요즘은 잘 사용하지 않음.— DI      필드 주입      package com.greenart.practice.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;      import com.greenart.practice.service.MemberService;      @Controller  public class MemberController {      @Autowired private MemberService memberservice;   }        별로 안좋음;;        setter주입      package com.greenart.practice.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;      import com.greenart.practice.service.MemberService;      @Controller  public class MemberController {      private MemberService memberservice;     \t\t  \t\t@Autowired  \t\tpublic void setMemberService(MemberService memberService){  \t\t\tthis.memberservice = memberservice;  \t\t}      }        MemberController를 누군가 호출했을 때 public으로 열려있어야함. 외부에서 호출하기 쉬(중간에 잘못 바뀌면 문제생길가능성 농후함)        생성자 주입      package com.greenart.practice.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;      import com.greenart.practice.service.MemberService;      @Controller  public class MemberController {      private final MemberService memberservice;          @Autowired//Spring 컨테이너의 memberservice와 연결시켜줌.      public MemberController(MemberService memberservice){          this.memberservice = memberservice;      }                  }        생성자를 통해 memberservice가 membercontroller에 주입  bean이 객체를 의미하는거고 스프링 컨테이너는 bean에 들어있는 객체를 관리하는거같음. 그래서 생성한 객체를 스프링 컨테이너에서 사용하려면 bean에 등록하는 과정이 필요해서 @component를 붙여줘야 하는거같음!!"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 웹페이지 생성 3",
    "url": "/posts/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%803/",
    "categories": "Spring",
    "tags": "spring, 국비교육",
    "date": "2022-12-08 00:00:00 +0900",
    





    
    "snippet": "package com.green.practice5.data;import java.util.Date;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Pro...",
    "content": "package com.green.practice5.data;import java.util.Date;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class ProductInfo {    private Integer no;    private String name;    private Integer price;    private Double discount;    private Date regDt;    }package com.green.practice5.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.green.practice5.data.ProductInfo;@RestController@RequestMapping(\"/api\")public class APIController {    private static List&lt;ProductInfo&gt; prod_list = new ArrayList&lt;ProductInfo&gt;();    private static Integer nextNo = 1;    //제품 전체 조회    @GetMapping(\"/product/list\")    public Map&lt;String, Object&gt; getProductList(){        // Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //HashMap이라 순서가 뒤죽박죽임        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); //LinkedHashMap이라 순서가 입력한 순서대로임        map.put(\"status\", true);        map.put(\"total\", prod_list.size());        map.put(\"totalPage\", (int)(Math.ceil(prod_list.size()/12.0)));        map.put(\"list\", prod_list); //입력값이 없다면 \"list\": []으로 나옴.         return map;    }    //제품 등록    @PutMapping(\"/product\")    public Map&lt;String, Object&gt; putProduct(@RequestBody ProductInfo data){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        System.out.println(data);        data.setNo(nextNo);        prod_list.add(data);        nextNo++;        map.put(\"status\", true);        map.put(\"message\", \"제품이 추가되었습니다\");                return map;    }    //제품 한개 조회    @GetMapping(\"/product/select_one\")    public ProductInfo getProductSelect(@RequestParam Integer prodNo){        for(ProductInfo p : prod_list){            if(p.getNo()==prodNo) return p;        }        return null;    }    //제품 정보 수정    @PatchMapping(\"/product\")    public Map&lt;String, Object&gt; patchProduct(@RequestBody ProductInfo data){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        for(ProductInfo p : prod_list){            if(p.getNo()==data.getNo()){                if(data.getName()!=null){                    p.setName(data.getName());                }                if(data.getPrice()!=null){                    p.setPrice(data.getPrice());                }                if(data.getDiscount()!=null){                    p.setDiscount(data.getDiscount());                }                if(data.getRegDt()!=null){                    p.setRegDt(data.getRegDt());                }                map.put(\"status\", true);                map.put(\"message\", \"제품 수정 완료\");                return map;            }        }        map.put(\"status\", false);        map.put(\"message\", \"제품 수정 실패. 제품번호를 확인해주세요\");        return map;    }}다시 시작하면 전에 입력해둔 prod_list가 다 날아가서 새로 입력해야함— 영화package com.green.practice5.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.green.practice5.data.MovieInfo;@RestController@RequestMapping(\"/api\")public class MovieController {    private static List&lt;MovieInfo&gt; mlist = new ArrayList&lt;MovieInfo&gt;();    private static Integer nextNo=1;    @PutMapping(\"/movie\")    public Map&lt;String, Object&gt; putMovie(@RequestBody MovieInfo m){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        m.setNo(nextNo);        nextNo++;        map.put(\"status\", true);        map.put(\"massage\", \"제품등록이 완료되었습니다.\");        // map.put(\"movie\", m);        mlist.add(m);        return map;    }    @GetMapping(\"/movie\")    public Map&lt;String, Object&gt; getMovieList(){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"total\", mlist.size());        map.put(\"totalpage\",(int)(Math.ceil(mlist.size()/10.0)));        map.put(\"list\", mlist);        return map;    }    @PatchMapping(\"/movie\")    public Map&lt;String, Object&gt; patchMovie(@RequestBody MovieInfo m){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        for(MovieInfo mo : mlist){            if(mo.getNo()==m.getNo()){                if(m.getTitle()!=null){                    mo.setTitle(m.getTitle());                }                if(m.getGenre()!=null){                    mo.setGenre(m.getGenre());                }                if(m.getRegDt()!=null){                    mo.setRegDt(m.getRegDt());                }                if(m.getStatus()!=null){                    mo.setStatus(m.getStatus());                }                map.put(\"massage\", \"수정완료\");                map.put(\"status\", true);                return map;            }        }        map.put(\"massage\", \"수정실패. 제품번호를 확인하세요\");        map.put(\"status\", false);        return map;    }    @DeleteMapping(\"/movie\")    public Map&lt;String, Object&gt; deleteMovie(@RequestParam Integer mNo){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        for(MovieInfo m : mlist){            if(m.getNo()==mNo){                mlist.remove(m);                map.put(\"message\", \"제품 삭제 완료\");                map.put(\"status\", true);                return map;            }        }        map.put(\"message\", \"제품 삭제 실패. 제품번호를 확인하세요\");        map.put(\"status\", false);        return map;    }    @GetMapping(\"movie/select_no\")    public Map&lt;String, Object&gt; getMovieNo(@RequestParam Integer mno){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        for(MovieInfo m : mlist){            if(m.getNo()==mno){                map.put(\"status\", true);                map.put(\"message\", \"영화정보를 찾았습니다\");                map.put(\"info\", m);                return map;            }        }        map.put(\"status\", false);        map.put(\"message\", \"해당 영화가 존재하지않습니다. 번호를 다시확인해주세요\");        return map;    }    @GetMapping(\"movie/select_genre\")    public Map&lt;String, Object&gt; getMovieGenre(@RequestParam String genre){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        List&lt;MovieInfo&gt; list = new ArrayList&lt;MovieInfo&gt;();        for(MovieInfo m : mlist){            if(m.getGenre().contains(genre)){                list.add(m);            }        }        map.put(\"total\", list.size());        map.put(\"totalpage\",(int)(Math.ceil(list.size()/10.0)));        map.put(\"list\", list);        return map;    }    @GetMapping(\"movie/select_status\")    public Map&lt;String, Object&gt; getMovieStatus(@RequestParam Integer status){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        List&lt;MovieInfo&gt; list = new ArrayList&lt;MovieInfo&gt;();        for(MovieInfo m : mlist){            if(m.getStatus()==status){                list.add(m);            }        }        map.put(\"total\", list.size());        map.put(\"totalpage\",(int)(Math.ceil(list.size()/10.0)));        map.put(\"list\", list);        return map;    }    @GetMapping(\"movie/select_all\")    public Map&lt;String, Object&gt; getMovieAll(            @RequestParam @Nullable Integer status,             @RequestParam @Nullable Integer mno,            @RequestParam @Nullable String genre        ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        List&lt;MovieInfo&gt; list = new ArrayList&lt;MovieInfo&gt;();        for(MovieInfo m : mlist){            if(m.getStatus()==status || m.getGenre().contains(genre) || m.getNo()==mno){                list.add(m);            }        }        map.put(\"total\", list.size());        map.put(\"totalpage\",(int)(Math.ceil(list.size()/10.0)));        map.put(\"list\", list);        return map;    }}PathVariable@GetMapping(\"/user/{id}\") //{}에 PathVariable이 들어감. 이경우는 매개변수로 받은 id 값이 들어감    public Map&lt;String, Object&gt; getUserInfo(@PathVariable String id){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"id\", id);                return map;    } //@PathVariable : URL로 받은 값이 파라미터로 바로 들어감. = URL로 받은 값을 변수 데이터로 사용//http://localhost:8080/api/movie/info/genre?value=판타 //http://localhost:8080/api/movie/info/status?value=2 URL이런식으로 들어감//만약 위에 장르와 상태값 조회 메소드 경로를 /movie/info/status로 받았다면 중복이라 제거했어야함. //지금은 다르게 만들어서 제거하지않아도 됨.//단 이제 /movie/info/~~~형태의 URL은 사용하지 못함// /movie/info/~~~/~~~~ 는 가능    @GetMapping(\"movie/info/{type}\")    public Map&lt;String, Object&gt; getMovieInfoByKeyword(            @PathVariable String type, @RequestParam @Nullable String value        ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        if(!type.equals(\"genre\") &amp;&amp; !type.equals(\"status\")){            map.put(\"status\", false);            map.put(\"message\", \"타입정보가 잘못되었습니다.\");        }        List&lt;MovieInfo&gt; list = new ArrayList&lt;MovieInfo&gt;();        for(MovieInfo m : mlist){            if(type.equals(\"status\") &amp;&amp;  m.getStatus()==Integer.parseInt(value)){                list.add(m);            }            if(type.equals(\"genre\") &amp;&amp;  m.getGenre().contains(value)){                list.add(m);            }        }        map.put(\"total\", list.size());        map.put(\"totalpage\",(int)(Math.ceil(list.size()/10.0)));        map.put(\"list\", list);        return map;    }하나의 메소드로 두가지 값을 확인가능함.헷갈리면 안쓰는게 좋음..product/1351?aa=45 → PathVariable(쿠팡)~~/?pcode=454 →RequestParam(다나와)PathVariable는 변수 명이 외부 노출이 안됨.만약 결과값이 없을때 에러코드를 띄우려면package com.green.practice6.api;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class APIController {    @GetMapping(\"/test\")    public ResponseEntity&lt;String&gt; getTest(){                return new ResponseEntity&lt;String&gt;(\"요청받음\",HttpStatus.OK);    }}HttpStatus.OK→HttpStatus.ACCEPTED 변경package com.green.practice6.api;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class APIController {    @GetMapping(\"/test\")    public ResponseEntity&lt;String&gt; getTest(){        return new ResponseEntity&lt;String&gt;(\"요청받음\",HttpStatus.ACCEPTED);    }}입력값에따라 에러 코드가 변경됨BAD_REQUEST - 사용자가 잘못된 값을 입력함 (제일 자주쓰임)@GetMapping(\"/test2\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getTest2(){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"status\", true);        map.put(\"message\", \"요청 성공\");        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map,HttpStatus.OK);    }위에게 복잡하다면 클래스를 하나 더 생성해서package com.green.practice6.data;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class ResponseVO {    private Boolean status;    private String message;}@GetMapping(\"/test3\")    public ResponseEntity&lt;ResponseVO&gt; getTest3(){        ResponseVO res = new ResponseVO(true, \"요청 성공\");        return new ResponseEntity&lt;ResponseVO&gt;(res,HttpStatus.OK);    }이렇게 해도 결과는 같음프론트에서 결과가 성공인지 실패인지 구분을 할 수 있어야함. 잘못된 호출은 에러코드를 확실히 내줘야함— 책package com.greenart.practice7.data;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class BookInfo {    private Integer no;    private String title;    private Integer price;    private String writer;    public void copyData(BookInfo src){        if(src.getTitle()!=null) this.title = src.getTitle();        if(src.getPrice()!=null) this.price = src.getPrice();        if(src.getWriter()!=null) this.writer = src.getWriter();    }}package com.greenart.practice7.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.greenart.practice7.data.BookInfo;@RestController@RequestMapping(\"/api/book\")public class BookAPIController {    private static List&lt;BookInfo&gt; book_list = new ArrayList&lt;BookInfo&gt;();    private static Integer nextNo = 1;    @PutMapping(\"/add\")    public ResponseEntity&lt; Map&lt;String, Object&gt; &gt; addBookInfo(@RequestBody BookInfo b){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        HttpStatus status = HttpStatus.OK;        String message = \"도서정보를 추가했습니다.\";        if(b.getTitle()==null || b.getTitle().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else if(b.getPrice()==null){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else if(b.getWriter()==null || b.getWriter().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else{            b.setNo(nextNo);            nextNo++;            book_list.add(b);        }        map.put(\"message\", message);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);    }    @GetMapping(\"/list\")    public ResponseEntity&lt; Map&lt;String, Object&gt; &gt; getBookList(        @RequestParam @Nullable Integer pageNo,        @RequestParam @Nullable String keyword,        @RequestParam @Nullable String searchType        ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();                    List&lt;BookInfo&gt; result_list = new ArrayList&lt;BookInfo&gt;();        if(pageNo==null) pageNo =1;        if(keyword==null){            result_list = book_list;        }else{            for(BookInfo b : book_list){                if(searchType==null){ //타입이 지정안됐으면 작가, 책제목 둘중하나만 같아도 list추가                    if(b.getTitle().contains(keyword) || b.getWriter().contains(keyword)){                        result_list.add(b);                    }                }else if(searchType.equals(\"title\")){                    if(b.getTitle().contains(keyword)){                        result_list.add(b);                    }                }else if(searchType.equals(\"writer\")){                    if(b.getWriter().contains(keyword)){                        result_list.add(b);                    }                }            }                    }        int totalPage = (int)Math.ceil(result_list.size()/10.0);        if(totalPage!=0 &amp;&amp; totalPage &lt; pageNo){            map.put(\"message\", \"페이지 범위를 넘어섭니다. 총 페이지 수 : \"+totalPage);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);        }        map.put(\"total\", result_list.size());        map.put(\"totalPage\", totalPage);        map.put(\"info\", result_list);        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);    }    // 책 여러개 등록    @PutMapping(\"/add/list\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; addBookInfoList(@RequestBody List&lt;BookInfo&gt; dataList) {        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : dataList){            b.setNo(nextNo);            book_list.add(b);            nextNo++;        }        map.put(\"message\", \"총 \"+dataList.size()+\"개의 데이터를 입력했습니다.\");        return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);    }    @PatchMapping(\"/update\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; updateBookInfo(        @RequestBody BookInfo data    ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : book_list){            if(b.getNo()==data.getNo()){                b.copyData(data);                map.put(\"message\", \"데이터가 변경되었습니다\");                return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);            }        }        map.put(\"message\", \"잘못된 책 번호 : \"+data.getNo());        return new ResponseEntity&lt;&gt;(map,HttpStatus.BAD_REQUEST);    }}— 음식점 메뉴등록package com.greenart.practice7.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.greenart.practice7.data.StoreMenuInfo;@RestController@RequestMapping(\"/api/menu\")public class MenuController {    private static List&lt;StoreMenuInfo&gt; menu_list = new ArrayList&lt;StoreMenuInfo&gt;();    private static Integer nextNo = 1;    @PutMapping(\"/add\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; putManuInfo(@RequestBody StoreMenuInfo data){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        HttpStatus status = HttpStatus.OK;        String message = \"메뉴를 추가했습니다.\";        if(data.getName()==null || data.getName().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";        }else if(data.getPrice()==null){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";        }else if(data.getDiscount()==null || data.getDiscount().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";        }else{            data.setNo(nextNo);            nextNo++;            menu_list.add(data);        }        map.put(\"message\", message);        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);    }    @PutMapping(\"/add/list\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; putMenuInfoList(@RequestBody List&lt;StoreMenuInfo&gt; dataList){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        HttpStatus status = HttpStatus.OK;        String message = \"총 \"+dataList.size()+\"개의 데이터를 입력했습니다.\";        List&lt;StoreMenuInfo&gt; errorList = new ArrayList&lt;StoreMenuInfo&gt;();        for(StoreMenuInfo data : dataList){            if(data.getName()==null || data.getName().equals(\"\")){                status = HttpStatus.BAD_REQUEST;                message = \"입력되지 않은 데이터입니다. 모든 항목을 입력해주세요. \";                message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";                errorList.add(data);            }else if(data.getPrice()==null){                status = HttpStatus.BAD_REQUEST;                message = \"입력되지 않은 데이터입니다. 모든 항목을 입력해주세요. \";                message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";                errorList.add(data);            }else if(data.getDiscount()==null){                status = HttpStatus.BAD_REQUEST;                message = \"입력되지 않은 데이터입니다. 모든 항목을 입력해주세요. \";                message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";                errorList.add(data);            }else{                data.setNo(nextNo);                nextNo++;                menu_list.add(data);            }        }        map.put(\"errorList\", errorList);        map.put(\"message\", message);        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map,status);    }    @GetMapping(\"/show\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getMenuInfo(@RequestParam Integer no){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        if(menu_list.size()==0){            map.put(\"message\", \"아직 제품이 등록되지 않았습니다..\");            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);        }        for(StoreMenuInfo s : menu_list){            if(s.getNo()==no){                map.put(\"manu\", s);                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }        }        map.put(\"message\", \"일치하는 제품이 존재하지 않습니다.\");        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);    }    @GetMapping(\"/show/list\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getMenuList(        @RequestParam @Nullable String name        ){            Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;            if(menu_list.size()==0){                map.put(\"message\", \"아직 제품이 등록되지 않았습니다.\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }            List&lt;StoreMenuInfo&gt; list = new ArrayList&lt;StoreMenuInfo&gt;();            if(name==null) list = menu_list;            else{                for(StoreMenuInfo s : menu_list){                    if(s.getName().contains(name)){                        list.add(s);                    }                }            }            if(list.size()==0){                map.put(\"message\", \"일치하는 제품이 존재하지않습니다. 검색어를 다시 확인해주세요.\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);            }            map.put(\"message\", \"총 \"+list.size()+\"개의 데이터가 조회되었습니다.\");            map.put(\"info\", list);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);        }        @PatchMapping(\"/update\")        public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; updateMenuInfo(@RequestBody StoreMenuInfo data){            Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;            if(menu_list.size()==0){                map.put(\"message\", \"아직 제품이 등록되지 않았습니다.\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }            for(StoreMenuInfo s : menu_list){                if(s.getNo()==data.getNo()){                    s.copyData(data);                    map.put(\"message\", \"데이터가 수정되었습니다\");                    return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);                }            }            map.put(\"message\", \"일치하는 제품번호가 존재하지 않습니다.\");            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);        }        @DeleteMapping(\"/delete\")        public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; deleteMenuInfo(@RequestParam Integer no){            Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;            if(menu_list.size()==0){                map.put(\"message\", \"아직 제품이 등록되지 않았습니다.\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }            for(StoreMenuInfo s : menu_list){                if(s.getNo()==no){                    menu_list.remove(s);                map.put(\"message\", \"데이터가 삭제되었습니다\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }        }                map.put(\"message\", \"일치하는 제품 번호가 존재하지 않습니다.\");        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);    }}package com.greenart.practice7.data;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class StoreMenuInfo {    private Integer no;    private String name;    private Integer price;    private Double discount;    public void copyData(StoreMenuInfo s){        if(s.name!=null) this.name=s.name;        if(s.price!=null) this.price=s.price;        if(s.discount!=null) this.discount=s.discount;    }}/데이터 추가 삭제가 빈번히 발생해서 순서가 유지되는 ArrayList보다 LinkedList가 나음VO : Values Object, 멤버변수로만 이루어진 클래스 타입. 객체적 특성보다는 데이터 타입의 특성이 더 강조되어있음"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] JPA",
    "url": "/posts/green_jpa/",
    "categories": "JPA",
    "tags": "spring, jpa, 국비교육, ORM",
    "date": "2022-12-08 00:00:00 +0900",
    





    
    "snippet": "생성후 sql DB생성package com.greenart.dbconnect.api;import java.util.Date;import java.util.LinkedHashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.spr...",
    "content": "생성후 sql DB생성package com.greenart.dbconnect.api;import java.util.Date;import java.util.LinkedHashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import com.greenart.dbconnect.entity.UserInfo;import com.greenart.dbconnect.respository.UserInfoRepository;@RestControllerpublic class MemberAPIController {  @Autowired UserInfoRepository repository; //bean에 매핑. controller와 repository를 연결함  @PutMapping(\"/member/join\")  public Map&lt;String, Object&gt; putMemberJoin(@RequestBody UserInfo data) {    Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();    data.setRegDt(new Date());    repository.save(data);    map.put(\"status\", true);    map.put(\"message\", \"회원이 등록되었습니다\");    return map;      }  }package com.greenart.dbconnect.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity(name = \"user_info\") //DB테이블과 class를 맵핑public class UserInfo {  @Id //primary key를 의미  @GeneratedValue(strategy = GenerationType.IDENTITY)  //GeneratedValue:주 키의 값을 위한 자동 생성 전략  //IDENTITY : 기본 키 생성을 DB에 위임(DB에 의존적)  // = 기본키 생성을 DB에 위임(=id값을 null로 하면 DB가 알아서 AUTO_INCREMENT해줌)    @Column(name = \"ui_seq\") //컬럼의 맵핑    private Integer seq;    @Column(name = \"ui_id\")    private String id;    @Column(name = \"ui_pwd\")    private String pwd;    @Column(name = \"ui_reg_dt\")    private Date regDt;    //각 칼럼 이름을 저렇게 부르겠다고 지정하는것같음.}package com.greenart.dbconnect.respository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import com.greenart.dbconnect.entity.UserInfo;@Repository //이 인터페이스가 JpaRepository임을 나타냄.public interface UserInfoRepository extends JpaRepository&lt;UserInfo,Long&gt;{  //JpaRepository : 미리 검색 메소드를 정의해둠. 호출만으로 데이터검색가능   //&lt;UserInfo,Long&gt; - 엔티티 클래스 이름, ID 필드 타임}— 책package com.greenart.practice7.data;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class BookInfo {    private Integer no;    private String title;    private Integer price;    private String writer;    public void copyData(BookInfo src){        if(src.getTitle()!=null) this.title = src.getTitle();        if(src.getPrice()!=null) this.price = src.getPrice();        if(src.getWriter()!=null) this.writer = src.getWriter();    }}package com.greenart.practice7.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.greenart.practice7.data.BookInfo;@RestController@RequestMapping(\"/api/book\")public class BookAPIController {    private static List&lt;BookInfo&gt; book_list = new ArrayList&lt;BookInfo&gt;();    private static Integer nextNo = 1;    @PutMapping(\"/add\")    public ResponseEntity&lt; Map&lt;String, Object&gt; &gt; addBookInfo(@RequestBody BookInfo b){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        HttpStatus status = HttpStatus.OK;        String message = \"도서정보를 추가했습니다.\";        if(b.getTitle()==null || b.getTitle().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else if(b.getPrice()==null){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else if(b.getWriter()==null || b.getWriter().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else{            b.setNo(nextNo);            nextNo++;            book_list.add(b);        }        map.put(\"message\", message);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);    }    @GetMapping(\"/list\")    public ResponseEntity&lt; Map&lt;String, Object&gt; &gt; getBookList(        @RequestParam @Nullable Integer pageNo,        @RequestParam @Nullable String keyword,        @RequestParam @Nullable String searchType        ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();                    List&lt;BookInfo&gt; result_list = new ArrayList&lt;BookInfo&gt;();        if(pageNo==null) pageNo =1;        if(keyword==null){            result_list = book_list;        }else{                                                                 for(BookInfo b : book_list){                if(searchType==null){ //타입이 지정안됐으면 작가, 책제목 둘중하나만 같아도 list추가                    if(b.getTitle().contains(keyword) || b.getWriter().contains(keyword)){                        result_list.add(b);                    }                }else if(searchType.equals(\"title\")){                    if(b.getTitle().contains(keyword)){                        result_list.add(b);                    }                }else if(searchType.equals(\"writer\")){                    if(b.getWriter().contains(keyword)){                        result_list.add(b);                    }                }            }                    }        int totalPage = (int)Math.ceil(result_list.size()/10.0);        if(totalPage!=0 &amp;&amp; totalPage &lt; pageNo){            map.put(\"message\", \"페이지 범위를 넘어섭니다. 총 페이지 수 : \"+totalPage);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);        }        map.put(\"total\", result_list.size());        map.put(\"totalPage\", totalPage);        map.put(\"info\", result_list);        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);    }    // 책 여러개 등록    @PutMapping(\"/add/list\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; addBookInfoList(@RequestBody List&lt;BookInfo&gt; dataList) {        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : dataList){            b.setNo(nextNo);            book_list.add(b);            nextNo++;        }        map.put(\"message\", \"총 \"+dataList.size()+\"개의 데이터를 입력했습니다.\");        return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);    }    @PatchMapping(\"/update\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; updateBookInfo(        @RequestBody BookInfo data    ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : book_list){            if(b.getNo()==data.getNo()){                b.copyData(data);                map.put(\"message\", \"데이터가 변경되었습니다\");                return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);            }        }        map.put(\"message\", \"잘못된 책 번호 : \"+data.getNo());        return new ResponseEntity&lt;&gt;(map,HttpStatus.BAD_REQUEST);    }    @DeleteMapping(\"/delete\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; deleteBookInfo(        @RequestParam Integer bookNo){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : book_list){            if(b.getNo()==bookNo){                book_list.remove(b);                map.put(\"message\", \"데이터가 삭제되었습니다\");                return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);            }        }        map.put(\"message\", \"잘못된 책 번호 : \"+bookNo);        return new ResponseEntity&lt;&gt;(map,HttpStatus.BAD_REQUEST);    }}branch develop생성, branch mywork생성Spring 생성server.port=8999spring.datasource.url = jdbc:mysql://localhost:3306/spring.datasource.username = rootspring.datasource.password = 1234mysql db생성후 연결package com.green.jpa_test.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity(name = \"member_info\")public class MemberInfoVO {    //jpa가 _는 제대로 인식을 못함    //mi_seq;mi_id;mi_pwd;mi_name;mi_nickname;mi_reg_dt;mi_status    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) //MYSQL의 AUTO_INCREMENT    @Column(name=\"mi_seq\") //기본기의 이름이 mi_seq임    private Integer seq;         @Column(name=\"mi_id\")    private String id;    @Column(name=\"mi_pwd\")    private String pwd;    @Column(name=\"mi_name\")    private String name;    @Column(name=\"mi_nickname\")    private String nickname;    @Column(name=\"mi_reg_dt\")    private Date regDt;    @Column(name=\"mi_status\")    private Integer status;}package com.green.jpa_test.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import com.green.jpa_test.entity.MemberInfoVO;@Repositorypublic interface MemberRepository extends JpaRepository&lt;MemberInfoVO, Long&gt; { //repository의 기본키 값이 Long이라 Long을 넣음    }package com.green.jpa_test;import java.util.Date;import java.util.List;import javax.transaction.Transactional;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import com.green.jpa_test.entity.MemberInfoVO;import com.green.jpa_test.repository.MemberRepository;@SpringBootTestclass JpaTestApplicationTests {\t@Autowired MemberRepository repo; //DI. 의존성 주입, MemberRepository에 해당하는 객체(bean)를 가져와서 repo안에 넣음\t//new 로 객체를 생성하지 않아도 사용가능함. \t@Test\t@Transactional //테스트 후 실행 데이터 삭제\t//아래 코드에서 수행한 insert를 수행 이전으로 되돌림\t//sql에서 확인해보니 seq 숫자는 테스트한만큼 올라감\tpublic void testMemberAdd(){\t\tMemberInfoVO data = new MemberInfoVO();\t\tdata.setId(\"user001\");\t\tdata.setPwd(\"1234\");\t\tdata.setName(\"사용자\");\t\tdata.setNickname(\"닉네임\");\t\tdata.setRegDt(new Date());\t\tdata.setStatus(1);\t\trepo.save(data); //JpaRepository에 있음\t}\t@Test\tpublic void testSelectMember(){\t\tList&lt;MemberInfoVO&gt; list =  repo.findAll(); //JpaRepository에 있음\t\tfor(MemberInfoVO m : list){\t\t\tSystem.out.println(m);\t\t}\t}}디비버에서 이렇게 해두면 아이디 코드 안적어도 중복일때 자동으로 막힘package com.green.jpa_test.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import com.green.jpa_test.entity.MemberInfoVO;@Repositorypublic interface MemberRepository extends JpaRepository&lt;MemberInfoVO, Long&gt; { //repository의 기본키 값이 Long이라 Long을 넣음    // MemberInfoVO findById(String id);    public Long countById(String id); //select count(*) from member_info where mi_id = \"\"; 자동생성해줌.     //이미 만들어진것은 커스텀하기까다로움}@Test\tpublic void idDupChkTest(){\t\tLong cnt = repo.countById(\"user001\");\t\tassertEquals(cnt,1); //cnt가 1과 동일하지않다면 \t}@PutMapping(\"/\")    public ResponseEntity&lt;Object&gt; memberJoin(@RequestBody MemberInfoVO data){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        if(repo.countById(data.getId())==1){            map.put(\"status\", false);            map.put(\"message\", data.getId()+\"은/는 이미 가입된 아이디입니다.\");            return new ResponseEntity&lt;&gt;(map, HttpStatus.NOT_ACCEPTABLE);        }        repo.save(data);        map.put(\"status\", true);        return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);    }"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 웹페이지 생성 2",
    "url": "/posts/%EC%9B%B9_%ED%8E%98%EC%9D%B4%EC%A7%80_%EC%83%9D%EC%84%B12/",
    "categories": "Spring",
    "tags": "spring, 국비교육",
    "date": "2022-12-07 00:00:00 +0900",
    





    
    "snippet": "DI : 객체간의 관계 설정IOC : 제어 역전. 실행의 주체가 바뀜.AOP : 상속등의 개념을 적극활용 . 파편화위험있음GoF : 디자인 패턴package com.greenart.practice3;import java.util.HashMap;import java.util.Map;import org.springframework.stereotype.Co...",
    "content": "DI : 객체간의 관계 설정IOC : 제어 역전. 실행의 주체가 바뀜.AOP : 상속등의 개념을 적극활용 . 파편화위험있음GoF : 디자인 패턴package com.greenart.practice3;import java.util.HashMap;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;@Controller//DI. 의존성 주입함public class PraticeController { //싱글톤. 계속살아있고 유일함.    @GetMapping(\"/\") //DI를 할수있는 객체 생성. 스프링프레임워크가 사용하는 DI    public String getMain(Model model){        // model.addAttribute(\"user\", \"member001\");//속성추가. viewResolver가 return값과 함께 내보내줌        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"id\", \"user001\");        map.put(\"name\", \"사용자\");        model.addAttribute(\"userInfo\", map); //이거 안쓰면 에러남.        //html에서 userInfo.id를 했는데 model을 사용하지 않으면 userInfo가 null이라서 null의 id를 가져오려고 연산을 하는것.        // 최종적으로 nullpointerException이 발생함        return \"main.html\";    } //IOC 사용자가 웹페이지에 URL을 입력해야 메소드가 실행됨.    @GetMapping(\"/main\")    public String getMain2(Model model){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"name\", \"제품이름\");        map.put(\"price\", 15000);        model.addAttribute(\"product\", map);        Product p = new Product(\"제품명\", 5000);        model.addAttribute(\"product2\", p);        return \"mymain.html\";    }    // parameter {RequestParam, PathVariable}    @GetMapping(\"/param\")    public String getParamTest(Model model, @RequestParam String prodNo){        model.addAttribute(\"prodNo\", prodNo);        return \"param.html\";    }}&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;main.html &lt;span th:text=\"${user}\"&gt;&lt;/span&gt;&lt;/h1&gt;    &lt;!-- 만약 Model에 입력값이 없으면 user는 출력되지 않음(null처리됨) model은 문제가 없으나 map이나 객체였다면 에러가 남 --&gt;    &lt;h1&gt;        &lt;span th:text=\"${userInfo.id}\"&gt;&lt;/span&gt;        &lt;span th:text=\"${userInfo.name}\"&gt;&lt;/span&gt;    &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;package com.greenart.practice3;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor //모든 멤버변수를 입력받는 생성자 자동 생성@NoArgsConstructor //기본 생성자 자동 생성public class Product {    private String name;    private Integer price;}&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;mymain.html&lt;/h1&gt;    &lt;p&gt;        &lt;span th:text = \"${product.name}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product.price}\"&gt;&lt;/span&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;span th:text = \"${product2.name}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product2.price}\"&gt;&lt;/span&gt;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;param.html&lt;/h1&gt;    &lt;p th:text=\"${prodNo}\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;— get 로그인&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;main.html &lt;span th:text=\"${user}\"&gt;&lt;/span&gt;&lt;/h1&gt;    &lt;!-- 만약 Model에 입력값이 없으면 user는 출력되지 않음(null처리됨) model은 문제가 없으나 map이나 객체였다면 에러가 남 --&gt;    &lt;h1&gt;        &lt;span th:text=\"${userInfo.id}\"&gt;&lt;/span&gt;        &lt;span th:text=\"${userInfo.name}\"&gt;&lt;/span&gt;    &lt;/h1&gt;    &lt;form action=\"/login\"&gt;        &lt;input type=\"text\" name =\"id\"&gt;        &lt;input type=\"password\" name =\"pwd\"&gt;        &lt;button&gt;로그인&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1 th:text=\"${msg}\"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;@GetMapping(\"/login\")    public String getLogin(@RequestParam String id, @RequestParam String pwd, Model model){        System.out.println(id);        System.out.println(pwd);         if(id.equals(\"admin\") &amp;&amp; pwd.equals(\"1234\")){            model.addAttribute(\"msg\",\"로그인 성공했습니다\");        }else{            model.addAttribute(\"msg\", \"로그인 실패. 아이디 또는 비밀번호 오류입니다.\");        }        return \"login.html\";    }만들어준 회원리스트가 없어서 if문으로 처리원래 로그인은 get이아니라 post로 처리함. url에 아이디랑 비밀번호가 노출되면 안되기때문임.— post 로그인&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;main.html &lt;span th:text=\"${user}\"&gt;&lt;/span&gt;&lt;/h1&gt;    &lt;!-- 만약 Model에 입력값이 없으면 user는 출력되지 않음(null처리됨) model은 문제가 없으나 map이나 객체였다면 에러가 남 --&gt;    &lt;h1&gt;        &lt;span th:text=\"${userInfo.id}\"&gt;&lt;/span&gt;        &lt;span th:text=\"${userInfo.name}\"&gt;&lt;/span&gt;    &lt;/h1&gt;    &lt;form action=\"/login\" method=\"post\"&gt;        &lt;input type=\"text\" name =\"id\"&gt;        &lt;input type=\"password\" name =\"pwd\"&gt;        &lt;button&gt;로그인&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;@PostMapping(\"/login\")    public String postLogin(String id, String pwd, Model model){ //post는 @RequestParam 못씀.(쓸수는있는데 못쓴다고 알아두면됨)        //민감정보는 파라미터가 아니라 내부 홈데이터로 받도록 처리함.        System.out.println(id);        System.out.println(pwd);         if(id.equals(\"admin\") &amp;&amp; pwd.equals(\"1234\")){            model.addAttribute(\"msg\",\"로그인 성공했습니다\");        }else{            model.addAttribute(\"msg\", \"로그인 실패. 아이디 또는 비밀번호 오류입니다.\");        }        return \"login.html\";    }이것도 완전한건아님. 추적하면 바로 아이디 비번 확인가능함일단 주소창에 아이디 비번이 표시되지는 않음public String postLogin(UserInfo user, Model model){ //post는 @RequestParam 못씀.(쓸수는있는데 못쓴다고 알아두면됨)        //민감정보는 파라미터가 아니라 내부 홈데이터로 받도록 처리함.        System.err.println(user.getId());        System.err.println(user.getPwd());        if(user.getId().equals(\"admin\") &amp;&amp; user.getPwd().equals(\"1234\")){            model.addAttribute(\"msg\",\"로그인 성공했습니다\");        }else{            model.addAttribute(\"msg\", \"로그인 실패. 아이디 또는 비밀번호 오류입니다.\");        }        return \"login.html\";    }postLogin의 매개변수를 객체로 받아도 결과는 동일함. 받아야할 변수가 많을수록 객체가 효율적임.단, html의 이름과 객체의 이름이 완전히 동일해야함.            ![[IMG-20240908144934-3.png      IMG-20240908144934-3.png]]      이거 두개❗@RequestParam은 1대1매칭만 가능— 제품추가&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;main.html &lt;span th:text=\"${user}\"&gt;&lt;/span&gt;&lt;/h1&gt;    &lt;!-- 만약 Model에 입력값이 없으면 user는 출력되지 않음(null처리됨) model은 문제가 없으나 map이나 객체였다면 에러가 남 --&gt;    &lt;h1&gt;        &lt;span th:text=\"${userInfo.id}\"&gt;&lt;/span&gt;        &lt;span th:text=\"${userInfo.name}\"&gt;&lt;/span&gt;    &lt;/h1&gt;    &lt;form action=\"/login\" method=\"post\"&gt;        &lt;input type=\"text\" name =\"id\"&gt;        &lt;input type=\"password\" name =\"pwd\"&gt;        &lt;button&gt;로그인&lt;/button&gt;    &lt;/form&gt;    &lt;form action=\"/product/add\" method=\"post\"&gt;        &lt;input type=\"text\" name =\"name\"&gt;        &lt;input type=\"text\" name =\"price\"&gt;        &lt;input type=\"text\" name =\"discount\"&gt;        &lt;input type=\"text\" name =\"cate\"&gt;        &lt;button&gt;추가&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;        &lt;span th:text = \"${product.name}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product.price}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product.discount}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product.cate}\"&gt;&lt;/span&gt;    &lt;/h1&gt;    &lt;p&gt;제품 추가 완료&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;@PostMapping(\"product/add\")    public String postMain(Product p, Model model){        model.addAttribute(\"product\", p);        return \"product.html\";    }404 - URL잘못(백, 프론트 둘다 잘못된 가능성있음)405 - crud 잘못됨401 - 인증안됨415 - 프론트 잘못(json을 텍스트로 읽음)400 - 파라미터 빠짐408 - 백, 프론트 둘다 잘못된 가능성있음409 - 충돌410 - 데이터 도착실패415 - JSON요청→text도착500대 - 서버에러. 백엔드 잘못  500 - 자바코드에러  501 - 구현불가  502 - 서버터짐  503 - 서버는되는데 서비스가안됨  504 - 서버아이피부터 응답없음  508 - 서버 무한루프  [!info] HTTP response status codes - HTTP | MDNThis interim response indicates that the client should continue the request or ignore the response if the request is already finished.https://developer.mozilla.org/en-US/docs/Web/HTTP/Status200~399 - 성공자세한 번호package com.g.gg.data;import java.util.Date;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class MemberInfoVO {    private String id;    private String pwd;    private String phone;    private Date reg_dt;    private Integer status;    }package com.g.gg.api;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.g.gg.data.MemberInfoVO;@RestController //데이터 전송 전용public class APIController {    @GetMapping(\"/api/getSomething\")    public String getSomething(){        return \"something\";    }    @GetMapping(\"/api/getData\")    public Map&lt;String, Object&gt; getData(){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"status\", true);        map.put(\"code\", 200);        map.put(\"message\", \"요청이 성공했습니다.\");        return map;    }        @GetMapping(\"/api/member/add\")    public Map&lt;String, Object&gt; getAddMember(@RequestParam String id, @RequestParam String pwd, @RequestParam String phone){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        if(id.contains(\"admin\")){            map.put(\"status\", false);            map.put(\"code\", 452);            map.put(\"message\", id+\"은/는 사용할 수 없습니다.\");            return map;        }        MemberInfoVO m = new MemberInfoVO(id, pwd, phone, new Date(), 1);        map.put(\"status\", true);        map.put(\"code\", 201);        map.put(\"message\", id+\"정상적으로 등록되었습니다.\");        map.put(\"data\", m);        return map;    }    @PostMapping(\"/api/member/add\")    public Map&lt;String, Object&gt; postAddMember(@RequestBody MemberInfoVO data){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        if(data.getId().contains(\"admin\")){            map.put(\"status\", false);            map.put(\"code\", 452);            map.put(\"message\", data.getId()+\"은/는 사용할 수 없습니다.\");            return map;        }        // MemberInfoVO m = new MemberInfoVO(id, pwd, phone, new Date(), 1);        map.put(\"status\", true);        map.put(\"code\", 201);        map.put(\"message\", data.getId()+\"이 정상적으로 등록되었습니다.\");        map.put(\"data\", data);        return map;    }    @PutMapping(\"/api/member/add\")    public Map&lt;String, Object&gt; putAddMember(@RequestBody MemberInfoVO data){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        if(data.getId().contains(\"admin\")){            map.put(\"status\", false);            map.put(\"code\", 452);            map.put(\"message\", data.getId()+\"은/는 사용할 수 없습니다.\");            return map;        }        // MemberInfoVO m = new MemberInfoVO(id, pwd, phone, new Date(), 1);        map.put(\"status\", true);        map.put(\"code\", 201);        map.put(\"message\", data.getId()+\"이 정상적으로 등록되었습니다.\");        map.put(\"data\", data);        return map;    } //위에거랑 같은데 회원추가라서 굳이 따지면 put이 맞음}  [!info] API Documentation &amp; Design Tools for Teams | SwaggerSimplify API development for users, teams, and enterprises with our open source and professional toolset.https://swagger.io/API문서 관련 사이트@GetMapping(\"/product\")    public Map&lt;String, Object&gt; getProduct(){        ProductInfoVo p = new ProductInfoVo(\"제품명\", 10000, 0.2, \"prod.png\", new Date(), 100);        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"status\", true);        map.put(\"message\", \"제품조회 완료\");        map.put(\"product\", p);        return map;    }    @PutMapping(\"/product\")    public Map&lt;String, Object&gt; putProduct(@RequestBody ProductInfoVo p){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"status\", true);        map.put(\"message\", \"제품등록 완료\");        p.setReg_dt(new Date());        map.put(\"product\", p);        return map;    }@GetMapping(\"product/list\")    public Map&lt;String, Object&gt; getProductList(        @RequestParam @Nullable String keyword,        @RequestParam @Nullable Integer page,        @RequestParam @Nullable  Integer status    ){        if(keyword==null) keyword=\"\";        if(page==null) page=1;        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        String sql = \"select * from movie_info where mi_kor_title like '%\"+keyword+\"%'\";        if(status!=null){            sql+=\" and mi_status = \"+status;        }        sql += \"limit 10 offset \"+(page-1)*10;        map.put(\"sql\", sql);        return map;    }"
  },
  
  {
    "title": "[김영한 스프링 입문] 회원관리",
    "url": "/posts/%ED%9A%8C%EC%9B%90%EA%B4%80%EB%A6%AC/",
    "categories": "",
    "tags": "spring, 김영한스프링입문",
    "date": "2022-12-06 00:00:00 +0900",
    





    
    "snippet": "      비지니스 요구사항 정리          데이터 : 회원id, 이름      기능 : 회원등록, 조회      아직 테이터 저장소가 선정되지 않음.(가상 시나리오)                    회원 도메인과 리포지토리 만들기      package com.greenart.practice.domain;      import lombok.D...",
    "content": "      비지니스 요구사항 정리          데이터 : 회원id, 이름      기능 : 회원등록, 조회      아직 테이터 저장소가 선정되지 않음.(가상 시나리오)                    회원 도메인과 리포지토리 만들기      package com.greenart.practice.domain;      import lombok.Data;      @Data  public class Member {      private Long id;      private String name;          }          package com.greenart.practice.domain;      import java.util.List;  import java.util.Optional;      public interface MemberRepository {      Member save(Member member);      Optional&lt;Member&gt; findById(Long id);      Optional&lt;Member&gt; findByName(String name);      List&lt;Member&gt; findAll();  }          package com.greenart.practice.domain;      import java.util.ArrayList;  import java.util.HashMap;  import java.util.List;  import java.util.Map;  import java.util.Optional;      public class MemoryMemberRepository implements MemberRepository {          private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();      private static long sequence = 0L;          public void clearStore(){          store.clear();      }          @Override      public Member save(Member member) {          member.setId(++sequence); //멤버 저장시 일련번호 값 1 증가          store.put(member.getId(), member);          return member;      }          @Override      public Optional&lt;Member&gt; findById(Long id) {          return Optional.ofNullable(store.get(id)); //null이라도 감싸서 반환가능      }          @Override      public Optional&lt;Member&gt; findByName(String name) {          return store.values().stream()                  .filter(member -&gt; member.getName().equals(name)) //같은 name을 가지고 있는 객체를 찾으면 반환. 없으면 null반환                  .findAny();      }          @Override      public List&lt;Member&gt; findAll() {          return new ArrayList&lt;&gt;(store.values());      }          }            회원 리포지토리 테스트 케이스 작성      package com.greenart.practice.repository;      import java.util.List;      import org.assertj.core.api.Assertions;  import org.junit.jupiter.api.AfterEach;  import org.junit.jupiter.api.Test;      import com.greenart.practice.domain.Member;  import com.greenart.practice.domain.MemoryMemberRepository;      public class MemoryMemberRepositoryTest {      MemoryMemberRepository repository = new MemoryMemberRepository();             @Test      public void save(){          Member member = new Member();          member.setName(\"Spring\");              repository.save(member);          Member result= repository.findById(member.getId()).get(); //Optional이라서 .get() 써줌          // System.out.println(result == member); //이렇게 비교하기 애매함          // Assertions.assertEquals(member, result); //테스트 통과. 초록불이 들어옴          // Assertions.assertEquals(member, null); //테스트 실패. 빨간불이 들어옴              Assertions.assertThat(member).isEqualTo(result); //요즘에 더 많이 씀          // 일치할때만 초록불인듯      }      @Test      public void findByName(){          Member member1 = new Member();          member1.setName(\"spring1\");          repository.save(member1);              Member member2 = new Member();          member2.setName(\"spring2\");          repository.save(member2);              Member result = repository.findByName(\"spring1\").get();          Assertions.assertThat(member1).isEqualTo(result);          //밑에 findAll을 추가하기 전까지 잘 작동했는데 추가후 에러가 뜸          //findAll이 먼저 수행되었기때문에 spring1, spring2가 이미 지정되어있어서 에러가 뜸          // -&gt; test가 끝날때마다 공용데이터나 저장소(repository)를 지워줘야함(아래 afterEach메소드 추가로 해결. 하나의 테스트가 끝날때마다 실행됨)      }      @AfterEach      public void afterEach(){          repository.clearStore();      }          @Test      public void findAll(){          Member member1 = new Member();          member1.setName(\"spring1\");          repository.save(member1);              Member member2 = new Member();          member2.setName(\"spring2\");          repository.save(member2);              List&lt;Member&gt; result = repository.findAll();              Assertions.assertThat(result.size()).isEqualTo(2);      }  }        구현클래스를 먼저 만들고 테스트 코드를 실행. 반대로 테스트를 먼저 작성한다면 테스트 주도 개발 = PDD 라고 부름        회원 서비스 개발      package com.greenart.practice.service;      import java.util.List;  import java.util.Optional;      import com.greenart.practice.domain.Member;  import com.greenart.practice.domain.MemberRepository;  import com.greenart.practice.domain.MemoryMemberRepository;      public class MemberService {      private final MemberRepository memberRepository = new MemoryMemberRepository();              public Long join(Member member){          //같은 이름x          // Optional&lt;Member&gt; result = memberRepository.findByName(member.getName());           //Optional을 바로 반환하는 것을 권장하지 않음(아래 메소드 참고)                  validateDuplicateMember(member);              //null이 들어올 확률이 있어서 Optional로 감싸줌. .get으로 바로 꺼내도 되나 권장하지 않음          //.orElseGet(값이 있으면 꺼내고 값이 없으면 메소드를 실행하거나 디폴트값을 꺼냄)을 써도됨.                       // result.ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원입니다.\"); // - 위에써서 주석처리함          // })/; //일치하는 회원이 있다면 로직이 동작          memberRepository.save(member);          return member.getId();      }      private void validateDuplicateMember(Member member){          memberRepository.findByName(member.getName())              .ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원\");});                 }      //전체회원 조회      public List&lt;Member&gt; findMembers(){          return memberRepository.findAll();      }      public Optional&lt;Member&gt; findOne(Long memberId){          return memberRepository.findById(memberId);      }  }            회원 서비스 테스트  https://velog.io/@ddingmun8/test위 링크 참고해서 단축키 설정후 generate test선택, 모두 선택하고 생성하면 테스트 폴더에 파일 생성됨.package com.greenart.practice.repository;import java.util.List;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.Test;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemoryMemberRepository;public class MemoryMemberRepositoryTest {    MemoryMemberRepository repository = new MemoryMemberRepository();       @Test    public void save(){        Member member = new Member();        member.setName(\"Spring\");        repository.save(member);        Member result= repository.findById(member.getId()).get(); //Optional이라서 .get() 써줌        // System.out.println(result == member); //이렇게 비교하기 애매함        // Assertions.assertEquals(member, result); //테스트 통과. 초록불이 들어옴        // Assertions.assertEquals(member, null); //테스트 실패. 빨간불이 들어옴        Assertions.assertThat(member).isEqualTo(result); //요즘에 더 많이 씀        // 일치할때만 초록불인듯    }    @Test    public void findByName(){        Member member1 = new Member();        member1.setName(\"spring1\");        repository.save(member1);        Member member2 = new Member();        member2.setName(\"spring2\");        repository.save(member2);        Member result = repository.findByName(\"spring1\").get();        Assertions.assertThat(member1).isEqualTo(result);        //밑에 findAll을 추가하기 전까지 잘 작동했는데 추가후 에러가 뜸        //findAll이 먼저 수행되었기때문에 spring1, spring2가 이미 지정되어있어서 에러가 뜸        // -&gt; test가 끝날때마다 공용데이터나 저장소(repository)를 지워줘야함(아래 afterEach메소드 추가로 해결. 하나의 테스트가 끝날때마다 실행됨)    }    @AfterEach    public void afterEach(){        repository.clearStore();    }    @Test    public void findAll(){        Member member1 = new Member();        member1.setName(\"spring1\");        repository.save(member1);        Member member2 = new Member();        member2.setName(\"spring2\");        repository.save(member2);        List&lt;Member&gt; result = repository.findAll();        Assertions.assertThat(result.size()).isEqualTo(2);    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 웹페이지 생성",
    "url": "/posts/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EC%83%9D%EC%84%B1/",
    "categories": "Spring",
    "tags": "spring, 국비교육",
    "date": "2022-12-06 00:00:00 +0900",
    





    
    "snippet": "!하고 탭@Controller, getTest 추가 후http://localhost:8081/test에 들어가면Hello World 뜸package com.greenart.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind....",
    "content": "!하고 탭@Controller, getTest 추가 후http://localhost:8081/test에 들어가면Hello World 뜸package com.greenart.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;//http://localhost:8081/test//http://localhost:8081 - 서버주소// /test - 매핑경로@Controllerpublic class TestContoller {    //http://localhost:8081/test를 요청했을때(웹 페이지에 접속했을때)    @GetMapping(\"/test\") //매핑경로.     public String getTest(){ //메소드 실행        System.out.println(\"요청을 받음\"); //터미널에 출력됨        return \"pages/test.html\"; //    }}model view controller→MVC위 자바 코드를 예시로 들면 contoller에서 pages/test.html파일이 return되서 view의 viewResolver한테 넘김.그럼 templates를 경로에 붙여서 view에게 최종적으로 templates/pages/test.html를 넘김경로가 잘못됐을경우 아래와같이 뜸앞뒤로 templates랑 html 붙여줌사용자(end user, front end[web], application 등) ←→ 백엔드(가공담당[data factory]) ←→ 데이터베이스(Raw data)MVC 패턴. 여기서 view(프론트)가 빠지면 Restful임[데이터 요청→데이터로(json형태) 응답]view와 controller사이에 viewResolver(thymeleaf)가 있음사용자(제품번호10번 요청) → controller→service→reoisutory(select)→DB →repository→service→controller→view→사용자  https://www.data.go.kr/  restful의 대표적인 사례bin 폴더 : binary타입.src 폴더  test폴더 - 테스트코드 저장(무결성검사 등) - TDD  main - develop          Practice3Application, ServletInitializer파일은 어지간하면 건들지말것. main안쪽에 파일을 만들어야 사용가능      static 폴더 : 별도의 지정없이 접속시 바로 실행bean - 싱글톤을 관리@controller를 붙여서 bean에 추가됨(다른폴더라도 같은이름이 2개면 에러남)뜨긴하지만 에러상태임❗static폴더에 html을 넣으면 경로지정없이 http://localhost:8080/링크로들어갔을때 바로 실행됨.만약package com.greenart.practice.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;// @RestController //viewResolver가 붙지않아서 return값이 String으로 표시됨@Controllerpublic class MainController {    //http://localhost:8080/ //static의 html의 주소와 같아서 현재 메소드가 실행됨    //@GetMapping(\"/\") - Get요청에 대한 URL매핑을 /로 하고, /로 요청이 들어오면 다음에 이어지는 메서드를 실행시킴    //Request방법 종류 - Get, Post, Delete, Patch, Put, Option    // Get 요청 - URL을 넣어서 해당하는 메소드를 실행시킴    // patch : update    // put : insert    // post : insert    // option : 선택사항(자동로그인)    @GetMapping(\"/\")     // @PostMapping(\"/\") // 브라우저에서 주소를 넣으면 에러남. Postman에서 post로 바꿔서 주소값넣으면 정상표시    public String getMain(){        return \"views/main.html\"; //file을 찾아서 파일 내용을 표시    }}이런식으로 경로 두개가 겹치면 메소드의 html이 실행됨  [!info] Download Postman | Get Started for FreeTry Postman for free!https://www.postman.com/downloads/설치package com.greenart.practice.data;import lombok.Data;@Data public class UserInfo {    private String id;    private String name;    public UserInfo(){}    public UserInfo(String id, String name){        this.id = id;        this.name = name;    }}package com.greenart.practice.data;import lombok.Data;@Datapublic class ProductInfo {    private Integer pi_seq;    private String pi_name;    private Double pi_discount_rate;    private Integer pi_price;    private Integer pi_score;    private String pi_img;}&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;views/main.html&lt;/h1&gt;    &lt;h3&gt;&lt;span th:text=\"${name}\"&gt;&lt;/span&gt;&lt;/h3&gt;    &lt;p&gt;&lt;span th:text=\"${product}\"&gt;&lt;/span&gt;&lt;/p&gt;    &lt;div&gt;        &lt;img th:src=\"${product.pi_img}\"&gt;        &lt;p th:text=\"${product.pi_name}\"&gt;        &lt;p&gt;            &lt;span th:text=\"${product.pi_discount_rate*100}\"&gt;&lt;/span&gt;%            &lt;span th:text=\"${product.pi_price}\" style=\"text-decoration:line-through\"&gt;&lt;/span&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;span th:text=\"${product.pi_price*(1-product.pi_discount_rate)}\"&gt;&lt;/span&gt;&lt;span&gt;원&lt;/span&gt;        &lt;/p&gt;         &lt;p th:text=\"${product.pi_score}\"&gt;&lt;/p&gt;    &lt;/div&gt;    &lt;p th:text=\"${userList}\"&gt;&lt;/p&gt;    &lt;table border=\"1\"&gt;        &lt;tbody&gt;            &lt;tr th:each=\"user, i : ${userList}\"&gt;                &lt;td th:text=\"${i.count}\"&gt;&lt;/td&gt;                &lt;td th:text=\"${user.id}\"&gt;&lt;/td&gt;                &lt;td th:text=\"${user.name}\"&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;package com.greenart.practice.controller;import java.util.ArrayList;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import com.greenart.practice.data.ProductInfo;import com.greenart.practice.data.UserInfo;// @RestController //viewResolver가 붙지않아서 return값이 String으로 표시됨@Controllerpublic class MainController {    @GetMapping(\"/main\")     // @PostMapping(\"/\") // 브라우저에서 주소를 넣으면 에러남. Postman에서 post로 바꿔서 주소값넣으면 정상표시    public String getMain(Model model){        model.addAttribute(\"name\", \"pjh\");        ProductInfo p = new ProductInfo();        p.setPi_seq(1);        p.setPi_name(\"하림 치킨너겟(냉동)\");        p.setPi_price(21020);        p.setPi_discount_rate(0.3);        p.setPi_score(5);        p.setPi_img(\"http://placekitten.com/80/80\");        model.addAttribute(\"product\", p);        List&lt;UserInfo&gt; userList = new ArrayList&lt;UserInfo&gt;();        userList.add(new UserInfo(\"user001\", \"일용자\"));        userList.add(new UserInfo(\"user002\", \"이용자\"));        userList.add(new UserInfo(\"user003\", \"삼용자\"));        userList.add(new UserInfo(\"user004\", \"사용자\"));        userList.add(new UserInfo(\"user005\", \"오용자\"));        model.addAttribute(\"userList\", userList);        return \"main\"; //file을 찾아서 파일 내용을 표시    }    @GetMapping(\"/main2\")    public String getMain2(Model model){        model.addAttribute(\"name\", \"pjh\");        ProductInfo p = new ProductInfo();        p.setPi_seq(1);        p.setPi_name(\"하림 치킨너겟(냉동)\");        p.setPi_price(21020);        p.setPi_discount_rate(0.3);        p.setPi_score(5);        p.setPi_img(\"http://placekitten.com/300/300\");        model.addAttribute(\"product\", p);        List&lt;UserInfo&gt; userList = new ArrayList&lt;UserInfo&gt;();        userList.add(new UserInfo(\"user001\", \"일용자\"));        userList.add(new UserInfo(\"user002\", \"이용자\"));        userList.add(new UserInfo(\"user003\", \"삼용자\"));        userList.add(new UserInfo(\"user004\", \"사용자\"));        userList.add(new UserInfo(\"user005\", \"오용자\"));        model.addAttribute(\"userList\", userList);        return \"/main\"; //매핑경로가 다르다=다른메소드를 실행한다. (위 메소드에서 보내는 데이터를 받지못함)                         // =&gt; main.html의 product와 user값이 없어서 에러남. (위에 메소드 내용을 복하면 가능함)                        //그래서 html을 탬플릿이라고 부름. 형태는 유지되지만 접근하는 url에 따라 안의 데이터는 다름    }    @GetMapping(\"/main3\")    public String getMain3(){        return \"redirect:/main\"; //main3으로 들어갔을때 main으로 강제 이동시킴. redirect가 붙으면 매핑경로를, 아니면 파일위치를 찾음        //로그인, 로그아웃에서 많이 사용됨    }}api - application programming interfacepackage com.greenart.practice.api;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class APIController {    // http://localhost:8080/api/main    @GetMapping(\"/api/main\")    public String getAPIMain(){        return \"API Main\";    }    @GetMapping(\"/api/main\")    public String getAPIMain2(){        return \"API Main2\";    }}같은 주소로 매핑시 빌드 실패함package com.greenart.practice.api;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class APIController {    // http://localhost:8080/api/main    @GetMapping(\"/api/main\")    public String getAPIMain(){        return \"[Get] API Main\";    }    @PostMapping(\"/api/main\")    public String postAPIMain(){        return \"[Post] API Main\";    }    @PutMapping(\"/api/main\")    public String putAPIMain(){        return \"[Put] API Main\";    }    @DeleteMapping(\"/api/main\")    public String deleteAPIMain(){        return \"[delete] API Main\";    }    @PatchMapping(\"/api/main\")    public String patchAPIMain(){        return \"[Patch] API Main\";    }}이건 가능스프링부트 대시보드 @GetMapping(\"/api/user_info\")    public UserInfo getAPIUserInfo(){        return new UserInfo(\"user001\", \"사용자\");    }나옴 프론트한테 여기 링크만 주면 됨URL에는 snake case를 추천함.@GetMapping(\"/api/datas\")    public Map&lt;String, Object&gt; getAPIDatas(){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"totalCnt\", 12438);        map.put(\"totalPages\", (int)Math.ceil(12438/10.0));        map.put(\"currentPage\", 1);        List&lt;UserInfo&gt; list = new ArrayList&lt;UserInfo&gt;();        list.add(new UserInfo(\"user001\", \"사용일\"));        list.add(new UserInfo(\"user002\", \"사용이\"));        list.add(new UserInfo(\"user003\", \"사용삼\"));        list.add(new UserInfo(\"user004\", \"사용사\"));        list.add(new UserInfo(\"user005\", \"사용오\"));        list.add(new UserInfo(\"user006\", \"사용육\"));        list.add(new UserInfo(\"user007\", \"사용칠\"));        map.put(\"list\", list);        return map;    }URL로 파라미터 받기//http://localhost:8080/api/parameter?productNo=84313511 이런식의 주소를 넣어야함.     @GetMapping(\"/api/parameter\")    public String getAPIParameter(@RequestParam String productNo){        return \"Received Parameter : \"+productNo;    }    //http://localhost:8080/info/?pcode=17203826&amp;cate=860 //다나와 형태    @GetMapping(\"/info\")    public String getInfo(@RequestParam String pcode, @RequestParam String cate){        return \"pcode : \"+pcode+\" / cate : \"+cate;    }//http://localhost:8080/info/?pcode=17203826&amp;cate=860 //다나와 형태    @GetMapping(\"/info\")    public String getInfo(@RequestParam String pcode, @RequestParam @Nullable String cate){ //@Nullable - null이 올수도 있음        return \"pcode : \"+pcode+\" / cate : \"+cate;    }@GetMapping(\"/myservice/aaa\")    public String getTest(){        return \"aaa\";    }    @GetMapping(\"/myservice/bbb\")     public String getTest2(Model model){        model.addAttribute(\"user\", \"user001\");        model.addAttribute(\"grade\", 1);        return \"bbb\";    }@GetMapping(\"/data/board\")    public Map&lt;String,Object&gt; getPost(){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"board_seq\", 1);        map.put(\"title\", \"글의 제목\");        map.put(\"content\", \"글의 내용\");        return map;    }        @GetMapping(\"data/user_list\")    public Map&lt;String, Object&gt; getjson(){        List&lt;UserInfo&gt; user = new ArrayList&lt;UserInfo&gt;();        user.add(new UserInfo(\"user1\", \"일름\"));        user.add(new UserInfo(\"user2\", \"이름\"));        user.add(new UserInfo(\"user3\", \"삼름\"));        user.add(new UserInfo(\"user4\", \"사름\"));        user.add(new UserInfo(\"user5\", \"오름\"));        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"list\", user);        return map;    }"
  },
  
  {
    "title": "[김영한 스프링 입문] 웹개발 방법",
    "url": "/posts/%EC%9B%B9%EA%B0%9C%EB%B0%9C_%EB%B0%A9%EB%B2%95/",
    "categories": "Spring",
    "tags": "김영한스프링입문, spring",
    "date": "2022-12-05 00:00:00 +0900",
    





    
    "snippet": "웹개발 방법      정적 컨텐츠 : 파일을 웹브라우저에 그대로 내려줌  resources안의 static폴더안에 html을 지정해주면 메소드를 만들지않고  http://localhost:8081/test2.html 처럼 파일명을 그대로 써주면 접속 가능함.            MVC와 템플릿 엔진 : jsp 등 서버에서 프로그래밍해서 html을 동적...",
    "content": "웹개발 방법      정적 컨텐츠 : 파일을 웹브라우저에 그대로 내려줌  resources안의 static폴더안에 html을 지정해주면 메소드를 만들지않고  http://localhost:8081/test2.html 처럼 파일명을 그대로 써주면 접속 가능함.            MVC와 템플릿 엔진 : jsp 등 서버에서 프로그래밍해서 html을 동적으로 바꿔서 내려줌. view와 contoller를 쪼개서 개발  D:\\vscode\\Spring\\demo\\src\\main\\resources\\templates\\pages\\testtemplates.html처럼 파일 경로를 웹에 직접 입력해서 접근 가능함.      &lt;!DOCTYPE html&gt;  &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;  &lt;head&gt;      &lt;meta charset=\"UTF-8\"&gt;      &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;      &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;      &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;p th:text=\"'hello ' + ${name}\"&gt;hello! empty&lt;/p&gt;  &lt;/body&gt;  &lt;/html&gt;          @GetMapping(\"/testmvc\")      public String testMVC(@RequestParam(\"name\") String name, Model model){          model.addAttribute(\"name\", name);          return \"pages/testtemplates\";      }        매개변수 name을 주소로 받음.    http://localhost:8081/testmvc?name=spring 에서 name=spring이 매개변수로 들어감            API : json이라는 데이터 포멧으로 전달      @GetMapping(\"/testapi\")      @ResponseBody //html없미 return을 그대로 표시해줌      public String getapi(@RequestParam(\"name\") String name){          return \"hello \" + name;      }            페이지에 접속해서 소스보기를하면 HTML문서가 뜨지않고 return한 내용이 그대로 표시      @GetMapping(\"/testapi2\")      @ResponseBody      public hello helloapi(@RequestParam(\"name\") String name){          hello h = new hello();          h.setname(name);          return h;      }      static class hello{          private String name;          public String getname() {              return name;          }          public void setname(String name){              this.name = name;          }      }            객체를 return했을때. json방식으로 표시됨        @responseBody를 사용하면 HTML의 BODY에 문자내용을 직접 반환. HttpMessageConverter사 동작 (기본문자처리-StringHttpMessageConverter, 기본 객체처리-MappingJackson2HttpMessageConverter), byte처리 등등 기타 여러 HttpMessageConverter가 기본등록되있음  클라이언트의 HTTP Accept해더와 서버의 컨트롤러 반환타입 정보 둘을 조합해서 HttpMessageConverter가 선택됨.  "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] Spring 환경설정",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/",
    "categories": "Spring",
    "tags": "spring, 국비교육",
    "date": "2022-12-05 00:00:00 +0900",
    





    
    "snippet": "vscode에서 해도됨  [!info] Spring InitializrInitializr generates spring boot project with just what you need to start quickly!https://start.spring.io/Dependencies에서 사진의 3가지 추가 +lombok위 설정으로 generate누르면 ...",
    "content": "vscode에서 해도됨  [!info] Spring InitializrInitializr generates spring boot project with just what you need to start quickly!https://start.spring.io/Dependencies에서 사진의 3가지 추가 +lombok위 설정으로 generate누르면 폴더 다운됨. 다운폴더 압축풀어서 vscode에 열기. 코끼리 안떠도 스프링부트만 뜨면 됨c드라이브 사용자 폴더에 .gradle안에 어지간한건 다 들어있음tomcat이 내장되어있음.DemoApplication에서 프로젝트 실행 후 아래 링크 들어가면  [!info]  http://localhost:8080/뜸❗실행한거 안끄고 또 실행하면 실행안됨.resources안의 application에서 서버 포트 설정 가능실행시 포트번호 바뀜만약 devtools가 있다면 포트번호가 바뀌었을때 자동재실행이됨. 배포전에 지우고 배포해야함resources폴더 안에 banner.txt파일 생성후 배너로 지정할 것을 입력하고 저장하면 실행시 뜨는 Spring이 변경됨https://patorjk.com/software/taag/#p=testall&amp;f=Graffiti&amp;t=Type%20Something%20여기서 양식받을수있음  [!info] Download Postman | Get Started for FreeTry Postman for free!https://www.postman.com/downloads/API 테스트를 위해 포스트맨 설치"
  },
  
  {
    "title": "[권오흠 영리한 프로그래밍을 위한 알고리즘 강좌] 정렬",
    "url": "/posts/%EC%A0%95%EB%A0%AC/",
    "categories": "알고리즘",
    "tags": "알고리즘, 권오흠알고리즘강좌",
    "date": "2022-11-21 00:00:00 +0900",
    





    
    "snippet": "정렬 알고리즘의 유형  Comparison sort          데이터 간의 상태적 크기관계만을 이용해서 정렬 → 데이터간의 크기관계가 정의되어있으면 어떤 데이터에든 적용가능(문자열, 알파벳, 사용자 정의 객체)              버블소트, 삽입정렬, 합병정렬, 퀵소트, 힙정렬 등        — 간단하지만 효율적이지는 않음          ...",
    "content": "정렬 알고리즘의 유형  Comparison sort          데이터 간의 상태적 크기관계만을 이용해서 정렬 → 데이터간의 크기관계가 정의되어있으면 어떤 데이터에든 적용가능(문자열, 알파벳, 사용자 정의 객체)              버블소트, 삽입정렬, 합병정렬, 퀵소트, 힙정렬 등        — 간단하지만 효율적이지는 않음                              selection Sort : 가장 큰 값을 찾아 맨 마지막으로보내는 것을 반복(이미 마지막으로 보낸 값은 제외하고 마지막자리임) → 오름차순정렬              package algorithm;              public class SelectionSort {      public static void main(String[] args) {          int[] a= {2,3,8,6,1,7,9};          selectionSort(a, a.length-1);          for(int i=0;i&lt;a.length;i++){              System.out.println(a[i]);          }      }      public static void selectionSort(int a[],int n) {          while(n&gt;0){              int max = 0;              int idx = 0;              for(int i=n;i&gt;=0;i--){                  if(a[i]&gt;max){                      max = a[i];                      idx = i;                  }              }              int tmp = a[n];              a[n] = max;              a[idx] = tmp;              n--;          }      }  }                        강의 듣고 내가 짜본 코드                                Bubble sort : selection sort와 비슷. 최대값을 찾아 정렬하는 방식에 차이가 있음. 최대값을 찾아서 다음값과 비교 후 다음값이 더 작다면 자리 변경              package algorithm;              public class SelectionSort {      public static void main(String[] args) {          int[] a= {2,3,8,6,1,7,9};          // selectionSort(a, a.length-1);          bubblesort(a, a.length);          for(int i=0;i&lt;a.length;i++){              System.out.println(a[i]);          }      }      public static void selectionSort(int a[],int n) {          while(n&gt;0){              int max = 0;              int idx = 0;              for(int i=n;i&gt;=0;i--){                  if(a[i]&gt;max){                      max = a[i];                      idx = i;                  }              }              int tmp = a[n];              a[n] = max;              a[idx] = tmp;              n--;          }      }      public static void bubblesort(int[] a, int n) {          while(n&gt;=0){              for(int i=0;i&lt;n-1;i++){                  if(a[i]&gt;a[i+1]){                      int tmp = a[i];                  a[i] = a[i+1];                  a[i+1] = tmp;                  }              }          n--;          }      }  }                        역시 강의보고 짜본 코드                                삽입정렬 : 마지막 값을 temp에 저장한 후 배열과 비교해서 있어야할 자리에 삽입함.              public static void insertsort(int[] a, int n) {          for(int i=1;i&lt;n;i++){              int temp = a[i];              int j=i-1;              while(j&gt;=0 &amp;&amp; temp&lt;a[j]){                  a[j+1] = a[j];                  j--;              }              a[j+1] = temp;          }      }                                      — 분할 정복법                              합병정렬(merge sort) : 배열을 절반으로 나눔 → 각각을 순환정렬 → 각각 두개를 합쳐서 전체 정렬 (합칠 떼 값 비교 필요)            분할(작은크기의 동일한 문제들로 분할) → 정복(문제 순환 해결) → 합명(문제들의 해를 합해(merge) 원래문제에 대한 해를 구함)              //p-시작, q-중간, r-끝(length-1)      public static void merge(int[] a, int p, int q, int r) {          int i=p, j=q+1,k=p;          int[] tmp = new int[a.length];          while(i&lt;=q &amp;&amp; j&lt;=r){              if(a[i]&lt;=a[j]){                  tmp[k++] = a[i++];              }else {                  tmp[k++] = a[j++];              }          }           // 앞배열에 남은 값이 있다면 복사          while(i&lt;=q){              tmp[k++] = a[i++];          }          //뒷배열에 남은 값이 있다면          while(j&lt;=r){              tmp[k++] = a[j++];          }          for(i=p;i&lt;=r;i++){              a[i] = tmp[i];          }      }                                            quick sort            분할(기준값[pivot]으로 마지막 값을 설정해 pivot보다 큰값과 작은 값 두개로 나눔) → 정복(각 부분 순환정렬) → 합병            → 인덱스 변수 i(-1으로 시작), j를 두고 마지막 값과 비교해서 작으면 i++후 j와 자리바꾸고 j++., 마지막 값보다 크면 j++후 다음 값 비교              //p-시작, r-끝      public static void quicksort(int[] a, int p,int r) {          if(p&lt;r){              int q = partition(a, p, r); //pivot의 위치              quicksort(a,p,q-1); //왼쪽 배열 정렬              quicksort(a, q+1, r); //오른쪽 배열 정렬          }      }      public static int partition(int[] a, int p, int r) {          int i=p-1;          int pivot = a[r];          for(int j=p;j&lt;r;j++){              if(a[j]&lt;=pivot){                  i++;                  int tmp=a[i];                  a[i]=a[j];                  a[j]=tmp;              }          }          i++;          int tmp = a[i];          a[i] = a[r];          a[r] = tmp;          return i;      }                                            힙 정렬(heap sort)                        heap은 comlpete binary tree면서 heap property를 만족해야함                                          heap property                max heap property : 부모는 자식보다 크거나 작다                min heap property : 부모는 자식보다 작거나 같다                이 강의에서 말하는 heap property는 max heap을 뜻함. 둘은 본질적으로 같은 자료구조임                heap은 동일한 데이터를 가졌다고해서 같은 모양인 것은 아님. = 유일하지않음                                      heap을 일차원 배열로 표현함            → a[1…n]            루트 노드 a[1]            a[i]의 부모 = a[i/2]            a[i]의 왼쪽 자식 = a[2i]            a[i]의 오른쪽 자식 = a[2i+1]                        왼쪽, 오른쪽 부트리(subtree)는 그 자체로도 heap임            ⇒ 부모가 자식보다 작다면 위치를 바꿔줘야함. 변경한 자식 노드(n위치)를 부모노드(n/2 또는 n-1/2 위치)로 재지정해서 재귀하면 됨. 맨 아래 오른쪽부터 위로 올라가면서 비교            for i=n/2에서 1씩 감소하면서 검사                          데이터로 힙 만들기              힙에서 최대값(루트)를 가장 마지막 값과 바꿈              힙의 크기가 1 줄거든 것으로 간주(마지막 값은 힙으로 안침)              루트노드에 대해 heapify(1)              2~4 반복                          public static void heapify (int[] a, int s, int l) {          int leftchild = 2*s+1; //0으로 시작해서 1 더해줌          int rightchild = 2*s+2; //0으로 시작해서 2 더해줌          int large = s; // 부모노드                      //왼자식노드 인덱스가 최대값보다 작고 부모노드가 더 작으면           if(leftchild &lt; l &amp;&amp; a[large]&lt;a[leftchild]){              large = leftchild;          } //부, 자 인덱스 변경          //오자식노드인덱스가 최대값보다 작고 부모노드가 더 작으면          if(rightchild&lt;l &amp;&amp; a[large]&lt;a[rightchild]){              large = rightchild;          }          //매개변수의 부모노드값과 if문을 거친 부모도느 값이 달라졌다면 자리 교체          if(large!=s){              int tmp = a[s];              a[s] = a[large];              a[large] = tmp;              heapify(a, large, l);          }                          }      public static void heapsort(int[] a) {          int size = a.length-1;                      if(size&lt;2){              return;          }          //가장 마지막 노드의 부모 인덱스 번호          int parent = (size-1)/2;                      //max heap 만들기          for(int i=parent;i&gt;=0;i--){              heapify(a, i, size);          }                      //정렬          for(int i=size;i&gt;0;i--){              //0번째와 i번째 인덱스 값을 교환해 max heap을 만든다              int tmp = a[0];              a[0]=a[i];              a[i]=tmp;              heapify(a, 0, i-1); //교환한 마지막 값 제외 heap생성          }      }                                      heap의 응용 : 우선순위 큐                                                      최대 우선순위 큐(maximum priority queue) - FIFO라고 부름                                          INSERT(X) : 새로운 원소 x를 삽입                                                  max heap의 마지막 노드에만 삽입가능. 부모노드보다 크다면 정렬필요                                                                    EXTRACT_MAX() : 최대값을 삭제하고 반환 - 큐 안에 저장된 데이터 중 최대값(루트노드)만 꺼낼 수 있음                                          public static void  max_heap_insert(int[] a, int key) {          size = a.length;          a[size] = key;          int i=size;          int parent = (i-1)/2;          while(i&gt;1 &amp;&amp; a[parent]&lt;a[i]){              int tmp = a[i];              a[i] = a[parent];              a[parent] = tmp;              i=parent;          }      }                                                        최소 우선순위 큐(minimum priority queue)는 EXTRACT-MAX대신 EXTRACT_MIN을 지원                  MAX HEAP을 이용하여 최대 우선순위 큐를 구현                                                                        하한(Lower bound) : comparison sort의 시간복잡도는 o(nlogn)보다 낮을 수 없음      Decision Tree : 정렬을 위해 값을 비교해가는 과정을 트리로 그린 것(leaf node[나올수 있는 경우의 수]는 n!개)        Non-comparison sort          정렬할 데이터에 대한 사전지식을 이용 - 적용에 제한사항있음      Bucket sort : 분류 먼저 하고 정렬      Radix sort      counting sort                  n개의 정수를 정렬. 단 0~k사이의 정수임                      배열 하나를 더 생성해서 해당 값이 위치하는 인덱스를 ++해줌.            → 0부터 값이 있는 개수만큼 출력해주면 될 것 같지만, 값이 여러개인경우(이름, 번호 두가지로 이루어진 배열) 한개의 값만 위치가 바뀌어서 혼동이생길수도있음            ⇒                        (b)에서 누적 합을 구함. (ex.3보다 작은 수는 7개[2+2+3]가 있음            (c)에서 A배열의 8번값은 3임. c배열의 3번값은 7임. 최종 B배열의 7번째 자리에 3을 넣음. 배열 C의 3번값을 1 감소시킴. 반복              public static void countingsort(int[] a,int k) {          int[] c = new int[k];          int[] result = new int[a.length];                      for(int i=0;i&lt;a.length;i++){              c[a[i]]++;          }          for(int i=1;i&lt;c.length;i++){              c[i] += c[i-1];          }          for(int i=a.length-1;i&gt;=0;i--){              int num = a[i];              int idx = c[num]-1;              result[idx] = num;              c[num]--;          }                              for(int i=0;i&lt;result.length;i++){              a[i] = result[i];          }      }                                                  Radix Sort                  n개의 d자리 정수들          가장 낮은 자리수부터 정렬(1의자리수만 비교해서 정렬→10의자리수만 비교해서 정렬→d자리까지 반복)                  //n-배열크기, r-자리수      public static void radix_sort(int n, int[] a, int r) {          Queue&lt;Integer&gt;[] bucket = new LinkedList[BUCKETSIZE];          for(int i=0;i&lt;BUCKETSIZE;i++){              bucket[i] = new LinkedList&lt;&gt;();          }          int factor =1;                  for(int i=0;i&lt;r;i++){              for(int j=0;j&lt;n;j++){                  bucket[(a[j]/factor)%10].add(a[j]);              }              for(int k=0, l=0;k&lt;BUCKETSIZE;k++){                  while(!bucket[k].isEmpty()){                      a[l++] = bucket[k].poll();                  }              }              factor*=10;          }      }                    "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 날짜",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EB%82%A0%EC%A7%9C/",
    "categories": "JAVA",
    "tags": "java, 국비교육",
    "date": "2022-11-09 00:00:00 +0900",
    





    
    "snippet": "substring, splitpublic class UtilitiesEx {  public static void main(String[] args) {    String str = \"Hello world\";    System.out.println(str.substring(0,5));    System.out.println(str.substring(5)...",
    "content": "substring, splitpublic class UtilitiesEx {  public static void main(String[] args) {    String str = \"Hello world\";    System.out.println(str.substring(0,5));    System.out.println(str.substring(5));    String filename = \"data_12346513.dat\";    System.out.println(filename.substring(5));    String imgFile=\"image.jpg\";    String[] split = imgFile.split(\"\\\\.\");    String ext = split[split.length-1];    if(ext.equals(\"jpg\") || ext.equals(\"png\") || ext.equals(\"gif\"));{      System.out.println(\"이미지파일입니다.\");    }  }}Dateimport java.text.SimpleDateFormat;import java.util.Date;public class DateEx {  public static void main(String[] args) {    Date dt = new Date();    System.out.println(dt);    SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd a HH:mm:ss\"); //a - 오전, 오후    System.out.println(f.format(dt));    Date dt2 = new Date(122,10,9); //년, 월, 일, 시, 분, 초 입력가능(단 년은 연도-1900 해야함, 월은 0이 1월임)    System.out.println(f.format(dt2));    // System.out.println(dt2&lt;dt); //안됨. 에러    //자바에서 권장안하나 변수로 사용은 많이함    //1970-01-01부터 지정날짜까지 흐른 시간을 ms단위로 표시    System.out.println(dt.getTime()); //long형. Unix TimeStamp.    System.out.println(dt2.getTime()); //long형 Unix TimeStamp.    Long diff = (dt.getTime()-dt2.getTime())/1000; //ms단위라서 /1000해줌    System.out.println(diff);    System.out.println(diff/60); //분    System.out.println(diff/60/60+\"시\"); //시간    System.out.println(diff/60%60+\"분\"); //시간계산하고 남은 분 표시    Date now = new Date();    long time = now.getTime() + 30*24*60*60*1000L;     Date dt3 = new Date(time);    System.out.println(f.format(dt3));  }}import java.util.Date;import java.util.Scanner;public class DateCounterEx {  public static void main(String[] args) {    Scanner s = new Scanner(System.in);    Date now = new Date(); //현재날짜    System.out.println(\"기준 날짜를 입력하세요\");    System.out.print(\"연도 : \");    Integer year = s.nextInt()-1900;    System.out.print(\"월 : \");    Integer month = s.nextInt()-1;    System.out.print(\"일 : \");    Integer date = s.nextInt();        Date targe = new Date(year, month, date);    long diff = targe.getTime()-now.getTime();    long remain = diff/1000/60/60/24;    String suffix = remain&gt;0?\"일 남음\":\"일 지남\";    System.out.println(Math.abs(remain)+suffix);  }}calendarimport java.util.Calendar;public class CalendarEx {  public static void main(String[] args) {    Calendar c = Calendar.getInstance(); //이미 만들어진 인스턴스를 가져옴    System.out.println(c);    System.out.println(c.getTime()); //Wed Nov 09 17:05:19 KST 2022    c.add(Calendar.DATE,30); //1달 후    System.out.println(c.getTime()); //Fri Dec 09 17:05:19 KST 2022    c.add(Calendar.DATE,-60); //2달전    System.out.println(c.getTime()); //Mon Oct 10 17:06:21 KST 2022    c.set(Calendar.YEAR, 2021);    c.set(Calendar.MONTH, 10); //월은 1    c.set(Calendar.DATE, 9);    System.out.println(c.getTime()); //Tue Nov 09 17:07:24 KST 2021  }}import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.LocalTime;import java.util.ArrayList;import java.util.Calendar;import java.util.List;import java.util.Locale;import java.util.Scanner;public class CalendarEx02 {  public static void main(String[] args) {    Calendar c1 = Calendar.getInstance();    Calendar c2 = Calendar.getInstance();    c2.set(Calendar.MONTH,10);    c2.set(Calendar.DATE, 28);    System.out.println(c2.getTimeInMillis() - c1.getTimeInMillis());    long diff = c2.getTimeInMillis()-c1.getTimeInMillis();     SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd\");    int interval = (int)(diff/1000/60/60/24);    List&lt;String&gt; dates = new ArrayList&lt;String&gt;();    for(int i=0;i&lt;interval;i++){      dates.add(f.format(c1.getTime()));      c1.add(Calendar.DATE, 1);    }     Scanner s = new Scanner(System.in);    System.out.print(\"예약할 날짜 (yyyy-MM-dd) : \");    String strDt = s.nextLine();    if(dates.contains(strDt)){      System.out.println(\"선택한 날짜는 예약할 수 없습니다.\");    }else{      System.out.println(\"선택한 날짜로 예약하였습니다.\");    }    LocalDate ldt = LocalDate.now();    System.out.println(ldt); //2022-11-09 출력    LocalTime ltime = LocalTime.now();    System.out.println(ltime); //17:45:19.156900100 출력  } }"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 예외처리 - 파일입출력",
    "url": "/posts/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC_%ED%8C%8C%EC%9D%BC%EC%9E%85%EC%B6%9C%EB%A0%A5/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 예외",
    "date": "2022-11-08 00:00:00 +0900",
    





    
    "snippet": "예외처리public class ExceptionEx {  public static void main(String[] args) {    int a=10;    int b=0;    int[] arr={10,20};    try {      //예외가 발생할 수도 있는 명령문은 try안에      System.out.println(a/b);      S...",
    "content": "예외처리public class ExceptionEx {  public static void main(String[] args) {    int a=10;    int b=0;    int[] arr={10,20};    try {      //예외가 발생할 수도 있는 명령문은 try안에      System.out.println(a/b);      System.out.println(arr[3]); //ArrayIndexOutOfBoundException발생(위에코드가 예외가 뜨면 작동되지 않음)    // } catch (ArithmeticException e) { //괄호 안쪽은, 처리할 예외의 종류를 씀(산술연산 예외)     //   //a/b했을때 발생할 수 있는 예외 - ArithmeticException이므로, 여기에서 예외처리됨    //   System.out.println(\"0으로 나눌 수 없습니다.\");    }catch(ArrayIndexOutOfBoundsException e){      System.out.println(\"배열범위를 넘어섰습니다.\");    }catch(Exception e){      System.out.println(\"뭔가 터졌다\");    }  }}메소드에서 exception이 발생한다면 메소드에서 try-catch문을 사용해야함만약 메소드에 throws Exception이 있다면 밖에서 처리해줘야함public class ExceptionEx2 {  public static void main(String[] args) /* throws Exception */ { //운영체제로 예외를 던짐 -&gt; 아무 처리하지않은상태와 같음 = 실행불가    // divide(10, 0); //예외처리안해서 에러    try {      divide(10, 0);           } catch (Exception e) {      e.printStackTrace(); //어떤 오류인지 출력. ArithmeticException 출력됨      System.out.println(\"0으로 나눌 수 없음\");      return;    }finally{      System.out.println(\"예외 발생, return과 상관없이 실행\");      //try-catch구문에 return이 있어도 실행이된다. 그 외에는 finally없이 밑에 적어줘도 크게 다르지않음    }  }  public static void divide(int a, int b) throws Exception{ //밖에서 예외를 처리하라는 구문. (밖에서는 무조건 처리해야함.)    // try {      System.out.println(a/b);    // } catch (Exception e) {    //   System.out.println(\"0으로 나눌 수 없음\");    // }  }}보통 프로젝트 말미에 한꺼번에 예외처리함. 제대로 작동하는건지 try-catch가 해결해준건지 구분이안감.public class MyException extends Exception{  @Override  public String getMessage(){  return \"내가 만든 예외 클래스\";  }}import java.util.Scanner;public class ExceptionEx3 {  public static void main(String[] args) throws Exception {    Scanner s = new Scanner(System.in);    while(true){      int n = s.nextInt();      if(n==0){        throw new MyException();        //0이 입력됐을때 예외를 발생시킴. 거의안씀      }    }  }}import java.util.InputMismatchException;import java.util.Scanner;public class ExceptionEx04 {  public static void main(String[] args) {    //Error / Exception    //Error - 에러상황 복구불가    //Complie time -실행파일 만드는 시간 / Runtime - 프로그램 사용 중  시간    //Exception - 에러상황 복구가능    //예외처리 - Exception이 발생했을때 대체코드를 실행함.    // Scanner s = new Scanner(System.in);    // try{    //   System.out.print(\"최소 : \");    //   int min = s.nextInt();    //   System.out.print(\"최대 : \"); //위에서 Exception이 일어나면 실행되지않음    //   int max = s.nextInt();    // }catch(InputMismatchException e){    //   System.out.println(\"정수만 입력가능합니다.\");    // }    // // System.out.println(\"min : \"+min+\" / max : \"+max); //try-catch안에있어서 min, max 사용 불가    // System.out.println(\"실행 후 문자열 출력\");    Scanner s = new Scanner(System.in);    int min=0, max=0;    String input = \"\"; //차라리 String으로 받아서 변환하는게 나을수도있음    input = s.nextLine();        int num = Integer.parseInt(input);    System.out.println(num);    try{      System.out.print(\"최소 : \");      min = s.nextInt();    }catch(InputMismatchException e){      System.out.println(\"정수만 입력가능합니다.\");      min=0;    }finally{      s.nextLine(); //위에서 에러가나서 처리하지못했을때 처리하지못한 문자열을 max가 먹음      //성공여부에 상관없이 finally구분이 필요해짐    }    try{      System.out.print(\"최대 : \");       max = s.nextInt();    }catch(InputMismatchException e){      System.out.println(\"정수만 입력가능합니다.\");      max = 255;    };     System.out.println(\"min : \"+min+\" / max : \"+max);    System.out.println(\"실행 후 문자열 출력\");    s.close();      }  }public class ExceptionEx07 {  public static final int MAX_VAlUE = 255;  public static void main(String[] args) throws Exception{    // try{      myMethod(0);      myMethod(1);      myMethod(2);      myMethod(10);      myMethod(1000);    // }catch(Exception e){    //   System.out.println(e.getMessage());    // }  }  public static void myMethod(int n) throws Exception {    if(n&gt;MAX_VAlUE){      //예외 객체를 만들어서 throw      throw new Exception(\"최대값을 초과합니다. 최댓값 : \"+MAX_VAlUE);    }      System.out.println(\"n : \"+n);  }}      아이디      public class MemberInfo {    public static final int MIN_LENGTH=6;    private String id;    private String pwd;            public String getId() {      return this.id;    }        public void setId(String id) throws Exception {      if(id.length()&lt;MIN_LENGTH){        throw new InputValueLengthException();      }      this.id = id;    }          public String getPwd() {      return this.pwd;    }          public void setPwd(String pwd) throws Exception {      if(pwd.length()&lt;MIN_LENGTH){        throw new InputValueLengthException();      }      this.pwd = pwd;    }      }          public class InputValueLengthException extends Exception {    @Override    public String getMessage() {      return \"Input value's length is must more than 6\";    }        }          public class MemberMain {    public static void main(String[] args) throws Exception {      MemberInfo m = new MemberInfo();      m.setId(\"aaaa\");       m.setId(\"aaaaaaa\");     }  }      파일입출력import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class InputOutputEx {  public static void main(String[] args) throws Exception {    // InputStream input = new InputStream; //추상클래스라서 객체생성 불가    // OutputStream output = new OutputStream(); //추상클래스라서 객체생성 불가    //파일읽어오기    BufferedReader reader = new BufferedReader( //속도향상을 위한 메모리 임시공간 제공      new InputStreamReader(        new FileInputStream(          //상대경로방식의 표현방법(애매함)          //리눅스시스템의 명령어 입력시 많이사용          new File(\"aaa.txt\")           // new File(\"../aaa.txt\") //상위폴더를 가르킴          // new File(\"../../aaa.txt\") //상위폴더의 상위폴더          //절대경로표시법          // new File(\"/aaa.txt\") //드라이브의 최상위(루트디렉토리)를 찾음.(현재예시에서는 D드라이브)          // new File(\"D:/Students/jinhee/aaa.txt\") //드라이브의 최상위(루트디렉토리)를 찾음.(현재예시에서는 D드라이브)        )      )    );    System.out.println(reader.read()); //76출력.     System.out.println((char)reader.read()); //L출력.    System.out.println((char)reader.read()); //o출력.    System.out.println((char)reader.read()); //r출력.    System.out.println((char)reader.read()); //e출력.    System.out.println((char)reader.read()); //m출력.    System.out.println((char)reader.read()); //,출력.    System.out.println((char)reader.read()); //i출력.    System.out.println((char)reader.read()); //p출력.    System.out.println(reader.readLine());//sum dolor sit amet consectetur adipisicing....(생략) 출력. 한줄읽어오기    System.out.println(reader.readLine());    System.out.println(reader.readLine());    System.out.println(reader.readLine());        reader.close(); //꼭 닫아야함    BufferedWriter writer = new BufferedWriter(      new OutputStreamWriter(        new FileOutputStream(          new File(\"bbb.txt\"),true //실행할때마다 hello world추가됨        )      )    );    writer.write(\"hello world\");    writer.flush();    writer.close();  }}엑셀파일로 내보낼때 자주 쓰나 라이브러리가있음..      제품파일      import java.security.PublicKey;      public class Product {    public String name;    public Integer price;    public Integer stock;        @Override    public String toString() {      return name+\",\"+price+\",\"+stock;    }  }          import java.io.BufferedWriter;  import java.io.File;  import java.io.FileNotFoundException;  import java.io.FileOutputStream;  import java.io.OutputStreamWriter;      public class FileEx01 {    public static void main(String[] args) throws Exception {      //출력(파일에 쓰기)      // BufferedWriter w = new BufferedWriter(      //   new OutputStreamWriter(      //     new FileOutputStream(      //       // new File(\"a.txt\")//재실행시 덮어쓰기함.      //       new File(\"a.txt\"),true //true - 뒤에 문자열 추가      //     ), \"UTF-8\" //출력형식 지정      //   )      // );          // w.write(\"안녕하세요\");      // w.close();      // File f = new File(\"b.txt\");      // File f = new File(\"a.txt\");      File f = new File(\"prod.csv\"); //엑셀 파일형식      FileOutputStream os = new FileOutputStream(f);      // OutputStreamWriter osw = new OutputStreamWriter(os, \"MS949\"); //텍스트 엑셀호환타입      OutputStreamWriter osw = new OutputStreamWriter(os, \"UTF-8\"); //터미널출력을위해 UTF-8로 바꿈      BufferedWriter writer = new BufferedWriter(osw);      // writer.write(\"안녕\");      // writer.close();      // writer.write(\"name,price,stock\\r\\n\");      for(int i =0;i&lt;50;i++){        Product p = new Product();        p.name = \"제품\"+i;        p.price = 20000;        p.stock = 100;        writer.write(p.toString()+\"\\r\\n\"); //\"\\r\\n\" - 파일에서 다음 줄로 이동. \\r이 커서를 맨 앞으로 옮김          }      writer.close();              }  }          import java.io.BufferedReader;  import java.io.File;  import java.io.FileInputStream;  import java.io.InputStreamReader;  import java.util.ArrayList;  import java.util.List;  import java.util.Scanner;      public class FileEx02 {    public static void main(String[] args) throws Exception {      //파일 읽어오기      BufferedReader reader = new BufferedReader(        new InputStreamReader(          new FileInputStream(            new File(\"prod.csv\")          ),\"UTF-8\"        )      );      // String line=\"\";      // while(line!=null){      //   line = reader.readLine();      //   System.out.println(line);      // }      List&lt;Product&gt; plist = new ArrayList&lt;Product&gt;();      while(true){        String line = reader.readLine();        if(line == null) break;        String[] split = line.split(\",\");        Product p = new Product();        p.name = split[0];        p.price = Integer.parseInt(split[1]);        p.stock = Integer.parseInt(split[2]);        plist.add(p);        System.out.println(p);        // for(String s : line.split(\",\")){ //길이가 3인 배열 나옴          //   System.out.println(s); //모든 요소가 잘려서 출력          // }        }        for(Product p : plist){          System.out.println(\"제품명 : \"+p.name+\" / 가격 : \"+p.price+\" / 재고 : \"+p.stock);        }        reader.close();                  Scanner s = new Scanner(new File(\"prod.csv\")); //파일안쪽의 내용을 읽는 용도로 Scanner를 사용        while(true){          String line = \"\";          try{            line = s.nextLine();          }catch(Exception e){            break;          }          if(line == null) break;          System.out.println(line);        }        s.close();    }  }      "
  },
  
  {
    "title": "자바의 정석 연습문제 9장 - java.lang패키지와 유용한 클래스",
    "url": "/posts/9%EC%9E%A5/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제",
    "date": "2022-11-07 00:00:00 +0900",
    





    
    "snippet": "[9-1] equals를 맴버변수인 num과 isKwang을 비교하도록 오버라이딩public class Ex9_1{    public static void main(String[] args) {        SutdaCard c1 = new SutdaCard(3, true);        SutdaCard c2 = new SutdaCard(3, tru...",
    "content": "[9-1] equals를 맴버변수인 num과 isKwang을 비교하도록 오버라이딩public class Ex9_1{    public static void main(String[] args) {        SutdaCard c1 = new SutdaCard(3, true);        SutdaCard c2 = new SutdaCard(3, true);        System.out.println(\"c1 = \"+c1);        System.out.println(\"c2 = \"+c2);        System.out.println(\"c1.equals(c2) : \"+c1.equals(c2));    }}class SutdaCard{    int num;    boolean isKwang;    public SutdaCard(){        this(1,true);    }    public SutdaCard(int num, boolean isKwang) {        this.num = num;        this.isKwang = isKwang;    }    public boolean equals(Object obj){        if(obj instanceof SutdaCard){            SutdaCard c = (SutdaCard)obj;            return this.num==c.num &amp;&amp; this.isKwang == c.isKwang;        }else{            return false;        }    }    public String toString(){        return num+(isKwang?\"K\":\"\");    }}먼저 매개변수로 받은 obj가 어떤 클래스인지를 확인한 후 비교해줌[9-2] equals를 오버라이딩해서 멤버변수 x,y,z를 비교하도록 만들고 toSring을 오버라이딩public class Ex9_2 {    public static void main(String[] args) {        Point3D p1 = new Point3D(1,2,3);        Point3D p2 = new Point3D(1,2,3);        System.out.println(p1);        System.out.println(p2);        System.out.println(\"p1==p2?\"+(p1==p2));        System.out.println(\"p1.equals(p2)?\"+(p1.equals(p2)));    }    }class Point3D{    int x, y, z;    Point3D(int x, int y, int z){        this.x = x;        this.y = y;        this.z = z;    }    Point3D(){        this(0,0,0);    }    public boolean equals(Object obj){        if(obj instanceof Point3D){            Point3D p = (Point3D)obj;            return this.x == p.x &amp;&amp; this.y==p.y &amp;&amp; this.z==p.z;        }else{            return false;        }    }    public String toString(){        return \"[\"+x+\", \"+y+\", \"+z+\"]\";    }}위와 동일한 문제[9-3] 문자열을 잘라내는 문제public class Ex9_3 {    public static void main(String[] args) {        String fullPath = \"c:\\\\jdk1.5\\\\work\\\\PathSeparateTest.java\";        String path=\"\";        String fileName = \"\";        path = fullPath.substring(0,14);        fileName=fullPath.substring(15);        System.out.println(fullPath);        System.out.println(path);        System.out.println(fileName);    }}subString을 사용했다답지코드public class Ex9_3 {    public static void main(String[] args) {        String fullPath = \"c:\\\\jdk1.5\\\\work\\\\PathSeparateTest.java\";        String path=\"\";        String fileName = \"\";        // path = fullPath.substring(0,14);        // fileName=fullPath.substring(15);        int pos = fullPath.lastIndexOf(\"\\\\\");        if(pos!=-1){            path = fullPath.substring(0, pos);            fileName = fullPath.substring(pos+1);        }        System.out.println(fullPath);        System.out.println(path);        System.out.println(fileName);    }}subString으로 잘라낸 것은 동일하나 lastIndexOf를 사용해서 마지막 문자열부터 “\\”을 검색해서 가장 뒤쪽에 있는 \\의 위치를 인덱스값으로 받아왔다. (해당 값이 없으면 -1이 반환된다)[9-4]배열의 담긴 값만큼 가로로 입력받은 char형 문자를 찍어내는 메소드를 작성하는 문제public class Ex9_4 {    public static void main(String[] args) {        printGraph(new int[]{3,7,1,4}, '*');    }    public static void printGraph(int[] dateArr, char ch){        for(int i=0;i&lt;dateArr.length;i++){            for(int j=0;j&lt;dateArr[i];j++){                System.out.print(ch);            }            System.out.print(dateArr[i]);            System.out.println();        }    }}[9-5]주어진 문자열에 특정 문자가 몇번 포함되는지 구하는 메소드를 작성하는 문제public class Ex9_5 {    public static void main(String[] args) {        System.out.println(count(\"12345AB12AB345AB\", \"AB\"));        System.out.println(count(\"12345\",\"AB\"));    }    public static int count(String src, String target){        int count=0;        int pos=0;        while(pos&lt;src.length()){            pos=src.indexOf(target, pos);            if(pos!=-1){                count++;                pos += target.length();            }else{                break;            }        }        return count;    }}처음엔 for문을 이용하다가 i값을 pos로 바꿨다가 i++도 의미가 없다는 것을 깨달아서 그냥 while문으로 변경했다. 처음엔 else에 pos++을 넣었다가 무한반복에 빠져서 고민해보니 그냥 종료시키면되는거였다. 한번 검사했는데 없으면 그냥 없는거니까.. 너무 for문에 익숙해져서 실수한것같다.[9-6] 문자열과 문자열의 길이를 받아 오른쪽 정렬로 문자열을 정렬했을때 남는 왼쪽 빈공간에 0을 넣는 메소드를 작성import java.util.Arrays;public class Ex9_6 {    public static void main(String[] args) {        String src = \"12345\";        System.out.println(fillZero(src, 10));        System.out.println(fillZero(src, -1));        System.out.println(fillZero(src, 3));    }    public static String fillZero(String src, int length){        String result=\"\";        if(src==null || src.length()==length){            return src;        }else if( length&lt;=0){            return \"\";        }else if(src.length()&gt;length){            return src.substring(0, length);        }else{            char[] c = new char[length];            Arrays.fill(c, '0');            int idx = src.length()-1;            for(int i=c.length-1;idx&gt;=0;i--)            {                c[i]=src.charAt(idx--);            }            result = String.valueOf(c);            return result;        }    }}되긴되는데 뭔가 for문을 쓰라고 만들어진 문제가 아닌거같은느낌.. arraycopy를 써볼까?import java.util.Arrays;public class Ex9_6 {    public static void main(String[] args) {        String src = \"12345\";        System.out.println(fillZero(src, 10));        System.out.println(fillZero(src, -1));        System.out.println(fillZero(src, 3));    }    public static String fillZero(String src, int length){        String result=\"\";        if(src==null || src.length()==length){            return src;        }else if( length&lt;=0){            return \"\";        }else if(src.length()&gt;length){            return src.substring(0, length);        }else{            char[] c = new char[length];            Arrays.fill(c, '0');            System.arraycopy(src.toCharArray(), 0, c, length-src.length(), src.length());            result = String.valueOf(c);            return result;        }    }}성공했당[9-7] 문자열에 특정 문자열이 있는지 검사하는 메소드public class Ex9_7 {    public static void main(String[] args) {        System.out.println(contains(\"12345\", \"23\"));        System.out.println(contains(\"12345\", \"67\"));    }    public static boolean contains(String src, String target){        if(src.indexOf(target)&lt;0){            return false;        }else{            return true;        }    }}[9-8] 주어진 자리수만큼 반올림하는 메소드를 작성. Math.round와 Math.pow(제곱함수)사용public class Ex9_8 {    public static void main(String[] args) {        System.out.println(round(3.1415, 1));        System.out.println(round(3.1415, 2));        System.out.println(round(3.1415, 3));        System.out.println(round(3.1415, 4));        System.out.println(round(3.1415, 5));    }    public static double round(double d, int n){        return Math.round(d*Math.pow(10, n))/Math.pow(10, n);    }}[9-9] 문자열에서 금지된문자를 제거하고 반환하는 메소드를 작성public class Ex9_9 {    public static void main(String[] args) {        System.out.println(\"(1!2@3^4~5)\"+\" -&gt; \"+delChar(\"1!2@3^4~5\", \"~!@#$%^&amp;*()\"));        System.out.println(\"1 2    3    4\\t5\"+\" -&gt; \"+delChar(\"1 2    3    4\\t5\", \" \\t\"));    }    public static String delChar(String src, String delCh){        String result=\"\";        for(int i=0;i&lt;src.length();i++){            char c = src.charAt(i);            if(delCh.indexOf(c)==-1){                result += c;            }        }        return result;    }}문제에 StringBuffer를 사용하라는데 필요성을 잘 못느끼겠어서 일단 그냥해보았다. append를 써서 없는 문자열을 연결시키면될거같긴한데 굳이 이렇게 할 이유가 있나?public class Ex9_9 {    public static void main(String[] args) {        System.out.println(\"(1!2@3^4~5)\"+\" -&gt; \"+delChar(\"1!2@3^4~5\", \"~!@#$%^&amp;*()\"));        System.out.println(\"1 2    3    4\\t5\"+\" -&gt; \"+delChar(\"1 2    3    4\\t5\", \" \\t\"));    }    public static String delChar(String src, String delCh){        StringBuffer sb = new StringBuffer(src.length());        for(int i=0;i&lt;src.length();i++){            char c = src.charAt(i);            if(delCh.indexOf(c)==-1){                sb.append(c);            }        }        return sb.toString();    }}일단 변환해주었다.[9-10] 문자열을 왼쪽정렬, 가운데정렬, 오른쪽정렬하는 메소드를 작성하라  1차시도(개선필요)import java.util.Arrays;public class Ex9_10 {    public static void main(String[] args) {        String str = \"가나다\";        System.out.println(format(str,7,0));        System.out.println(format(str,7,1));        System.out.println(format(str,7,2));            }    public static String format(String str, int length, int alignment){        if(length&lt;str.length()){            return str.substring(0, length);        }else{            char[] c = new char[length];            Arrays.fill(c, '.');            char[] sarr = str.toCharArray();            String result=\"\";            if(alignment==0){                System.arraycopy(sarr, 0, c, 0, sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else if(alignment==1){                System.arraycopy(sarr, 0, c, c.length/str.length(), sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else if(alignment==2){                System.arraycopy(sarr, 0, c, c.length-str.length(), sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else{                System.out.println(\"번호를 잘못입력하셨습니다\");            }            return result;        }    }}보기좋으라고 c배열을 공백이아닌 .으로 처리했다. 일단 값은 나오는데 배열값이 커지면 뭐랄까.. 3분의 1정도에 위치한다고해야하나.. 이식은 잘못된듯  2차시도(성공)import java.util.Arrays;public class Ex9_10 {    public static void main(String[] args) {        String str = \"가나다\";        System.out.println(format(str,7,0));        System.out.println(format(str,70,1));        System.out.println(format(str,7,2));            }    public static String format(String str, int length, int alignment){        if(length&lt;str.length()){            return str.substring(0, length);        }else{            char[] c = new char[length];            Arrays.fill(c, '.');            char[] sarr = str.toCharArray();            String result=\"\";            if(alignment==0){                System.arraycopy(sarr, 0, c, 0, sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else if(alignment==1){                System.arraycopy(sarr, 0, c, (c.length-str.length())/2, sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else if(alignment==2){                System.arraycopy(sarr, 0, c, c.length-str.length(), sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else{                System.out.println(\"번호를 잘못입력하셨습니다\");            }            return result;        }    }}length가 11이라면 11-x = 4, 7이라면 7-x = 2, 5-x = 1…하면서 여러 식을 써보고있었는데 갑자기 5-str.length는 2인데 /1하면 안되나 하고 다른식에 적용해보았더니 됐다!! 정확히 중간에 위치함[9-11] 입력받은 숫자의 범위만큼 구구단을 출력하는 메소드를 작성하는 문제import java.util.Scanner;public class Ex9_11 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        int start = s.nextInt();        int end = s.nextInt();        gugudan(start, end);            }    public static void gugudan(int start, int end){        for(int i=start;i&lt;=end;i++){            for(int j=1;j&lt;=9;j++){                System.out.println(i+\" x \"+j+\" = \"+i*j);            }            System.out.println();        }    }}간단한 문제다[9-12] 범위를 지정하고 범위 내 랜덤값 뽑는 메소드 작성. 단, 범위 시작보다 범위 끝이 작을 수도 있음public class Ex9_12 {    public static void main(String[] args) {        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, -3)+\",\");        }    }    public static int getRand(int from, int to) {        int r = (int)(Math.random()*to);        return r;    }}일단 일반적으로 하던 방법으로 시도해보았다 당연히 안된다. 나와야하는 값은 1~-3인데 0~-2가 나온다. 범위값을 1추가해주는 것이 좋을 듯 하다. 문제의 main문에 to가 음수이니까 단순히 +1을 해주면 안될것같다.public class Ex9_12 {    public static void main(String[] args) {        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, -3)+\",\");        }    }    public static int getRand(int from, int to) {        int r = (int)(Math.random()*(Math.abs(to)+1));        return r;    }}일단 범위를 보기위해 실행해보았는데 역시 양수로 나온다. 음수로 전환할 방법이 필요하다현 상태에서 나오는 범위는 0~3. 음수로 변환만 해주면 된다. 간단하게 +to를 하면 안되나?public class Ex9_12 {    public static void main(String[] args) {        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, -3)+\",\");        }        System.out.println();        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, 10)+\",\");        }    }    public static int getRand(int from, int to) {        int r = (int)(Math.random()*(Math.abs(to)+1))+to;        return r;    }}음수값은 제대로 나오지만 to에 양수가 나왔을때 범위가10~20이다 음수일떄만 +to를 해주도록 if문을 사용해도 될것같지만.. 뭔가 마음에드는 방법이 아니라 고민이다. 문제를 자세히보니 나오는 범위가 1~-3이다 충격import java.text.Normalizer.Form;public class Ex9_12 {    public static void main(String[] args) {        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, -3)+\",\");        }        System.out.println();        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, 10)+\",\");        }    }    public static int getRand(int from, int to) {        int r = (int)(Math.random()*(Math.abs(to)+1))+(Math.min(from, to));        return r;    }}처음엔 삼항연산자를 사용했다가 Math의 min을 사용해서 더 작은 수를 더하도록 만들었다"
  },
  
  {
    "title": "[SQLD 시험 준비] 최종 정리본",
    "url": "/posts/%EC%B5%9C%EC%A2%85-%EC%A0%95%EB%A6%AC%EB%B3%B8/",
    "categories": "RDBMS",
    "tags": "RDBMS, sql, sqld",
    "date": "2022-11-05 00:00:00 +0900",
    





    
    "snippet": "  성능 데이터모델링 : 분석 및 설계단계부터 성능과 관련한 데이터모델링을 수행함(정규화/반정규화, 테이블분할/병합/추가, 칼럼추가, PK/FK조정, 슈퍼타입/서브타입 조정 등)          데이터 증가가 빠를수록 성능개선비용 증가 → 테이블분할을 하게되는경우 할일이 많아짐      성능을 튜닝하면서 변경되는 특징이 있음      분석/설계단계에서...",
    "content": "  성능 데이터모델링 : 분석 및 설계단계부터 성능과 관련한 데이터모델링을 수행함(정규화/반정규화, 테이블분할/병합/추가, 칼럼추가, PK/FK조정, 슈퍼타입/서브타입 조정 등)          데이터 증가가 빠를수록 성능개선비용 증가 → 테이블분할을 하게되는경우 할일이 많아짐      성능을 튜닝하면서 변경되는 특징이 있음      분석/설계단계에서 하면 비용을 최소화할수있음      고려사항                  용량산정은 성능데이터모델링시 트랜잭션의 유형과 양을 파악가능해서 중요한 작업임          물리적 데이터 모델링시, PK/FK의 칼럼의 순서조정, FK인덱스 생성 등은 성능 향상을 위한 데이터 모델링 작업에 중요한 요소          이력데이터는 반복발생 → 다량데이터일 확률이 높음 ⇒ 특별히 성능을 고려해 칼럼 등을 추가하도록 설계                      트랜잭션          항상 전체를 대상으로 일괄처리 → 전체를 하나의 테이블로 구성(Rollup) (테이블을 서브타입별로 개별유지하면 Union연산에 의해 성능저하 가능성 있음)      항상 서브타입을 개별로 처리 → 서브타입을 개별 테이블로 구성(Rolldown) (테이블을 하나로 통합시 불필요하게 많은 데이터 집적으로 성능저하)      슈퍼+서브타입을 공동초리 → 슈퍼타입 + 서브타입 테이블로 구성(Identity) (개별유지시 조인에의해 성능저하)      — 1:M관계일때 부모테이블에 인덱스가 있더라도 상속받은 테이블도 인덱스가 필요함마찬가지로 FK생성 여부와는 별개로 상속받은 테이블에도 인덱스 생성이 필요함테이블 삭제  TRUNCATE : 테이블 초기상태로, 재사용 가능함. 행만 삭제하는 것. 디스크 초기화. Auto commit  DROP : 완전 삭제. 테이블 자체를 삭제함. Auto commit  DELETE : 로그 남음. 데이터 삭제. 사용자 commit내장함수  1:M관계의 테이블조인시 M쪽에 단일행, 다중행 함수 사용가능  입력행수에따라 단일행 함수와 다중행 함수로 구분          단일행 함수                  추출되는 각 행마다 작업을 수행          각 행마다 하나의 결과를 반환          단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET절에 사용 가능          데이터타입 변경가능          중첩사용 가능                    다중행 함수                  여러개의 인수가 입력되어도 단일값만을 반환          그룹집계함수 (SUM, AVG, MAX, MIN…)                    순위  top n with ties : 동일데이터 모두 출력  rank() over() : 1 1 3 4 4 6  row_number() over : 같은순위 다른순위로 나타냄  dense_rank() over : 1 1 2 3 3 4순수관계연산자  SELECT(가로)  JOIN  DIVIDE  PROJECTION(세로)USING절: 왼쪽 테이블이 각 열이 오른쪽 테이블에 있는 동일이름의 열과 비교되는 결합조건USING (PROJNO, ACTNO)= ON CORPDATA.PROJACT.PROJNO = CORPDATA.EMPPROJACT.PROJNOAND CORPDATA.PROJACT.ACTNO = CORPDATA.EMPPROJACT.ACTNO같은거임집합연산자                   sql      oracle                  교집합             INTERSECT              차집합      EXCEPT      MINUS              합집합             UNION      계층형 질의  sql에서는 CTE를 재귀호출함으로써 계층구조를 전개  sql에서는 앵커멤버를 실행해서 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행  oracle의 where절은 모든 전개를 진행한 후 필터 조건으로서 조건을 만족하는 데이터만 추출  oracle의 PRIOR키워드는 CONNECT BY, SELECT, WHERE절에서 사용가능서브쿼리  단일 행 또는 복수행 비교연산자와 사용가능  SELECT절, FROM절, HAVING절, ORDER BY절 등에서 사용 가능  단일행 결과를 반환하는 경우 ‘=’, ’≥’, ’≤’등의 연산자와 사용 가능  다중 행 비교연산자는 IN, ALL 등이있다  다중행 서브쿼리 비교연산자는 단일 행 서브쿼리의 비교연산자로도 사용가능  연관(Correlated) 서브쿼리: 서브쿼리가 메인쿼리칼럼을 포함하고 있는 형태의 서브쿼리, 메인쿼리에서 값을 제공받음  Oracle은 다중칼럼 서브쿼리를 지원하지만 SQL은 지원하지않음  스칼라 서브쿼리 : JOIN으로 동일한 결과 추출가능  동적 뷰 : SQL 문장 중 테이블명이 올 수 있는 곳에 사용가능뷰(view)  필요한 정보를 테이블로 추출하는 SQL만을 저장함  데이터 구조 단순화  단지 정의만 가지고 있으며 실행시점에 질의를 재작성하여 수행  복잡한 SQL문장을 단순히 저장.  테이블구조 변경에 의한 영향으로부터 응용프로그램을 분리  보안목적으로도 사용가능  실제 데이터를 저장하고있는 뷰를 생성하는 기능을 지원하는 DBMS도 있음  user에게 단순한 인터페이스 제공그룹함수결과건수가 줄어든다ROLLUP  ROLLUP(A,B) : A,B그룹바이기준으로 해서 (A,B), A를 그룹바이 기준으로 해서 (A,null), 아무기준없이 전체를 기준으로 (null,null) 총 세가지의 값을 모두 조회  칼럼의 순서에 따라 다른결과가 출력되는 것GROUPING SETS  칼럼의 순서가 중요하지 않음.  각 함수의 인자로 주어진 칼럼 중 집계기준이 되는 칼럼 이외의 칼럼은 NULL값이 반환  각각의 합계를 출력CUBE  각 함수의 인자로 주어진 칼럼 중 집계기준이 되는 칼럼 이외의 칼럼은 NULL값이 반환  인자로 주어진 칼럼의 결합가능한 모든 조합에 대해 집계 → 다른 그룹함수에 비해 부하가 큼  모든 경우의 수에 대해 소계화 합계를 출력Grouping  해당 칼럼이 그룹화되어있다면 1, 아니면 0을 반환. CASE와 함께 씀윈도우 함수  적용범위가 partition을 넘을 수 없음  그룹함수가 먼저 실행된 후 윈도우 함수가 실행.  rangeRANGE between 1000 PERCECDING and 1000 FOLLOWING → -1000~+1000 사이에 존재하는 ~의 개수lag(), lead()  lag() : 앞의 값 찾기  lead() : 뒤의 값 찾기PL/SQL  변수와 상수 등을 사용해서 일반 SQL문장을 실행시 WHERE절 조건으로 대입 가능  procedure, User defined function, Trigger객체 생성가능 → 트랜잭션 분할 가능. 각 트랜잭션 별로 프로시저, UDF를 호출 가능  Procedure내부에 작성된 절차적코드 처리 (일반적인 SQL문장은 SQL실행기가 처리해줌)— EXECUTE IMMEDIATE ‘TRUNCATE TABLE 테이블명’ → 테이블의 모든 데이터를 롤백이 불가능하도록 삭제  절차형 SQL모듈          logic과 함께 데이터베이스에 저장한 명령문의 집합. CREATE PROCEDURE명령을 사용해서 생성      사용자함수는 다른 SQL문을 통해 호출되고 그 결과를 리턴. SQL의 보조적인 역할 - CREATE FUNCTION명령을 사용해서 생성      Trigger                  DML문이 수행되면 데이터베이스에서 자동으로 동작하도록 작성된 프로그램.          데이터의 무결성과 일관성 유지가능          CREATE TRIGGER 명령을 사용해서 생성.          데이터베이스에 로그인하는 작업에도 정의 가능          롤백안됨          테이블, 뷰에만 트리거를 작성(데이터베이스에선 안됨)                    JOIN  인라인뷰 안에서 뷰 바깥의 테이블과 Join불가  PK와 FK값의 연관성에 의해 성립된다.  DBMS절의 옵티마이저는 from절에 나열된 테이블들을 임의로 2개씩 묶어서 Join처리함  Equi join은 join에 관여하는 테이블간의 칼럼값들이 정확하게 일치하는 경우에 사용하는 방법  EQUI JOIN은 ‘=’연산자에 의해서만 수행되며, 그 이외의 비교연산자를 사용하는 경우에는 모두 Non EQUI JOIN임  설계상의 이유로 Non EQUI JOIN이 불가능한 경우도 있음  테이블사이에 JOIN조건이 없는 경우 카타시안 곱 발생  NATURAL JOIN에서 OWNER 명을 사용하면 에러 발생CROSS JOIN: 한쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 조인. → 최종 결과개수 = 두 테이블의 행의 개수를 곱한개수⇒ FROM EMP,DEPT = FROM EMP CROSS JOIN DEPTself join  한 테이블 내에서 두 칼럼이 연관 관계에 있을때 사용Nested Loops Join중첩for문같은느낌 - 인덱스구성전략이 매우 중요, 대량테이블에는 비효율적  조인 칼럼에 적당한 인덱스가 있어서 자연조인(Natural join)이 효율적일때 유리.  Driving테이블의 조인 데이터양이 큰 영향을 줌  유니크 인덱스를 활용하여 수행시간이 적게걸리는 소량테이블을 온라인조회할때 유용  조인조건의 인덱스 유무에 영향을 많이 받음  선택도가 낮은(결과 행의 수가 적은)테이블이 선행테이블로 선택되는것이 유리Sort Merge Join  조인 칼럼에 적당한 인덱스가 없어서 자연조인이 비효율적일때 사용  Driving테이블의 영향을 받지 않음  조인조건의 인덱스 유무에 영향받지않음  equal join이 아니라 범위조인할때 효율적Hash Join대용량테이블에쓰면 좋음. key컬럼에 중복이없을수록 유리. hash영역에 올라가는 테이블의 크기가 작아야함  해싱기법을 이용해 조인을 함  DW등 데이터집계업무에서 많이 사용  EQUI(=) 조인조건에서만 동작한다.  한쪽 테이블이 주 작고 해시 키 속성에 중복값이 적을 때 효과적  조인 칼럼에 적당한 인덱스가 없어서 자연조인이 비효율적일때 사용  자연조인시 드라이빙 집합쪽으로 조인 엑세스 량이 많아 랜덤 엑세스 부하가 심할때 사용  소트머지조인을 하기에는 두 테이블이 너무 커서 소트부하가 심할때 사용          동등조인(Euqi Join)에서만 사용가능 → 제약존재        작은테이블을 먼저 읽으면 부하가 심해짐— EXISTS(긍정) → SEMI JOIN— NOT EXISTS(부정) → ANTI JOIN옵티마이저실행계획을 만들어주는 역할  실행계획 : SQL처리를 위한 실행절차와 방법을 표현. 시각적으로 표현해줌          알수있는 정보                  엑세스 기법          질의 처리 예상비용          조인방법, 순서                    실행순서 : 안에서 밖으로, 위에서 아래로      동일 SQL문에대해 실행계획이 다르면 Performance가 달라질수있음      Oracle의 실행계획에 나타나는 기본적인 join기법에는 NL Join, Hash Join, Sort Merge Join등이 있음      CBO: 비용기반 실행계획, SQL문 실행시 소요될 처리시간, CPU, I/O 자원량 등을 계산하여 가장 효율적일 것으로 예상되는 실행계획을 선택하는 옵티마이저. 단계별 예상 비용 및 건수 표시  객체의 통계정보를 사용하여 실행계획 수립 → 통계정보 변경 시 SQL의 실행계획이 달라질수도 있음RBO: 규칙기반 실행계획.  제일 높은 우선순위는 행에대한 고유주소 사용하는 방법임  인덱스 스캔이 항상 유리함, 적절한 인덱스가 있다면 무조건 사용하려함  Single row by rowid엑세스 기법이 가장 우선순위가 높음인덱스  B-Tree - 관계형 데이터베이스의 주요 인덱스 구조. 일반적으로 OLTP시스템 환경에서 가장 많이 사용. 일치 및 범위검색에 적절한 구조임          branch block : 분기를 목적      leaf block : 인덱스 구성하는 칼럼의 값으로 정렬        CLUSTERED : 인덱스의 leaf페이지가 곧 데이터 페이지, 모든 데이터는 인덱스 키 칼럼순으로 물리적으로 정렬  BUTMAP : 시스템에서 사용될 질의를 시스템 구현시에 모두 알 수 없는 경우인 DW 및 AD-HOC질의 환경을 위해 설계, 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조  인덱스 범위 스캔 시 결과가 없으면 한 건도 반환하지않을 수도 있음  인덱스 조건 중 ‘=’가 사용된 칼럼이 앞쪽에 위치하는것이 효율적임  SQL의 클러스터형 인덱스틑 ORACLE의 IOT와 매우 유사함SELECT - 스칼라 서브쿼리FROM - 인라인뷰WHERE - 서브쿼리(자유롭게 사용못함)CHARACTER :고정길이 문자열, S만큼 최대길이(그보다 작을시 공백으로 채운다.), 서로 길이가 달라도 같은 내용으로 판단1 PRECEDING / 1 FOLLOWING - 현재행을 기준으로 이전행+현재+다음행 합계를 표시인덱스 생성구문 - createANY (다수의 비교값 중 하나라도 만족하면 TRUE)      트랜잭션 특징    원자성 일관성 고립성 지속성        순위 1 2 3 3 4 5    DENSE_RANK        부모삭제시 자식도 삭제    CASCADE        계층쿼리에서 형제노드간의 정렬을 지정    ORDER SIBLINGS BY        엔터티의 일반 속성간에는 서로 종속되지 않음    제 3정규형        관계의 표기법에 표현되는 개념 3가지    관계명, 관계차수(1:M:), 관계선택사양        SUMMER 테이블 이름 FALL로 변경    RENAME SUMMER TO FALL;        카타시안곱    CROSS JOIN        이름같은 칼럼 기준 EQUIJON    NATURAL JOIN        SELECT SIGN(-77) FROM DUAL;    -1. 음수면 -1, 0이면 0, 양수면 1        날짜 문자열로 변환    TO_CHAR  "
  },
  
  {
    "title": "[SQLD 시험 준비] 스피드 퀴즈",
    "url": "/posts/%EC%8A%A4%ED%94%BC%EB%93%9C%ED%80%B4%EC%A6%88/",
    "categories": "RDBMS",
    "tags": "RDBMS, sql, sqld",
    "date": "2022-11-04 00:00:00 +0900",
    





    
    "snippet": "드래그하면 답 나옴      모델링의 특징    추상화 명확화 단순화        각 속성이 가질 수 있는 값의 범위    도메인        DCL에 속하는 명령어    Grant, revoke        DDL    ALTER, CREATE, RENAME, DROP        SELECT시 중복제거    DISTINCT        트랜잭션 특...",
    "content": "드래그하면 답 나옴      모델링의 특징    추상화 명확화 단순화        각 속성이 가질 수 있는 값의 범위    도메인        DCL에 속하는 명령어    Grant, revoke        DDL    ALTER, CREATE, RENAME, DROP        SELECT시 중복제거    DISTINCT        트랜잭션 특징    원자성 일관성 고립성 지속성        독립성 편리성 보안성    view        순위 1 2 3 3 4 5    DENSE_RANK        교집합 연산자    INTERSECT        NULIF(’A’,’A’)    A가A면 NULL.        SELECT문의 순서    FROM WHERE GROUP BY HAVING SELECT ORDER BY        부모삭제시 자식도 삭제    CASCADE        계층쿼리에서 형제노드간의 정렬을 지정    ORDER SIBLINGS BY        SELECT절에 오는 서브쿼리?    스칼라 서브쿼리        FROM절에 오는 서브쿼리    인라인 뷰        엔터티의 일반 속성간에는 서로 종속되지 않음    제 3정규형        관계의 표기법에 표현되는 개념 3가지    관계명, 관계차수(1:M:), 관계선택사양  SUMMER 테이블 이름 FALL로 변경RENAME SUMMER TO FALL;      다양한 권한을 그룹으로 묶어 관리    ROLE        카타시안곱    CROSS JOIN        그룹함수    ROLLUP CUBE GROUPING SETS        INSERT, UPDATE 한번에    MERGE INTO        차집합    MINUS        이름같은 칼럼 기준 EQUIJON    NATURAL JOIN        SELECT SIGN(-77) FROM DUAL;    -1        GROUP BY할때 조건절    HAVING        날짜 문자열로 변환    TO_CHAR  "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 컬렉션 프레임워크 2",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EC%BB%AC%EB%A0%89%EC%85%98%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC2/",
    "categories": "JAVA",
    "tags": "java, 국비교육, collection",
    "date": "2022-11-03 00:00:00 +0900",
    





    
    "snippet": "Hash Map!!프론트엔드에 데이터를 넘겨줄때 사용이걸로 출력하면 JSON으로 출력됨.import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class MapEx{  public static void main(String[] args) {    //Key,...",
    "content": "Hash Map!!프론트엔드에 데이터를 넘겨줄때 사용이걸로 출력하면 JSON으로 출력됨.import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class MapEx{  public static void main(String[] args) {    //Key, Value    //특정 key에 특정 값을 mapping(연결)    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();    map.put(\"asdf\", 1234); //추가    System.out.println(map); //{asdf=1234}    map.put(\"ffff\", 1111); //추가    System.out.println(map); //{asdf=1234, ffff=1111}    System.out.println(map.get(\"asdf\")); //1234 출력 키 값 \"asdf\"의 value 가지고오기    System.out.println(map.get(\"ffff\")); //1111 출력 키 값 \"ffff\"의 value 가지고오기    //key를 넣으면 연결된 값이 나옴    map.put(\"asdf\", 100); //변경    System.out.println(map); //{asdf=100, ffff=1111} 이미 있는 asdf에 100을 새로 연결시킴.    //Map에서 key값은 중복을 허용하지 않음.    map.put(\"ASDF\", 50); //추가    System.out.println(map); //{asdf=100, ASDF=50, ffff=1111} 대문자, 소문자는 따로 연결됨.    //같은 put이라도 추가, 변경이 나뉨.    map.put(\"a\", 100);    map.put(\"A\", 100);    System.out.println(map); //{a=100, A=100, asdf=100, ASDF=50, ffff=1111} 정확한 기준은 모르지만 추가순으로 추가되는것은 아님    //데이터의 순서가 중요하면 사용하면 안됨        Map&lt;String, Integer&gt; mapLink = new LinkedHashMap&lt;String, Integer&gt;(); //추가한 순서대로 추가가됨.    mapLink.put(\"c\", 123);    mapLink.put(\"A\", 123);    mapLink.put(\"b\", 123);    System.out.println(mapLink); //{c=123, A=123, b=123} 입력순    Map&lt;String, String&gt; user = new LinkedHashMap&lt;String, String&gt;();    user.put(\"id\", \"user001\");    user.put(\"pwd\",\"123456\");    System.out.println(user); //{id=user001, pwd=123456}    Map&lt;String,Integer&gt; dataMap = new LinkedHashMap&lt;String, Integer&gt;();    for(int i=0;i&lt;10;i++){      dataMap.put(\"data\"+i, i);    }    System.out.println(dataMap); //{data0=0, data1=1, data2=2, data3=3, data4=4, data5=5, data6=6, data7=7, data8=8, data9=9}    for(int i=0;i&lt;10;i++){      System.out.print(dataMap.get(\"data\"+i)+\", \"); //0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 출력. 일치하는 key의 value출력    }    System.out.println();    Map&lt;String,Integer&gt; dataMap2 = new LinkedHashMap&lt;String, Integer&gt;();    dataMap2.put(\"ab\", 10);    dataMap2.put(\"gdfafa\", 10);    dataMap2.put(\"ghfsqw\", 10);    dataMap2.put(\"hfsvs\", 10);    dataMap2.put(\"hthcae\", 10);    System.out.println(dataMap2); //{ab=10, gdfafa=10, ghfsqw=10, hfsvs=10, hthcae=10} 출력    //key의 규칙이 없어서 일반 반복문으로는 조회불가    System.out.println(dataMap2.keySet()); //[ab, gdfafa, ghfsqw, hfsvs, hthcae] 출력. key값의 배열    System.out.println(dataMap2.keySet().toArray()); //[Ljava.lang.Object;@5305068a 출력    //키 값에 대한 Object 배열을 저장    Object[] keys = dataMap2.keySet().toArray();    for(Object k : keys){ //keys배열을 순차 조회      System.out.print(k+ \", \"); //ab, gdfafa, ghfsqw, hfsvs, hthcae, 출력      //조회한 object를 문자열로 변환, 출력    }    for(Object k : keys){       System.out.println(k.toString()); //ab, gdfafa, ghfsqw, hfsvs, hthcae, 출력      System.out.println(dataMap2.get(k.toString())); //10 10 10 10 10 출력    }    //일반적인 방법이 아님. 가능은 하다 정도  }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 객체지향언어 2",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A52/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 객체",
    "date": "2022-11-03 00:00:00 +0900",
    





    
    "snippet": "상속 : 클래스의 확장. 프레임워크를 개발할때 많이사용함. 그외에는 잘안씀해당 클래스를 아무도 상속받지못하게하려면 final을 사용하면됨포함 : 클래스안에 클래스. 대표적으로 String      도형      public class Point {    int x,y;    public Point(){}    public Point(int x, int...",
    "content": "상속 : 클래스의 확장. 프레임워크를 개발할때 많이사용함. 그외에는 잘안씀해당 클래스를 아무도 상속받지못하게하려면 final을 사용하면됨포함 : 클래스안에 클래스. 대표적으로 String      도형      public class Point {    int x,y;    public Point(){}    public Point(int x, int y){      this.x = x;      this.y = y;    }    void printPoint(){      System.out.println(\"(\"+x+\", \"+y+\")\");    }      }          public class Point3D extends Point {    int z;    public Point3D(){}    public Point3D(int x, int y, int z){      super(x,y);      this.z = z;    }    void printPoint(){      System.out.println(\"(\"+x+\", \"+y+\", \"+z+\")\");    }      }          public class Circle extends Point {    double r;    public Circle(){}    public Circle(int x, int y, double r){      super(x, y);      this.r = r;    }    double getArea(){      return r*r*Math.PI;    }    void printPoint(){      System.out.println(\"(\"+x+\", \"+y+\") r: \"+r);    }  }          public class Rectangle extends Point {    int width;    int height;    public Rectangle(){}    public Rectangle(int x, int y, int width, int height){      super(x, y);      this.width = width;      this.height = height;    }    int getArea(){      return width * height;    }    void printPoint(){      System.out.println(\"(\"+x+\", \"+y+\") w: \"+width+\" / h: \"+height);    }  }            USB      import java.util.ArrayList;  import java.util.Date;  import java.util.List;      public class USBMain {    public static void main(String[] args) {      USBDevice d1 = new USBMouse(\"A\",\"2.0\",\"laser\",\"no\");      d1.input();      d1.output(); //오버라이딩 본문안에 구현을 안해놔서 상위클래스의 output실행      // d1.mousewheel(); //에러. USBDevice에는 mousewheel없음      // d1.sensor;//안됨. USBDevice에서는 하위클래스의 메소드 유무를 판단할수없음      ((USBMouse)d1).mousewheel();      ((USBMouse)d1).wireless=\"asd\";              List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //List가 부모, ArrayList가 자식. 상속과 다형성.       //LinkedList로 바꿔도 작동했던게 list는 부모클래스인 List의 변수라서              Object obj = new String(\"aaa\");      Object obj1 = new Date();      Object obj2 = new ArrayList&lt;String&gt;();      Object obj3 = new USBMouse();          // obj.add(\"a\"); //불가능      // obj3.input(); //불가능      System.out.println(obj.toString()); //Object로 유일하게 가능한 것      System.out.println();              System.out.println(obj); //aaa      System.out.println(obj1); //Thu Nov 03 16:50:44 KST 2022      System.out.println(obj2); //[]      System.out.println(obj3); //USBMouse@1b28cdfa -&gt; 오버라이딩 후 : 마우스 정보 출력 출력됨      //오버라이딩 된 toString이 있다면 해당 toString형식에 맞춰서 출력됨            }  }            직업 상속      public class Person {    String name;    String gen;        public Person(){}    public Person(String name, String gen){      this.name = name;      this.gen = gen;    }        void work(){      System.out.println(\"일을 시작합니다.\");    }        public String toString() {      return \"이름 : \"+name+\" / 성별 : \"+gen;    }  }          public class Developer extends Person {    String language; //프로그래밍언어        public Developer(){      //super()가 생략된 상태. 다 만들거나 다 만들지 말거나    }    public Developer(String name, String gen, String language){      super(name, gen);      this.language = language;    }    @Override    void work(){      super.work();      System.out.println(\"개발자 \"+name+\"가(이) \"+language+\"(으)로 프로그램을 개발한다.\");    }  }          public class Designer extends Person {    String tool; //사용 툴        public Designer(){      //super()가 생략된 상태. 다 만들거나 다 만들지 말거나    }    public Designer(String name, String gen, String tool){      super(name, gen);      this.tool = tool;    }        @Override    void work(){      super.work();      System.out.println(\"디자이너 \"+name+\"가(이) \"+tool+\"(으)로 디자인을 한다.\");    }  }          public class PersonMain {    public static void main(String[] args) {              Person[] persons ={        new Person(\"박진희\", \"여\"),        new Designer(\"박진희\", \"여\",\"photoshop\"),        new Developer(\"박진희\", \"여\",\"JAVA\")      };      for(Person p : persons){        System.out.println(p.toString());        p.work();        System.out.println();      }       /*이름 : 박진희 / 성별 : 여      일을 시작합니다.                이름 : 박진희 / 성별 : 여        일을 시작합니다.        디자이너 박진희가(이) photoshop(으)로 디자인을 한다.                  이름 : 박진희 / 성별 : 여        일을 시작합니다.        개발자 박진희가(이) JAVA(으)로 프로그램을 개발한다.*/ //출력됨                  //Person클래스 타입으로 Developer, Designer 클래스 타입의 객체를 생성가능 : 다형성. 상속관계에서만 사용가능        Person p1  = new Person(\"박진희\", \"여\");        Person p2 = new Designer(\"박진희\", \"여\",\"photoshop\");        Person p3 = new Developer(\"박진희\", \"여\",\"JAVA\");        p1.work(); //Person의 work실행        p2.work(); //Designer의 work실행        p3.work(); //Developer의 work실행        //기존클래스 Person의 work를 Developer와 Designer에서도 만들어줬다(재정의) : 오버라이딩          }  }            동물      public class Animal {    String name;    String color;    public Animal(){}    public Animal(String name, String color){      this(); //생성자. 위의 매개변수없는 기본생성자를 가르킴. 맨위에 써줘야함      // this(name, color); //무한반복에걸려서 에러      //this 포인터      // this; //현재 이 클래스 전체를 의미      if(name.length()==0){        this.name = \"동물\";      }else{        this.name = name;      }      this.color = color;      // this.someMethod();    }    // public void someMethod(){    //   System.out.println(\"some Method\");    // }        void makeSound(){      System.out.println(\"동물 \"+name+\"이(가) 소리를 냅니다.\");    }  }          public class Cat extends Animal {    String gen;    public Cat(){}    public Cat(String name, String color, String gen){      super(name, color);      this.gen = gen;    }        void makeSound(){      System.out.println(gen+\"고양이 \"+name+\"이(가) 야옹소리를 냅니다.\");    }  }          public class Dog extends Animal { //dog is a animal    String size;    public Dog(){}    public Dog(String name, String color, String size){      super(name, color); //Animal클래스안에 제약사항이 있어서 상위클래스에서 처리하는것이 효율적임.      this.size = size;    }    @Override //오버라이딩, 기능재정의    // dog타입의 객체들은 Animal클래스의 makeSound를 실행하지않고 아래의 makeSound를 실행함    void makeSound(){      System.out.println(size+\"견 \"+name+\"이(가) 멍멍 짖습니다.\");    }        }          public class Lion extends Cat{    Integer age;    public Lion(){}    public Lion(String name, String color, String gen, Integer age){       super(name, color, gen);      this.age = age;    }        @Override    void makeSound() {      System.out.println(gen+\"사자 \"+name+\"이(가) 어흥하고 소리를 냅니다.\" );    } //오버라이딩안해주면 Cat클래스의 makesound를 실행함.        }          import java.util.ArrayList;  import java.util.LinkedHashMap;  import java.util.List;  import java.util.Map;      public class AnimalMain {    public static void main(String[] args) {      //변수타입 - Animal / 객체타입 - Animal      Animal a = new Animal(\"동물1\", \"흰색\");      a.makeSound();      //변수타입 - Dog / 객체타입 - Dog      Dog d = new Dog(\"멍멍이\", \"검정\", \"중형\");      d.makeSound();      //변수타입 - Animal / 객체타입 - Dog  -&gt; 다형성.       Animal a1 = new Dog(\"강쥐\", \"흰색\", \"소형\");      a1.makeSound();          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); //key - String, value - object      map.put(\"animal\", a);      map.put(\"dog\", d);      List&lt;String&gt; list = new ArrayList&lt;String&gt;();      list.add(\"1\");      list.add(\"2\");      list.add(\"3\");      map.put(\"list\",list);      map.put(\"integer\", 123);      System.out.println(map);  //{animal=Animal@5305068a, dog=Dog@1f32e575, list=[1,2,3], integer=123} 출력      // 집어넣는건 가능한데 꺼낼때 곤란해짐. 형변환도 정확하지않으면 에러남      // 프론트엔드에 넘겨주면 됨. JSON에서는 보임          Animal a2 = new Cat(\"냥이\", \"삼색\", \"암컷\");          a2.makeSound();          List&lt;Animal&gt; aniList = new ArrayList&lt;Animal&gt;();      aniList.add(a);      aniList.add(a1);      aniList.add(a2);      aniList.add(new Lion(\"사자\", \"누렁이\", \"암컷\", 5));       System.out.println(\"---------------------\");      for(Animal am : aniList){        am.makeSound();        System.out.println();      }      System.out.println(\"---------------------\");      Cat l = new Lion(\"사장\", \"노랑\", \"수컷\", 11);      l.makeSound();            // Lion a3 = new Animal(\"동뮬\", \"갈색\"); //불가능.       //하위클래스(Sub Class)타입으로 상위클래스(Super Class) 타입의 객체를 저장할 수 없음        }  }      object는 모든 객체의 최고 조상. 컬렉션프레임워크에서 많이쓰임집어넣는건 가능한데 꺼낼때 곤란해짐. 형변환도 정확하지않으면 에러남프론트엔드에 넘겨주면 됨. JSON에서는 보임package : 폴더. 다른패키지면 이름이 같아도 됨. 대신 위에 어느패키지인지 import문을 사용해서 표시해줘야함. 동시에 다른패키지 두개 import사용불가.아니면 import쓰지말고 앞에 패키지.클래스이름 사용개발시 각자 다른패키지를 사용함.대표적으로 Date클래스가있음설정 - compact folders 해제할것.import 폴더.폴더.폴더;Call By Value - 원본수정 불가능. 파라미터가 기본형일때public class CbrCbv {  public static void change(String str) { //Call By Value    str+=\"456\";       }  public static void main(String[] args) {    String str=\"ABC123\";    change(str);    System.out.println(str);  }}public class CbrCbv {  public static String change(String str) { //Call By Value    str+=\"456\";     return str;  }  public static void main(String[] args) {    String str=\"ABC123\";    str = change(str);    System.out.println(str);  }}Call By Reference - 원본수정 가능.public class CbrCbv {  public static void a(int[] arr) {    arr[0] = 100;      }  public static void main(String[] args) {    int[] arr = {10,20};    a(arr);    System.out.println(arr[0]);  }}주소값을 줘서 객체의 값도 바뀜. 파라미터가 참조형일때메소드는 public, 멤버변수는 private      접근제어자      package JAVA4;      public class Product {    // String name;    // public String sub_title;    // protected Integer price;    // private Integer stock;        private String name;    private String sub_title;    private Integer price;    private Integer stock;        public Product(){}    public Product(String name, String sub_title, Integer price, Integer stock){      setName(name);      setSub_title(sub_title);      setPrice(price);      setStock(stock);    }        public String getName() {      return this.name;    }        public void setName(String name) {      this.name = name;    }        public String getSub_title() {      return this.sub_title;    }        public void setSub_title(String sub_title) {      this.sub_title = sub_title;    }        public Integer getPrice() {      return this.price;    }        public void setPrice(Integer price) {      this.price = price;    }        public Integer getStock() {      return this.stock;    }        public void setStock(Integer stock) {      this.stock = stock;    }        // void showStock(){    //   System.out.println(\"재고 : \"+stock+\"개\");    // }              }          package JAVA3;      import JAVA4.Product;      public class Main {    public static void main(String[] args) {      // Product p = new Product();      // p.name = \"제품\"; //default. 클래스파일을 다른곳으로 옮기니 에러      // p.sub_title = \"제품간략설명\"; //public      // p.price = 10000; //protected/ 같은 폴더위치에서는 사용가능, 클래스파일을 다른곳으로 옮기니 에러      // p.stock = 100; 에러. private라서 안됨. 클래스내에 메소드를 만들어야 접근가능      // p.showStock();//클래스파일을 다른곳으로 옮기니 에러          //default와 protedcted는 같은 패키지 내에서만 사용가능              Product p = new Product(\"제품\",\"제품설명\",12300,100);      System.out.println(p.getName());                }  }      확장자 Getter and Setter Generator로 자동 생성가능(완벽x)생성할 변수 선택 후 f1 → &gt;gen검색해서 자동생성      암호화 복호화          [!info]      https://mvnrepository.com/        외부라이브러리 연결            자르파일 다운(외부에서 실행가능한상태로 압축한파일. 아카이브파일)          import javax.crypto.Cipher;  import javax.crypto.spec.IvParameterSpec;  import javax.crypto.spec.SecretKeySpec;      import org.apache.tomcat.util.codec.binary.Base64;      public class AESAlgorithm {    public static String Decrypt(String text) throws Exception{ //복호화      String key = \"pwd!@#$\"; //복호화시 사용하는 비밀번호(유출되면 큰일남)      Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");      byte[] keyBytes= new byte[16];      byte[] b= key.getBytes(\"UTF-8\");      int len= b.length;      if (len &gt; keyBytes.length) len = keyBytes.length;      System.arraycopy(b, 0, keyBytes, 0, len);      SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");      IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);      cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);              byte [] results = cipher.doFinal(Base64.decodeBase64(text));      return new String(results,\"UTF-8\");   }        public static String Encrypt(String text) throws Exception{ //암호화        String key = \"pwd!@#$\"; //암호화시 사용하는 비밀번호        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");        byte[] keyBytes= new byte[16];        byte[] b= key.getBytes(\"UTF-8\");        int len= b.length;        if (len &gt; keyBytes.length) len = keyBytes.length;        System.arraycopy(b, 0, keyBytes, 0, len);        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);        cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec);            byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));        return Base64.encodeBase64String(results);    }  }          public class Main {    public static void main(String[] args) throws Exception {      System.out.println(AESAlgorithm.Encrypt(\"1234\")); //4g9CwF3G17sk3kn/7DQTeQ== 출력      System.out.println(AESAlgorithm.Decrypt(\"4g9CwF3G17sk3kn/7DQTeQ==\")); //1234 출력    }  }        자동저장 설정 꺼놔야함                  복습          public /* final */ class SuperClass {    final int a=100; //변경불가 상수    /* final */ void printInfo(){      System.out.println(\"SuperClass\");            }  }                  public class SubClass extends SuperClass { // SuperClass에 final을 붙여서 상속금지임(주석처리함)    int b;            void printInfo(){ //SuperClass 메소드에 final붙어서 에러남(주석처리함)      System.out.println(\"Subclass\");    }          }                  public class StaticTest {    int a; //인스턴스변수 - 생성된 객체 수 만큼 존재    static int b; //클래스변수 - 단 1개만 생성 = 공유변수    static final int VALUE = 100; //클래스 상수 - 단 1개만 생성 = 공유상수            void nonStaticMethod(){ //클래스매소드      System.out.println(\"non static Method\");      StaticMethod();      //인스턴스메소드에서는 같은 클래스 내의 static메소드와 인스턴스 메소드 모두 사용 가능    }    static void StaticMethod(){ //인스턴스메소드(객체메소드)      System.out.println(\"static Method\");      // nonStaticMethod(); //불가능.       //Static메소드에서는 같은 클래스 내의 인스턴스 메소드 사용 불가                            }  }                  package group1;          public class AccessTest {    int a;    private int b;    protected int c;    public int d;            /* public */ int getB(){      return b;    }  }                  package group1;          public class SubAccessTest extends AccessTest {    public SubAccessTest(){      this.a=100; //default      // this.b=200; //private - 에러남. 자식클래스에서도 접근불가함.      this.c=300; //protected - 잘안씀      this.d=400; //publuc    }  }                  import group1.AccessTest; //패키지가 나눠져있어서 import해야 사용가능          public class Main {    public static void main(String[] args) throws Exception {      // StaticTest.a=10; //직접접근 불가 = 인스턴스변수(객체변수)      StaticTest.b=20; //직접접근 가능 = 클래스변수              StaticTest obj1 = new StaticTest();      obj1.a=10;  //인스턴스변수는 객체생성 후 접근 가능      StaticTest obj2 = new StaticTest();      obj2.a=20;      System.out.println(obj1.a);      System.out.println(obj2.a);//서로 다름              obj1.b=50;              System.out.println(obj1.b+\", \"+obj2.b+\",\"+StaticTest.b); //전부 같음                  System.out.println(Integer.MIN_VALUE); //클래스변수                  System.out.println(obj1.VALUE+\", \"+obj2.VALUE+\",\"+StaticTest.VALUE); //전부 같음                  StaticTest.StaticMethod();      // StaticTest.nonStaticMethod(); //불가능      obj1.nonStaticMethod();      obj1.StaticMethod();              AccessTest obj = new AccessTest();      // obj.a=10; //default - 에러남. 다른패키지라서 사용불가. 같은 패키지 내에서는 사용가능      // obj.b=20; //private - 에러남. 클래스외부에서 사용 불가능      // obj.c=30; //protected - 에러남. 다른패키지라서 사용불가. 같은 패키지 내에서는 사용가능      obj.d=40; //public 공개. 모은 곳에서 사용 가능      //private와 public을 많이 씀      // System.out.println(obj.getB()); //public이 빠져서 에러남.    }  }                인스턴스객체를 하나만 만들어야 할때 생성자에 private를 붙여준다.(singleton. 스프링으로가면 알아서 만들어줌)              ### 추상클래스    메소드가 추상적임. 개념만있음. 잘안만드나 이미 만들어진 추상클래스를 받는일이생김    상세내용 구체화      public abstract class AbstractSuperClass {     public int x;    public int y;    // public void showInfo(){    //   System.out.println(\"asdjaldlka\");    // }//모든 하위클래스에서 오버라이딩중이면 상위클래스에서 세부내용을 구현할 필요가 없ㅇ,ㅁ    public abstract void showInfo();  }          public class SubClass extends AbstractSuperClass{    // @Override    // public void showInfo() {    //   System.out.println(\"자식클래스에서 오버라이드\");    // } //만들지않으면 에러남.    @Override    public void showInfo() {      // TODO Auto-generated method stub    } //자동생성기능 사용              }            동물      public abstract class Animal {    public String name;    public String color;        //abstract : 추상의 / 구현의. 껍데기만 있는 상태    public abstract void makeSound();  }          public /* abstract */ class Dog extends Animal { //Dog도 추상클래스로 만들면 makeSound안만들어도됨    @Override    public void makeSound() {      // TODO Auto-generated method stub      System.out.println(\"이름 : \"+name+\" / 색깔 : \"+color);      System.out.println(\"멍멍\");    }        }          public class Cat extends Animal {    @Override    public void makeSound() {      // TODO Auto-generated method stub      System.out.println(\"이름 : \"+name+\" / 색깔 : \"+color);      System.out.println(\"야옹\");    }        }          public class AbsMain {    public static void main(String[] args) {      // AbstractSuperClass superClass = new AbstractSuperClass(); //불가능. 메소드가 구현안된 상태이기때문.       AbstractSuperClass obj = new SubClass(); //객체생성은 못하지만 하위클래스타입의 객체를 담는 변수타입으로는 사용가능      //추상클래스 = 상속 / 다형성 전용          obj.x = 10;      obj.showInfo();          Animal animal = new Dog();      Animal animal2 = new Cat();      animal.name = \"멍멍이\";      animal.color = \"흰색\";      animal.makeSound(); //멍멍출력      animal2.name = \"야옹이\";      animal2.color = \"치즈\";      animal2.makeSound(); //야옹출력          // Animal a = new Animal(); //불가능.         }  }            직업      public abstract class Person {    String name;    String gen;        public Person(){}    public Person(String name, String gen){      this.name = name;      this.gen = gen;    }          abstract void work();        public String toString() {      return \"이름 : \"+name+\" / 성별 : \"+gen;    }  }          public class Designer extends Person {    String tool; //사용 툴        public Designer(){      //super()가 생략된 상태. 다 만들거나 다 만들지 말거나    }    public Designer(String name, String gen, String tool){      super(name, gen);      this.tool = tool;    }        @Override    public void work(){      System.out.println(\"디자이너 \"+name+\"가(이) \"+tool+\"(으)로 디자인을 한다.\");    }  }          public class Developer extends Person {    String language; //프로그래밍언어        public Developer(){      //super()가 생략된 상태. 다 만들거나 다 만들지 말거나    }    public Developer(String name, String gen, String language){      super(name, gen);      this.language = language;    }    @Override    public void work(){      System.out.println(\"개발자 \"+name+\"가(이) \"+language+\"(으)로 프로그램을 개발한다.\");    }  }          public class PersonMain {    public static void main(String[] args) {              Person[] persons ={        // new Person(\"박진희\", \"여\"),        new Designer(\"박진희\", \"여\",\"photoshop\"),        new Developer(\"박진희\", \"여\",\"JAVA\")      };      for(Person p : persons){        System.out.println(p.toString());        p.work();        System.out.println();      }       /*이름 : 박진희 / 성별 : 여      일을 시작합니다.                이름 : 박진희 / 성별 : 여        일을 시작합니다.        디자이너 박진희가(이) photoshop(으)로 디자인을 한다.                  이름 : 박진희 / 성별 : 여        일을 시작합니다.        개발자 박진희가(이) JAVA(으)로 프로그램을 개발한다.*/ //출력됨                  //Person클래스 타입으로 Developer, Designer 클래스 타입의 객체를 생성가능 : 다형성. 상속관계에서만 사용가능        // Person p1  = new Person(\"박진희\", \"여\");        Person p2 = new Designer(\"박진희\", \"여\",\"photoshop\");        Person p3 = new Developer(\"박진희\", \"여\",\"JAVA\");        // p1.work(); //Person의 work실행        p2.work(); //Designer의 work실행        p3.work(); //Developer의 work실행        //기존클래스 Person의 work를 Developer와 Designer에서도 만들어줬다(재정의) : 오버라이딩          }  }      인터페이스껍데기. inplements로 상속받음상세내용 구현public interface MyInterface {  // int x; //멤버변수 불가능  public final int MAX_VALUE=10; //보통 상수를 많이 넣음  public void showInfo(); //껍데기  // {  // System.out.println(\"ㄴㄴㄴ\");      // } //절대 구현부가 올 수 없음 + 접근제한자가 무조건 public}public class MyRunnable implements Runnable {  @Override  public void run() {    // TODO Auto-generated method stub      } //}      로그인      public interface LoginInterface {    public boolean connect();    public boolean authorication();    public void showLoginInfo();    public boolean logout();    public boolean discounnect();  }          public class ShopLogin implements LoginInterface {        private String id;    private String pwd;              @Override    public boolean connect() {      return false;    }    @Override    public boolean authorication() {      return false;    }    @Override    public void showLoginInfo() {            }      @Override    public boolean logout() {      return false;    }    @Override    public boolean discounnect() {      return false;    }  }          public class InterfaceMain {    public static void main(String[] args) {      // LoginInterface i = new LoginInterface(); //불가능               LoginInterface obj = new ShopLogin();    }  }      mvc패턴. 모델(데이터)과 컨트롤러(기능처리→결과)사이의 관계성립. v는view(프론트, 화면).restful은 view없음데이터와 기능을 분리시키기위해 클래스를 나눔 - 스프링에서 사용할 개념"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 컬렉션 프레임워크",
    "url": "/posts/%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/",
    "categories": "JAVA",
    "tags": "java, 국비교육, collection",
    "date": "2022-11-01 00:00:00 +0900",
    





    
    "snippet": "listpublic class WrapperEx {  public static void main(String[] args) {    //wrapper Class    Integer value =10;    int value2= 20;    value = null; //Integer가 클래스타입이라서 null가능.     // value2 = null;...",
    "content": "listpublic class WrapperEx {  public static void main(String[] args) {    //wrapper Class    Integer value =10;    int value2= 20;    value = null; //Integer가 클래스타입이라서 null가능.     // value2 = null; //null불가능.     value=10;    System.out.println(value+value2);    String s = \"123456\";    System.out.println(s+100);    System.out.println(Integer.parseInt(s)+100); //Warpper class의 핵심기능. 문자있으면 Exception뜸    Byte v1 =100;    Short v2 = 200;    Integer v3 = 300;    Long v4 = 400L;    Float v5 = 1.23f;    Double v6 = 1.23;    Character v7 = 'a';    Boolean v8 = false; //null도 가능하니까 사용자가 값을 입력하지않았을때 null로 두기위해 주로 사용함    //전부 4byte    // BigDecimal aa;    // BigInteger bb;    System.out.println(v1);    System.out.println(v2);    System.out.println(v3);    System.out.println(v4);    System.out.println(v5);    System.out.println(v6);    System.out.println(v7);    System.out.println(v8);      }}primitive타입보다는 Wrapper클래스를 많이 사용하는것이 좋음List : 배열, 순서o,중복x(중간데이터삭제시 자동으로 빈값 땡겨줌)Set : 집합(중복불가)Map : 키와 값의 쌍으로 이루어짐. 라벨링. RestfulAPI를 내보낼때 무조건 사용ArrayList : 배열을 클래스화. (많이 씀.[비효율적으로 보이지만] 속도가 빠름)LinkedList : 배열단점보완, 중간데이터 삭제시 삭제데이터 다음 데이터의 주소와 삭제데이터 전데이터를 이어줌(덜씀)코드 호환가능. 바꿔도 쓸수있음import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;import java.util.List;import java.util.Vector;public class CollectionEx {  public static void main(String[] args) {    Integer[] arr = {10,20,30}; //크기변경 불가    System.out.println(arr);    // List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //제일많이씀    //&lt;&gt;사이에 무조건 클래스만 들어감    // List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); //위에꺼 주석하고 했는데도 전부 정상 작동함. 출력값 다른것도없음    List&lt;Integer&gt; list = new Vector&lt;Integer&gt;(); //마찬가지로 전부 정상 작동함. 출력값 다른것도없음    list.add(10);    list.add(20);    list.add(30);        for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }    System.out.println(\"-----------------------\");    list.add(40); //배열크기 추가 가능    for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }     System.out.println(\"-----------------------\");    // list.remove(30); //에러남. 30번째 데이터 삭제라는 뜻    Integer rm = 30;    list.remove(rm);    for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }     System.out.println(\"-----------------------\");    list.remove((Integer)20); //오 된다    for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }     System.out.println(\"-----------------------\");    list.remove(0); //첫번째 제거    for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }     Integer target=30;    //현재 list에 Integer값 30이 있는가?    System.out.println(list.contains(target)); //false출력.    System.out.println(list.contains((Integer)40)); //true출력    //아이디 중복검사할때 유용함        System.out.println(\"-----------------------\");    list.add(10);    list.add(20);    list.add(30);    System.out.println(list.size());    list.removeAll(list); //전체삭제    System.out.println(list.size());    list.add(10);    list.add(20);    list.add(40);    System.out.println(\"-----------------------\");    List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();    list2.add(10);    list2.add(40);    list2.add(50);    System.out.println(list2.size());    list.removeAll(list2);    System.out.println(list2.size()); //삭제안됨    System.out.println(list.size()); //1출력. list와 list2에서 겹치는값만 삭제(차집합)    // System.out.println(Arrays.toString(list));  //안되는구만    System.out.println(list2.toString()); //되는구만    List&lt;Integer&gt; list3 = new LinkedList&lt;Integer&gt;();    System.out.println(list3); //[] 출력됨          }}      아이디 추가      public class MemberInfo {    private String id;    private String pwd;    private String name;        public MemberInfo(){}    public MemberInfo(String id, String pwd, String name){      setId(id);      setPwd(pwd);      setName(name);    }        void setId(String id){      if(id.length()&lt;6){        System.out.println(\"아이디는 6자리 이상입니다.\");      }else{        this.id = id;      }    }    void setPwd(String pwd){      if(pwd.length()&lt;6){        System.out.println(\"비밀번호는 6자리 이상입니다.\");      }else{        this.pwd = pwd;      }    }    void setName(String name){      if(name.length()==0){        System.out.println(\"이름이 입력되지 않았습니다.\");      }else{        this.name = name;      }    }    public String toString(){      return \"아이디 : \"+id+\" / 이름 : \"+name;    }    Boolean pwdCheck(String pwd){      return this.pwd.equals(pwd);    }          public static void main(String[] args) {            }  }          import java.util.ArrayList;  import java.util.LinkedList;  import java.util.List;  import java.util.Scanner;      public class MemberMain {    public static void main(String[] args) {      Scanner s = new Scanner(System.in);      // List&lt;MemberInfo&gt; memberList = new ArrayList&lt;MemberInfo&gt;();      List&lt;MemberInfo&gt; memberList = new LinkedList&lt;MemberInfo&gt;();      // MemberInfo m1 = new MemberInfo(\"user01\",\"123456\",\"사용자\");      // memberList.add(m1);      // System.out.println(memberList);      // memberList.add(new MemberInfo(\"user02\", \"123456\", \"사용자2\"));      // System.out.println(memberList);          while(true){        System.out.println(\"1.회원가입, 2.회원삭제, 3.회원수정, 4.회원목록 0.종료\");        int sel = s.nextInt();        s.nextLine();        if(sel==0){          System.out.println(\"종료합니다\");          s.close();          break;        }        else if(sel==1){          System.out.print(\"아이디 : &gt;&gt; \");          String id = s.nextLine();          System.out.print(\"비밀번호 : &gt;&gt; \");          String pwd = s.nextLine();          System.out.print(\"이름 : &gt;&gt; \");          String name = s.nextLine();                      MemberInfo m = new MemberInfo(id, pwd, name);          memberList.add(m);          System.out.println(\"회원가입이 완료되었습니다.\");                    }        else if(sel==2){          for(int i=0;i&lt;memberList.size();i++){            System.out.println((i)+\"번째 회원 - \"+memberList.get(i));          }          System.out.println(\"삭제할 회원의 번호를 입력하세요.\");          int idx = s.nextInt();          memberList.remove(idx);          System.out.println(\"삭제했습니다.\");        }        else if(sel==3){          for(int i=0;i&lt;memberList.size();i++){            System.out.println((i)+\"번째 회원 - \"+memberList.get(i));          }          System.out.println(\"수정할 회원의 번호를 입력하세요.\");          int idx = s.nextInt();          MemberInfo m = memberList.get(idx);          s.nextLine();          System.out.print(\"비밀번호 : &gt;&gt; \");          String pwd = s.nextLine();          if(m.pwdCheck(pwd)){            System.out.println(m);            System.out.print(\"변경할 아이디 : &gt;&gt; \");            String id = s.nextLine();            // m.setId(id);            System.out.print(\"변경할 비밀번호 : &gt;&gt; \");            pwd = s.nextLine();            // m.setPwd(pwd);            System.out.print(\"변경할 이름 : &gt;&gt; \");            String name = s.nextLine();            // m.setName(name);            memberList.set(idx, new MemberInfo(id,pwd,name)); //해당인덱스의 값을 바꿔줌. 이전 데이터를 날려서 주소값도 날리고 새로 입력함.            System.out.println(\"변경했습니다.\");          }else{            System.out.println(\"비밀번호가 일치하지 않습니다.\");          }        }        else if(sel == 4){          for(int i=0;i&lt;memberList.size();i++){            System.out.println((i)+\"번째 회원 - \"+memberList.get(i));          }        }else{          System.out.println(\"번호를 잘못입력하셨습니다.\");        }      }            }  }      메모리구조 추가설명import java.util.LinkedList;import java.util.List;public class MemberTestMain {  public static void main(String[] args) {    List&lt;MemberInfo&gt; mList = new LinkedList&lt;MemberInfo&gt;();    for(int i=0;i&lt;10;i++){      mList.add(new MemberInfo(\"user0\"+i,\"123456\",\"사용자\"+i));    }    System.out.println(mList);    System.out.println(mList.get(5));    MemberInfo m= mList.get(5);    System.out.println(m);    m.setId(\"iiiiiiiiiiiiii\");    System.out.println(m);    System.out.println(mList.get(5)); //같은 메모리주소라서 둘다 바뀜. 앞데이터를 삭제하면 5번을 지우려했는데 4번이 지워질수도    mList.get(5).setId(\"vvvvvvvvvvvvvvvvvv\");    System.out.println(m);    System.out.println(mList.get(5));      }}      학생점수등록      public class StudentScore {    private String name;    private Integer score;    private String grade=\"\";    private boolean check = true;    public StudentScore(String name, Integer score){      setName(name);      setScore(score);    }    public StudentScore(){    }        void setName(String name){      if(name.length()==0){        System.out.println(\"이름을 입력하지않으셨습니다.\");        this.check = false;      }else{        this.name = name;      }    }    void setScore(Integer score){      if(score &lt; 0 || score &gt;100){        System.out.println(\"입력값이 잘못되었습니다\");        this.check = false;      }else{        this.score = score;      }    }    boolean getCheck(){      return check;    }    String getGrade(Integer score){      if(score&gt;=90){        grade = \"A\"+ (score&gt;=95?\"+\":\"O\");      }else if(score&gt;=80){        grade = \"B\"+ (score&gt;=85?\"+\":\"O\");      }else if(score&gt;=70){        grade = \"C\"+(score&gt;=75?\"+\":\"O\");      }else if(score&gt;=60){        grade = \"D\"+ (score&gt;=65?\"+\":\"O\");      }else{        grade = \"F\";      }      return grade;    }    boolean checkName(String name){      this.name.equals(name);      return true;    }        Integer getScore(){      return score;    }        public String toString(){      return \"이름 : \"+name+\" / 점수 : \"+score + \" / 등급 \"+getGrade(score);    }      }          import java.util.ArrayList;  import java.util.List;  import java.util.Scanner;      public class StudentScoreMain {    public static void main(String[] args) {      List&lt;StudentScore&gt; studentlist = new ArrayList&lt;StudentScore&gt;();      Scanner s= new Scanner(System.in);              while(true){        System.out.print(\"1.추가, 2.수정, 3.삭제, 4.조회, 0.종료 &gt;&gt; \");        int sel = s.nextInt();         s.nextLine();            if(sel ==0){          System.out.println(\"프로그램을 종료합니다.\");          s.close();          break;        }        else if(sel ==1){          System.out.print(\"이름 : \");          String name = s.nextLine();          System.out.print(\"점수 : \");          Integer score = s.nextInt();          StudentScore std = new StudentScore(name, score);          if(std.getCheck()){            studentlist.add(new StudentScore(name, score));          }        }        else if(sel ==2 ){          if(studentlist.size()!=0){            System.out.println(\"===============목록================\");            for(int i=0;i&lt;studentlist.size();i++){              System.out.println(i+\"번째 학생 -\"+studentlist.get(i));            }            System.out.print(\"수정할 학생의 번호를 입력하세요 : &gt;&gt;\");                int index = s.nextInt();              StudentScore st = studentlist.get(index);              String name = s.nextLine();              if(st.checkName(name)){                System.out.print(\"이름 : \");                name = s.nextLine();                System.out.print(\"점수 : \");                Integer score = s.nextInt();                studentlist.set(index, new StudentScore(name, score));              }            }            else{              System.out.println(\"등록된 학생이 없습니다.\");            }          }          else if(sel ==3 ){            if(studentlist.size()!=0){            System.out.println(\"================목록==================\");            for(int i=0;i&lt;studentlist.size();i++){              System.out.println(i+\"번째 학생 -\"+studentlist.get(i));            }            System.out.print(\"삭제할 학생의 번호를 입력하세요 : &gt;&gt;\");              int index = s.nextInt();            studentlist.remove(index);            System.out.println(\"삭제되었습니다.\");            }          else{            System.out.println(\"등록된 학생이 없습니다.\");          }        }          else if(sel ==4 ){          int sum=0;          for(int i=0;i&lt;studentlist.size();i++){            // StudentScore st = studentlist.get(i);            // sum += st.getScore();            sum += studentlist.get(i).getScore();            System.out.println(\"===목록===\");            System.out.println(i+\"번째 학생 -\"+studentlist.get(i));          }          if(studentlist.size()!=0){            System.out.println(\"전체 학생의 평균 : \"+sum/studentlist.size());          }else{            System.out.println(\"등록된 학생이 없습니다.\");          }        }else{          System.out.println(\"번호를 잘못입력하셨습니다. 0~4사이의 번호를 입력해주세요\");        }      }    }  }            복습      import java.util.List;  import java.util.Scanner;      public class CollectionEx2 {    public static void main(String[] args) {      //Wrapper Class타입      //기본형 타입을 Reference형태로 만들어둔것      // int a = null; //불가      Integer b = null; //가능      System.out.println(b);      b = new Integer(10);  //추천하지않아서 취소선 그어짐. 자바에서 비추      b = 10; //자바 추천방법      Scanner s = null; //가능. 메모리상에 객체가 만들어지기 전 상태      s = new Scanner(System.in); //메모리에 Scanner 객체 생성          // List&lt;int&gt; list = null; //int는 null사용불가 -&gt; 에러      List&lt;Integer&gt; list = null; //List도 Reference타입.      String str = null; //Reference타입. null을 넣을수있다면 Reference타입임.      System.out.println(list);      System.out.println(str);          s.close();    }  }          import java.util.ArrayList;  import java.util.List;      public class CollectionEx3 {    public static void main(String[] args) {      List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();      list.add(10);      list.add(20);      list.add(30);      System.out.println(list); //[10, 20, 30]으로 출력됨. toString써줄필요없는듯?              List&lt;String&gt; strlist = new ArrayList&lt;String&gt;();          strlist.add(\"abcde\"); //\"abcde\"객체의 주소를 ArrayList객체의 첫번째 배열에 저장, ArrayList객체의 주소를 strlist에 저장      strlist.add(\"fghij\"); //\"abcde\"객체의 주소를 ArrayList객체의 두번째 배열에 저장, ArrayList객체의 주소를 strlist에 저장      strlist.add(\"klmno\"); //\"abcde\"객체의 주소를 ArrayList객체의 세번째 배열에 저장, ArrayList객체의 주소를 strlist에 저장      strlist.add(\"pqrst\");      strlist.add(\"uvwsyz\");      System.out.println(strlist);                     }  }            은행      import java.util.ArrayList;  import java.util.List;      public class AccountMain2 {    public static void main(String[] args) {      List&lt;Account&gt; accList = new ArrayList&lt;Account&gt;();      accList.add(new Account(\"aaa\",50000));      accList.add(new Account(\"bbb\",4600000));      accList.add(new Account(\"ccc\",1000));      accList.add(new Account(\"ddd\",100000000));          System.out.println(\"accList의 크기 : \"+accList.size());      for(int i=0;i&lt;accList.size();i++){        accList.get(i).showInfo();      }       System.out.println();      for(Account a:accList){        a.showInfo();      } //위 for문이랑 같음. 짧아서 씀      System.out.println();      accList.remove(1);      for(Account a:accList){        a.showInfo();      }      System.out.println();      System.out.println(accList.get(1));      Account acc =accList.remove(1); //제거한 값 변수에 저장. 잘 안쓰긴함      System.out.println(acc);       for(Account a:accList){        a.showInfo();      }    }  }          import java.text.DecimalFormat;      public class Account {    private String owner;    private Integer balance;          public Account(){    }    public Account(String owner, Integer balance){      setBalance(balance);      setowner(owner);        }    public void setBalance(Integer balance) {      this.balance = balance;    }    public void setowner(String owner) {      this.owner = owner;    }    public Integer getBalance() {      return balance;    }    public String getowner() {      return owner;    }        public void showInfo() {      DecimalFormat formatter = new DecimalFormat(\"###,###\");      System.out.println(\"예금주 : \"+owner+\" / 잔액 : \"+formatter.format(balance)+\"원\");    }    // public String toString() {    //   DecimalFormat formatter = new DecimalFormat(\"###,###\");    //   return \"예금주 : \"+owner+\" / 잔액 : \"+formatter.format(balance)+\"원\";    // }        }      CRUDCreate : addRead : getUpdate : setDelete : remove      대학생정보      public class Campuse {    private Integer no;    private String name;    private Integer grade;    private String major;        public Campuse(){}    public Campuse(Integer no, String name, Integer grade, String major){      setNo(no);      setName(name);      setgrade(grade);      setMajor(major);    }    void setNo(Integer no){      this.no = no;    }    void setName(String name){      this.name = name;    }    void setgrade(Integer grade){      this.grade = grade;    }    void setMajor(String major){      this.major = major;    }        public String toString(){      return \"학번 : \"+no+\" / 이름 : \"+name+\" / 학년 : \"+grade+\" / 전공 : \"+major;    }  }          import java.util.ArrayList;  import java.util.Arrays;  import java.util.List;      public class CampuseMain {    public static void main(String[] args) {      List&lt;Campuse&gt; camList = new ArrayList&lt;Campuse&gt;();          camList.add(new Campuse(20220001, \"남형남\", 1, \"전산공학\"));      camList.add(new Campuse(20220002, \"조현숙\", 3, \"정보공학\"));      camList.add(new Campuse(20220003, \"남희준\", 2, \"물리학\"));      camList.add(new Campuse(20220004, \"윤상원\", 2, \"국어교육과\"));      camList.add(new Campuse(20220005, \"문용태\", 3, \"전산공학\"));      camList.add(new Campuse(20220006, \"사공채은\", 4, \"정보공학\"));      camList.add(new Campuse(20220007, \"정문옥\", 1, \"경영학\"));      camList.add(new Campuse(20220008, \"황상훈\", 2, \"국어국문학\"));      camList.add(new Campuse(20220009, \"탁희아\", 2, \"국어국문학\"));      camList.add(new Campuse(20220010, \"봉성훈\", 4, \"정보공학\"));       //컬럼이름 = 멤버변수      //1학년 학생수, 전산공학 학생수, 남씨 학생 수 등 여러값을 구할수있음          for(Campuse c : camList){        System.out.println(c);      }              //학년 별 학생 수      // for(Campuse c : camList){      //   System.out.println(c.grade); //학년만 출력      // }              // Integer grade1 = 0;      // Integer grade2 = 0;      // Integer grade3 = 0;      // Integer grade4 = 0;      // for(Campuse c : camList){      //   if(c.grade == 1){      //     grade1++;      //   }else if(c.grade == 2){      //     grade2++;      //   }else if(c.grade == 3){      //     grade3++;      //   }else if(c.grade == 4){      //     grade4++;      //   }      // }      // System.out.println(\"1학년 : \"+grade1+\"명\");      // System.out.println(\"2학년 : \"+grade2+\"명\");      // System.out.println(\"3학년 : \"+grade3+\"명\");      // System.out.println(\"4학년 : \"+grade4+\"명\");              int[] grade_cnt = {0,0,0,0};      for(Campuse c : camList){        grade_cnt[c.grade-1]++;      }      System.out.println(Arrays.toString(grade_cnt));              for(int i=0;i&lt;grade_cnt.length;i++){        System.out.print((i+1)+\"학년 : \"+grade_cnt[i]+\"명\");        if(i!=grade_cnt.length-1){          System.out.print(\" / \");        }      }    }  }      자리뽑기import java.util.ArrayList;import java.util.List;public class SeatEx {  public static void main(String[] args) {    List&lt;String&gt; stuList = new ArrayList&lt;String&gt;();    stuList.add(\"이호진\");    stuList.add(\"주봉진\");    stuList.add(\"정아미\");    stuList.add(\"김호혁\");    stuList.add(\"이민석\");    stuList.add(\"유지은\");    stuList.add(\"김성민\");    stuList.add(\"차대군\");    stuList.add(\"유상연\");    stuList.add(\"권영장\");    stuList.add(\"신래은\");    stuList.add(\"박정은\");    stuList.add(\"류승지\");    stuList.add(\"이영은\");    stuList.add(\"이찬희\");    stuList.add(\"이태훈\");    stuList.add(\"박진희\");    stuList.add(\"박진혁\");    stuList.add(\"정인원\");    stuList.add(\"문주영\");    stuList.add(\"남현우\");    stuList.add(\"이영준\");    stuList.add(\"김동현\");    stuList.add(\"우민경\");    stuList.add(\"우현주\");    stuList.add(\"차경준\");    stuList.add(\"김한수\");    stuList.add(\"이도영\");        int num = 1;    while(stuList.size()&gt;0){        int n = (int)(Math.random()*stuList.size());        // System.out.println(stuList.get(n)); //이렇게하면 무한반복임        String name = stuList.remove(n);        System.out.println(num+\". \"+name);        num++;      }      // while(num&lt;28){        //   int n = (int)(Math.random()*stuList.size());    //   System.out.println(num+\". \"+stuList.get(n));  //이렇게하면 중복값나옴    //   num++;    // }  }}      마켓컬리      public class ProductInfo {    Integer prod_no; //제품번호    String prod_name; //제품명    Integer prod_price; //가격    Integer prod_stock; //재고     Double prod_dc_rate; //할인율          public ProductInfo(){}    public ProductInfo(Integer prod_no, String prod_name, Integer prod_price, Integer prod_stock, Double prod_dc_rate){      this.prod_no = prod_no;      this.prod_name = prod_name;      this.prod_price = prod_price;      this.prod_stock = prod_stock;      this.prod_dc_rate = prod_dc_rate;    }        void showInfo(){      System.out.println(\"제품번호 : \"+prod_no);      System.out.println(\"제품명 : \"+prod_name);      System.out.println(\"가격 : \"+prod_price);      System.out.println(\"재고 : \"+prod_stock);      System.out.println(\"할인률 : \"+(int)(prod_dc_rate*100)+\"%\");    }    int getDiscountedPrice(){      return (int)(prod_price*(1-prod_dc_rate));    }        public static void main(String[] args) {            }  }          import java.util.ArrayList;  import java.util.List;  import java.util.Scanner;      public class ShopMain {    static List&lt;ProductInfo&gt; prodList = new ArrayList&lt;ProductInfo&gt;();    static Integer no = 0; //중간에 데이터가 삭제돼도 제품번호를 당기지는 않음    static Scanner s = new Scanner(System.in);    public static void main(String[] args) {      for(int i=0;i&lt;10;i++){        initializeData(); //10개의 데이터추가 10번 반복      }      //1.제품추가, 2.제품삭제, 3.제품수정, 4.제품목록      while(true){        System.err.print(\"1.제품추가, 2.제품삭제, 3.제품수정, 4.제품목록, 0.종료 &gt;&gt; \" );        int sel = s.nextInt();        s.nextLine();        if(sel==0){          System.out.println(\"프로그램을 종료합니다.\");          s.close();          return;        }        else if(sel ==1){          addProduct();        }        else if(sel ==2){          deletedProduct();        }        else if(sel==3){          updateProduct();        }        else if(sel ==4){          showProductList();        }      }    }    public static void addProduct(){      System.out.print(\"제품 명 : \");      String name = s.nextLine();      System.out.print(\"가격 : \");      Integer price = s.nextInt();      System.out.print(\"재고 : \");      Integer stock = s.nextInt();      System.out.print(\"할인률(%) : \");      Integer dc_percent = s.nextInt();          prodList.add(new ProductInfo(no, name, price, stock, dc_percent/100.0));      no++;      System.out.println(\"제품정보가 등록되었습니다.\");    }    public static void deletedProduct(){      System.out.print(\"삭제할 제품의 번호(\"+(prodList.get(0).prod_no+\"-\"+(prodList.get(prodList.size()-1).prod_no)+\") : &gt;&gt; \"));      int n = s.nextInt();      s.nextLine();      int index=0;      boolean check=false;      for(int i=0;i&lt;prodList.size();i++){        if(prodList.get(i).prod_no == n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"등록된 제품번호가 아닙니다.\");        return;      }      // if(n&gt;= prodList.size()){      //   System.out.println(\"잘못된 제품번호입니다.\");      //   return; //메소드 종료      // }      ProductInfo p = prodList.get(index);      p.showInfo();      System.out.print(\"삭제하시겠습니까? (y/n) &gt;\");      String confirm = s.nextLine();      if(confirm.equalsIgnoreCase(\"y\")){        prodList.remove(index);        System.out.println(\"삭제하였습니다.\");      }else {        System.out.println(\"삭제가 취소되었습니다.\");      }    }    public static void updateProduct(){      System.out.print(\"수정할 제품의 번호(\"+(prodList.get(0).prod_no+\"-\"+(prodList.get(prodList.size()-1).prod_no)+\") : &gt;&gt; \"));      int n = s.nextInt();      s.nextLine();      int index=0;      boolean check=false;      for(int i=0;i&lt;prodList.size();i++){        if(prodList.get(i).prod_no == n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"등록된 제품번호가 아닙니다.\");        return;      }      ProductInfo p = prodList.get(index);      p.showInfo();      System.out.println(\"=======수정 정보 입력=========\");      System.out.print(\"제품명 (기존 : \"+p.prod_name+\") : &gt;&gt; \");      String name = s.nextLine();      if(name.length()==0){ //입력안했을때        name = p.prod_name; //기존정보 유지      }      System.out.print(\"가격 (기존 : \"+p.prod_price+\"원) : &gt;&gt; \");      Integer price = s.nextInt();      s.nextLine();      System.out.print(\"재고 (기존 : \"+p.prod_stock+\"개) : &gt;&gt; \");      Integer stock = s.nextInt();      s.nextLine();      System.out.print(\"할인율 (기존 : \"+p.prod_dc_rate+\"%) : &gt;&gt; \");      Integer dc_percent = s.nextInt();      s.nextLine();      System.out.print(\"수정하시겠습니까? (y/n) &gt;\");      String confirm = s.nextLine();      if(confirm.equalsIgnoreCase(\"y\")){        prodList.set(index, new ProductInfo(index, name, price, stock, dc_percent/100.0));        System.out.println(\"수정하였습니다.\");      }else {        System.out.println(\"수정이 취소되었습니다.\");      }                                            }    public static void showProductList(){      // for(ProductInfo p : prodList){      //   System.out.println(\"-------------------\");      //   p.showInfo();      //   System.out.println(\"할인 적용가 : \"+p.getDiscountedPrice()+\"원\");      // } //인덱스 번호 표시못함.      for(int i=0;i&lt;prodList.size();i++){        System.out.println(\"========[\"+i+\"]========\");        prodList.get(i).showInfo();        System.out.println(\"할인 적용가 : \"+prodList.get(i).getDiscountedPrice()+\"원\");      }//인덱스 번호 표시가능    }    public static void initializeData(){      prodList.add(new ProductInfo(no, \"입욕제 굿나잇 4구 세트\", 19500, 50, 0.0));      no++;      prodList.add(new ProductInfo(no, \"편백 스프레이 3종\", 24900, 50, 0.20));      no++;      prodList.add(new ProductInfo(no, \"볶음밥 5종\", 19980, 50, 0.36));      no++;      prodList.add(new ProductInfo(no, \"국산 콩두부 300g\", 1900, 50, 0.0));      no++;      prodList.add(new ProductInfo(no, \"머스크 멜론 1.5kg\", 9990, 50, 0.0));      no++;      prodList.add(new ProductInfo(no, \"유정란 20구\", 9550, 50, 0.07));      no++;      prodList.add(new ProductInfo(no, \"한우양지국거리 200g\", 12900, 50, 0.28));      no++;      prodList.add(new ProductInfo(no, \"실속 바나나 1kg\", 3700, 50, 0.15));      no++;      prodList.add(new ProductInfo(no, \"갈비탕\", 12000, 50, 0.0));      no++;      prodList.add(new ProductInfo(no, \"깐대파 500g\", 2990, 50, 0.0));      no++;    }  }        배열의 인덱스값을 받는게 마음에안들어서 제품번호를 입력받도록 바꿨음        게시판      import java.text.SimpleDateFormat;  import java.util.ArrayList;  import java.util.Date;  import java.util.List;          public class Board {    private Integer no; //글번호    private String title;    private String name;    private String mainText;    private String Sdate;    SimpleDateFormat format = new SimpleDateFormat(\"yyyy/MM/dd hh:mm:ss\");    List&lt;BoardDetail&gt; commentList = new ArrayList&lt;BoardDetail&gt;();    private int view;    Date nowDate = new Date();    private String[] category={\"정보\",\"유머\",\"이슈\",\" 팁\",\"잡담\"};    private int index =0;          public Board(){}    public Board(Integer no, int index, String title, String name, String mainText, Date date){      setNo(no);      setName(name);      setTitle(title);      setMainText(mainText);      setDate(date);      setIndex(index);      makeDummydata();    }        //랜덤용    public Board(Integer no, int index, String title, String name, String mainText, Date date, int view){      setNo(no);      setName(name);      setTitle(title);      setMainText(mainText);      setDate(date);      randomView(view);      setIndex(index);      makeDummydata();    }        void setNo(Integer no){      this.no = no;    }    void setTitle(String title){      this.title = title;    }    void setName(String name){      this.name = name;    }    void setMainText(String mainText){      this.mainText = mainText;    }    void setDate(Date nowdate){      this.Sdate = format.format(nowdate);    }    void randomView(int view){      this.view = (int)(Math.random()*view)+1;    }    void setView(int view){      this.view = view;    }    void setIndex(int index){      this.index = index;    }    Integer getNo(){      return this.no;    }    String getName(){      return this.name;    }    String getTitle(){      return this.title;    }    String getMainText(){      return this.mainText;    }    String getDate(){      return this.Sdate;    }    int getCategorysize(){      return category.length;    }    int getView(){      return view;    }        public String toString(){      return \"[\"+category[index]+\"] \"+title+\"(댓글 : \"+commentList.size()+\")\"+\" / 글쓴이 : \"+ name + \" / 작성일 : \"+ Sdate + \" / 조회수 : \"+view +\" / 글번호 : \"+no;    }    void showDetailInfo(){      view++;      System.out.println(\"-------------------------------------\");      System.out.println(\"[\"+category[index]+\"] \"+title + \"(no.\"+no+\")\");      System.out.println(\"글쓴이    : \"+name);      System.out.println(\"조회수    : \"+view);      System.out.println(\"작성일    : \"+Sdate);      System.out.println(\"-------------------------------------\");      System.out.println(mainText);      System.out.println(\"-------------------------------------\");      System.out.println(\"[댓글창] \"+commentList.size());      for(BoardDetail b : commentList){        b.showInfo();      }    }    int num;    void makeDummydata(){      int n = (int)(Math.random()*(view/5));      for(int  i=0;i&lt;n;i++){        commentList.add(new BoardDetail(\"name\"+num, \"댓글내용입니다.\"+num, nowDate));        num++;      }    }    // BoardDetail getcommentList(){    //   return commentList.    // }      }          import java.text.SimpleDateFormat;  import java.util.Date;      public class BoardDetail {    private String commentName;    private String comment;    private String Sdate;    SimpleDateFormat format = new SimpleDateFormat(\"yyyy/MM/dd hh:mm:ss\");        public BoardDetail(){}    public BoardDetail(String name, String comment, Date date){      setComment(comment);      setCommentName(name);      setDate(date);    }        void setCommentName(String commentName){      this.commentName = commentName;    }    void setComment(String comment){      this.comment = comment;    }    void setDate(Date nowdate){      this.Sdate = format.format(nowdate);    }    String getComment(){      return comment;    }    String getCommentName(){      return commentName;    }    void showInfo(){      System.out.println(commentName+\"(\"+Sdate+\")\" + \" : \"+comment );    }            }          import java.util.ArrayList;  import java.util.Date;  import java.util.List;  import java.util.Scanner;      public class Boardmain {    static List&lt;Board&gt; boardList = new ArrayList&lt;Board&gt;();    static Integer no = 0;    static Date date = new Date();    static Scanner s = new Scanner(System.in);    static List&lt;BoardDetail&gt; commentList = new ArrayList&lt;BoardDetail&gt;();        public static void main(String[] args) {      //글쓰기, 글수정, 글 삭제, 글목록(글내용 제외), 글내용 상세보기      dummydata(10);          while(true){        System.out.print(\"1.글쓰기, 2.글수정, 3.글 삭제, 4.글목록조회, 5.글내용 상세보기 0.종료 : &gt;&gt; \");        int sel = s.nextInt();        s.nextLine();        if(sel == 0){          System.out.println(\"프로그램을 종료합니다.\");          s.close();          break;        }        else if(sel==1){          addpost();        }        else if(sel==2){          updatePost();        }        else if(sel==3){          deletePost();        }        else if(sel==4){          showInfo();            }        else if(sel==5){          detailShowInfo();        }        else{          System.out.println(\"잘못된 번호를 입력하셨습니다. 번호를 다시 입력해주세요.\");        }      }    }    public static void dummydata(int n){      Board b = new Board();      for(int i=0;i&lt;n;i++){        int r = (int)(Math.random()*b.getCategorysize());        boardList.add(new Board(no, r,\"글\"+no, \"닉네임\"+no, \"글본문입니다.\"+no, date, 100));        no++;          }    }    public static void showInfo(){      System.out.println(\"===========글 목록=============\");      for(Board b : boardList){        System.out.println(b);      }    }    public static void addpost(){      System.out.println(\"글을 작성합니다.\");      System.out.print(\"카테고리 : 0.정보, 1.유머, 2.이슈, 3.팁, 4.잡담 &gt;&gt; \");      int a = s.nextInt();      System.out.print(\"제목 : \");      s.nextLine();      String title = s.nextLine();      System.out.print(\"글쓴이 : \");      String name = s.nextLine();      System.out.print(\"본문 내용 : \");      String mainText = s.nextLine();      boardList.add(new Board(no, a, title, name, mainText, date));      System.out.println(\"글 작성이 완료되었습니다.\");      no++;    }    public static void updatePost(){      System.out.print(\"수정할 글 번호를 입력하세요 : &gt;&gt; \");      int n = s.nextInt();      int index=0;      boolean check = false;      for(int i=0;i&lt;boardList.size();i++){        if(boardList.get(i).getNo()==n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"해당 글 번호가 존재하지 않습니다. 글 번호를 다시 확인해주세요.\");        return;      }      System.out.println(\"======수정할 내용 입력======\");      System.out.println(\"카테고리 : 0.정보, 1.유머, 2.이슈, 3.팁, 4.잡담\");      int a = s.nextInt();      System.out.print(\"제목 : \");      s.nextLine();      String title = s.nextLine();      System.out.print(\"글쓴이 : \");      String name = s.nextLine();      System.out.print(\"본문 내용 : \");      String mainText = s.nextLine();              System.out.print(\"정말로 수정하시겠습니까? 예-Y, 아니오 - 아무키나 입력하세요 : &gt;&gt; \");      String comfirm = s.nextLine();      if(comfirm.equalsIgnoreCase(\"y\")){        boardList.get(index).setTitle(title);        boardList.get(index).setName(name);        boardList.get(index).setMainText(mainText);        boardList.get(index).setIndex(a);            System.out.println(\"수정이 완료되었습니다.\");      }      else{        System.out.println(\"수정이 취소되었습니다.\");      }    }    public static void deletePost(){      System.out.print(\"삭제할 글 번호를 입력하세요 : &gt;&gt; \");      int n = s.nextInt();      int index=0;      boolean check = false;      for(int i=0;i&lt;boardList.size();i++){        if(boardList.get(i).getNo()==n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"해당 글 번호가 존재하지 않습니다. 글 번호를 다시 확인해주세요.\");        return;      }      System.out.println(boardList.get(index));      System.out.print(\"정말로 삭제하시겠습니까? 예-Y, 아니오 - 아무키나 입력하세요 : &gt;&gt; \");      s.nextLine();      String comfirm = s.nextLine();      if(comfirm.equalsIgnoreCase(\"y\")){        boardList.remove(index);        System.out.println(\"삭제 완료되었습니다.\");      }      else{        System.out.println(\"삭제가 취소되었습니다.\");      }    }    public static void detailShowInfo(){      System.out.print(\"조회할 글 번호를 입력하세요 : &gt;&gt; \");      int n = s.nextInt();      int index=0;      boolean check = false;      for(int i=0;i&lt;boardList.size();i++){        if(boardList.get(i).getNo()==n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"해당 글 번호가 존재하지 않습니다. 글 번호를 다시 확인해주세요.\");        return;      }      boardList.get(index).showDetailInfo();      System.out.print(\"댓글을 다시려면 Y를 눌러주세요. 처음으로 돌아가려면 아무키나 누르세요 : &gt;&gt;\");      s.nextLine();      String comfirm = s.nextLine();      if(comfirm.equalsIgnoreCase(\"Y\")){        System.out.print(\"닉네임 : &gt;&gt; \");        String name = s.nextLine();        System.out.print(\"댓글 : &gt;&gt; \");        String comment = s.nextLine();        boardList.get(index).commentList.add(new BoardDetail(name, comment, date));        System.out.println(\"댓글 등록이 완료되었습니다.\");        boardList.get(index).showDetailInfo();      }    }  }        글 수정할때 객체를 새로만들어서 수정하려고하니까 댓글이랑 조회수가 날아가서 쌤한테 물어봄. 원래는 글이랑 댓글을 따로 관리하는게 좋다고하심. 이 상황에서는 새 객체를 만드는 것 보다는 기존객체를 수정하는 것이 낫다고 하심. 사본을 만들어서 고치는게 안전하긴함    오버헤드    회원가입 선생님코드      import java.text.SimpleDateFormat;  import java.util.Date;      //게시 글 정보  public class BoardPost{    //next_no는 클래스변수라서 객체생성 전에도 사용 가능함. 모든 BoardPost타입의 객체가 공유중임. 단 1개만 존재    static int next_no = 1;    Integer post_no; //글번호    String post_title;    String post_content; //글내용    Date post_reg_dt; //글 등록일    Date post_mod_dt; //글 수정일    String post_author;//작성자    Integer post_count; //조회수    String post_pwd; //게시글 비밀번호            public BoardPost(String title, String content, String author, String pwd){      post_no = next_no;      this.post_pwd=pwd;      this.post_title = title;      this.post_content = content;      this.post_author = author;      this.post_reg_dt = new Date(); //글 등록일 = 객체를 만든 시간      this.post_mod_dt = new Date(); //글 수정일 = 객체를 만든 시간      this.post_count = 0;      next_no++;    }    SimpleDateFormat f= new SimpleDateFormat(\"yy-MM-dd HH:mm:ss\");    void showPostSummary(boolean detail){      System.out.print(post_no+\"\\t\");      System.out.print(post_title+\"\\t\");      System.out.print(post_reg_dt+\"\\t\");      System.out.print(post_author+\"\\t\");      System.out.print(post_count+\"\\t\");      if(detail){        System.out.println(f.format(post_mod_dt)+\"\\t\");      }      System.out.println(post_content);      if(detail){        System.out.println(\"------------------------------------------------------\");        System.out.println(post_content);        System.out.println(\"------------------------------------------------------\");      }            }    public void showPostInfo(boolean b) {      System.out.println(post_no+\"\\t\"+post_title+\"\\t\"+post_author+\"\\t\"+f.format(post_mod_dt)+\"\\t\"+post_count);      if(b){        System.out.println(\"---------------------------------------------------------------------------------\");        System.out.println(post_content);        System.out.println(\"---------------------------------------------------------------------------------\");      }    }  }          import java.text.SimpleDateFormat;  import java.util.Date;      public class BoardComment {    Integer post_no;    String comment;    Date reg_dt;    String author;    String pwd;    SimpleDateFormat f = new SimpleDateFormat(\"yy-MM-dd HH:mm:ss\");        public BoardComment(Integer post_no, String comment, String author, String pwd){      this.post_no = post_no;      this.comment = comment;      this.author = author;      this.pwd = pwd;      reg_dt = new Date();    }    public void printCommentInfo(){      System.out.println(author+\" : \"+comment+\"(\"+f.format(reg_dt)+\")\");    }  }          import java.util.ArrayList;  import java.util.Date;  import java.util.List;  import java.util.Scanner;          public class BoardMain2 {    public static List&lt;BoardPost&gt; postList = new ArrayList&lt;BoardPost&gt;();    public static Scanner s = new Scanner(System.in);    public static List&lt;BoardComment&gt; commentList = new ArrayList&lt;BoardComment&gt;();    public static void main(String[] args) {      // System.out.println(BoardPost.next_no); //next_no는 클래스변수라서 객체생성 전에도 사용 가능함. 모든 BoardPost타입의 객체가 공유중임      // BoardPost post1 = new BoardPost(null, null, null);      // System.out.println(post1.next_no); //2      // System.out.println(BoardPost.next_no); //2      // BoardPost post2 = new BoardPost(null, null, null);      // System.out.println(BoardPost.next_no); //3      // System.out.println(post2.next_no); //3      // for(int i=0;i&lt;100;i++){      //   BoardPost post = new BoardPost(null, null, null);      // }      // System.out.println(BoardPost.next_no); //103    \t\t      initializeBoardPost(10);      while(true){        System.out.print(\"1.글 등록, 2.글 수정, 3.글 삭제, 4.글 목록 5.글 상세조회, 0.종료 : &gt;&gt; \");        int sel = s.nextInt();        s.nextLine();        // if(sel==0){        //   s.close();        //   System.out.println(\"프로그램을 종료합니다\");        //   break;        // }        // else if(sel==1){        //   addPost();        // }        // else if(sel==2){        //   updatePost();        // }        // else if(sel==3){        //   deletePost();        // }        // else if(sel==4){        //   printPostList();        // }        // else if(sel==5){        //   printPostDetail();        // }        // else{        //   System.out.println(\"번호를 잘못입력하셨습니다. 다시 입력해주세요.\");        // }        switch(sel){          case 1:            addPost();            break;          case 2:            updatePost();            break;          case 3:            deletePost();            break;          case 4:            printPostList();            break;          case 5:            printPostDetail();            break;          case 0:            System.out.println(\"종료합니다\");            return;          default :             System.out.println(\"번호를 잘못입력하셨습니다. 다시 입력해주세요.\");        }      }    }        public static void addPost(){      System.out.print(\"제목 : \");      String title = s.nextLine();      System.out.print(\"내용 : \");      String content = s.nextLine();      System.out.print(\"작성자 : \");      String author = s.nextLine();      System.out.print(\"비밀번호 : \");      String pwd = s.nextLine();      System.out.print(\"글을 등록하시겠습니까?(y/n): \");      String confirm =s.nextLine();      if(confirm.equalsIgnoreCase(\"y\")){        postList.add(new BoardPost(title, content, author, pwd));        System.out.println(\"글이 등록되었습니다\");      }else{        System.out.println(\"글 등록이 취소되었습니다.\");      }    }    public static void printPostList(){      System.out.println(\"글번호\\t글제목\\t\\t작성자\\t등록일\\t\\t\\t조회수\");      for(BoardPost p : postList){        p.showPostInfo(false);      }    }    public static void printPostDetail(){      System.out.print(\"글번호 : \");      int n = s.nextInt();      s.nextLine();      BoardPost p = searchPostDetailByNumber(n);      if(p != null){        p.post_count++;        p.showPostInfo(true);        showComment(p.post_no);        System.out.println(\"1.댓글쓰기 0.목록으로\");        int sel = s.nextInt();        s.nextLine();        if(sel == 1){          addComment(n);          p.showPostInfo(true);          showComment(p.post_no);        }else{          System.out.println(\"목록으로 돌아갑니다.\");        }      }    }            public static void showComment(Integer post_no) {      for(BoardComment c : commentList){        if(c.post_no==post_no){        c.printCommentInfo();        }      }    }    public static void addComment(Integer post_no){      System.out.print(\"닉네임 : \");      String author = s.nextLine();      System.out.print(\"내용 : \");      String comment = s.nextLine();      System.out.print(\"비밀번호 : \");      String pwd = s.nextLine();      System.out.println(\"정말 등록하시겠습니까? (y/n\");      String confirm = s.nextLine();      if(confirm.equalsIgnoreCase(\"y\")){        commentList.add(new BoardComment(post_no, comment, author, pwd));      }else{      System.out.println(\"댓글 등록이 취소되었습니다.\");      }    }    public static void initializeBoardPost(int count){      for(int i=0;i&lt;count;i++){        postList.add(new BoardPost(\"dummytitle\"+i, \"dummycontent\"+i, \"autor\"+i, \"123\"+i));      }    }    public static void updatePost(){      System.out.print(\"수정할 글 번호 : \");      int n = s.nextInt();      s.nextLine();      BoardPost p =searchPostDetailByNumber(n);      if(p!=null){        p.showPostInfo(true);        System.out.print(\"글 비밀번호 : &gt;&gt; \");        String pwd = s.nextLine();        if(p.post_pwd.equals(pwd)){          System.out.print(\"제목 : \");          String title = s.nextLine();          if(title.equals(\"\")){            title = p.post_title;          }          System.out.print(\"내용 : \");          String content = s.nextLine();          if(content.equals(\"\")){            content = p.post_content;          }          System.out.print(\"수정하시겠습니까?(y/n) : &gt;&gt; \");          String confirm = s.nextLine();          if(confirm.equalsIgnoreCase(\"y\")){            p.post_title = title;            p.post_content = content;            p.post_mod_dt = new Date();            System.out.println(\"수정되었습니다.\");          }        }else{          System.out.println(\"비밀번호가 일치하지않습니다.\");        }      }    }            public static void deletePost(){      System.out.print(\"삭제할 글 번호 : \");      int n = s.nextInt();      s.nextLine();      BoardPost p =searchPostDetailByNumber(n);      if(p!=null){        p.showPostInfo(true);        System.out.print(\"삭제하시겠습니까?(y/n) : &gt;&gt; \");        String confirm = s.nextLine();        if(confirm.equalsIgnoreCase(\"y\")){          System.out.print(\"글 비밀번호 : &gt;&gt; \");          String pwd = s.nextLine();          if(p.post_pwd.equals(pwd)){            postList.remove(p); //일치하는 것 삭제            System.out.println(\"삭제되었습니다.\");          }else{            System.out.println(\"비밀번호가 일치하지않습니다.\");          }        }      }    }    public static BoardPost searchPostDetailByNumber(int post_no){      for(BoardPost p : postList){        if(p.post_no==post_no){          System.out.println(\"글번호\\t글제목\\t\\t작성자\\t등록일\\t\\t\\t조회수\");          // p.post_count++;          // p.showPostInfo(true);          return p;        }      }      System.out.println(post_no+\"번 글이 존재하지않습니다.\");      return null;    }      }        Integer같은 Wapper클래스는 null값이 올수있어서 return값에 null을 넣어도 되는구나  "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 객체지향언어",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%96%B8%EC%96%B4/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 객체",
    "date": "2022-10-28 00:00:00 +0900",
    





    
    "snippet": "객체≥인스턴스, 객체가 상위개념이나 거의 동일하게 사용함      마우스      package JAVA_221028;      public class Mouse {        //클래스 상수    final static int VALUE = 100;        //클래스변수    //static - 정적메모리(프로그램 실행시에 생성됨)    //...",
    "content": "객체≥인스턴스, 객체가 상위개념이나 거의 동일하게 사용함      마우스      package JAVA_221028;      public class Mouse {        //클래스 상수    final static int VALUE = 100;        //클래스변수    //static - 정적메모리(프로그램 실행시에 생성됨)    //모든 인스턴스가 공유하는 변수    static int count = 0;        //인스턴스변수(Mouse클래스의 멤버변수)    //인스턴스화가 되어야 사용가능(메모리에 생성되어야 사용가능)    boolean wireless;    boolean wheel;    boolean leftBtn;    boolean rightBtn;    int sensor; //0.광 / 1.레이저 / 2.트랙패드 / 3.트랙볼    int shape; //0.일반 / 1.인체공학 / 2.게이밍 / 3.패드        boolean connect;    int posX;    int posY;    int wheelDelta; //휠을 아래로돌렸는지 위로돌렸는지, 속도는 어느정도인지        void deviceConnectToggle() {      connect = !connect;    }        void changeMousePos(int x, int y) {      posX = x;      posY = y;    }        void rollingMouseWheel(int delta) {      wheelDelta = delta;    }        void showStatus() {      System.out.println(\"장치 연결 상태 : \" + (connect ? \"연결됨\" : \"연결안됨\"));      if (connect) {        System.out.println(\"마우스 위치 : (\" + posX + \", \" + posY + \")\");        System.out.println(\"휠 변화량 : \"+wheelDelta);      }    }        void printInfo() {      System.out.println(\"마우스 연결 방식 : \" + (wireless ? \"무선\" : \"유선\"));      System.out.println(\"마우스 휠 유무 : \"+(wheel?\"있음\":\"없음\"));      System.out.println(\"마우스 버튼(왼쪽) : \"+(leftBtn?\"있음\":\"없음\"));      System.out.println(\"마우스 버튼(오른쪽) : \" + (rightBtn ? \"있음\" : \"없음\"));      if(sensor==0) System.out.println(\"감응방식 : 광\");      else if(sensor==1) System.out.println(\"감응방식 : 레이저\");      else if(sensor==2) System.out.println(\"감응방식 : 트랙패드\");      else if(sensor==3) System.out.println(\"감응방식 : 트랙볼\");              if(sensor==0) System.out.println(\"마우스 형태 : 일반\");      else if(sensor==1) System.out.println(\"마우스 형태 : 인체공학\");      else if(sensor==2) System.out.println(\"마우스 형태 : 게이밍\");      else if(sensor==3) System.out.println(\"마우스 형태 : 패드\");    }        void mouseClick(int btn) {      if (btn == 0) {        System.out.println(\"왼쪽 클릭\");      }      else if (btn == 1) {        System.out.println(\"오른쪽 클릭\");      }      else if (btn == 2) {        System.out.println(\"휠버튼 클릭\");      }    }    public static void main(String[] args) {    }  }          package JAVA_221028;      public class ObjectTestEx01 {          public static void main(String[] args) {      Mouse m1 = new Mouse(); // 클래스의 인스턴스화(메모리에 생성) - 사용가능한상태          m1.wireless = false;      m1.wheel = true;      m1.leftBtn = true;      m1.rightBtn = true;      m1.sensor = 0;      m1.shape = 0;      System.out.println(m1.wireless);      System.out.println(m1.wheel);      System.out.println(m1.leftBtn);      System.out.println(m1.rightBtn);      System.out.println(m1.sensor);      System.out.println(m1.shape);      Mouse m2 = null;      // m2.leftBtn = false; //NullPointerException 에러. 객체생성이안된상태에서 사용하려고해서 에러남      m2.count = 2;      System.out.println(m2.count); // 객체생성없이 사용가능          m1.count = 10;      m2.count = 5;      // m1, m2의 count값이 둘다 5로 바뀜 - static이라서      System.out.println(m1.count);      System.out.println(m2.count);          Mouse.count = 7;      System.out.println(m1.count);      System.out.println(m2.count);      System.out.println(Mouse.count); // 객체 생성없이 사용가능해서 클래스이름을 바로 적어줌      // 전부 7로 바뀜          System.out.println(Integer.MAX_VALUE); // Integer클래스의 MAX_VALUE 클래스변수          System.out.println(Mouse.VALUE);      // Mouse.VALUE = 50; //에러, 상수라서 수정불가          m1.mouseClick(0);      m1.mouseClick(1);      m1.mouseClick(2); // Mouse클래스안의 mouseClick메소드 호출      System.out.println();      // Mouse.mouseClick(2); // 에러. static이 없어서 인스턴스메소드임 = 객체생성필요 or mouseClick메소드에      // static붙이기      m1.printInfo();      // m2.printInfo(); //null에러 값을 모두 안채워줌      // Mouse.printInfo(); //사용불가      System.out.println();      m2 = new Mouse();      m2.wireless = true;      m2.wheel = false;      m2.leftBtn = false;      m2.rightBtn = false;      m2.sensor = 1;      m2.shape = 1;      m2.printInfo();      System.out.println();      m1.deviceConnectToggle();      m1.changeMousePos(960, 540);      m1.rollingMouseWheel(-240);      m1.showStatus();            }  }            회원가입      package JAVA_221028;      import java.util.Date;  import java.util.Scanner;      public class MemberInfo {        String id;    String pwd;    String name;    Date birth;    int gen;    String address;    String phone;    String email;    String profileImg;    String nickname;    String statusMsg;          boolean login(String loginId, String loginPwd) {      return id.equals(loginId) &amp;&amp; pwd.equals(loginPwd);    }        void changePassword(/*String oldPass, String newPass*/) {      Scanner s = new Scanner(System.in);      System.out.print(\"기존 비밀번호 : \");      String oldPass = s.nextLine();      if (!pwd.equals(oldPass)) {        System.out.println(\"비밀번호가 틀렸습니다.\");        return;      }      System.out.print(\"새 비밀번호 : \");      String newPass = s.nextLine();      pwd = newPass;      System.out.println(\"비밀번호가 변경되었습니다.\");    }        void changeDetailInfo(String attr) {      Scanner s = new Scanner(System.in);      if (attr.equals(\"address\")) {        System.out.print(\"변경할 주소 : \");        address = s.nextLine();        System.out.println(\"주소가 변경되었습니다.\");      }      if (attr.equals(\"phone\")) {        System.out.print(\"변경할 전화번호(-제외) : \");        phone = s.nextLine();        System.out.println(\"번호가 변경되었습니다.\");      }      if (attr.equals(\"email\")) {        System.out.print(\"변경할 이메일 : \");        email = s.nextLine();        System.out.println(\"이메일이 변경되었습니다.\");      }      if (attr.equals(\"profileImg\")) {        System.out.print(\"프로필 이미지 파일 : \");        profileImg = s.nextLine();        System.out.println(\"프로필 이미지가 변경되었습니다.\");      }      if (attr.equals(\"nickname\")) {        System.out.print(\"변경할 닉네임 : \");        nickname = s.nextLine();        System.out.println(\"닉네임이 변경되었습니다.\");      }      if (attr.equals(\"statusMsg\")) {        System.out.print(\"변경할 상태메세지 : \");        statusMsg = s.nextLine();        System.out.println(\"상태메세지가 변경되었습니다.\");      }    }        void showInfo() {      System.out.println(\"아이디 : \"+id);      System.out.println(\"이름 : \"+name);      System.out.println(\"생일 : \"+birth);      System.out.println(\"성별 : \"+gen);      System.out.println(\"주소 : \"+address);      System.out.println(\"전화번호 : \"+phone);      System.out.println(\"이메일 : \"+email);      System.out.println(\"프로필사진 : \"+profileImg);      System.out.println(\"닉네임 : \"+nickname);      System.out.println(\"상태메시지 : \"+statusMsg);    }  }          package JAVA_221028;      import java.util.Date;  import java.util.Scanner;      public class Object_memberTestEx {    public static void main(String[] args) {      MemberInfo member1 = new MemberInfo();      member1.id = \"user1\";      member1.pwd = \"123456\";      member1.name = \"사용자\";      member1.birth = new Date(); // 실행 시 날짜      member1.gen = 0;      member1.address = \"대구 중구 중앙대로 394\";      member1.phone = \"01012345678\";      member1.email = \"user@service.com\";      member1.profileImg = \"pfimg.jpg\";      member1.nickname = \"사용자\";      member1.statusMsg = \"ㅁㅁㅁㅁ\";          member1.showInfo();      if (member1.login(\"user1\", \"123456\")) {        System.out.println(\"로그인 성공\");      } else {        System.out.println(\"로그인 실패\");      } // 성공          if (member1.login(\"user2\", \"123456\")) {        System.out.println(\"로그인 성공\");      } else {        System.out.println(\"로그인 실패\");      } // 실패          member1.changePassword();          System.out.println(\"변경할 상세정보[phone, email, profileImg, nickname, statusMsg\");      Scanner s = new Scanner(System.in);      String field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();          s.close();    }  }            영화      package JAVA_221028;      import java.util.Date;      public class MovieBasicInfo {    String[] status_list = { \"개봉예정\", \"상영중\", \"상영종료\", \"재개봉\", \"VOD\" };    String title_kor; //한글제목    String title_eng; //영어제목    int status; //0:개봉예정, 1:상영중, 2:상영종료, 3:재개봉, 4:VOD    double audience_score; //관람객평점    double netizen_score; //네티즌 평점    double critic_score; //기자,평론가 평점    String genre; //장르    String country; //국가    int running_time; //상영시간    Date opening_dt; //날짜데이터를 dt로 씀, 개봉일    String director; //감독    String main_actor; //주연배우    String sub_actor; //조연배우    int viewing_age; //관람등급    int acc_audience; //누적관객    String poster_img; //포스터이미지        void showInfo(){      System.out.println(title_kor + \"(\" + title_eng + \")\"+\" [\"+status_list[status]+\"]\");      System.out.printf(\"관람객 평점 : %.2f / 네티즌 평점 : %.2f / 기자, 평론가 평점 : %.2f\\n\",audience_score, netizen_score, critic_score);      System.out.println(\"장르 : \" + genre + \" / 국가 : \" + country + \" / 상영시간 : \" + running_time + \"분\");      System.out.println(\"개봉일 : \" + opening_dt + \" / 감독\" + director + \" / 주연 : \" + main_actor + \" / 조연 : \" + sub_actor);      String str_viewing_age = \"\";      if (viewing_age == 0){        str_viewing_age = \"전체관람\";      }      else {        str_viewing_age = viewing_age + \"세 이상 관람가\";      }      System.out.println(\"관람등급 : \"+str_viewing_age+\"누적관객 : \"+acc_audience+\"명 / 포스터이미지 : \"+poster_img);    }    void changeMovieStatus(int status){      if(status&lt;0 || status &gt;= status_list.length){        System.out.println(\"상태변경 실패 (0~4중 입력)\");        return;      }      System.out.println(\"상태 변경 : \"+status_list[this.status]+\" -&gt; \"+status_list[status]);      status=status;    }    void changeAudienceScore(double score){      System.out.println(\"관람객 평점 변경 : \"+this.audience_score+\" -&gt; \"+score);      audience_score=score;    }    void changeNetizenScore(double score){      System.out.println(\"네티즌 평점 변경 : \"+this.netizen_score+\" -&gt; \"+score);      netizen_score=score;            }    void changeCriticScore(double score){      System.out.println(\"기자, 평론가 평점 변경 : \"+this.critic_score+\" -&gt; \"+score);      this.critic_score=score;    }    void addAudienceCount(int count){      System.out.println(\"누적 관객 수 : \"+acc_audience+\" -&gt; \"+count);      acc_audience=count;    }  }          package JAVA_221028;      import java.util.Date;      public class MovieTest {    public static void main(String[] args) {      MovieBasicInfo movie = new MovieBasicInfo();      movie.title_kor = \"블랙 아담\";      movie.title_eng = \"Black Adam\";      movie.status = 1;      movie.audience_score = 7.60;      movie.netizen_score = 7.70;      movie.critic_score = 5.67;      movie.genre = \"액션, 모험, SF\";      movie.country = \"미국\";      movie.running_time = 125;      //연도는 현재연도에서 1900뻼      movie.opening_dt = new Date(122,9,19); //쓰는거 권장안한다고 줄그어짐      movie.director = \"자움 콜렛 세라\";      movie.main_actor = \"드웨인 존슨\";      movie.sub_actor = \"노아센티네오, 피어스 프로스넌\";      movie.viewing_age = 12;      movie.acc_audience = 531013;      movie.poster_img = \"poster.jpg\";              movie.showInfo();      System.out.println();          movie.changeMovieStatus(2);      System.out.println();      movie.showInfo();      System.out.println();      movie.changeMovieStatus(9);      movie.changeMovieStatus(1);      movie.changeMovieStatus(3);      movie.changeMovieStatus(4);      System.out.println();      movie.showInfo();          movie.changeAudienceScore(8.05);      movie.changeNetizenScore(6.80);      movie.changeCriticScore(5.98);      movie.addAudienceCount(853153);      movie.showInfo();    }  }        접근제한자를 안쓰면 다른폴더에서는 못씀  마켓컬리(그나마 간단함..마켓컬리→쿠팡→다나와)들어가서 제품정보 클래스로 작성할인가격, 원가 모두 표시해야함setter mothod : 속성이 private인 멤버변수의 값을 설정하는 용도getter method : 값을 내어보이는 역할을 하는 메소드마켓컬리      마켓컬리      public class KurlyProduct {    public static void main(String[] args) {            }        final String[] delivery = {\"일반택배\",\"샛별배송\",\"낮배송\"};    String prod_img; //상품이미지    String prod_manufacturer; //상품제조사    String prod_title; //상품명    String prod_sub_title; //상품부제목    String prod_seller; //판매자    String prod_unit; //상품판매단위    String prod_quantity; //상품용량    String prod_notice; //안내사항          //정보 은닉    private int prod_price; //가격    private double prod_discount_rate; //할인률    private double prod_Point_rate; //적립률    private int prod_delivery_type; //배송타입 0-일반택배/ 1-샛별배송 / 2-낮배송    private int prod_stock; //재고        void printProductInfo(boolean login){      System.out.println(\"제품 이미지 :\"+prod_img);      System.out.println(\"배송구분 :\"+delivery[prod_delivery_type]);      System.out.println(\"[\"+prod_manufacturer+\"]\"+prod_title);      System.out.println(prod_sub_title);      if(login){        System.out.println(\"제품 원가 : \"+prod_price+\"원\");        System.out.println(\"할인률 : \"+(int)(prod_discount_rate*100)+\"%\");        System.out.println(\"할인 적용 가 : \"+getDiscountedPrice(login)+\"원\");        System.out.println(\"적립율 : \"+(int)(prod_Point_rate*100)+\"%\");        System.out.println(\"적립포인트 : \"+getSavingPoint(login)+\"점\");      }else{        System.out.println(\"제품 가격 : \"+prod_price+\"원\");      }      System.out.println(\"판매자 : \"+prod_seller);      System.out.println(\"판매단위 : \"+prod_unit);      System.out.println(\"제품용량 : \"+prod_quantity);      System.out.println(\"제품안내사항 : \"+prod_notice);    }    int getDiscountedPrice(boolean login){      if(login){        return (int)(prod_price*(1-prod_discount_rate));      }      return prod_price;      }    int getSavingPoint(boolean login){      if(login){        return (int)(getDiscountedPrice(login)*prod_Point_rate);      }      return 0;    }    boolean isOrderAvailable(){ //재고가없으면 false      return prod_stock&gt;0;    }    boolean productOrder(int stock){      if(prod_stock-stock&gt;=0){        System.out.println(\"제품을 \"+stock+\"개 주문했습니다.\");        prod_stock -= stock;        return true;      }        System.out.println(\"제품의 재고가 부족합니다. (재고수량 : \"+prod_stock+\")\");        return false;    }        void setProductPrice(int price){      if(price&lt;0){        prod_price = 0;      }else {        prod_price = price;      }    }    void setProductDiscountRate(double discount_rate){      if(discount_rate&lt;0){        prod_discount_rate = 0;      }else if(discount_rate&gt;=1){        prod_discount_rate=1;      }else {        prod_discount_rate = discount_rate;      }    }    void setProductPointRate(double point_rate){      if(point_rate&lt;0){        prod_Point_rate = 0;      }else if(point_rate&gt;=1){        prod_Point_rate=1;      }else {        prod_Point_rate = point_rate;      }    }    void setProductDeliveryType(int delivery_type){      if(delivery_type&gt;=0 &amp;&amp; delivery_type &lt; delivery.length){        prod_delivery_type = delivery_type;      }else{        prod_delivery_type=0;      }    }    void setProductStock(int stock){      if(stock&lt;0){        stock = 0;      }else{        prod_stock=stock;      }    }  }          public class KurlyMain {    public static void main(String[] args) {      KurlyProduct prod1 = new KurlyProduct();      // prod1.printProductInfo(false);      // System.out.println();      // prod1.printProductInfo(true);      // System.out.println();              prod1.prod_img = \"product.jpg\";      prod1.prod_manufacturer = \"루메나\";      prod1.prod_title = \"루메나 FAN STAND 3X 무선 써큘레이터\";      prod1.prod_sub_title = \"감성 캠핑의 완성\";      prod1.prod_seller = \"컬리\";      prod1.prod_unit = \"1개\";      prod1.prod_quantity = \"-\";      prod1.prod_notice = \"-\";              // prod1.prod_price = -50000; //에러, private를 붙여서 직접접근 불가능함. KurlyProduct클래스 안에서만 접근 가능       // System.out.println(prod1.prod_price); //에러. 직접접근 불가능          //setter mothod (속성이 private인 멤버변수의 값을 설정하는 용도)      prod1.setProductPrice(39900);      prod1.setProductDiscountRate(0.1253);      prod1.setProductPointRate(0.05);      prod1.setProductDeliveryType(2);      prod1.setProductStock(10);          boolean login = true;      // login = false;      System.out.println();      prod1.printProductInfo(login);          int order = 8;      //getter method : 값을 내어보이는 역할을 하는 메소드      if(prod1.productOrder(order)){        System.out.println(\"총 구매 금액 : \"+prod1.getDiscountedPrice(login)*order+\"원\");      }      order = 5;      if(prod1.productOrder(order)){        System.out.println(\"총 구매 금액 : \"+prod1.getDiscountedPrice(login)*order+\"원\");      }      order = 2;      if(prod1.productOrder(order)){        System.out.println(\"총 구매 금액 : \"+prod1.getDiscountedPrice(login)*order+\"원\");      }    }  }      예제public class Account {  private int balance; //계좌 잔액  private String owner;  // 계좌 소유자 이름  public Account(int balance, String owner){    this.balance = balance;    this.owner = owner;  }  public Account(){  }  void setBalance(int balance){    if(balance&lt;0){      System.out.println(\"입력값이 잘못되었습니다.\");      return;    }    this.balance = balance;  }  int getBalance(){    return this.balance; //일반적으로 this 붙임  }  void setOwner(String owner){    this.owner = owner;  }  String getOwner(){    return this.owner;  }  void withdraw(int money){    System.out.println(\"출금 신청 액 : \"+money+\"원\");    if(money&lt;0){      System.out.println(\"출금액이 잘못 입력되었습니다.\");      return;    }    if(this.balance&lt;money){      System.out.println(\"잔액이 부족합니다.\");      return;    }    this.balance -= money;    System.out.println(money+\"원을 출금하였습니다. (잔액 : \"+balance+\"원)\");  }  void deposit(int money){    System.out.println(\"입금 신청 액 : \"+money+\"원\");    if(money&lt;0){      System.out.println(\"입금액이 잘못 입력되었습니다.\");      return;    }    this.balance += money;    System.out.println(money+\"원을 입금하였습니다. (잔액 : \"+balance+\"원)\");  }  void showInfo(){    System.out.println(\"소유주 : \"+this.owner+\" / 잔액 : \"+this.balance);  }}public class AccountEx {  public static void main(String[] args) {    Account account = new Account(10000,\"빅데이터\");    account.showInfo();    account.withdraw(100000);    account.withdraw(-100000);    account.withdraw(1000);    account.deposit(35000);    account.deposit(-10000);    account.showInfo();    account.setBalance(-1000);    account.showInfo();  }}      점수      public class StudentScore { //클래스 선언(정의, define)        //멤버변수(=인스턴스변수)    private String name;    private double score;        //생성자 : 객체를 생성함과 동시에 실행되는 메소드    //생성자 오버로딩    public StudentScore(){ //기본생성자. 만들지 않으면 빈 상태로 자바에서 생성함      System.out.println(\"StudentScore생성자 실행\");      this.name = \"aaa\";      // this.score = 95;      setScore(95);    }    public StudentScore(String name, double score){ //입력 값이 있는 생성자      System.out.println(\"StudentScore(name, score)\");      this.name = name;      // this.score = score;      setScore(score);    } //입력값이있는 생성자(Constructor)가 있으면 기본생성자는 자바가 자동으로 안만들어줌            //메소드(기능)    void showInfo(){      System.out.println(\"이름 : \"+name);      System.out.println(\"점수 : \"+score);      System.out.println(\"등급 : \"+getGrade());    }        void setScore(double s){ //int s : 파라미터, 외부 입력값      System.out.println(\"double\");      if(s &lt; 0 || s&gt;100){        System.out.println(\"입력값이 잘못되었습니다.\");        return;      }      this.score = s;    }          void setScore(int s){ //int s : 파라미터, 외부 입력값      System.out.println(\"int\");      if(s &lt; 0 || s&gt;100){        System.out.println(\"입력값이 잘못되었습니다.\");        return;      }        this.score = s;    }        String getGrade(){      String grade=\"\";          if(score&gt;100 || score&lt;0){        System.out.println(\"입력값이 잘못되었습니다.\");      }else if(score&gt;=90){        grade = \"A\"+(score&gt;=95?\"+\":\"0\");      }else if(score&gt;=80){        grade = \"B\"+(score&gt;=85?\"+\":\"0\");      }else if(score&gt;=70){        grade = \"C\"+(score&gt;=75?\"+\":\"0\");      }else if(score&gt;=60){        grade = \"D\"+(score&gt;=65?\"+\":\"0\");      }else{        grade = \"F\";      }      return grade;        }      }          public class ScoreMain{    public static void main(String[] args) {      StudentScore std1 = new StudentScore(); //new - 인스턴스화, 객체생성      std1.showInfo();      // std1.name = \"가나다\";      // std1.score = 85.7;      System.out.println();          // System.out.println(std1.name); 뒤늦게 private를 붙여서 에러뜸      // System.out.println(std1.score);              StudentScore std2 = new StudentScore();      std2.showInfo();      System.out.println();          // std2.name=\"라마바\";      // std2.score=95.2; //직접접근방식. 유효성검사를 못해서 거의 안씀      // System.out.println(std2.name);      // System.out.println(std2.score);              System.out.println(std1);      System.out.println(std2);              StudentScore[] std = {std1,std2};      System.out.println(std[0]);      System.out.println(std[1]);      System.out.println();      // System.out.println(std[0].name);      // System.out.println(std[1].name);              std1.showInfo();      std2.showInfo();      System.out.println();      std[0].showInfo();      std[1].showInfo();      System.out.println();      std[0].setScore(807.0);      std[0].showInfo();      System.out.println();      std[0].setScore(80.7); //간접접근방식      std[0].showInfo();              System.out.println(std[0].getGrade());      System.out.println(std[1].getGrade());              String g = std2.getGrade();      System.out.println(g);              StudentScore std3 = new StudentScore();      System.out.println(std3.getGrade()); //double초기값이 0이라서 f나옴          StudentScore std4 = new StudentScore(\"aaaa\",75);      std4.showInfo();      std4.setScore(85);      std4.setScore(85.7);        }  }            배달의 민족    일단 내가 짠거      public class restaurant {            final String[] pay = {\"만나서 결제, 바로결제\",\"매장, 포장\"};    private int min_amount;    private int min_time;    private int max_time;    private int min_delivery_tips;    private int max_delivery_tips;    private int pickup_amount;    private int pickup_min_time;    private int pickup_max_time;    private String address;    private String img;    private String name;    private String open_time;    private String close_time;    private String delivery_area;    private String notice;        restaurant(){}    restaurant(String attr[],int min_amount, int min_time, int max_time,               int min_delivery_tips, int max_delivery_tips, int pickup_amount, int pickup_min_time,               int pickup_max_time,String address)      {      this.img = attr[0];      this.name = attr[1];      this.open_time = attr[2];      this.close_time = attr[3];      this.delivery_area = attr[4];      this.notice = attr[5];      setMinAmount(min_amount);      setMinTime(min_time);      setMaxTime(max_time);      setMinDeliveryTips(min_delivery_tips);      setMaxDeliveryTips(max_delivery_tips);      setPickUpAmount(pickup_amount);      setPickUpMinTime(min_time);      setPickUpMinTime(max_time);      setPickUpMinTime(pickup_min_time);      setPickUpMaxTime(pickup_max_time);      setAddress(address);    }          void setName(String name){      this.name = name;    }    void setMinAmount(int min_amount){      if(min_amount&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");      }      this.min_amount = min_amount;    }    void setAddress(String address){      this.address = address;    }    void setMinTime(int min_time){      if(min_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.min_time = min_time;    }    void setMaxTime(int max_time){      if(max_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.max_time = max_time;    }    void setMinDeliveryTips(int min_delivery_tips){      if(min_delivery_tips&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.min_delivery_tips = min_delivery_tips;    }    void setMaxDeliveryTips(int max_delivery_tips){      if(max_delivery_tips&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.max_delivery_tips = max_delivery_tips;    }    void setPickUpAmount(int pickup_amount){      if(pickup_amount&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_amount = pickup_amount;    }    void setPickUpMinTime(int pickup_min_time){      if(pickup_min_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_min_time = pickup_min_time;    }    void setPickUpMaxTime(int pickup_max_time){      if(pickup_max_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_max_time = pickup_max_time;    }    void showInfo(){      System.out.println(\"이미지 : \"+img);      System.out.println(\"상호 : \"+name);      System.out.println(\"운영시간 : \"+open_time+\" ~ \"+close_time);      System.out.println(\"배달가능지역 : \"+delivery_area);      System.out.println(\"공지 : \"+notice);      System.out.println(\"===배달주문===\");      System.out.println(\"최소 주문 금액 : \"+min_amount);      System.out.println(\"결제방법 : \"+pay[0]);      if(min_time == 0){        System.out.println(\"배달시간 : \"+max_time+\"분 소요 예상\");      }else{        System.out.println(\"배달시간 : \"+min_time+\"~\"+max_time+\"분 소요 예상\");      }      if(min_delivery_tips == 0){        System.out.println(\"배달팁 : \"+max_delivery_tips+\"원\");      }else{        System.out.println(\"배달팁 : \"+min_delivery_tips+\"~\"+max_delivery_tips+\"원\");      }          System.out.println(\"===포장/방문주문===\");      if(pickup_amount != 0){        System.out.println(\"할인 : \"+pickup_amount+\"(\"+min_amount+\"원 이상 포장시 할인됩니다.)\");      }      System.out.println(\"최소 주문 금액 : 없음\");      System.out.println(\"이용방법 : \"+pay[1]);      if(pickup_min_time == 0){        System.out.println(\"픽업시간 : \"+pickup_max_time+\"분 소요 예상\");      }else{        System.out.println(\"픽업시간 : \"+pickup_min_time+\"~\"+pickup_max_time+\"분 소요 예상\");      }      System.out.println(\"주소 : \"+address);      System.out.println();      showMenu();      System.out.println();    }        private String[][] menu = new String[10][2];    private int index;    void addmenu(String item_name, String price){      if(index&gt;=menu.length){        System.out.println(\"상품을 등록할 수 없습니다. 관리자에게 문의하세요\");        index=9;        return;      }      if(Integer.parseInt(price)&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      menu[index][0]=item_name;      menu[index][1]= (String)price;      index++;    }    void showMenu(){      System.out.println(\"=======메뉴=======\");      for(int i=0;i&lt;=index;i++){        if(menu[i][0]==null){          System.out.println(\"아직 등록된 메뉴가 없습니다.\");          System.out.println(\"==================\");          continue;        }         System.out.println(\"상품 : \"+menu[i][0]);        System.out.println(\"가격 : \"+menu[i][1]);        System.out.println(\"===================\");      }    }    void order(String item_name, int num, int delivery_type){      for(int i=0;i&lt;=index;i++){        if(item_name.equals(menu[i][0])){          int sum = num*Integer.parseInt(menu[i][1]);          if(sum&lt;min_amount){            System.out.println(\"최소주문금액보다 주문금액이 적습니다.\");            return;          }          if(sum&gt;=20000){            System.out.println((sum)+\"원 주문하셨습니다\");            System.out.println(\"주문 메뉴 : \"+menu[i][0]);            System.out.println(\"주문 수량 : \"+num);            if(delivery_type==0){              System.out.println(\"배달비 : \"+min_delivery_tips);              System.out.println(\"총 결제금액 : \"+(sum+min_delivery_tips));            }else{              System.out.println(\"총 결제금액 : \"+sum);            }          }else{            System.out.println((sum)+\"원 주문하셨습니다\");            System.out.println(\"주문 메뉴 : \"+menu[i][0]);            System.out.println(\"주문 수량 : \"+num);            if(delivery_type==0){              System.out.println(\"배달비 : \"+max_delivery_tips);              System.out.println(\"총 결제금액 : \"+(sum+max_delivery_tips));            }else{              System.out.println(\"총 결제금액 : \"+sum);            }          }          return;        }      }      System.out.println(\"메뉴를 잘못입력하셨습니다.\");    }  }          public class restaurantEx {    public static void main(String[] args) {      String attr[] = {\"cafe.jpg\",\"커피홀\",\"오전 8:50\",\"오후 11:00\",\"내당동, 비산동, ...\",\"디저트만 배달이 불가합니다. 음료와 함께 주문해주세요\"};      restaurant cafe = new restaurant(attr,10000,9,24,1000,2500,0,5,15,\"대구 서구 내당동 890-37\");      cafe.showInfo();      System.out.println();      // restaurant chicken = new restaurant();      // chicken.setName(\"동근이숯불두마리치킨\");      // chicken.setMinAmount(16000);      // chicken.setMinTime(49);      // chicken.setMaxTime(64);      // chicken.setMaxDeliveryTips(2000);      // chicken.setPickUpAmount(1000);      // chicken.setAddress(\"대구광역시 북구 고성동2가 114-9 1층\");      // chicken.setPickUpMaxTime(32);      // chicken.setPickUpMinTime(22);      // chicken.showInfo();      // System.out.println();              cafe.addmenu(\"아메리카노\", \"3700\");      cafe.addmenu(\"바닐라라떼\", \"4500\");      cafe.addmenu(\"흑당카페라떼\", \"5300\");      cafe.addmenu(\"제주한라봉스무디\", \"5300\");      cafe.addmenu(\"콜드브루 아인슈페너\", \"5500\");      cafe.addmenu(\"홍시주스\", \"5500\");      cafe.addmenu(\"초코렛라떼\", \"4300\");      cafe.addmenu(\"그린티라떼\", \"4300\");      cafe.addmenu(\"캐모마일허브티\", \"4300\");      cafe.addmenu(\"망고쥬스\", \"5500\");      cafe.addmenu(\"레몬에이드\", \"5000\");      System.out.println();      System.out.println();      cafe.showInfo();          cafe.order(\"아메리카노\", 2,0);      System.out.println();      cafe.order(\"아메\", 2,1);      System.out.println();      cafe.order(\"바닐라라떼\", 10,1);      System.out.println();      cafe.order(\"콜드브루 아인슈페너\", 3,0);        }  }          public class restaurant {            final String[] pay = {\"만나서 결제, 바로결제\",\"매장, 포장\"};    private int min_amount;    private int min_time;    private int max_time;    private int min_delivery_tips;    private int max_delivery_tips;    private int pickup_amount;    private int pickup_min_time;    private int pickup_max_time;    private String address;    private String img;    private String name;    private String open_time;    private String close_time;    private String delivery_area;    private String notice;        restaurant(){}    restaurant(String attr[],int min_amount, int min_time, int max_time,         int min_delivery_tips, int max_delivery_tips, int pickup_amount, int pickup_min_time,         int pickup_max_time,String address)      {      this.img = attr[0];      this.name = attr[1];      this.open_time = attr[2];      this.close_time = attr[3];      this.delivery_area = attr[4];      this.notice = attr[5];      setMinAmount(min_amount);      setMinTime(min_time);      setMaxTime(max_time);      setMinDeliveryTips(min_delivery_tips);      setMaxDeliveryTips(max_delivery_tips);      setPickUpAmount(pickup_amount);      setPickUpMinTime(min_time);      setPickUpMinTime(max_time);      setPickUpMinTime(pickup_min_time);      setPickUpMaxTime(pickup_max_time);      setAddress(address);    }          void setName(String name){      this.name = name;    }    void setMinAmount(int min_amount){      if(min_amount&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");      }      this.min_amount = min_amount;    }    void setAddress(String address){      this.address = address;    }    void setMinTime(int min_time){      if(min_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.min_time = min_time;    }    void setMaxTime(int max_time){      if(max_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.max_time = max_time;    }    void setMinDeliveryTips(int min_delivery_tips){      if(min_delivery_tips&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.min_delivery_tips = min_delivery_tips;    }    void setMaxDeliveryTips(int max_delivery_tips){      if(max_delivery_tips&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.max_delivery_tips = max_delivery_tips;    }    void setPickUpAmount(int pickup_amount){      if(pickup_amount&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_amount = pickup_amount;    }    void setPickUpMinTime(int pickup_min_time){      if(pickup_min_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_min_time = pickup_min_time;    }    void setPickUpMaxTime(int pickup_max_time){      if(pickup_max_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_max_time = pickup_max_time;    }    void showInfo(){      System.out.println(\"이미지 : \"+img);      System.out.println(\"상호 : \"+name);      System.out.println(\"운영시간 : \"+open_time+\" ~ \"+close_time);      System.out.println(\"배달가능지역 : \"+delivery_area);      System.out.println(\"공지 : \"+notice);      System.out.println(\"===배달주문===\");      System.out.println(\"최소 주문 금액 : \"+min_amount);      System.out.println(\"결제방법 : \"+pay[0]);      if(min_time == 0){        System.out.println(\"배달시간 : \"+max_time+\"분 소요 예상\");      }else{        System.out.println(\"배달시간 : \"+min_time+\"~\"+max_time+\"분 소요 예상\");      }      if(min_delivery_tips == 0){        System.out.println(\"배달팁 : \"+max_delivery_tips+\"원\");      }else{        System.out.println(\"배달팁 : \"+min_delivery_tips+\"~\"+max_delivery_tips+\"원\");      }          System.out.println(\"===포장/방문주문===\");      if(pickup_amount != 0){        System.out.println(\"할인 : \"+pickup_amount+\"(\"+min_amount+\"원 이상 포장시 할인됩니다.)\");      }      System.out.println(\"최소 주문 금액 : 없음\");      System.out.println(\"이용방법 : \"+pay[1]);      if(pickup_min_time == 0){        System.out.println(\"픽업시간 : \"+pickup_max_time+\"분 소요 예상\");      }else{        System.out.println(\"픽업시간 : \"+pickup_min_time+\"~\"+pickup_max_time+\"분 소요 예상\");      }      System.out.println(\"주소 : \"+address);      System.out.println();      showMenu();      System.out.println();    }        private String[][] menu = new String[10][2];    private int index;    void addmenu(String item_name, String price){      if(index&gt;=menu.length){        System.out.println(\"상품을 등록할 수 없습니다. 관리자에게 문의하세요\");        index=9;        return;      }      if(Integer.parseInt(price)&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      menu[index][0]=item_name;      menu[index][1]= (String)price;      index++;    }    void showMenu(){      System.out.println(\"=======메뉴=======\");      for(int i=0;i&lt;=index;i++){        if(menu[i][0]==null){          System.out.println(\"아직 등록된 메뉴가 없습니다.\");          System.out.println(\"==================\");          continue;        }         System.out.println(\"상품 : \"+menu[i][0]);        System.out.println(\"가격 : \"+menu[i][1]);        System.out.println(\"===================\");      }    }    private String[][] cart = new String[10][3];    int cart_index;    void addcart(String item_name, int num, int delivery_type){      for(int i=0;i&lt;=index;i++){        if(item_name.equals(menu[i][0])){          cart[cart_index][0] = menu[i][0];          cart[cart_index][1] = Integer.toString(num);          cart[cart_index][2] = menu[i][1];          cart_index++;        }      }      System.out.println(\"메뉴를 잘못입력하셨습니다.\");    }          void order(int delivery_type){      int sum=0;      String order_list=\"\";      for(int i=0;i&lt;=index;i++){        if(cart[i][0]==null){          continue;        }        sum += Integer.parseInt(cart[i][1])*Integer.parseInt(cart[i][2]);        order_list += cart[i][0] +\" \" + cart[i][1]+ \"개, \"+\"\\n\";      }      if(sum&lt;min_amount){        System.out.println(\"최소주문금액보다 주문금액이 적습니다.\");        return;      }      if(sum&gt;=20000){        System.out.println(\"주문 메뉴 : \\n\"+order_list);        if(delivery_type==0){          System.out.println(\"배달비 : \"+min_delivery_tips);          System.out.println(\"총 결제금액 : \"+(sum+min_delivery_tips));        }else{          System.out.println(\"총 결제금액 : \"+sum);        }      }else{        System.out.println((sum)+\"원 주문하셨습니다\");        System.out.println(\"주문 메뉴 : \"+order_list);        if(delivery_type==0){          System.out.println(\"배달비 : \"+max_delivery_tips);          System.out.println(\"총 결제금액 : \"+(sum+max_delivery_tips));        }else{          System.out.println(\"총 결제금액 : \"+sum);        }      }    }  }          public class restaurantEx {    public static void main(String[] args) {      String attr[] = {\"cafe.jpg\",\"커피홀\",\"오전 8:50\",\"오후 11:00\",\"내당동, 비산동, ...\",\"디저트만 배달이 불가합니다. 음료와 함께 주문해주세요\"};      restaurant cafe = new restaurant(attr,10000,9,24,1000,2500,0,5,15,\"대구 서구 내당동 890-37\");      cafe.showInfo();      System.out.println();      // restaurant chicken = new restaurant();      // chicken.setName(\"동근이숯불두마리치킨\");      // chicken.setMinAmount(16000);      // chicken.setMinTime(49);      // chicken.setMaxTime(64);      // chicken.setMaxDeliveryTips(2000);      // chicken.setPickUpAmount(1000);      // chicken.setAddress(\"대구광역시 북구 고성동2가 114-9 1층\");      // chicken.setPickUpMaxTime(32);      // chicken.setPickUpMinTime(22);      // chicken.showInfo();      // System.out.println();              cafe.addmenu(\"아메리카노\", \"3700\");      cafe.addmenu(\"바닐라라떼\", \"4500\");      cafe.addmenu(\"흑당카페라떼\", \"5300\");      cafe.addmenu(\"제주한라봉스무디\", \"5300\");      cafe.addmenu(\"콜드브루 아인슈페너\", \"5500\");      cafe.addmenu(\"홍시주스\", \"5500\");      cafe.addmenu(\"초코렛라떼\", \"4300\");      cafe.addmenu(\"그린티라떼\", \"4300\");      cafe.addmenu(\"캐모마일허브티\", \"4300\");      cafe.addmenu(\"망고쥬스\", \"5500\");      cafe.addmenu(\"레몬에이드\", \"5000\");      System.out.println();      System.out.println();      cafe.showInfo();          cafe.addcart(\"아메리카노\", 2,0);      System.out.println();      cafe.addcart(\"아메\", 2,1);      System.out.println();      cafe.addcart(\"바닐라라떼\", 10,1);      System.out.println();      cafe.addcart(\"콜드브루 아인슈페너\", 3,0);          cafe.order(0);      System.out.println();      cafe.order(1);        }  }        이차원 String배열에 int값을 받는게 애매해서 선생님께 이럴때는 일차원배열을 여러개 쓰는게 낫냐고 물어봤는데 일반적으로는 클래스배열을 사용한다고 하심!!클래스배열….      public class StoreBasicInfo {    String thumbnail;    String name;    Double score;    Integer min_order_price;    String[] payments;    Integer min_delivery_time;    Integer max_delivery_time;    Integer min_delivery_price;    Integer max_delivery_price;        public StoreBasicInfo(        String thumbnail, String name, double score, int min_order_price, String[] payments,       int min_delivery_time, int max_delivery_time, int min_delivery_price, int max_delivery_price    ){      this.thumbnail=thumbnail;      setName(name);      setScore(score);      setMinOrderPrice(min_order_price);      setPayments(payments);      setDeliveryTime(min_delivery_time, max_delivery_time);      setDeliveryPrice(min_delivery_price, max_delivery_price);    }        void setName(String name){      if(name.length() ==0){        System.out.println(\"가게 이름을 올바르게 설정하세요.\");      }else{        this.name = name;      }    }    void setScore(double score){      if(score&lt;0 || score&gt;5){        System.out.println(\"별점을 올바르게 입력하세요\");      }else{        this.score = score;      }    }    void setMinOrderPrice(int min_order_price){      if(min_order_price ==0){        System.out.println(\"올바른 최소주문 금액을 입력하세요.\");      }else{        this.min_order_price = min_order_price;      }    }    void setPayments(String[] payments){      if(payments==null || payments.length ==0){        System.out.println(\"올바른 결제방법을 입력하세요.\");      }else{        this.payments = payments;      }    }    void setDeliveryTime(int min, int max){      if(min&lt;0){        System.out.println(\"올바른 배달시간을 입력하세요.\");      }else{        this.min_delivery_time = min;        this.max_delivery_time = max;      }    }    void setDeliveryPrice(int min, int max){      if(min&lt;0){        System.out.println(\"올바른 배달팁을 입력하세요.\");      }else{        this.min_delivery_price = min;        this.max_delivery_price = max;      }    }    public String toString(){      String str =\"\";      str += \"=======================기존정보=======================\\n\";      str += name+\"\\n\";      int nScore = (int)(Math.round(score));      str += \"별점 : \";      for(int i=0;i&lt;5;i++){        if(i &lt; nScore){          str+=\"★ \";        }else{          str+=\"☆\";        }      }      str+=\" \"+score+\"\\n\";      str +=\"최소주문금액 : \"+min_order_price+\"원\\n\";      str += \"결제 방법 : \";      for(int i=0;i&lt;payments.length;i++){        str += payments[i]+ \" \";      }      str+=\"배달시간 : \"+min_delivery_time+\" ~ \"+max_delivery_time+\"분\\n\";      str+=\"배달 팁 : \"+min_delivery_price + \" ~ \"+max_delivery_price+\"원\\n\";          return str;    }  }          public class StoreBusinessInfo {    String business_owner;    String business_name;    String business_address;    String business_number;        public StoreBusinessInfo(        String business_owner,        String business_name,        String business_address,        String business_number      ){        this.business_owner = business_owner;        this.business_name = business_name;        this.business_address = business_address;        this.business_number = business_number;                }      public String toString(){        String str = \"\";        str +=\"대표자 : \"+business_owner+\"\\n\";        str +=\"상호명 : \"+business_name+\"\\n\";        str +=\"사업자주소 : \"+business_address+\"\\n\";        str +=\"사업자등록번호 : \"+business_number;            return str;      }  }          public class StoreDetailInfo {    String introduce;    String origin_name;    String open_time;    String close_time;    String[] close_day;    String phone;    String delivery_area;    String notice;    // int[][] delivery_boundary;    DeliveryBoundary[] delivery_boundaries;          public StoreDetailInfo(      String introduce, String origin_name, String open_time, String close_time, String[] close_day, String phone,       String delivery_area, String notice, DeliveryBoundary[] delivery_boundaries    ){      this.introduce = introduce;      this.origin_name = origin_name;      this.open_time = open_time;      this.close_time = close_time;      this.close_day=close_day;      this.phone = phone;      this.delivery_area = delivery_area;      this.notice = notice;      this.delivery_boundaries =delivery_boundaries;    }        public String toString(){      String str=\"\";      str += \"가게소개 \\n\";      str +=introduce+\"\\n\";      str = \"영업정보\\n\";      str = \"상호명 : \"+origin_name+\"\\n\";      str = \"영업시간 : \"+open_time+\" ~ \"+close_time+\"\\n\";      str = \"휴무일 : \";      if(close_day == null){        str+=\"연중무후\";      }else{        str+=close_day+\"/n\";      }      str = \"전화번호 : \"+phone+\"\\n\";      str = \"배달지역 : \"+delivery_area+\"\\n\";      str = \"배달팁\\n\";      if(delivery_area == null){        str+=\"무료\";      }else{        for(int i=0;i&lt;delivery_boundaries.length;i++){          str+=delivery_boundaries[i].boundary+\"원 이상 : \";          str+=delivery_boundaries[i].price+\"원\\n\";        }      }          return str;    }      }          public class StoreInfo {    StoreBasicInfo store_basic;    StoreDetailInfo store_detail;    StoreBusinessInfo store_business;    public String toString(){      String str =\"\";      str+=store_basic.toString();      str+=store_detail.toString();      str+=store_business.toString();      return str;    }        public StoreInfo(StoreBasicInfo basicInfo, StoreDetailInfo detial, StoreBusinessInfo business){      store_basic = basicInfo;      store_detail = detial;      store_business = business;    }  }          public class StoreMain {    public static void main(String[] args) {      // StoreInfo store = new StoreInfo();      String[] payments={\"바로결제\",\"만나서결제\"};      StoreBasicInfo basicInfo = new StoreBasicInfo(\"store.jpg\", \"교촌치킨 송현점\", 4.9, 16000, payments, 38, 53, 2000, 3000);      System.out.println(basicInfo);      // store.store_basic = basicInfo;      DeliveryBoundary[] boundaries = {        new DeliveryBoundary(50000, 2000),        new DeliveryBoundary(16000, 3000)      };      StoreDetailInfo detailInfo = new StoreDetailInfo(\"바쁘면 오래걸림, 따뜻한 치킨 배달하겠음\",        \"교촌치킨 송현1호점\", \"12:30\", \"23:35\", null, \"050-6115-1090\", \"송현1동 송현2동 본동일부 상인동 대명동\",         \"포장은 접수번호를 말하세요, 귀찮으면 전번 알려주세요\", boundaries);        // store.store_detail=detailInfo;        StoreBusinessInfo businessInfo = new StoreBusinessInfo(\"노경곤\", \"교촌치킨 송현 1호점\", \"대구광역시 달서구 송현동 207-2\", \"541-25-55195\");        // store.store_business = businessInfo;        StoreInfo store = new StoreInfo(basicInfo, detailInfo, businessInfo);        System.out.println(store);        StoreInfo store2 = new StoreInfo(          new StoreBasicInfo(\"store.jpg\", \"교촌치킨 송현점\", 4.9, 16000, payments, 38, 53, 2000, 3000),          new StoreDetailInfo(\"바쁘면 오래걸림, 따뜻한 치킨 배달하겠음\",            \"교촌치킨 송현1호점\", \"12:30\", \"23:35\", null, \"050-6115-1090\", \"송현1동 송현2동 본동일부 상인동 대명동\",             \"포장은 접수번호를 말하세요, 귀찮으면 전번 알려주세요\", boundaries),          new StoreBusinessInfo(\"노경곤\", \"교촌치킨 송현 1호점\", \"대구광역시 달서구 송현동 207-2\", \"541-25-55195\"));          System.out.println(store2);    }  }          public class DeliveryBoundary{    int boundary;    int price;    public DeliveryBoundary(int boundary, int price){      setBountdary(boundary);      setPrice(price);    }    void setBountdary(int boundary){      if(boundary&gt;0){        this.boundary=boundary;      }    }    void setPrice(int price){      if(price&gt;0){        this.price=price;      }    }  }      "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 변수와 메소드",
    "url": "/posts/%EB%B3%80%EC%88%98%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C/",
    "categories": "",
    "tags": "java, 국비교육, 변수",
    "date": "2022-10-27 00:00:00 +0900",
    





    
    "snippet": "인스턴스변수 : 대표적으로 String str = new String(0);지역변수 : 메소드내에서 변수선언문 수행 시메소드 : 명령문의 집합. 값을 입력받아처리 후 결과를 돌려줌(결과 안돌려줄수도있음 - void[공허]), ()붙은건 전부 메소드임. - 정보은닉, 캡슐화  cmd로 args값 받는 법M누르고 탭누르면 해당 자바파일 자동완성됨프로그램실...",
    "content": "인스턴스변수 : 대표적으로 String str = new String(0);지역변수 : 메소드내에서 변수선언문 수행 시메소드 : 명령문의 집합. 값을 입력받아처리 후 결과를 돌려줌(결과 안돌려줄수도있음 - void[공허]), ()붙은건 전부 메소드임. - 정보은닉, 캡슐화  cmd로 args값 받는 법M누르고 탭누르면 해당 자바파일 자동완성됨프로그램실행시에 완전 외부에서 특정 데이터를 심어서 같이실행하는 방법(java -version과 같은것임)프로그램으로 받을수도 있음실행결과가 뜨는 터미널이 파워쉘(cmd비슷한거)임.import java.util.Scanner;public class Member_method {    static final int MAX_MOMBER = 100;    static String user_id = \"\";    static String user_pw = \"\";    static String user_name = \"\";    static String user_birth = \"\";            static String user[][] = new String[MAX_MOMBER][4];    static int index = 0;    static Scanner s = new Scanner(System.in);    static int input=0;    static boolean id_check = true;    static boolean login_check=false;    public static void main(String[] args) {        while(true){            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 4.회원탈퇴, 5.회원정보조회, 0.종료 : &gt; \");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1: //회원가입                    String result = input_member();                    // 아이디, 비번 6자리 이상. 미만이면 실패                    for(index=0;index&lt;user.length;index++){                        if(user[index][0] == null){                            break;                        }                    }                    if(index==user.length){                        System.out.println(\"회원가입에 실패했습니다. 관리자에게 문의하십시오.\");                        break;                    }                    if(result.split(\",\").length==4){                        user[index][0] = result.split(\",\")[0];                         user[index][1] = result.split(\",\")[1];                         user[index][2] = result.split(\",\")[2];                         user[index][3] = result.split(\",\")[3];                     }                    break;                case 2:  // 로그인(조회)                    login();                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 3:// 회원정보 수정                    login();                    if(login_check){                        result = input_member();                        if(result.split(\",\").length==4){                            user[index][0] = result.split(\",\")[0];                             user[index][1] = result.split(\",\")[1];                             user[index][2] = result.split(\",\")[2];                             user[index][3] = result.split(\",\")[3];                         }                    }                    else {                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 4:                     login();                    if(login_check){                        System.out.print(\"정말 회원탈퇴하시겠습니까?(1-예. 0-아니오) &gt; \");                        input =s.nextInt();                        if(input==1){                            user[index][0] = null;                            user[index][1] = null;                            user[index][2] = null;                            user[index][3] = null;                            break;                        }                        else {                            System.out.println(\"회원탈퇴가 취소되었습니다. 처음으로 돌아갑니다.\");                        }                    }else {                            System.out.println(\"아이디와 비밀번호를 확인해주세요\");                            break;                    }                    break;                case 5:                    int manager_code = 1234;                    System.out.print(\"관리자 코드를 입력하세요 : &gt;\");                    input = s.nextInt();                    if(input == manager_code){                        for(int i=0;i&lt;user.length;i++){                            if(user[i][0]!=null){                                System.out.println(\"===회원정보====\");                                System.out.println(\"아이디 : \"+user[i][0]);                                System.out.print(\"비밀번호 : \");                                for(int j=0;j&lt;user[i][1].length();j++){                                    System.out.print(\"*\");                                }                                System.out.println();                                System.out.println(\"이름 : \"+user[i][2]);                                System.out.println(\"생년월일 : \"+user[i][3]);                            }                        }                    }                    break;                case 0:                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"입력번호가 잘못되었습니다.\");            }//switch        }//while    }//main       public static String input_member(){        System.out.print(\"아이디를 입력하세요(6자리 이상) : &gt; \");        user_id=s.nextLine();        if(user_id.length()&lt;6){            System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");            return \"\";        }        id_check = true;        for(int i=0;i&lt;user.length;i++){            if(user_id.equals(user[i][0])){                System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                id_check = false;            }        }        if(id_check){            System.out.print(\"비밀번호를 입력하세요(6자리 이상) : &gt; \");            user_pw=s.nextLine();            if(user_pw.length()&lt;6){                System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                return \"\";            }            System.out.print(\"이름을 입력하세요 : &gt; \");            user_name=s.nextLine();            System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");            user_birth=s.nextLine();            if(user_birth.length()!=8){                System.out.println(\"생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                return \"\";            }        }        return user_id+\",\"+user_pw+\",\"+user_name+\",\"+user_birth;    }//input_member    public static boolean login(){        System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");        user_id = s.nextLine();        System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");        user_pw = s.nextLine();        login_check=false;        for(int i=0;i&lt;user.length;i++){            if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                login_check =true;                index = i;                System.out.println(\"=====회원정보=====\");                System.out.println(\"아이디 : \"+user[i][0]);                System.out.println(\"이름 : \"+user[i][2]);                System.out.println(\"생년월일 : \"+user[i][3]);            }        }        return login_check;    }}//class회원가입 코드 예습겸 로그인이랑 입력받은 회원정보 유효성검사하는부분 메소드안에 넣어봤다. input_member()메소드 중간중간에 return때문에 main메소드안에서 if(result.split(“,”).length == 4)를 사용했는데 조금 마음에 안든다..내일 학원가서 물어보던가해야지..package JAVA_221027;import java.util.Scanner;public class Ex01_Method2 {    final static int MAX_VALUE = 10;    static String[] member_id = new String[MAX_VALUE];    static String[] member_pwd = new String[MAX_VALUE];    static String[] member_name = new String[MAX_VALUE];    static String[] member_birth = new String[MAX_VALUE];    static int next_index = 0;    static Scanner  s = new Scanner(System.in);    public static int checkMember(){        System.out.print(\"아이디 : \");        String login_id = s.nextLine();        System.out.print(\"비밀번호 : \");        String login_pwd = s.nextLine();        int member_index=-1;        for(int i=0;i&lt;MAX_VALUE;i++){            if(login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){                 System.out.println(\"==인증 성공==\");                System.out.println(\"아이디 : \"+member_id[i]);                System.out.println(\"이름: \"+member_name[i]);                System.out.println(\"생년월일 : \"+member_birth[i]);                member_index=i;                break;            }        }        return member_index;    }    public static void makeDummyDate(int num){        if(num&lt;0){                        return; //음수가 입력되면 실행안함        }        else if(num&gt;MAX_VALUE){            num=MAX_VALUE;        }        for(int i=0;i&lt;num;i++){            member_id[i] = \"member\"+i;            member_pwd[i] = \"123456\";            member_name [i] = \"사용자\";            member_birth[i] = \"20221027\";        } //더미값넣기        next_index=num;    }    public static String inputMemberInfo(){        System.out.print(\"아이디(8자이상) : \");        String id;        while(true){            id = s.nextLine();            if(id.length()&lt;8) {                System.out.print(\"아이디는 8자리 이상이어야합니다. 다시 입력해주세요 \");                continue;            }            boolean isDuplicate = false;            for(int i=0;i&lt;MAX_VALUE;i++){                if(id.equals(member_id[i])){                    System.out.print(\"이미 가입된 아이디 입니다. 다시입력해주세요\");                    isDuplicate=true;                }            }            if(!isDuplicate) break;        }        System.out.print(\"비밀번호(6자이상) : \");        String pwd;        while(true){            pwd = s.nextLine();            if(pwd.length()&lt;6) {                System.out.print(\"비밀번호는 6자리 이상이어야합니다. 다시 입력해주세요 \");                continue;            }else {                break;            }        }        System.out.print(\"이름 : \");        String name = s.nextLine();        System.out.print(\"생년월일(8자리) : \");        String birth;        while(true){            birth = s.nextLine();            if(birth.length()!=8) {                System.out.print(\"생년월일은 8자리로 입력하세요. 다시 입력해주세요 \");                continue;            }else {                break;            }        }        return id+\",\"+pwd+\",\"+name+\",\"+birth;    }    public static void deleteMember(int member){        member_id[member] = null;        member_pwd[member] = null;        member_name[member] = null;        member_birth[member] = null;        System.out.println(\"==회원 탈퇴 완료==\");        String[] temp1 = new String[MAX_VALUE];        String[] temp2 = new String[MAX_VALUE];        String[] temp3 = new String[MAX_VALUE];        String[] temp4 = new String[MAX_VALUE];        for(int i=0;i&lt;MAX_VALUE;i++){            temp1[i] = member_id[i]; //배열복사            temp2[i] = member_pwd[i]; //배열복사            temp3[i] = member_name[i]; //배열복사            temp4[i] = member_birth[i]; //배열복사        }        for(int i=0;i&lt;MAX_VALUE;i++){            member_id[i]=null;            member_pwd[i]=null;            member_name[i]=null;            member_birth[i]=null;        }        int n =0;        int n2=0;        while(n&lt;MAX_VALUE){            if(temp1[n]!=null){                member_id[n2]=temp1[n];                member_pwd[n2]=temp2[n];                member_name[n2]=temp3[n];                member_birth[n2]=temp4[n];                n2++;            }            n++; //만약 temp[i]가 null이라면, n2는 증가하지 않아서 한자리씩 땡겨짐.        }        next_index--;    }    public static void main(String[] args) {        //1차원배열로 진행, 재차입력요구까지 구현        makeDummyDate(5);        while(true){            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 4.회원탈퇴, 5.회원정보조회, 0.종료 : &gt; \");            int sel = s.nextInt();            if(sel == 0) {                System.out.println(\"종료합니다.\");                s.close();                return;            }            s.nextLine();            switch(sel){                case 1 :                    if(next_index==MAX_VALUE){                        System.out.println(\"더 이상 가입불가능합니다.\");                        break;                    }                    System.out.println(\"=====회원정보 등록=====\");                    String input_value = inputMemberInfo();                    member_id[next_index] = input_value.split(\",\")[0];                    member_pwd[next_index] = input_value.split(\",\")[1];                    member_name[next_index] = input_value.split(\",\")[2];                    member_birth[next_index] = input_value.split(\",\")[3];                    next_index++;                    System.out.println(\"==회원등록 완료==\");                    break;                case 2 :                    System.out.println(\"==로그인==\");                    int member_index = checkMember();                    if(member_index==-1){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                    }                    break;                case 3 :                    member_index=checkMember();                    if(member_index==-1){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                        break;                    }                    System.out.println(\"====등록된 정보 수정====\");                    input_value = inputMemberInfo();                    System.out.print(\"수정하시겠습니까? 1:예. 0:아니오.&gt; \");                    int confirm =s.nextInt();                    if(confirm==1){                        member_id[member_index] = input_value.split(\",\")[0];                        member_pwd[member_index] = input_value.split(\",\")[1];                        member_name[member_index] = input_value.split(\",\")[2];                        member_birth[member_index] = input_value.split(\",\")[3];                        System.out.println(\"==회원 정보 수정 완료==\");                    }                    else {                        System.out.println(\"정보수정이 취소되었습니다\");                    }                    break;                case 4 :                    member_index = checkMember();                    if(member_index==-1){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                        break;                    }                    System.out.print(\"탈퇴하시겠습니까? 1:예. 0:아니오.&gt; \");                    confirm =s.nextInt();                    if(confirm==1){                        deleteMember(member_index);                    }                    else {                        System.out.println(\"회원탈퇴가 취소되었습니다\");                    }                    break;                case 5 :                    for(int i=0;i&lt;MAX_VALUE;i++){                        if(member_id[i]!=null){                                System.out.println(\"===회원정보===\");                                System.out.println(\"아이디 : \"+member_id[i]);                                System.out.println(\"생년월일 : \"+member_pwd[i]);                                System.out.println(\"비밀번호 : \"+member_birth[i]);                            }                        }                    break;                default :                     System.out.println(\"잘못된 메뉴번호입니다.\");            }        }    }}선생님 코드 메소드화함. 메소드를 사용하지않고 같은 부분을 반복작성하는것을 하드코딩이라고함. 틀린건아님"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 배열2",
    "url": "/posts/%EB%B0%B0%EC%97%B42/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 배열",
    "date": "2022-10-26 00:00:00 +0900",
    





    
    "snippet": "회원가입package JAVA_221026;import java.util.Scanner;public class Ex01 {    public static void main(String[] args) {        String user_id = \"\";        String user_pw = \"\";        String user_name = \"\"...",
    "content": "회원가입package JAVA_221026;import java.util.Scanner;public class Ex01 {    public static void main(String[] args) {        String user_id = \"\";        String user_pw = \"\";        String user_name = \"\";        String user_birth = \"\";                String user[][] = new String[10][4];        int index = 0;        for(int i=0;i&lt;user.length;i++){            user[i][0] = \"\";        }        while(true){            Scanner s = new Scanner(System.in);            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 0.종료 : &gt; \");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1: //회원가입                    // 아이디, 비번 6자리 이상. 미만이면 실패                    if(index&gt;=user.length){                        System.out.println(\"허용 가입인원수를 초과하였습니다. 더이상 등록할 수 없습니다.\");                    }                    System.out.print(\"아이디를 입력하세요(6자리 이상) : &gt; \");                    user_id=s.nextLine();                    if(user_id.length()&lt;6){                        System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    System.out.print(\"비밀번호를 입력하세요(6자리 이상) : &gt; \");                    user_pw=s.nextLine();                    if(user_pw.length()&lt;6){                        System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    System.out.print(\"이름을 입력하세요 : &gt; \");                    user_name=s.nextLine();                    // 생년월일 8자리 아니면 실패                    System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                    user_birth=s.nextLine();                    if(user_birth.length()!=8){                        System.out.println(\"생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                        break;                    }                    //이미 가입된 아이디가 있으면 실패                    boolean id_check = true;                    for(int i=0;i&lt;user.length;i++){                        if(user[i][0].equals(user_id)){                            System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                            id_check = false;                            break;                        }                    }                    if(id_check){                        user[index][0] = user_id;                         user[index][1] = user_pw;                         user[index][2] = user_name;                         user[index][3] = user_birth;                         index++;                    }                    break;                case 2:  // 로그인(조회)                    // 아이디,비번입력                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    boolean login_check=false;                    for(int i=0;i&lt;user.length;i++){                        // 성공시 비번제외 회원정보 출력                        if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                            login_check =true;                            System.out.println(\"=====회원정보=====\");                            System.out.println(\"아이디 : \"+user[i][0]);                            System.out.println(\"이름 : \"+user[i][2]);                            System.out.println(\"생년월일 : \"+user[i][3]);                        }                    }                    // 일치아니면 실패. 로그인 정보가 잘못되었습니다                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 3:// 회원정보 수정                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    login_check=false;                    for(int i=0;i&lt;user.length;i++){                        // 성공시 비번제외 회원정보 출력                        if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                            login_check =true;                            System.out.print(\"변경할 아이디를 입력하세요(6자리 이상) : &gt; \");                            user_id=s.nextLine();                            if(user_id.length()&lt;6){                                System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            System.out.print(\"변경할 비밀번호를 입력하세요(6자리 이상) : &gt; \");                            user_pw=s.nextLine();                            if(user_pw.length()&lt;6){                                System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            System.out.print(\"변경할 이름을 입력하세요 : &gt; \");                            user_name=s.nextLine();                            System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                            user_birth=s.nextLine();                            if(user_birth.length()!=8){                                System.out.println(\"변경할 생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                                break;                            }                            id_check = true;                            for(int j=0;j&lt;user.length;j++){                                if(user[j][0].equals(user_id)){                                    System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                                    id_check = false;                                    break;                                }                            }                            if(id_check){                                // 수정하시겠습니까?(condirm처리)                                System.out.println(\"수정하시겠습니까?(1-예. 0-아니오) &gt; \");                                int input = s.nextInt();                                if(input==1){                                    user[i][0] = user_id;                                     user[i][1] = user_pw;                                     user[i][2] = user_name;                                     user[i][3] = user_birth;                                 }                            }                        }                    }                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 0:                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"입력번호가 잘못되었습니다.\");            }//switch        }//while    }//main}//class2차원배열 씀package JAVA_221026;import java.util.Scanner;public class Ex01ver2 {    public static void main(String[] args) {        String user_id = \"\";        String user_pw = \"\";        String user_name = \"\";        String user_birth = \"\";                String arr_id[] = new String[10];        String arr_pw[] = new String[10];        String arr_name[] = new String[10];        String arr_birth[] = new String[10];        int index = 0;        for(int i=0;i&lt;arr_id.length;i++){            arr_id[i] = \"\";        }        while(true){            Scanner s = new Scanner(System.in);            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 0.종료 : &gt; \");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1: //회원가입                    // 아이디, 비번 6자리 이상. 미만이면 실패                    if(index&gt;=arr_id.length){                        System.out.println(\"허용 가입인원수를 초과하였습니다. 더이상 등록할 수 없습니다.\");                    }                    System.out.print(\"아이디를 입력하세요(6자리 이상) : &gt; \");                    user_id=s.nextLine();                    if(user_id.length()&lt;6){                        System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    System.out.print(\"비밀번호를 입력하세요(6자리 이상) : &gt; \");                    user_pw=s.nextLine();                    if(user_pw.length()&lt;6){                        System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    System.out.print(\"이름을 입력하세요 : &gt; \");                    user_name=s.nextLine();                    // 생년월일 8자리 아니면 실패                    System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                    user_birth=s.nextLine();                    if(user_birth.length()!=8){                        System.out.println(\"생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                        break;                    }                    //이미 가입된 아이디가 있으면 실패                    boolean id_check = true;                    for(int i=0;i&lt;arr_id.length;i++){                        if(arr_id[i].equals(user_id)){                            System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                            id_check = false;                            break;                        }                    }                    if(id_check){                        arr_id[index] = user_id;                         arr_pw[index] = user_pw;                         arr_name[index] = user_name;                         arr_birth[index] = user_birth;                         index++;                    }                    break;                case 2:  // 로그인(조회)                    // 아이디,비번입력                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    boolean login_check=false;                    for(int i=0;i&lt;arr_id.length;i++){                        // 성공시 비번제외 회원정보 출력                        if(user_id.equals(arr_id[i]) &amp;&amp;  user_pw.equals(arr_pw[i])){                            login_check =true;                            System.out.println(\"=====회원정보=====\");                            System.out.println(\"아이디 : \"+arr_id[i]);                            System.out.println(\"이름 : \"+arr_name[i]);                            System.out.println(\"생년월일 : \"+arr_birth[i]);                        }                    }                    // 일치아니면 실패. 로그인 정보가 잘못되었습니다                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 3:// 회원정보 수정                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    login_check=false;                    for(int i=0;i&lt;arr_id.length;i++){                        // 성공시 비번제외 회원정보 출력                        if(user_id.equals(arr_id[i]) &amp;&amp;  user_pw.equals(arr_pw[i])){                            login_check =true;                            System.out.print(\"변경할 아이디를 입력하세요(6자리 이상) : &gt; \");                            user_id=s.nextLine();                            if(user_id.length()&lt;6){                                System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            System.out.print(\"변경할 비밀번호를 입력하세요(6자리 이상) : &gt; \");                            user_pw=s.nextLine();                            if(user_pw.length()&lt;6){                                System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            System.out.print(\"변경할 이름을 입력하세요 : &gt; \");                            user_name=s.nextLine();                            System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                            user_birth=s.nextLine();                            if(user_birth.length()!=8){                                System.out.println(\"변경할 생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                                break;                            }                            id_check = true;                            for(int j=0;j&lt;arr_id.length;j++){                                if(arr_id[j].equals(user_id)){                                    System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                                    id_check = false;                                    break;                                }                            }                            if(id_check){                                // 수정하시겠습니까?(condirm처리)                                System.out.println(\"수정하시겠습니까?(1-예. 0-아니오) &gt; \");                                int input = s.nextInt();                                if(input==1){                                    arr_id[i] = user_id;                                     arr_pw[i] = user_pw;                                     arr_name[i] = user_name;                                     arr_birth[i] = user_birth;                                 }                            }                        }                    }                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 0:                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"입력번호가 잘못되었습니다.\");            }//switch        }//while    }//main}//class혹시몰라서 1차원배열도 만들어놨음회원탈퇴, 회원조회기능 추가import java.util.Scanner;public class Member_method {    public static void main(String[] args) {        final int MAX_MOMBER = 100;        String user_id = \"\";        String user_pw = \"\";        String user_name = \"\";        String user_birth = \"\";                String user[][] = new String[MAX_MOMBER][4];        int index = 0;        Scanner s = new Scanner(System.in);        int input=0;        while(true){            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 4.회원탈퇴, 5.회원정보조회, 0.종료 : &gt; \");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1: //회원가입                    // 아이디, 비번 6자리 이상. 미만이면 실패                    for(index=0;index&lt;user.length;index++){                        if(user[index][0] == null){                            break;                        }                    }                    if(index==user.length){                        System.out.println(\"허용 가입인원수를 초과하였습니다. 더 이상 등록할 수 없습니다. 관리자에게 문의하십시오.\");                        break;                    }                    System.out.print(\"아이디를 입력하세요(6자리 이상) : &gt; \");                    user_id=s.nextLine();                    if(user_id.length()&lt;6){                        System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    boolean id_check = true;                    for(int i=0;i&lt;user.length;i++){                        if(user_id.equals(user[i][0])){                            System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                            id_check = false;                        }                    }                    if(id_check){                        System.out.print(\"비밀번호를 입력하세요(6자리 이상) : &gt; \");                        user_pw=s.nextLine();                        if(user_pw.length()&lt;6){                            System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                            break;                        }                        System.out.print(\"이름을 입력하세요 : &gt; \");                        user_name=s.nextLine();                        System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                        user_birth=s.nextLine();                        if(user_birth.length()!=8){                            System.out.println(\"생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                            break;                        }                            user[index][0] = user_id;                             user[index][1] = user_pw;                             user[index][2] = user_name;                             user[index][3] = user_birth;                         }                    break;                case 2:  // 로그인(조회)                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    boolean login_check=false;                    for(int i=0;i&lt;user.length;i++){                        if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                            login_check =true;                            System.out.println(\"=====회원정보=====\");                            System.out.println(\"아이디 : \"+user[i][0]);                            System.out.println(\"이름 : \"+user[i][2]);                            System.out.println(\"생년월일 : \"+user[i][3]);                        }                    }                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 3:// 회원정보 수정                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    login_check=false;                    for(int i=0;i&lt;user.length;i++){                        if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                            login_check =true;                            System.out.print(\"변경할 아이디를 입력하세요(6자리 이상) : &gt; \");                            user_id=s.nextLine();                            if(user_id.length()&lt;6){                                System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            id_check = true;                            for(int j=0;j&lt;user.length;j++){                                if(user_id.equals(user[j][0])){                                    System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                                    id_check = false;                                    break;                                }                            }                            if(id_check){                                System.out.print(\"변경할 비밀번호를 입력하세요(6자리 이상) : &gt; \");                                user_pw=s.nextLine();                                if(user_pw.length()&lt;6){                                    System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                    break;                                }                                System.out.print(\"변경할 이름을 입력하세요 : &gt; \");                                user_name=s.nextLine();                                System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                                user_birth=s.nextLine();                                if(user_birth.length()!=8){                                    System.out.println(\"변경할 생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                                    break;                                }                                System.out.print(\"수정하시겠습니까?(1-예. 0-아니오) &gt; \");                                input = s.nextInt();                                if(input==1){                                    user[i][0] = user_id;                                     user[i][1] = user_pw;                                     user[i][2] = user_name;                                     user[i][3] = user_birth;                                 }                            }                        }                    }                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 4:                     System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    login_check=false;                    for(int i=0;i&lt;user.length;i++){                        if(user_id.equals(user[i][0]) &amp;&amp; user_pw.equals(user[i][1])){                            login_check=true;                            System.out.print(\"정말 회원탈퇴하시겠습니까?(1-예. 0-아니오) &gt; \");                            input =s.nextInt();                            if(input==1){                                    user[i][0] = null;                                    user[i][1] = null;                                    user[i][2] = null;                                    user[i][3] = null;                                    break;                            }                        }else {                            System.out.println(\"아이디와 비밀번호를 확인해주세요\");                            break;                        }                    }                    break;                case 5:                    int manager_code = 1234;                    System.out.print(\"관리자 코드를 입력하세요 : &gt;\");                    input = s.nextInt();                    if(input == manager_code){                        for(int i=0;i&lt;user.length;i++){                            if(user[i][0]!=null){                                System.out.println(\"===회원정보====\");                                System.out.println(\"아이디 : \"+user[i][0]);                                System.out.print(\"비밀번호 : \");                                for(int j=0;j&lt;user[i][1].length();j++){                                    System.out.print(\"*\");                                }                                System.out.println();                                System.out.println(\"이름 : \"+user[i][2]);                                System.out.println(\"생년월일 : \"+user[i][3]);                            }                        }                    }                    break;                case 0:                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"입력번호가 잘못되었습니다.\");            }//switch        }//while    }//main}//class선생님께 물어봤는데 배열을 생성해서 값을 당기는 것이(가입순서대로 정렬하는것이) 일반적인 데이터베이스관점이라고하심작동하면 이것도 상관은없다고하셨당equals에서 자꾸 nullException이 생겼는데 검색해보니 a.equals(b)에 a에 null값이 오면 오류가 나는거였다.. 반대로 하니 오류가 안나서 수정해줬음..선생님 버전package JAVA_221027;import java.util.Scanner;public class Ex01teach {    public static void main(String[] args) {        //1차원배열로 진행, 재차입력요구까지 구현        final int MAX_VALUE = 10;        String[] member_id = new String[MAX_VALUE];        String[] member_pwd = new String[MAX_VALUE];        String[] member_name = new String[MAX_VALUE];        String[] member_birth = new String[MAX_VALUE];        Scanner  s = new Scanner(System.in);        for(int i=0;i&lt;MAX_VALUE;i++){            member_id[i] = \"member\"+i;            member_pwd[i] = \"123456\";            member_name [i] = \"사용자\";            member_birth[i] = \"20221027\";        } //더미값넣기        int next_index = 10;        while(true){            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 4.회원탈퇴, 5.회원정보조회, 0.종료 : &gt; \");            int sel = s.nextInt();            if(sel == 0) {                System.out.println(\"종료합니다.\");                s.close();                return;            }            s.nextLine();            switch(sel){                case 1 :                    if(next_index==MAX_VALUE){                        System.out.println(\"더 이상 가입불가능합니다.\");                        break;                    }                    System.out.println(\"=====회원정보 등록=====\");                    System.out.print(\"아이디(6자이상) : \");                    String id;                    while(true){                        id = s.nextLine();                        if(id.length()&lt;6) {                            System.out.print(\"아이디는 6자리 이상이어야합니다. 다시 입력해주세요 \");                            continue;                        }                        boolean isDuplicate = false;                        for(int i=0;i&lt;MAX_VALUE;i++){                            if(id.equals(member_id[i])){                                System.out.print(\"이미 가입된 아이디 입니다. 다시입력해주세요\");                                isDuplicate=true;                            }                        }                        if(!isDuplicate) break;                    }                    System.out.print(\"비밀번호(6자이상) : \");                    String pwd;                    while(true){                        pwd = s.nextLine();                        if(pwd.length()&lt;6) {                            System.out.print(\"비밀번호는 6자리 이상이어야합니다. 다시 입력해주세요 \");                            continue;                        }else {                            break;                        }                    }                    System.out.print(\"이름 : \");                    String name = s.nextLine();                    System.out.print(\"생년월일(8자리) : \");                    String birth;                    while(true){                        birth = s.nextLine();                        if(birth.length()!=8) {                            System.out.print(\"생년월일은 8자리로 입력하세요. 다시 입력해주세요 \");                            continue;                        }else {                            break;                        }                    }                    member_id[next_index] = id;                    member_pwd[next_index] = pwd;                    member_name[next_index] = name;                    member_birth[next_index] = birth;                    next_index++;                    System.out.println(\"==회원등록 완료==\");                    break;                case 2 :                    System.out.println(\"==로그인==\");                    System.out.print(\"아이디 : \");                    String login_id = s.nextLine();                    System.out.print(\"비밀번호 : \");                    String login_pwd = s.nextLine();                    boolean loginStatus = false;                    for(int i=0;i&lt;MAX_VALUE;i++){                        if(loginStatus=login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){                             //아이디 비번이 같으면 loginStatus를 true로 변경                            System.out.println(\"==로그인 성공==\");                            System.out.println(\"아이디 : \"+member_id[i]);                            System.out.println(\"이름: \"+member_name[i]);                            System.out.println(\"생년월일 : \"+member_birth[i]);                            break;                        }                    }                    //if(loginStatus=login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){는 {}안에                    //loginStatus = true한거랑 같음. 한줄로 만든것.                    if(!loginStatus){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                    }                    break;                case 3 :                    System.out.println(\"==정보수정==\");                    System.out.print(\"아이디 : \");                    login_id = s.nextLine();                    System.out.print(\"비밀번호 : \");                    login_pwd = s.nextLine();                    loginStatus = false;                    int moidfy_index=0;                    for(int i=0;i&lt;MAX_VALUE;i++){                        if(loginStatus=login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){                             System.out.println(\"==기존정보==\");                            System.out.println(\"아이디 : \"+member_id[i]);                            System.out.println(\"이름: \"+member_name[i]);                            System.out.println(\"생년월일 : \"+member_birth[i]);                            moidfy_index=i;                            break;                        }                    }                    if(!loginStatus){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                        break;                    }                    System.out.println(\"====등록된 정보 수정====\");                    System.out.print(\"아이디(6자이상) : \");                    while(true){                        id = s.nextLine();                        if(id.length()&lt;6) {                            System.out.print(\"아이디는 6자리 이상이어야합니다. 다시 입력해주세요 \");                            continue;                        }                        boolean isDuplicate = false;                        for(int i=0;i&lt;MAX_VALUE;i++){                            if(id.equals(member_id[i])){                                System.out.print(\"이미 가입된 아이디 입니다. 다시입력해주세요\");                                isDuplicate=true;                            }                        }                        if(!isDuplicate) break;                    }                    System.out.print(\"비밀번호(6자이상) : \");                    while(true){                        pwd = s.nextLine();                        if(pwd.length()&lt;6) {                            System.out.print(\"비밀번호는 6자리 이상이어야합니다. 다시 입력해주세요 \");                            continue;                        }else {                            break;                        }                    }                    System.out.print(\"이름 : \");                    name = s.nextLine();                    System.out.print(\"생년월일(8자리) : \");                    while(true){                        birth = s.nextLine();                        if(birth.length()!=8) {                            System.out.print(\"생년월일은 8자리로 입력하세요. 다시 입력해주세요 \");                            continue;                        }else {                            break;                        }                    }                    System.out.print(\"수정하시겠습니까? 1:예. 0:아니오.&gt; \");                    int confirm =s.nextInt();                    if(confirm==1){                        member_id[moidfy_index] = id;                        member_pwd[moidfy_index] = pwd;                        member_name[moidfy_index] = name;                        member_birth[moidfy_index] = birth;                        System.out.println(\"==회원 정보 수정 완료==\");                    }                    else {                        System.out.println(\"정보수정이 취소되었습니다\");                    }                    break;                case 4 :                    System.out.println(\"==로그인==\");                    System.out.print(\"아이디 : \");                    login_id = s.nextLine();                    System.out.print(\"비밀번호 : \");                    login_pwd = s.nextLine();                    loginStatus = false;                    int del_index =0;                    for(int i=0;i&lt;MAX_VALUE;i++){                        if(loginStatus=login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){                             System.out.println(\"==로그인 성공==\");                            System.out.println(\"아이디 : \"+member_id[i]);                            System.out.println(\"이름: \"+member_name[i]);                            System.out.println(\"생년월일 : \"+member_birth[i]);                            del_index=i;                            break;                        }                    }                    if(!loginStatus){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                        break;                    }                    System.out.print(\"탈퇴하시겠습니까? 1:예. 0:아니오.&gt; \");                    confirm =s.nextInt();                    if(confirm==1){                        member_id[del_index] = null;                        member_pwd[del_index] = null;                        member_name[del_index] = null;                        member_birth[del_index] = null;                        System.out.println(\"==회원 탈퇴 완료==\");                        String[] temp1 = new String[MAX_VALUE];                        String[] temp2 = new String[MAX_VALUE];                        String[] temp3 = new String[MAX_VALUE];                        String[] temp4 = new String[MAX_VALUE];                        for(int i=0;i&lt;MAX_VALUE;i++){                            temp1[i] = member_id[i]; //배열복사                            temp2[i] = member_pwd[i]; //배열복사                            temp3[i] = member_name[i]; //배열복사                            temp4[i] = member_birth[i]; //배열복사                        }                        for(int i=0;i&lt;MAX_VALUE;i++){                            member_id[i]=null;                            member_pwd[i]=null;                            member_name[i]=null;                            member_birth[i]=null;                        }                        int n =0;                        int n2=0;                        while(n&lt;MAX_VALUE){                            if(temp1[n]!=null){                                member_id[n2]=temp1[n];                                member_pwd[n2]=temp2[n];                                member_name[n2]=temp3[n];                                member_birth[n2]=temp4[n];                                n2++;                            }                            n++; //만약 temp[i]가 null이라면, n2는 증가하지 않아서 한자리씩 땡겨짐.                        }                        next_index--;                    }                    else {                        System.out.println(\"회원탈퇴가 취소되었습니다\");                    }                    break;                case 5 :                for(int i=0;i&lt;MAX_VALUE;i++){                    if(member_id[i]!=null){                            System.out.println(\"===회원정보===\");                            System.out.println(\"아이디 : \"+member_id[i]);                            System.out.println(\"생년월일 : \"+member_pwd[i]);                            System.out.println(\"비밀번호 : \"+member_birth[i]);                        }                    }                    break;                default :                     System.out.println(\"잘못된 메뉴번호입니다.\");            }        }    }}"
  },
  
  {
    "title": "[SQLD 시험 준비] SQL 기본 - 활용",
    "url": "/posts/SQL-%EA%B8%B0%EB%B3%B8-%ED%99%9C%EC%9A%A9/",
    "categories": "RDBMS",
    "tags": "sql, sqld, RDBMS",
    "date": "2022-10-24 00:00:00 +0900",
    





    
    "snippet": "SQL문장 종류  DML : 데이터 조작어 (사용자가 무슨데이터를 원하는지. 사용자가 실질적으로 접근하는데 사용, 호스트 프로그램속에 사용되는 DML명령어를 데이터 부속어라고도 함)          insert : 입력      delete : 삭제      select : 조회      update : 수정      merge : 존재x → inse...",
    "content": "SQL문장 종류  DML : 데이터 조작어 (사용자가 무슨데이터를 원하는지. 사용자가 실질적으로 접근하는데 사용, 호스트 프로그램속에 사용되는 DML명령어를 데이터 부속어라고도 함)          insert : 입력      delete : 삭제      select : 조회      update : 수정      merge : 존재x → insert, 존재O → updatev        DDL : 데이터 정의어          alter : 오브젝트 변경      create : 오브젝트 생성      rename : 이름변경      drop : 오브젝트 제거      truncate : 모든 행 없앰            DCL : 데이터 제어어, 엑세스 권한 부여/삭제          grant : 권한 부여 - GRANT pricileges [ON object] TO user;      revoke : 권한 삭제        — ROLL : 많은 DBMS에서는 관리자가 사용자별로 권한을 관리해야한다는 부담, 복잡함 → 줄이기 위해 다양한 권한을 그룹으로 묶어 관리하도록 중개역할을 수행    TCL : 트랜잭션 제어어          commit : 작업완료      rollback : 취소      savapoint      —PK 지정 방법  contraint_name PRIMARY KEY (col_1, col_2) - 만들 때 바로 지정방법  ALTER TABLE table_name ADD CONSTRAINT_name PRIMAY KEY (col_1, col_2) - 이후 지정— SQL 서버는 두 칼럼을 하나의 명령으로 동시 작업 못함 ()안에 여러개 못넣는다는 말임제약조건  PRAMARY KEY(기본키) : 테이블 당 한개, 중복x, null x  FOREIGN KEY(외래키) : 테이블 당 여러개 기능, 다른 테이블의 칼럼 값 참조          CASCADE : 삭제된 테이블과 참조하는 부분은 전체 삭제      SET NULL : 삭제된 테이블과 참조하는 부분만 null      RESTRICT : child 테이블에 PK값이 없는 경우만 MASTER삭제 허용      AUTOMATIC : master테이블에 PK가 없는 경우 master PK를 생성 후 Child 입력      DEPENDENT : master테이블에 PK가 존재할 때만 Child입력 허용      SET DEFAULT : master테이블에 PK가 없으면 Child FK를 지정된 기본값으로 입력        UNIQUE KEY(고유키) : 중복x, null가능  NOT NULL  CHECK : 해당 조건을 만족하는 값만 입력가능, 데이터 무결성 유지를 위해 설정테이블 데이터 조회: SELECT [ALL / DISTINCT] 보고싶은 칼럼명, 보고싶은 칼럼명, …. FROM 해당 칼럼들이 있는 테이블 명  ALL : 중복데이터 모두 출력  DISTINCT : 중복데이터 1건으로 출력테이블 삭제  TRUNCATE : 테이블 초기상태로, 재사용 가능함. 행만 삭제하는 것. 디스크 초기화. Auto commit  DROP : 완전 삭제. 테이블 자체를 삭제함. Auto commit  DELETE : 로그 남음. 데이터 삭제. 사용자 commit트랜잭션: 데이터베이스의 논리적 연산단위, 밀접히 관련되어 분리될 수 없는 한개이상의 데이터베이스 조각  원자성 : 모두 성공적이거나 전혀 실행되지않은 상태로 남아있어야함  일관성 : 실행전에 잘못이없다면 실행 후에도 잘못이 없음  고립성 : 다른 트랜잭션의 영향을 받으면 안됨          고립성이 낮을 경우                  Dirty read : 다른 트랜잭션에 의해 수정 + commit 전 데이터를 읽음          non-Repeatable Read : 같은 쿼리 두번 수행 → 그사이에 다른 트랜잭션이 값을 수정 → 쿼리결과가 다르게 나타남          Phantom Read : 같은 쿼리 두번 수행 → 첫번째 쿼리에 없던 유령 레코드가 두번째 쿼리에 등장                      지속성 : 성공적으로 수행되면 영구저장  명령          commit      rollback      내장함수  1:M관계의 테이블조인시 M쪽에 단일행, 다중행 함수 사용가능  입력행수에따라 단일행 함수와 다중행 함수로 구분          단일행 함수                  추출되는 각 행마다 작업을 수행          각 행마다 하나의 결과를 반환          단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET절에 사용 가능          데이터타입 변경가능          중첩사용 가능                    다중행 함수                  여러개의 인수가 입력되어도 단일값만을 반환          그룹집계함수 (SUM, AVG, MAX, MIN…)                    null 함수  NVL(1,2) : 1이 null이면 2반환  NVL(1,2,3) : 1이 null이면 2, 아니면 3  NULLIF(1,2) : 1과 2가 같으면 null, 다르면 1  COALESCE : null을 제외한 가장 최초의 값을 반환순위  top n with ties : 동일데이터 모두 출력  rank() over() : 1 1 3 4 4 6  row_number() over : 같은순위 다른순위로 나타냄  dense_rank() over : 1 1 2 3 3 4순수관계연산자  SELECT(가로)  JOIN  DIVIDE  PROJECTION(세로)USING절: 왼쪽 테이블이 각 열이 오른쪽 테이블에 있는 동일이름의 열과 비교되는 결합조건USING (PROJNO, ACTNO)= ON CORPDATA.PROJACT.PROJNO = CORPDATA.EMPPROJACT.PROJNOAND CORPDATA.PROJACT.ACTNO = CORPDATA.EMPPROJACT.ACTNO같은거임집합연산자                   sql      oracle                  교집합             INTERSECT              차집합      EXCEPT      MINUS              합집합             UNION      계층형 질의  START WITH절은 계층구조의 시작점을 지정  ORDER SIBLINGS BY절은 형제 Node사이의 정렬을 지정  순방향 전개 : 부모 Node에서 자식 Node로 전개되는것  루트 Node의 Level은 1임  sql에서는 CTE를 재귀호출함으로써 계층구조를 전개  sql에서는 앵커멤버를 실행해서 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행  oracle의 where절은 모든 전개를 진행한 후 필터 조건으로서 조건을 만족하는 데이터만 추출  oracle의 PRIOR키워드는 CONNECT BY, SELECT, WHERE절에서 사용가능서브쿼리  단일 행 또는 복수행 비교연산자와 사용가능  SELECT절, FROM절, HAVING절, ORDER BY절 등에서 사용 가능  단일행 결과를 반환하는 경우 ‘=’, ’≥’, ’≤’등의 연산자와 사용 가능  다중 행 비교연산자는 IN, ALL 등이있다  다중행 서브쿼리 비교연산자는 단일 행 서브쿼리의 비교연산자로도 사용가능  연관(Correlated) 서브쿼리: 서브쿼리가 메인쿼리칼럼을 포함하고 있는 형태의 서브쿼리, 메인쿼리에서 값을 제공받음  Oracle은 다중칼럼 서브쿼리를 지원하지만 SQL은 지원하지않음  스칼라 서브쿼리 : JOIN으로 동일한 결과 추출가능  동적 뷰 : SQL 문장 중 테이블명이 올 수 있는 곳에 사용가능뷰(view)  필요한 정보를 테이블로 추출하는 SQL만을 저장함  데이터 구조 단순화  단지 정의만 가지고 있으며 실행시점에 질의를 재작성하여 수행  복잡한 SQL문장을 단순히 저장.  테이블구조 변경에 의한 영향으로부터 응용프로그램을 분리  보안목적으로도 사용가능  실제 데이터를 저장하고있는 뷰를 생성하는 기능을 지원하는 DBMS도 있음  user에게 단순한 인터페이스 제공그룹함수결과건수가 줄어든다ROLLUP  ROLLUP(A,B) : A,B그룹바이기준으로 해서 (A,B), A를 그룹바이 기준으로 해서 (A,null), 아무기준없이 전체를 기준으로 (null,null) 총 세가지의 값을 모두 조회  칼럼의 순서에 따라 다른결과가 출력되는 것GROUPING SETS  칼럼의 순서가 중요하지 않음.  각 함수의 인자로 주어진 칼럼 중 집계기준이 되는 칼럼 이외의 칼럼은 NULL값이 반환  각각의 합계를 출력CUBE  각 함수의 인자로 주어진 칼럼 중 집계기준이 되는 칼럼 이외의 칼럼은 NULL값이 반환  인자로 주어진 칼럼의 결합가능한 모든 조합에 대해 집계 → 다른 그룹함수에 비해 부하가 큼  모든 경우의 수에 대해 소계화 합계를 출력Grouping  해당 칼럼이 그룹화되어있다면 1, 아니면 0을 반환. CASE와 함께 씀분석함수/윈도우함수Partition  groupby와 유사  partition구문이 없으면 하나의 partition으로 정의한 것과 동일윈도우 함수  적용범위가 partition을 넘을 수 없음      그룹함수가 먼저 실행된 후 윈도우 함수가 실행.        range      RANGE between 1000 PERCECDING and 1000 FOLLOWING → -1000~+1000 사이에 존재하는 ~의 개수lag(), lead()  lag() : 앞의 값 찾기  lead() : 뒤의 값 찾기PL/SQL  변수와 상수 등을 사용해서 일반 SQL문장을 실행시 WHERE절 조건으로 대입 가능  procedure, User defined function, Trigger객체 생성가능 → 트랜잭션 분할 가능. 각 트랜잭션 별로 프로시저, UDF를 호출 가능  Procedure내부에 작성된 절차적코드 처리 (일반적인 SQL문장은 SQL실행기가 처리해줌)— EXECUTE IMMEDIATE ‘TRUNCATE TABLE 테이블명’ → 테이블의 모든 데이터를 롤백이 불가능하도록 삭제  절차형 SQL모듈          logic과 함께 데이터베이스에 저장한 명령문의 집합. CREATE PROCEDURE명령을 사용해서 생성      사용자함수는 다른 SQL문을 통해 호출되고 그 결과를 리턴. SQL의 보조적인 역할 - CREATE FUNCTION명령을 사용해서 생성      Trigger                  DML문이 수행되면 데이터베이스에서 자동으로 동작하도록 작성된 프로그램.          데이터의 무결성과 일관성 유지가능          CREATE TRIGGER 명령을 사용해서 생성.          데이터베이스에 로그인하는 작업에도 정의 가능          롤백안됨          테이블, 뷰에만 트리거를 작성(데이터베이스에선 안됨)                    JOIN  인라인뷰 안에서 뷰 바깥의 테이블과 Join불가  PK와 FK값의 연관성에 의해 성립된다.  DBMS절의 옵티마이저는 from절에 나열된 테이블들을 임의로 2개씩 묶어서 Join처리함  Equi join은 join에 관여하는 테이블간의 칼럼값들이 정확하게 일치하는 경우에 사용하는 방법  EQUI JOIN은 ‘=’연산자에 의해서만 수행되며, 그 이외의 비교연산자를 사용하는 경우에는 모두 Non EQUI JOIN임  설계상의 이유로 Non EQUI JOIN이 불가능한 경우도 있음  테이블사이에 JOIN조건이 없는 경우 카타시안 곱 발생  NATURAL JOIN에서 OWNER 명을 사용하면 에러 발생CROSS JOIN: 한쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 조인. → 최종 결과개수 = 두 테이블의 행의 개수를 곱한개수⇒ FROM EMP,DEPT = FROM EMP CROSS JOIN DEPTself join  한 테이블 내에서 두 칼럼이 연관 관계에 있을때 사용Nested Loops Join중첩for문같은느낌 - 인덱스구성전략이 매우 중요, 대량테이블에는 비효율적  조인 칼럼에 적당한 인덱스가 있어서 자연조인(Natural join)이 효율적일때 유리.  Driving테이블의 조인 데이터양이 큰 영향을 줌  유니크 인덱스를 활용하여 수행시간이 적게걸리는 소량테이블을 온라인조회할때 유용  조인조건의 인덱스 유무에 영향을 많이 받음  선택도가 낮은(결과 행의 수가 적은)테이블이 선행테이블로 선택되는것이 유리Sort Merge Join  조인 칼럼에 적당한 인덱스가 없어서 자연조인이 비효율적일때 사용  Driving테이블의 영향을 받지 않음  조인조건의 인덱스 유무에 영향받지않음  equal join이 아니라 범위조인할때 효율적Hash Join대용량테이블에쓰면 좋음. key컬럼에 중복이없을수록 유리. hash영역에 올라가는 테이블의 크기가 작아야함  해싱기법을 이용해 조인을 함  DW등 데이터집계업무에서 많이 사용  EQUI(=) 조인조건에서만 동작한다.  한쪽 테이블이 주 작고 해시 키 속성에 중복값이 적을 때 효과적  조인 칼럼에 적당한 인덱스가 없어서 자연조인이 비효율적일때 사용  자연조인시 드라이빙 집합쪽으로 조인 엑세스 량이 많아 랜덤 엑세스 부하가 심할때 사용  소트머지조인을 하기에는 두 테이블이 너무 커서 소트부하가 심할때 사용          동등조인(Euqi Join)에서만 사용가능 → 제약존재        작은테이블을 먼저 읽으면 부하가 심해짐— EXISTS(긍정) → SEMI JOIN— NOT EXISTS(부정) → ANTI JOIN옵티마이저실행계획을 만들어주는 역할  실행계획 : SQL처리를 위한 실행절차와 방법을 표현. 시각적으로 표현해줌          알수있는 정보                  엑세스 기법          질의 처리 예상비용          조인방법, 순서                    실행순서 : 안에서 밖으로, 위에서 아래로      동일 SQL문에대해 실행계획이 다르면 Performance가 달라질수있음      Oracle의 실행계획에 나타나는 기본적인 join기법에는 NL Join, Hash Join, Sort Merge Join등이 있음      CBO: 비용기반 실행계획, SQL문 실행시 소요될 처리시간, CPU, I/O 자원량 등을 계산하여 가장 효율적일 것으로 예상되는 실행계획을 선택하는 옵티마이저. 단계별 예상 비용 및 건수 표시  객체의 통계정보를 사용하여 실행계획 수립 → 통계정보 변경 시 SQL의 실행계획이 달라질수도 있음RBO: 규칙기반 실행계획.  제일 높은 우선순위는 행에대한 고유주소 사용하는 방법임  인덱스 스캔이 항상 유리함, 적절한 인덱스가 있다면 무조건 사용하려함  Single row by rowid엑세스 기법이 가장 우선순위가 높음관계형 데이터베이스  인덱스          기본 인덱스에 null값 불가, 중복 불가      보조 인덱스에는 중복값 가능      변경이 적은 속성을 인덱스로 지정해야함      테이블의 전체데이터를 읽는경우엔 없는것이 나음 - full table scan이 더 빠름      조회성능 향상시킴      삭제, 삽입, 갱신 연산의 속도를 줄임 - 데이터 입력 후에 인덱스를 생성하는것이 좋음      update작업에는 부하가 없을 수도 있음      B-Tree - 관계형 데이터베이스의 주요 인덱스 구조. 일반적으로 OLTP시스템 환경에서 가장 많이 사용. 일치 및 범위검색에 적절한 구조임                  branch block : 분기를 목적          leaf block : 인덱스 구성하는 칼럼의 값으로 정렬                    CLUSTERED : 인덱스의 leaf페이지가 곧 데이터 페이지, 모든 데이터는 인덱스 키 칼럼순으로 물리적으로 정렬      BUTMAP : 시스템에서 사용될 질의를 시스템 구현시에 모두 알 수 없는 경우인 DW 및 AD-HOC질의 환경을 위해 설계, 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조      인덱스 범위 스캔 시 결과가 없으면 한 건도 반환하지않을 수도 있음      인덱스 조건 중 ‘=’가 사용된 칼럼이 앞쪽에 위치하는것이 효율적임      SQL의 클러스터형 인덱스틑 ORACLE의 IOT와 매우 유사함      오답노트— 오라클/sql차이점  오라클          자동 commit      ddl명령은 rollback이 수행되는 명령이 아님      null값 조회시 IS NULL로 조회      날짜를 내부적으로는 숫자로 저장 → system+1/24/60 = system날짜 + 1분            sql          rollback + update 일때 update에 의해 rollback 취소      null값 조회시 = ’’ 로 조회      86번 다시 101,p134~p136 : 141번~146번 142번NOT IN문 서브쿼리의 결과 중에 NULL이 포함되는 경우 데이터가 출력되지 않는다.IN 문은 OR 조건, NOT IN 문은 AND 조건, NOT In은 NULL값 계산안함CHARACTER (고정길이 문자열, S만큼 최대길이(그보다 작을시 공백으로 채운다.)CHAR(10)으로 칼럼을 생성하고 8개의 문자를 입력하면 나머지 2개는 공백으로 입력2번임서브쿼리에 있는 칼럼을 자유롭게 사용할수 없다1 PRECEDING / 1 FOLLOWING - 현재행을 기준으로 이전행+현재+다음행 합계를 표시답 2번임인덱스 생성구문 - createANY (다수의 비교값 중 하나라도 만족하면 TRUE)"
  },
  
  {
    "title": "[SQLD 시험 준비] 데이터 모델링의 이해",
    "url": "/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/",
    "categories": "RDBMS",
    "tags": "sql, RDBMS, sqld",
    "date": "2022-10-23 00:00:00 +0900",
    





    
    "snippet": "데이터 모델링: 정보 시스템 구축을 위한 데이터관점, 프로세스관점의 업무 분석/ 데이터베이스 구축을 위한 분석 및 설계하는 과정  특징          추상화      단순화      명확화(정확화)        필요한 이유          업무 정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현      데이터베이스를 생성해 개발 ...",
    "content": "데이터 모델링: 정보 시스템 구축을 위한 데이터관점, 프로세스관점의 업무 분석/ 데이터베이스 구축을 위한 분석 및 설계하는 과정  특징          추상화      단순화      명확화(정확화)        필요한 이유          업무 정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현      데이터베이스를 생성해 개발 및 데이터관리에 사용      업무 흐름 설명, 분석        유의점          중복      비유연성      비일관성        관계          존재에 의한 관계와 행위에 의한 관계로 구분가능. ERD에서는 존재와 행위를 구분하지 않고 단일화된 표기법을 사용      UML에는 클래스다이어그램의 관계 중 연산관계와 의존관계가 있고 이를 실선과 점선의 표기법으로 다르게 표현함      관계명, 관계차수, 관계선택사양의 3가지 개념을 사용      두개의 엔터티사이에 관심있는 연관규칙이 있는지, 정보의 조합이 발생하는지, 관계연결을 가능하게 하는 동사가 있는지, 관계연결에대한 규칙이 서술되어있는지 확인해야함        성능 데이터모델링 : 분석 및 설계단계부터 성능과 관련한 데이터모델링을 수행함(정규화/반정규화, 테이블분할/병합/추가, 칼럼추가, PK/FK조정, 슈퍼타입/서브타입 조정 등)          데이터 증가가 빠를수록 성능개선비용 증가 → 테이블분할을 하게되는경우 할일이 많아짐      성능을 튜닝하면서 변경되는 특징이 있음      분석/설계단계에서 하면 비용을 최소화할수있음      순서                  정규화          용량산정          트랜잭션 유형 파악          반정규화          이력모델 조정, PK/FK조정, 슈퍼타입/서브타입 조정 수행          성능관점 데이터모델검증                    고려사항                  용량산정은 성능데이터모델링시 트랜잭션의 유형과 양을 파악가능해서 중요한 작업임          물리적 데이터 모델링시, PK/FK의 칼럼의 순서조정, FK인덱스 생성 등은 성능 향상을 위한 데이터 모델링 작업에 중요한 요소          이력데이터는 반복발생 → 다량데이터일 확률이 높음 ⇒ 특별히 성능을 고려해 칼럼 등을 추가하도록 설계                      정규화          1차 정규화 : 중복제거, 실행 후 인덱스 적용            반정규화 기법                  테이블 분할(로우체이닝시 효과적임)                  수직 분할 : 칼럼단위, 1:1관계          수평 분할 : 로우단위, 관계없음                → 디스크 I/O분산, 데이터 접근 효율성            테이블 병합      테이블 추가(중복/통계/이력/부분테이블)                  중복테이블 추가 : 원격지와의 조인을 줄이기 위해 같은 구조의 테이블 추가          부분테이블 추가 : 하나의 테이블의 전체칼럼 중 자주 이용하는 집중화된 칼럼들을 디스크 I/O를 줄이기위해 별도로 모아놓는 기법                    칼럼추가(중복/파생/이력테이블에 칼럼추가)                  중복칼럼 추가 : 조인 감소를 위해 여러 테이블에 동일칼럼 추가          파생칼럼 추가 : 조회성능을 위해 미리 계산된 칼럼 추가          이력테이블에 기능 칼럼 추가 : 최신값을 처리하는 이력의 특성을 고려, 기능성 칼럼 추가                    PK/FK조정      슈퍼/서브타입 조정              판단요소                  정보에대한 재현의 적시성(ex.계산된 잔액을 위해 파생칼럼 추가)          인덱스를 활용한 탐색으로 성능향상 가능          윈도우 함수를 사용할 때 이전 또는 이후위치의 레코드에 접근 가능                      정규화          1차 정규화 : 중복제거, 실행 후 인덱스 적용            반정규화 기법                  테이블 분할(로우체이닝시 효과적임)                  수직 분할 : 칼럼단위, 1:1관계          수평 분할 : 로우단위, 관계없음                → 디스크 I/O분산, 데이터 접근 효율성            테이블 병합      테이블 추가(중복/통계/이력/부분테이블)                  중복테이블 추가 : 원격지와의 조인을 줄이기 위해 같은 구조의 테이블 추가          부분테이블 추가 : 하나의 테이블의 전체칼럼 중 자주 이용하는 집중화된 칼럼들을 디스크 I/O를 줄이기위해 별도로 모아놓는 기법                    칼럼추가(중복/파생/이력테이블에 칼럼추가)                  중복칼럼 추가 : 조인 감소를 위해 여러 테이블에 동일칼럼 추가          파생칼럼 추가 : 조회성능을 위해 미리 계산된 칼럼 추가          이력테이블에 기능 칼럼 추가 : 최신값을 처리하는 이력의 특성을 고려, 기능성 칼럼 추가                    PK/FK조정      슈퍼/서브타입 조정              판단요소                  정보에대한 재현의 적시성(ex.계산된 잔액을 위해 파생칼럼 추가)          인덱스를 활용한 탐색으로 성능향상 가능          윈도우 함수를 사용할 때 이전 또는 이후위치의 레코드에 접근 가능                      파티셔닝 : 논리적으로는 하나의 테이블이지만 물리적으로는 여러개의 테이블로 분리해 데이터 엑세스 성능 향상, 데이터 관리방법을 개선하는 방법  트랜잭션          항상 전체를 대상으로 일괄처리 → 전체를 하나의 테이블로 구성(Rollup) (테이블을 서브타입별로 개별유지하면 Union연산에 의해 성능저하 가능성 있음)      항상 서브타입을 개별로 처리 → 서브타입을 개별 테이블로 구성(Rolldown) (테이블을 하나로 통합시 불필요하게 많은 데이터 집적으로 성능저하)      슈퍼+서브타입을 공동초리 → 슈퍼타입 + 서브타입 테이블로 구성(Identity) (개별유지시 조인에의해 성능저하)      — 1:M관계일때 부모테이블에 인덱스가 있더라도 상속받은 테이블도 인덱스가 필요함마찬가지로 FK생성 여부와는 별개로 상속받은 테이블에도 인덱스 생성이 필요함  분산 데이터베이스 : 데이터가 여러지역에 분산되어있지만 하나의 데이터베이스처럼 사용하는 경우          실시간 동기화가 요구되지 않을 때      거의 실시간의 업무적 특징을 가질 때      특정 서버에 부하가 집중되어 분산시킬때      백업 site를 구성할때      마스터 데이터는 분산데이터베이스에 복제분산 적용        외부단계 : 개별 사용자들 관점  개념단계 : 전체 데이터베이스의 논리적 구조 기술, 개념스키마 존재  내부단계 : 데이터베이스에 어떤 데이터가 어떻게 저장되어있는가를 기술, 내부스키마 가짐ERD  1976년 피터첸에 의해 만들어짐  엔터티 도출 → 배치 → 관계설정 →관계명 기술  관계의 명칭이 관계표현에 매우 중요한 부분임  중요엔터티를 왼쪽 상단에 추가 발생하는 엔터티를 오른쪽 하단에 배치엔터티  반드시 해당업무에서 필요하며 관리하고자 하는 정보  지속적으로 존재하는 2개 이상의 인스턴스 집합  반드시 속성을 가짐  통계성 엔터티나 코드성 엔터티의 경우 관계 생략 가능, 그 외에는 반드시 다른 엔터티와 관계가 있음  유일한 식별자에 의해 식별가능해야함  발생 시점에 따른 분류          기본엔터티(키 엔터티) : 독립적, 자신의 주 식별자를 가짐, 부모역할 (고객)      중심엔터티(메인 엔터티) : 기본엔터티로부터 발생, 해당업무의 중심역할 (계약, 대출, 주문 등)      행위 엔터티 : 주문목록 : 2개 이상의 부모엔터티로부터 발생, 내용이 자주 바뀜(변경 이력, 주문 목록)        유무에 따른 분류          유형 엔터티 : 물리적 형태가 있고 안정적이고 지속적(상품, 사원)      개념 엔터티 : 물리적 형태가 없는 관리해야할 개념적 정보(회사, 조직)      무형 엔터티 : 업무 수행에 따라 비교적 많이 발생 (주문, 배송)        이름          업무 용어 사용      약어 사용 자제      단수 명사 사용      유일한 이름 부여      생상하는 의미대로 이름 부여      속성: 더 이상 분리되지 않는 최소의 데이터 단위  엔터티에 대한 자세하고 구체적인 정보를 나타냄  하나의 엔터티는 두개 이상의 속성을 가짐  하나의 속성은 단 하나의 속성값을 가짐  속성도 집합임  특성에 따른 분류          기본 속성(BASIC) : 업무상 필요한 데이터에 대해 정의. (코드 성 데이터, 일련번호, 계산에 의해 생성된 속성은 제외)      설계 속성(DESIGNED) : 업무를 규칙화하기 위해 새로 만들거나 변형한 속성, 코드 성 데이터, 일련번호 등      파생 속성(DERIVED) : 다른 속성의 영향을 받아 발생. 주로 계산된 값들이 이에 해당. 가급적 적게 정의하는 것이 좋음. 조회시 빠른 성능을 위해 원래 속성의 값을 계산해서 저장할수 있도록 만든 속성        엔터티 구성 방식에 따른 분류          PK속성      FK속성      일반속성        명칭 부여 방법          업무에서 자주 사용하는 용어 사용      약어 사용 자제      서술식 이름x      유일한 이름        도메인 : 속성 값의 데이터 타입과 크기, 추가적인 제약사함식별자: 하나의 엔터티에 구성되어 있는 여러 속성들에 대해 각 속성을 구분하기 위한 구분자  주식별자 : 각 인스턴스 구분가능, 해당 엔터티에 대한 대표성을 가져 타 엔터티와 참조관계를 연결할 수 있는 식별자 (ex.사번)          유일성 : 주식별자에의해 모든 인스턴스가 유일하게 구분      최소성 : 속성의 수는 유일성을 만족하는 최소의 수      불변성 : 자주변하면안됨      존재성 : 반드시 값이 들어와야함      도출 기준                  자주 이용되는 속성          속성(칼럼)의 수를 최소화          명칭, 이름으로 기술되는 것은 가급적 자제          자주 수정되는 속성은 자제                      보조식별자(주민등록번호)  단일식별자(모든 칼럼들)  복합식별자  내부식별자(부서번호 제외)  외부식별자(부서번호)  인조식별자  본질식별자(모든칼럼들)— 식별자관계 : 부모엔터티로부터 속성을 받아 자식엔터티의 주식별자로 사용하는 경우(연결선이 직선)— 비식별자관계 : 부모엔터티로부터 속성을 받았지만 주식별자로는 사용하지 않음. 연결선이 점선"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 중간정리(변수~배열)",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EC%A0%95%EB%A6%AC/",
    "categories": "",
    "tags": "",
    "date": "2022-10-21 00:00:00 +0900",
    





    
    "snippet": "public class Variables {    public static void main(String[] args) {    //     //정수    //     // byte val1 = 10000;    //     // short val2 = 100000;    //     // int val3 = 10000000000;     //    ...",
    "content": "public class Variables {    public static void main(String[] args) {    //     //정수    //     // byte val1 = 10000;    //     // short val2 = 100000;    //     // int val3 = 10000000000;     //     long val4 = 10000000000L;    //     long val5 = 10000000000l; //대소문자 둘다 가능    //     // System.out.println(val1);    //     // System.out.println(val2);    //     // System.out.println(val3);    //     System.out.println(val4);    //     //실수    //     float f1 = 10.23f;    //     double d1 = 10.23;    //     System.out.println(f1);    //     System.out.println(d1);    //     //논리    //     boolean b1 = false;    //     System.out.println(b1);    //     //문자    //     char ch = ' ';    //     System.out.println(ch);    //     //참조    //     String str = new String(\"Hello World\");    //     System.out.println(str);        System.out.println(\"double size : \"+Double.BYTES);        System.out.println(\"byte min : \"+Byte.MIN_VALUE+\", byte max : \"+Byte.MAX_VALUE);        System.out.println(\"Short min : \"+Short.MIN_VALUE+\", Short max : \"+Short.MAX_VALUE);        System.out.println(\"int min : \"+Integer.MIN_VALUE+\", int max : \"+Integer.MAX_VALUE);        System.out.println(\"long min : \"+Long.MIN_VALUE+\", long max : \"+Long.MAX_VALUE);        System.out.println(\"float min : \"+Float.MIN_VALUE+\", float max : \"+Float.MAX_VALUE);        System.out.println(\"double min : \"+Double.MIN_VALUE+\", double max : \"+Double.MAX_VALUE);        /*  double size : 8            byte min : -128, byte max : 127            Short min : -32768, Short max : 32767                  int min : -2147483648, int max : 2147483647            long min : -9223372036854775808, long max : 9223372036854775807            float min : 1.4E-45, float max : 3.4028235E38            double min : 4.9E-324, double max : 1.7976931348623157E308             출력됨            */            Integer i = 1000;            int aa = 100;             System.out.println(i);            System.out.println(aa); //두개 차이없음                }}public class Variables2222 {    public static void main(String[] args) {        //예약어(키워드) 사용 불가        //public, static, void, String        //int, short, byte, long, double, float, boolean, char        //Integer, Short, Byte, Long, Double, Float, Boolean, Charater        //if, for, while, new , delete, try, catch, class, private, protedcted        //yield, return, goto.... 등 사용 불가        //int static = 10; //오류                //2개 이상 단어 사용불가(공백문자안됨)        // int number of student = 10; //오류        int number_of_studrent=10; //snake case        int numberOfStudent = 10; //camel case 요즘은 이걸 더 많이 씀        System.out.println(numberOfStudent);        System.out.println(number_of_studrent);        //숫자로 시작 불가        // int 1number =10; //오류        int number1 =10; //가능        System.out.println(number1);        //대소문자 구분        // int apple, Apple, aPPle, appLe, appLE, APPLE;         //모두 다른 변수임. 그래도 이렇게 쓰지말기(유지보수 어렵게 할때 사용함[프리랜서작업시])        // int Int = 10; //가능하나 쓰지말것        // float Float = 10; //가능하나 쓰지말것        // int $$$$$____$$$$$ =10; //가능하나 알아보기힘드니 쓰지말것        //이미 만든 변수 재선언 불가        // int number_of_studrent=10; //에러            }}import java.util.Scanner;public class InputEx01 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"숫자를 입력하세요 : &gt; \");        int n=0;        try{            n=s.nextInt();        }catch(Exception e){            System.out.println(\"잘못된 입력값입니다.\");            s.close();            // return;        }        System.out.println(n);                s.close();    }}8장 예외처리 잠깐 봄power=!power를 toggle이라고 부름import java.util.Scanner;public class OperatorEx {    public static void main(String[] args) {        //연산자        //1.부호, 2.산술, 3.비교, 4.논리, 5.비트, 6.증가감소, 7.대입        //8.조건선택        //1.단항 (부호, 증가감소, typecasting)        //2.이항 (산술, 비교, 논리, 비트, 대입)        //3.삼항 (조건선택)        //1.부호연산자        int value1 = -10+20; //10        System.out.println(value1);        int value2 = (int)10.23 * 10;         System.out.println(value2); //100나옴        int value3 = (int)(10.23 * 10);         System.out.println(value3); //102나옴        int r = (int)Math.random()*10;         System.out.println(r);         //무조건 0나옴. Math.random이 0.xxxxx...이 나오는데 (int)처리되서 0됨. 0*10인꼴        //(int)(Math.random*10) 으로 해야 원하는 값이 나옴        //2.산술연산자        int result1 = 10 + 20;        int result2 = result1 + 20;        int result3 = result1 + result2;        int result4 = 10+20*5/3-10; // * / + - 순서로 계산됨        System.out.println(result4);        //3.비교연산(대소비교, 동일비교)        boolean b1 = result3 == result2;        boolean b2 = result2 != 20;        System.out.println(b1);        System.out.println(b2);        boolean b3 = result3&gt;=200; //이상        boolean b4 = result3&lt;=200; //이하        boolean b5 = result3&gt;200; //초과        boolean b6 = result3&lt;200; //미만        System.out.println(b3);        System.out.println(b4);        System.out.println(b5);        System.out.println(b6);        //논리연산 (&amp;&amp;, ||, !)        // final int PRICE = 8000; //가격        // Scanner s = new Scanner(System.in);        // final int STANDARD_PRICE = s.nextInt(); //점심값사용가능금액        // s.close();        // int money = 10000; //현금        // int balance = 5000; //계좌        // System.out.println(money&gt;=PRICE || balance &gt;= PRICE? \"구매가능\":\"구매불가능\");        // System.out.println(money&gt;=PRICE &amp;&amp; PRICE&lt;=STANDARD_PRICE?\"구매가능\":\"구매불가능\");        double bmi=25.5;        System.out.println(\"저체중 인가? \"+(bmi&gt;=0 &amp;&amp; bmi&lt;18.5));        System.out.println(\"정상체중 인가? \"+(bmi&gt;=18.5 &amp;&amp; bmi&lt;23));        System.out.println(\"과체중 인가? \"+(bmi&gt;=23 &amp;&amp; bmi &lt;25));        System.out.println(\"비만 인가? \"+(bmi&gt;=25 &amp;&amp; bmi &lt;30));        System.out.println(\"고도비만 인가? \"+(bmi&gt;=30));                boolean power = false;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power; //toggle        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        String phone_manufacturer[] = {\"삼성전자\",\"Apple\",\"샤오미\",\"Oppo\",\"화웨이\",\"LG\"};        for(int i=0;i&lt;phone_manufacturer.length;i++){            if(phone_manufacturer[i].equals(\"LG\")) System.out.println(phone_manufacturer[i]);        }        // 5.증감감소연산자(증감문)        int number = 0;        number++;        System.out.println(number); //1        number--;        System.out.println(number); //0        System.out.println(number++);//0        System.out.println(++number);//2        System.out.println(number--);//2        System.out.println(--number);//0        int i=0;        while(i&lt;phone_manufacturer.length)            System.out.println(phone_manufacturer[i++]);        //6. 대입연산        int num = 10+20;         num += 10;         num -= 10;         num /= 10;         num *= 10;         num %= 10;         System.out.println(num);    }}import java.util.Scanner;public class Exercise01 {    public static void main(String[] args) {        // int arr[] = {80,75,55};        // int sum=0;        // for(int i=0;i&lt;arr.length;i++){        //     sum += arr[i];        // }        // System.out.println(\"평균 : \"+sum/(double)arr.length); //70나옴        Scanner s = new Scanner(System.in);        String sarr[] = {\"국어\",\"수학\",\"영어\",\"물리\",\"화학\",\"생물\"};        int arr[] = new int[sarr.length];        int sum=0;                for(int i=0;i&lt;arr.length;i++){            System.out.print(sarr[i]+\"의 점수를 입력하세요. &gt; \");            // arr[i]=s.nextInt();            sum+=arr[i] = s.nextInt(); //한줄로 받는 법        }        System.out.println(\"입력받은 점수의 평균 : \"+sum/(double)arr.length);                s.close();    }}import java.util.Arrays;public class StringClassEx {    public static void main(String[] args) {        String str1= \"Hello\";        System.out.println(str1);        String str2 = new String(\"Hello\");        System.out.println(str2);        str1 = str1 + 10 + 20 ;        System.out.println(str1); //Hello1020 출력        String str3 = \"Java Programming\";        System.out.println(str3.length()); //공백까지 셀려서 16출력        System.out.println(str3.substring(0, 4)); //0&lt;=x&lt;4         System.out.println(str3.substring(5, 16)); //5&lt;=x&lt;16        String str4 = str3.substring(0, 4);        System.out.println(str4);         String str5 = str3.substring(5, 16);         System.out.println(str5);        System.out.println(str3.contains(\"Java\")); //str3이 \"java\"를 포함하고 있는가? true출력됨        System.out.println(str3.contains(\"python\")); //str3이 \"python\"를 포함하고 있는가? false출력됨        System.out.println(str3.indexOf(\"Java\")); //Java가 몇번째 문자열부터 시작되는가? 없으면 -1 출력.  0출력됨        System.out.println(str3.replaceAll(\"Java\", \"Python\")); //Java를 Python으로 변경. Python Programming 출력됨        System.out.println(str3);//값을 대체시킨것이 아니라서 str3의 값은 그대로임        System.out.println(str3.equals(\"Java Programming\"));//괄호안의 문자열과 완전히 일치하는가? true출력        System.out.println(str3.equalsIgnoreCase(\"java programming\")); //대소문자구분안하고 완전히일치하는가? true출력                System.out.println(str3.toUpperCase()); //전부 대문자        System.out.println(str3.toLowerCase()); //전부 소문자        String splitStr = \"1,2,3,4,5,6,7,8,9\";        System.out.println(splitStr.split(\",\"));        String arr[] = splitStr.split(\",\"); //spliter - 구분이되는 문자기준. 여기서는 \",\" 임        System.out.println(Arrays.toString(arr));    }}for문에 i를 많이쓰는 이유, 배열의 index를 의미함. 배열에서 가장 많이쓰이기때문임.다음으로 j,k가 많이쓰이는것은 그냥 i다음이라서뒤에 ()가 붙으면 함수임package JAVA_221024;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class DiceEx {    public static void main(String[] args) throws IOException {        int dice1 = (int)(Math.random()*6)+1;        int dice2 = (int)(Math.random()*6)+1;                System.out.println(\"주사위의 눈금은 \"+dice1+\"입니다.\");        System.out.println();        System.out.println(\"=====if문 사용=====\");        if(dice1==1) System.out.println(\"주사위의 눈금은 1입니다.\");        else if(dice1==2) System.out.println(\"주사위의 눈금은 2입니다.\");        else if(dice1==3) System.out.println(\"주사위의 눈금은 3입니다.\");        else if(dice1==4) System.out.println(\"주사위의 눈금은 4입니다.\");        else if(dice1==5) System.out.println(\"주사위의 눈금은 5입니다.\");        else System.out.println(\"주사위의 눈금은 6입니다.\");        System.out.println();        System.out.println(\"=====switch문 사용=====\");        switch(dice1){            case 1:                 System.out.println(\"주사위의 눈금은 1입니다.\");                break;            case 2:                 System.out.println(\"주사위의 눈금은 2입니다.\");                break;            case 3:                 System.out.println(\"주사위의 눈금은 3입니다.\");                break;            case 4:                 System.out.println(\"주사위의 눈금은 4입니다.\");                break;            case 5:                 System.out.println(\"주사위의 눈금은 5입니다.\");                break;                default :                 System.out.println(\"주사위의 눈금은 6입니다.\");            }            int sum = dice1+dice2;            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));            System.out.print(\"홀짝을 입력하세요. (홀 : 1, 짝 : 0) &gt;&gt;\");            int input=0;            while(true){                input = Integer.parseInt(br.readLine());                if(input==0 || input ==1) {                    break;                }else {                    System.out.println(\"입력값이 잘못되었습니다\");                    continue;                }            }                        int result= sum%2;            System.out.println(\"주사위 눈의 합 : \"+sum);            System.out.println(\"=====if문 사용=====\");            if(result == input) System.out.println(\"사용자 승\");            else System.out.println(\"컴퓨터 승\");            System.out.println();                        System.out.println(\"=====switch문 사용=====\");            switch(result){                case 1:                    switch(input){                        case 1:                            System.out.println(\"사용자 승\");                            break;                        default:                            System.out.println(\"컴퓨터 승\");                    }                    break;                default :                     switch(input){                         case 0 :                             System.out.println(\"사용자 승\");                            break;                        default :                             System.out.println(\"컴퓨터 승\");                    }            }            br.close();    }}package JAVA_221024;// import java.io.BufferedReader;// import java.io.IOException;// import java.io.InputStreamReader;public class LoopEx01 {    public static void main(String[] args) //throws IOException    {        for(int i=0;i&lt;3;i++){            System.out.println(\"for반복:\"+i);        }        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        // int dan = Integer.parseInt(br.readLine());        // for(int i=1;i&lt;=9;i++){        //     System.out.println(dan+\" X \"+i+\" = \"+dan*i);        // }        String str = \"Hello World!!\";        for(int i=0;i&lt;str.length();i++){            if(str.charAt(i)=='l') continue;            System.out.println(i+\" : \"+str.charAt(i));            // if(str.charAt(i)=='o') break;        }    }}for문에서 i&lt;arr.size() 데이터가 몇개인지 모를때 사용  공공데이터 api   https://www.data.go.kr/package JAVA_221024;import java.util.Scanner;public class InfiniteLoop {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        int dice1,dice2;        int total=0,user_win=0;        while(true){                dice1 = (int)(Math.random()*6)+1;                dice2 = (int)(Math.random()*6)+1;                int sum = dice1+dice2;                int input=0;                                System.out.print(\"홀짝을 입력하세요. (홀 : 1, 짝 : 0) &gt;&gt;\");                input = s.nextInt();                if(!(input==0 || input ==1)) {                    System.out.println(\"입력값이 잘못되었습니다\");                    System.out.println();                    continue;                }                int result= sum%2;                System.out.println(\"주사위 눈의 합 : \"+sum);                if(result == input) {                    System.out.println(\"사용자 승\");                    user_win++;                }                else{                    System.out.println(\"컴퓨터 승\");                }                total++;                System.out.println();                System.out.println(\"다시 하시겠습니까?(0:아니오 / 계속하려면 아무키나 누르세요.\");                input = s.nextInt();                if(input==0) {                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    break;                }        }        System.out.println(\"총 시도 : \"+total+\" / 승률 : \"+user_win/(double)total*100+\"%\");    }}홀짝게임FileReaderpackage JAVA_221025;import java.io.File;import java.io.FileReader;public class FileReaderEx {    public static void main(String[] args) throws Exception{        File file = new File(\"JAVA_221025/test.txt\"); //작업영역에 폴더를 여러개 열어서 폴더 명을 적어줘야함.        FileReader reader = new FileReader(file);        while(true){            int rd = reader.read();            if(rd == -1){                break;            }            System.out.print((char)rd);        }        reader.close();    }}만약 안되면 txt파일있는 폴더의 경로를 복사해서 넣을 것. \\를 /로 수정해줘야함플래쉬메모리 : usb 등package JAVA_221025;import java.util.Scanner;public class ArrayEx3 {    public static void main(String[] args) {        int[] score = {95,85,80,70,92};        String[] name = {\"송종하\", \"정시안\", \"손경은\", \"송효빈\", \"안해일\"};        Scanner s = new Scanner(System.in);                while(true){            System.out.print(\"조회 할 학생의 번호 (0-4) -1 to quit : &gt; \");            int n = s.nextInt();            if(n==-1) break;            else if(n&gt;=0 &amp;&amp; n&lt;score.length) {                System.out.println(\"이름 : \"+name[n]);                System.out.println(\"점수 : \"+score[n]);            }else {                System.out.println(\"잘못된 번호입니다 [번호범위 : 0-4]\");                System.out.println();            }        }        System.out.println(\"종료합니다.\");        s.close();    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 배열",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 배열",
    "date": "2022-10-20 00:00:00 +0900",
    





    
    "snippet": "배열 - 레퍼런스 타입public class ArrayEx {    public static void main(String[] args) {        int arr[] = new int[5];        //배열 요소의 초기화        System.out.println(arr);        for(int i=0;i&lt;arr.length;...",
    "content": "배열 - 레퍼런스 타입public class ArrayEx {    public static void main(String[] args) {        int arr[] = new int[5];        //배열 요소의 초기화        System.out.println(arr);        for(int i=0;i&lt;arr.length;i++){            arr[i]=(i+1)*10;        //배열 요소의 조회        System.out.println(arr[i]);//인덱스 기반 조회방법        }         //arr배열의 첫번째부터 차례대로 접근해서 조회        //조회된 값을 i에 복사        for(int i:arr){            System.out.println(i);        } //무조건 처음부터 끝까지 순차조회    }}import java.util.ArrayList;import java.util.List;public class ArrayEx01 {    public static void main(String[] args) {        int arr[] = new int[3]; //생성(선언)        // int i=0;        // arr[i] = (i+1)*10;        // System.out.println(arr[i]);        // i++;        // arr[i] = 20;        // System.out.println(arr[i]);        // i++;        // arr[i] = 30;        // System.out.println(arr[i]);        for(int i=0;i&lt;3;i++){            arr[i] = (i+1)*10;            System.out.println(arr[i]);        }        arr = new int[5]; //덮어쓰기 (정적 - static)        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        list.add(10);        list.add(10);        list.add(10);        list.add(10);        list.add(10); //컬렉션 프레임워크. 추가하는대로 배열의 길이가 늘어남.    }    }import java.util.Arrays;public class ArrayEx02 {    public static void main(String[] args) {        int arr[] = new int[3];        int arr2[] = {5,10,15};        arr2[0] =55;        double arr3[] = new double[3];        arr3[0]=70;        boolean arr4[] = new boolean[3];        arr4[0] = true;        char arr5[] = {'H','e','l','l','o',' ','W','o','r','l','d','!','\\0'}; // \\0 = null문자. 문자열의 끝을 나타내는 문자.        // arr5[0]='a';        String arr6[] = new String[3];        arr6[0] = \"abcd1234\";        String str = \"Hello World!\";        System.out.println(str.charAt(0));        System.out.println(str.toCharArray()[0]); //charAt(0)과 같은 것임        System.out.println(str.substring(0, 5)); //Hello 나옴        System.out.println(str.substring(6, 12)); //World 나옴        String strArr[] = new String[5];        String strArr2[] = {\"asd\",\"fgh\",\"jkl\"};        for(int i=0;i&lt;strArr2.length;i++){            System.out.println(strArr2[i]);        }        System.out.println(Arrays.toString(strArr2));    }}import java.util.Arrays;public class ArrayEx03 {    public static void main(String[] args) {        int arr[] = {10,20,30};        // int arr2[] = arr;        int arr2[] = new int[arr.length];        // System.out.println(\"before\");        // System.out.println(Arrays.toString(arr));        // System.out.println(Arrays.toString(arr2));        // arr[0]=100;        // System.out.println(\"after\");        // System.out.println(Arrays.toString(arr));        // System.out.println(Arrays.toString(arr2));        //둘다 0번째 자리 값이 바뀜. arr2가 arr의 주소값을 받아왔기때문임. 레퍼런스 타입의 특징임!!!        //배열 복사        System.out.println();        System.arraycopy(arr, 0, arr2, 0, 3);        System.out.println(\"before\");        System.out.println(Arrays.toString(arr));        System.out.println(Arrays.toString(arr2));        arr[0]=100;        System.out.println(\"after\");        System.out.println(Arrays.toString(arr));        System.out.println(Arrays.toString(arr2));    }}package JAVA_221025;import java.util.Scanner;public class ArrayEx3 {    public static void main(String[] args) {        // int[] score = {95,85,80,70,92};        // String[] name = {\"송종하\", \"정시안\", \"손경은\", \"송효빈\", \"안해일\"};        Scanner s = new Scanner(System.in);        int next_index=0;        System.out.print(\"학생 수를 입력하세요 : &gt; \");        int t=s.nextInt();        int[] score = new int[t];        String[] name = new String[t];        while(true){            System.out.println(\"1.점수추가, 2.점수조회, 0:종료\");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1:                    if(next_index&gt;=t){                        System.out.println(\"더 이상 입력할 수 없습니다.\");                        System.out.println();                    }else{                        System.out.print(\"이름 : &gt; \");                        String stu_name = s.nextLine();                        System.out.print(\"점수 : &gt; \");                        int stu_score = s.nextInt();                        s.nextLine(); //엔터키 입력 비우기                        name[next_index] = stu_name;                        score[next_index] = stu_score;                        System.out.println(\"점수가 저장되었습니다\");                        next_index++;                    }                    break;                case 2:                    System.out.print(\"조회 할 학생의 번호 (0-\"+(t-1)+\") -1 to quit : &gt; \");                    int n = s.nextInt();                    if(n&gt;=0 &amp;&amp; n&lt;score.length) {                        System.out.println(\"이름 : \"+name[n]);                        System.out.println(\"점수 : \"+score[n]);                    }else {                        System.out.println(\"잘못된 번호입니다 [번호범위 : 0-4]\");                        System.out.println();                    }                    System.out.println();                    break;                case 0:                    System.out.println(\"종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"잘못된 메뉴 번호입니다.\");            }                    }    }}점수 입력, 조회package JAVA_221025;import java.util.Scanner;public class ArrayEx3 {    public static void main(String[] args) {        // int[] score = {95,85,80,70,92};        // String[] name = {\"송종하\", \"정시안\", \"손경은\", \"송효빈\", \"안해일\"};        Scanner s = new Scanner(System.in);        System.out.print(\"학생 수를 입력하세요 : &gt; \");        int t=s.nextInt(); //다음에 받은게 int sel이라서 nextInt안해줘도됨        int[] score = new int[t];        String[] name = new String[t];        int next_index=0; //점수 추가시 점수를 저장할 위치        while(true){            System.out.println(\"1.점수추가, 2.점수조회, 3.점수수정, 0:종료\");             int sel = s.nextInt();            s.nextLine();            switch(sel){                 case 1: //점수추가기능 시작                    if(next_index&gt;=t){ //현재 입력할 위치가 최대 인덱스를 넘어설경우 오류처리                        System.out.println(\"더 이상 입력할 수 없습니다.\");                        System.out.println();                    }else{                        System.out.print(\"이름 : &gt; \");                        String stu_name = s.nextLine();                        System.out.print(\"점수 : &gt; \");                        int stu_score = s.nextInt();                        s.nextLine(); //엔터키 입력 비우기                        name[next_index] = stu_name;//next_index위치에 저장                        score[next_index] = stu_score;                        System.out.println(\"점수가 저장되었습니다\");                        next_index++; //다음번호로 이동                    }                    break;//switch문 종료                case 2://점수 조회기능                    System.out.print(\"조회 할 학생의 번호 (0-\"+(t-1)+\") : &gt; \");                    int n = s.nextInt();                    if(n&gt;=0 &amp;&amp; n&lt;score.length) { //조회할 인덱스가 범위내인지 검사                        System.out.println(\"이름 : \"+name[n]);                        System.out.println(\"점수 : \"+score[n]);                    }else {                        System.out.println(\"잘못된 번호입니다 [번호범위 : 0-\"+(t-1)+\"]\");                        System.out.println();                    }                    System.out.println();                    break;//switch문 종료                    case 3://점수수정기능                    System.out.print(\"수정할 번호 : &gt; \");                    int num1 =s.nextInt();                                        //범위확인 코드 빠짐                    //(구현필요)                    if(num1&gt;=0 &amp;&amp; num1&lt;score.length) { //조회할 인덱스가 범위내인지 검사                        System.out.println(\"====수정 전 데이터====\");                        System.out.println(\"이름 : \"+name[num1]);                        System.out.println(\"점수 : \"+score[num1]);                    }else {                        System.out.println(\"잘못된 번호입니다 [번호범위 : 0-\"+(t-1)+\"]\");                        System.out.println();                        break;                    }                                        System.out.println(\"====수정 후 데이터====\");                    s.nextLine();                    System.out.print(\"이름 : &gt; \");                    String stu_name = s.nextLine();                    System.out.print(\"점수 : &gt; \");                    int stu_score = s.nextInt();                    s.nextLine(); //엔터키 입력 비우기                    System.out.println(\"이름 : \"+name[num1]+\" -&gt; \"+stu_name);                    System.out.println(\"점수 : \"+score[num1]+\" -&gt; \"+stu_score);                    System.out.print(\"수정하시겠습니까? 1-수정, 0-적용안함\");                    int num2 = s.nextInt();                    if(num2 == 1){                        name[num1] = stu_name;                        score[num1] = stu_score;                        System.out.println();                        System.out.println(\"점수가 저장되었습니다\");                    }else System.out.println(\"취소했습니다.\");                    System.out.println();                    break;//switch문 종료                case 0: //프로그램종료                    System.out.println(\"종료합니다.\");                    s.close();                    return; //main메소드 종료 = 프로그램종료                default : //숫자 잘못입력한경우                    System.out.println(\"잘못된 메뉴 번호입니다.\");            }        }    }}수정기능 추가nextInt nextdouble nextbyte 뒤에는 s.nextLine으로 엔터 날려주는게 좋음package JAVA_221025;public class ArrayLoopEx01 {    public static void main(String[] args) {        // int[] arr = new int[10];        // for(int i=0;i&lt;arr.length;i++){        //     arr[i] = (i+1)*10;        //     System.out.println(arr[i]);        // }        //시도별코로나감염자수        int[] corona = {            12888,10066,2032,2310,2641,1893,1831,1647,1046,1028,1369,1344,843,1443,771,141,439        };        //지역정보        String[] region = {            \"경기\", \"서울\", \"경남\", \"부산\", \"인천\",            \"경북\", \"대구\", \"충남\", \"전북\", \"전남\",             \"충북\", \"강원\", \"광주\", \"대전\", \"울산\",             \"제주\", \"세종\"        };        int sum=0;         int max=-1; //최소값으로 초기화 -&gt; 최대 확진자 수를 저장        int min=Integer.MAX_VALUE; //최대값으로 초가화 -&gt; 최소확진자수 저장        int max_idx =0; //최대값의 배열인덱스        int min_idx =0; //최소값의 배열인덱스        for(int i=0;i&lt;corona.length;i++){ //i값이 17미만일동일 반복            //for문 활용 corona배열의 모든 값 출력            //총 확진자 수 구하기            sum +=corona[i]; //누적            //최댓값 구하기            if(max&lt;corona[i]){ //변수 max가 corona배열의 i위치보다 작으면 max 수정                max = corona[i];                max_idx=i;            }            //최소값            if(min&gt;corona[i]){  //변수 min가 corona배열의 i위치보다 크면 min 수정                min = corona[i];                min_idx=i;            }        }        System.out.println(\"일일 확진자 수 : \"+sum); //합계        System.out.println(\"지역별 최대 확진자 수 : \"+max); //최대값출력        System.out.println(\"지역별 최소 확진자 수 : \"+min); //최소값출력        System.out.println(\"최대 확진 지역 : \"+region[max_idx]); //최대확진지역 이름        System.out.println(\"최소 확진 지역 : \"+region[min_idx]); //최소확진지역 이름            }}Integer.MAX_VALUE; int의 최대값을 반환package JAVA_221025;import java.util.Scanner;public class ArrayLoopEx02 {    public static void main(String[] args) {        //제일 높은 시간대, 낮은 시간대, 평균        int[] arr = {199,165,90,107,89,99,195,284,307,598,545,674,726,581,560,673,498,908,944,742,429,489,402,307}; //시간대별무단횡단        int max_idx=0,min_idx=0,sum=0; //최대치 인덱스, 최소치인덱스, 총합계        for(int i=0;i&lt;arr.length;i++){            if(arr[i]&gt;arr[max_idx]) max_idx=i; //지금 비교하는 arr의 i번째값이 최대치자리수의 값보다 크다면 max_idx변경            if(arr[i]&lt;arr[min_idx]) min_idx=i;//지금 비교하는 arr의 i번째값이 최소치자리수의 값보다 작다면 min_idx변경            sum+=arr[i]; //총 합계        }        System.out.println(\"최대 시간대 : \"+max_idx+\"시\"); //최대인원의 시간대        System.out.println(\"최소 시간대 : \"+min_idx+\"시\"); //최소인원의 시간대        System.out.println(\"평균 : \"+sum/(double)arr.length+\"명\"); //총합계/(double형변환)하루시간 -&gt; 평균 출력        double[] score = {80.75,59.7,60.5,78.8,96.8,100.0,45.21,63.66,45.2,56.48,98.6,94.89,78.9,49.87,88.97,78.9}; //점수배열        int pass_cnt=0; //합격자수        for(int i=0;i&lt;score.length;i++){ //16회 반복(i=0~15)                if(score[i]&gt;=60) pass_cnt++; //i번째 위치하는 데이터가 60이상이면 합격 pass_cnt 1 증가        }        //합불/합격률 계산        System.out.println(\"합격률 : \"+(pass_cnt/(double)score.length)*100+\"%\");         //합격한사람/(double형으로변환)전체응시인원수*100 -&gt; double형 평균 산출        System.out.println(\"불합격률 : \"+((score.length-pass_cnt)/(double)score.length)*100+\"%\");        //(전체응시인원수-합격한사람)/(double형으로변환)전체응시인원수*100 -&gt; double형 평균 산출        //만약 조건에 변경이있을확률이있으면 (ex.0점 미응시자) 불합격인원수도 변수로 지정해서 for문에서 같이적어줘야 덜번거로움        int[] covid={32451,29581,25434,13296,35177,31352,28130}; //코로나 확진자수        int total=0; //전체 합        double avg=0; //평균        for(int i=0;i&lt;covid.length;i++){ //전체 합계 구하는 for문            total +=covid[i];        }        avg = total/(double)covid.length; //전체합계/(double형 변환)총 일자 - double형 굳이 안해줘도됨        Scanner s = new Scanner(System.in);        System.out.print(\"감염자 수를 입력하세요 : \");        int input = s.nextInt(); //오늘 감염자수 입력        if(input&gt;=avg) System.out.println(\"코로나 감염 주의 단계 : 위험\"); //오늘의 단계.평균이상이면 위험        else System.out.println(\"코로나 감염 주의 단계 : 주의\"); //오늘의 단계. 평균미만이면 주의        s.close();    }}2차원 배열package JAVA_221025;public class NestedArrayEx01 {    public static void main(String[] args) {        int[][] arr= {            {10,20,30},            {40,50,60},            {70,80,90}        };        System.out.println(arr[0]); //주소값 출력        for(int i=0;i&lt;arr.length;i++){            for(int j=0;j&lt;arr[i].length;j++){                System.out.print(arr[i][j]+\" \");            }            System.out.println();        }    }}side effect : 내쪽이 아니고 다른쪽에서 문제생김EOF : end of file.문서의 끝(-1) - 완벽하지는않음ref : reference. 주소값"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 조건문과 반복문",
    "url": "/posts/%EC%A1%B0%EA%B1%B4%EB%AC%B8%EA%B3%BC_%EB%B0%98%EB%B3%B5%EB%AC%B8/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 조건문, 반복문",
    "date": "2022-10-19 00:00:00 +0900",
    





    
    "snippet": "조건문import java.util.Scanner;public class ConditionalCheck01 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"점수를 입력하세요 &gt; \");     ...",
    "content": "조건문import java.util.Scanner;public class ConditionalCheck01 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"점수를 입력하세요 &gt; \");        double score = s.nextDouble();        final int PASS_SCORE = 60;                if(score&gt;100){            System.out.println(\"입력값이 잘못되었습니다.\");        }else if(score &gt;=PASS_SCORE) {            //score의 값이 PASS_SCORE이상일때 실행            System.out.println(\"합격입니다.\");            if(score&lt;=100 &amp;&amp; score&gt;=90){                System.out.print(\"A\"+(score&gt;=95?\"+\":\"0\"));                // if(score&gt;=95){                //  System.out.println(\"+\");                // }else if(score&lt;95){                //     System.out.println(\"0\");                // }            }else if(score&gt;=80) {                System.out.print(\"B\");            }else if(score&gt;=70) {                System.out.print(\"c\");            }else if(score&gt;=60) {                System.out.print(\"d\");            }        }else{            System.out.println(\"불합격입니다\");         }        s.close();    }}import java.util.Scanner;public class SwitchEx {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.println(\"=======================\");        System.out.println(\"      1. 1번 기능\");        System.out.println(\"      2. 2번 기능\");        System.out.println(\"      3. 3번 기능\");        System.out.println(\"      4. 4번 기능\");        System.out.print(\"선택 : &gt;\");        int sel = s.nextInt();        // switch(sel){        //     case 1:         //         System.out.println(\"1번 기능 선택됨\");        //         break;        //     case 2:         //         System.out.println(\"2번 기능 선택됨\");        //         break;        //     case 3:         //         System.out.println(\"3번 기능 선택됨\");        //         break;        //     case 4:         //         System.out.println(\"4번 기능 선택됨\");        //         break;        //     default:        //         System.out.println(\"잘못된 번호 선택입니다.\");        // }        if(sel ==1 )        System.out.println(\"1번 기능 선택됨\");        else if(sel ==2 )   System.out.println(\"2번 기능 선택됨\");        else if(sel ==3 )   System.out.println(\"3번 기능 선택됨\");        else if(sel ==4 )   System.out.println(\"4번 기능 선택됨\");        else                System.out.println(\"잘못된 번호 선택입니다.\");        s.close();    }}import java.util.Scanner;public class ScannerExercise {    public static void main(String[] args) {        System.out.println(\"=====회원등록=====\");        Scanner s = new Scanner(System.in);        System.out.print(\"아이디 : &gt;\");        String user_id = s.nextLine();        System.out.print(\"비밀번호 : &gt;\");        String user_pwd = s.nextLine();        System.out.print(\"이름 : &gt;\");        String user_name = s.nextLine();        System.out.print(\"이메일 : &gt;\");        String user_email = s.nextLine();        System.out.print(\"생년월일(8자리로 입력하세요.) : &gt;\");        String user_birth = s.nextLine();        if(user_birth.length()!=8){            System.out.println(\"입력값이 잘못되었습니다.\");            s.close();            return;        }                // String user_gen = \"\";        System.out.print(\"성별을 입력하세요. 0-선택안함. 1-남자, 2-여자 : &gt;\");        int n = s.nextInt();                // if(n==0) user_gen=\"선택안함\";        // else if(n==1) user_gen=\"남\";        // else if(n==2) user_gen=\"여\";        // else{         //     System.out.println(\"입력값이 잘못되었습니다.\");        //     s.close();        //     return;        // }        String user_gen = n==0?\"선택안함\":n==1?\"남\":\"여\";        s.close();        System.out.println(\"=====회원등록정보=====\");        System.out.println(\"아이디 : \"+user_id);        System.out.println(\"비밀번호 : \"+user_pwd);        System.out.println(\"이름 : \"+user_name);        System.out.println(\"이메일 : \"+user_email);        System.out.println(\"생년월일 (8자리) : \"+user_birth);        System.out.println(\"성별 : \"+user_gen);        System.out.println(\"====가입정보====\");        System.out.print(\"아이디 : \"+user_id +\" / 비밀번호 : \");        for(int i=0;i&lt;user_pwd.length();i++){            System.out.print(\"*\");        }        System.out.println();        System.out.println(\"이름 : \"+user_name +\" / 생년월일 : \"+user_birth+\" / 성별 : \"+user_gen);        System.out.println(\"이메일 : \"+user_email);    }    }import java.util.Scanner;public class ScannerEx2 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"정수값을 입력해주세요 &gt; \");        int input_value=s.nextInt();        final int MAX_VALUE = 255;        // System.out.println(\"입력 값이 최대 값을 초과하는가? \"+(input_value&gt;MAX_VALUE));        // System.out.println(\"입력 값이 최대 값을 이하인가? \"+(input_value&lt;=MAX_VALUE));        String msg = input_value&gt;MAX_VALUE?\"최대 초과\":\"최대 이하\";        System.out.println(msg);        s.close();    }}import java.util.Calendar;import java.util.Scanner;public class ConditionalCheck01 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        // System.out.print(\"점수를 입력하세요 &gt; \");        // double score = s.nextDouble();        // final int PASS_SCORE = 60;                // if(score&gt;100 || score&lt;0){        //     System.out.println(\"잘못된 점수입니다.\");        // }else if(score &gt;=PASS_SCORE) {        //     //score의 값이 PASS_SCORE이상일때 실행        //     System.out.println(\"합격입니다.\");        //     if(score&gt;=90){        //         System.out.print(\"A\"+(score&gt;=95?\"+\":\"0\"));        //         // if(score&gt;=95){        //         //  System.out.println(\"+\");        //         // }else if(score&lt;95){        //         //     System.out.println(\"0\");        //         // }        //     }else if(score&gt;=80) {        //         System.out.print(\"B\");        //     }else if(score&gt;=70) {        //         System.out.print(\"c\");        //     }else if(score&gt;=60) {        //         System.out.print(\"d\");        //     }        // }else{        //     System.out.println(\"불합격입니다\");        //     System.out.println(\"f\");        //  }        // String grade = \"\";        // if(score&gt;100 || score&lt;0)        grade =\"잘못된 입력값입니다\";        // else if(score &gt;=90)             grade =\"A\";        // else if(score &gt;=80)             grade =\"B\";        // else if(score &gt;=70)             grade =\"C\";        // else if(score &gt;=60)             grade =\"D\";        // else if(score &gt;=0)              grade =\"F\";        // System.out.println(grade);        //생년월일 입력하기, 현재 연도와 계산 후 나이를 구함        //어린이, 청소년, 성인을 판별하여 표시하는 프로그램을 작성하세요        //어린이 0~13세, 청소년 14~17세, 성인 18세 이상        //입력한 생년이 현재 연도보다 큰 경우 오류로 처리한다.        //계산한 연령이 120세를 넘으면 오류로 처리한다                //추가사항) 연령대를 표시한다. 생년을 2000을 입력했을 경우, \"20대입니다\" 표시        System.out.println(\"태어난년도를 입력하세요 &gt; \");        int birthyear = s.nextInt();        Calendar c = Calendar.getInstance();        final int CURRENT_YEAR = c.get(Calendar.YEAR);        int age = CURRENT_YEAR-birthyear;                s.close();        if(birthyear&gt;CURRENT_YEAR) {            System.out.println(\"입력값이 잘못되었습니다. 출생년도는 현재년도보다 높을 수 없습니다.\");            // return;        }        else if(age&gt;=120) {            System.out.println(\"출생년도 입력 오류입니다.\");            // return;        }        else if(age&lt;=13) System.out.println(\"어린이입니다\");        else if(age&lt;=17) System.out.println(\"청소년입니다\");        else System.out.println(\"성인입니다.\");        if(!(birthyear&gt;CURRENT_YEAR || age&gt;=120))        System.out.println(age/10*10+\"대 입니다.\");            }}import java.util.Scanner;public class ScoreSwitch {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.println(\"점수를 입력하세요. &gt; \");        int score = s.nextInt();        switch(score/10){        case 10: case 9:            System.out.println(\"A\");            break;            case 8:            System.out.println(\"B\");            break;            case 7:            System.out.println(\"C\");            break;            case 6:            System.out.println(\"D\");            break;        default :            System.out.println(\"F\");        }        //150처럼 100점이 넘는것도 입력이 가능함. 입력값을받을때는 if문을 써야함    }}비교횟수가 최소화되어야 속도가 빠름.높은수부터 비교하는것이 좋음랜덤값public class RandomEx {    public static void main(String[] args) {        System.out.println((int)(Math.random()*10+1)); //0~10        System.out.println(Math.round(Math.random()*10)); //반올림        System.out.println(Math.ceil(Math.random()*10)); //올림        System.out.println(Math.floor(Math.random()*10)); //내림        System.out.println();        System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));     }}반복문import java.util.Scanner;public class LoopEx {    public static void main(String[] args) {        // for(int i=0;i&lt;3;i++){        //     System.out.println(\"반복합니다.\"+i);                    // }        // int j=0;        // while(j&lt;10){        //     int value = 10;        //     System.out.println(\"while반복\"+j+\"번째\");        //     j++;        // }        // int value=10;        // System.out.println();        System.out.println(\"====구구단 출력====\");        for(int i=1;i&lt;10;i++){            System.out.println(\"7 * \"+i+\" = \"+i*7);        }        System.out.println();        for(int i=1;i&lt;=7;i++){            for(int k=1;k&lt;=9;k++){                System.out.println(i +\" * \"+k+\" = \"+i*k);            }            System.out.println();        }        System.out.println(\"====구구단 while문 사용====\");        int i=1, k=1;        while(i&lt;=7){            System.out.println(i +\" * \"+k+\" = \"+i*k);            k++;            if(k==9){                i++;                k=1;                System.out.println();            }        }         System.out.println();        int arr[] = {10,20,30,40,50};        for(int index = 0;index&lt;arr.length;index++){            System.out.println(arr[index]);        }    }    }public class NestedLoop {    public static void main(String[] args) {        for(int i=0;i&lt;4;i++){            for(int j=0;j&lt;3;j++){                System.out.println(\"i : \"+i+\" / j : \"+j);            }            System.out.println();        }        for(int i=1;i&lt;=7;i++){            for(int j=1;j&lt;=9;j++){                System.out.println(i +\" * \"+j+\" = \"+i*j);            }            System.out.println();        }        // System.out.println(\"====구구단 while문 사용====\");        // int i=1, j=1;        // while(i&lt;=7){        //     System.out.println(i +\" * \"+j+\" = \"+i*j);        //     j++;        //     if(j==9){        //         i++;        //         j=1;        //         System.out.println();        //     }        // }        for(int i=0;i&lt;5;i++){            for(int j=0;j&lt;=i;j++){                System.out.print(\" * \");            }            System.out.println();        }    }}for문의 선언된 변수 이름으로 반복문을 부름i Loop, j Loop 이런식import java.util.Scanner;public class StringCompare {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.println(\"Hello를 입력하세요. : &gt;\");        String input = s.nextLine();        if(input.equalsIgnoreCase(\"Hello\")) System.out.println(\"안녕하세요.\");        else System.out.println(\"안녕히가세요.\");        //equalsIgnoreCase : 대소문자 무시비교        s.close();    }}equalsIgnoreCase : 대소문자 무시비교import java.util.Scanner;public class ConditionCheck {    public static void main(String[] args) {        final int MAX_VALUE = 255;        Scanner s = new Scanner(System.in);        System.out.println(\"값을 입력하세요(최대 0 ~ 255) : &gt; \");        int input =s.nextInt();        // if(input &gt; MAX_VALUE) System.out.println(\"입력값은 최대 값을 넘습니다.\");        // // if(input &lt;=MAX_VALUE) System.out.println(\"입력한 값 : \"+input);        // else if(input&lt;0) System.out.println(\"입력값은 최소 값 미만입니다.\");        // else System.out.println(\"입력한 값 : \"+input);                if(input &gt;MAX_VALUE || input &lt; 0 ) System.out.println(\"입력값이 범위를 넘어섭니다. (범위 0 ~ 255)\");        else System.out.println(\"입력한 값 : \"+input);         s.close();    }}import java.util.Scanner;public class ConditionCheck2 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"선택(1~4) : &gt; \");        int input = s.nextInt();        if(input == 1 )      System.out.println(\"1번을 선택하셨습니다.\");        else if(input == 2 ) System.out.println(\"2번을 선택하셨습니다.\");        else if(input == 3 ) System.out.println(\"3번을 선택하셨습니다.\");        else if(input == 4 ) System.out.println(\"4번을 선택하셨습니다.\");        else                 System.out.println(\"잘못된 번호 선택입니다.\");                switch(input){            case   1: System.out.println(\"1번 기능\"); break;            case   2: System.out.println(\"2번 기능\"); break;            case   3: System.out.println(\"3번 기능\"); break;            case   4: System.out.println(\"4번 기능\"); break;            default : System.out.println(\"잘못된 번호 선택입니다.\");        }        s.close();    }}public class NameGenerate {    public static void main(String[] args) {        String name_first[] = {\"김\",\"이\",\"박\",\"최\",\"정\",\"강\",\"조\",\"윤\",\"장\",\"임\"};        String name_mid[] = {\"민\",\"서\",\"도\",\"예\",\"시\",\"하\",\"주\",\"준\",\"윤\",\"예\"};        String name_last[] = {\"준\",\"윤\",\"우\",\"원\",\"현\",\"은\",\"빈\",\"연\",\"진\",\"하\"};        for(int i=0;i&lt;10;i++){            int r1 = (int)(Math.random()*name_first.length);            int r2 = (int)(Math.random()*name_mid.length);            int r3 = (int)(Math.random()*name_last.length);            System.out.println(name_first[r1]+name_mid[r2]+name_last[r3]);        }    }}public class RandomEx2 {    public static void main(String[] args) {        System.out.println((int)(Math.random()*10)); //0~9        System.out.println((int)(Math.random()*100)); //0~99        System.out.println((int)(Math.random()*100)+1); //1~100        double d1 = 1.23;        double d2 = 1.88;        double d3 = 1.67;        System.out.println(Math.round(d3));        System.out.println(Math.ceil(d1)); //올림        System.out.println(Math.floor(d2)); //내림        int arr [] = {1,2,3,4,5};        System.out.println(arr[(int)(Math.random()*arr.length)]);    }}public class LoopEx3 {    public static void main(String[] args) {        for(int i=0;i&lt;3;i++){            System.out.println(\"Hello\");        }        int i=0;        while(i&lt;3){            System.out.println(\"Hello\");            i++;        }        for(i=0;i&lt;3;i++){            System.out.println(\"Hello\");        }        int value = 10;        for(i=0;i&lt;3;i++){            // int value =10;            System.out.println(\"Hello\");            value++;            System.out.println(value);        }        System.out.println(value);        int sum = 0;        int j=0;        while(sum&lt;=100){            System.out.println(\"sum : \"+sum);            // sum +=++j;            j++;            sum+=j;                    }    }}import java.util.Scanner;public class NestedLoop2 {    public static void main(String[] args) {        for(int i=0;i&lt;3;i++){            for(int j=0;j&lt;2;j++){                System.out.println(\"i : \"+ i+\" / j : \"+j);            }        }        Scanner s = new Scanner(System.in);        System.out.print(\"시작단을 입력하세요 : &gt; \");        int begin = s.nextInt();        System.out.print(\"끝단을 입력하세요 : &gt; \");        int end = s.nextInt();        if(begin&lt;=end){            for(int i=begin;i&lt;=end;i++){                System.out.println(i+\"단==========\");                for(int j=1;j&lt;=9;j++){                    System.out.println(i+\" X \"+ j+\" = \"+i*j);                }            }        }else {            System.out.println(\"시작 단은 끝 단 보다 클 수 없습니다.\");            return;        }    }}public class LoopEx4 {    public static void main(String[] args) {        for(int i=0;i&lt;10;i++){            System.out.println(\"반복합니다.\");            // break;            if(i==5) break;        }        int i=0;        int sum=0;        // while(sum&lt;1000){        // while(true){        //     sum = sum+i;        //     i++;        //     if(sum&gt;=1000) break;        // }        for(;;){            sum = sum+i;            i++;            if(sum&gt;=1000) break;        }        System.out.println(\"누적 횟수 : \"+i+\", 총 합 : \"+sum);    }}import java.util.Scanner;public class InfiniteLoop {    public static void main(String[] args) {        Scanner s= new Scanner(System.in);        while(true){            int sel = 0;            System.out.println(\"===============\");            System.out.println(\"1. 회원추가\");            System.out.println(\"2. 회원조회\");            System.out.println(\"3. 회원수정\");            System.out.println(\"4. 회원삭제\");            System.out.println(\"0. 종료\");            System.out.print(\"선택 : &gt; \");            sel = s.nextInt();            if(sel ==0) break;            else if(sel ==1) System.out.println(\"회원추가 기능 실행\");            else if(sel ==2) System.out.println(\"회원조회 기능 실행\");            else if(sel ==3) System.out.println(\"회원수정 기능 실행\");            else if(sel ==4) System.out.println(\"회원삭제 기능 실행\");            else System.out.println(\"잘못된 기능번호 입니다. 다시 선택해주세요\");         }        s.close();    }}public class LoopEx5 {    public static void main(String[] args) {        for(int i=0;i&lt;10;i++){            System.out.println(\"반복합니다\"+i);            if(i%3==0) continue; //필터링 역할            System.out.println(\"continue 다음 출력\");        }    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 연산자(Operator)",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EC%97%B0%EC%82%B0%EC%9E%90(Operator)/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 연산자",
    "date": "2022-10-18 00:00:00 +0900",
    





    
    "snippet": "비교연산자는 우선순위가 거의 비슷해서 적은 순서대로 처리됨비트연산자는 거의 안씀. (», «) - low level에서 사용low level : 컴퓨터 기계쪽에 가까움(서버)high level : 사용자쪽에 가까움(프론트)middle level : 백엔드=가 제일 후순위임import java.io.BufferedReader;import java.io....",
    "content": "비교연산자는 우선순위가 거의 비슷해서 적은 순서대로 처리됨비트연산자는 거의 안씀. (», «) - low level에서 사용low level : 컴퓨터 기계쪽에 가까움(서버)high level : 사용자쪽에 가까움(프론트)middle level : 백엔드=가 제일 후순위임import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Calendar;public class InputEx {    public static void main(String[] args) throws IOException {        //표준입력을 대상으로 하는 스캐너 생성        // Scanner s = new Scanner(System.in);        // int input = s.nextInt(); //int형태의 값 하나 입력받기        // s.close(); //Scanner 사용 종료        Calendar c = Calendar.getInstance();        final int CURRENT_YEAR=c.get(Calendar.YEAR);        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        while(true){            System.out.println(\"출생년도를 입력하세요. 종료하려면 0을 입력하세요\");            int birthyear = Integer.parseInt(br.readLine());            if(birthyear==0) break;            else if(birthyear&gt;2022 || birthyear&lt;0){                System.out.println(\"입력값이 잘못되었습니다.\");                return;            }            System.out.println(\"입력한 값 : \"+birthyear);            // System.out.println((CURRENT_YEAR-birthyear+1)+\"세 입니다\");            int age=CURRENT_YEAR-birthyear;            System.out.println(age+\"세 입니다\");            if(age&gt;=18) System.out.println(\"성인입니다.\");            System.out.println(\"=================\");        }              br.close();    }}심심해서 만들어봄클래스에 final이 붙어있으면 하위 클래스를 만들지 말라는뜻임import java.util.Scanner;public class ConditionCheck {    public static void main(String[] args) {        //비교연산자        //대소비교(이상, 이하, 초과, 미만)        //동일비교(같다, 다르다)        // int x =10;        // System.out.println(x&gt;=10);//이상        // System.out.println(x&lt;=10);//이하        // System.out.println(x&gt;10);//초과        // System.out.println(x&gt;10);//미만        // System.out.println(x==10); //동일        // System.out.println(x!=10); //다른값?                //동일비교        // int sel = s.nextInt();        // System.out.println(\"1번 선택 : \"+(sel == 1));        // System.out.println(\"2번 선택 : \"+(sel == 2));        // System.out.println(\"3번 선택 : \"+(sel == 3));        // System.out.println(\"4번 선택 : \"+(sel == 4));        // if(sel == 1) System.out.println(\"1번을 선택함\");        // if(sel == 2) System.out.println(\"2번을 선택함\");        // if(sel == 3) System.out.println(\"3번을 선택함\");        // if(sel == 4) System.out.println(\"4번을 선택함\");                Scanner s = new Scanner(System.in);        String input = s.nextLine();        if(input.equals(\"hello\")) System.out.println(\"Hello World!!\");        if(input.equals(\"bye\")) System.out.println(\"Exit Program\");                s.close(); //단순프로그램에선 안써도 문제없지만 복잡해지면 안썻을때 문제생길수도        // System.out.println(\"출생 연도를 입력하세요\");        // int birthYear=s.nextInt();        // int age = 2022-birthYear;        // String msg= age&gt;=18 ? \"성인입니다.\" :\"미성년입니다.\";        // System.out.println(msg);        // s.close();        // int totalCount =123;        // final int POST_PER_PAGE=10;        // //totalcount를 POST_PER_PAGE로 나눈 나머지 값이 0을 초과한다면 additionalPage를 1. 아니면 0        // int additionalPage = totalCount % POST_PER_PAGE &gt; 0 ? 1 : 0;        // int totalPage = totalCount / POST_PER_PAGE + additionalPage;        // System.out.println(\"총 페이지 수 : \"+totalPage);     }}            x             y = 논리합 (true[1]+false[0] → true)      x&amp;&amp;y = 논리곱 (true*false → false)이산수학 비둘기집원리printf보다 println이 좀더 범용적임import java.util.Scanner;public class ScannerExercise {    public static void main(String[] args) {        System.out.println(\"=====회원등록=====\");        Scanner s = new Scanner(System.in);        System.out.print(\"아이디 : &gt;\");        String user_id = s.nextLine();        System.out.print(\"비밀번호 : &gt;\");        String user_pwd = s.nextLine();        System.out.print(\"이름 : &gt;\");        String user_name = s.nextLine();        System.out.print(\"이메일 : &gt;\");        String user_email = s.nextLine();        System.out.print(\"생년월일(8자리로 입력하세요.) : &gt;\");        String user_birth = s.nextLine();        if(user_birth.length()!=8){            System.out.println(\"입력값이 잘못되었습니다.\");            s.close();            return;        }                // String user_gen = \"\";        System.out.print(\"성별을 입력하세요. 0-선택안함. 1-남자, 2-여자 : &gt;\");        int n = s.nextInt();                // if(n==0) user_gen=\"선택안함\";        // else if(n==1) user_gen=\"남\";        // else if(n==2) user_gen=\"여\";        // else{         //     System.out.println(\"입력값이 잘못되었습니다.\");        //     s.close();        //     return;        // }        String user_gen = n==0?\"선택안함\":n==1?\"남\":\"여\";        s.close();        System.out.println(\"=====회원등록정보=====\");        System.out.println(\"아이디 : \"+user_id);        System.out.println(\"비밀번호 : \"+user_pwd);        System.out.println(\"이름 : \"+user_name);        System.out.println(\"이메일 : \"+user_email);        System.out.println(\"생년월일 (8자리) : \"+user_birth);        System.out.println(\"성별 : \"+user_gen);        System.out.println(\"====가입정보====\");        System.out.print(\"아이디 : \"+user_id +\" / 비밀번호 : \");        for(int i=0;i&lt;user_pwd.length();i++){            System.out.print(\"*\");        }        System.out.println();        System.out.println(\"이름 : \"+user_name +\" / 생년월일 : \"+user_birth+\" / 성별 : \"+user_gen);        System.out.println(\"이메일 : \"+user_email);    }    }Scanner의 문제점import java.util.Scanner;public class ScannerProblem {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"숫자 입력 &gt; \");        int number =s.nextInt();        System.out.print(\"문자열 입력 &gt; \");        // String str =s.nextLine();         //문자열을 입력받기 전에 종료해버림.        //number값을 받은 후 입력한 enter를 str값으로 인식한것임        s.nextLine();        String str =s.nextLine();         //number뒤에 온 enter를 따로 처리해줌    }}import java.util.Scanner;public class ScannerEx2 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"정수값을 입력해주세요 &gt; \");        int input_value=s.nextInt();        final int MAX_VALUE = 255;        // System.out.println(\"입력 값이 최대 값을 초과하는가? \"+(input_value&gt;MAX_VALUE));        // System.out.println(\"입력 값이 최대 값을 이하인가? \"+(input_value&lt;=MAX_VALUE));        String msg = input_value&gt;MAX_VALUE?\"최대 초과\":\"최대 이하\";        System.out.println(msg);        s.close();    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 변수(Variable)",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EB%B3%80%EC%88%98(Variable)/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 변수",
    "date": "2022-10-17 00:00:00 +0900",
    





    
    "snippet": "  단축키          ctrl + alt + 방향키 - 멀티라인 셀렉트. 동시수정 단축키      주석처리 ctrl + /      int와 double이 처리속도가 가장 빠름shift + home - 커서부터 줄의 맨 앞쪽까지 선택public class VariablesEx {    public static void main(String[] a...",
    "content": "  단축키          ctrl + alt + 방향키 - 멀티라인 셀렉트. 동시수정 단축키      주석처리 ctrl + /      int와 double이 처리속도가 가장 빠름shift + home - 커서부터 줄의 맨 앞쪽까지 선택public class VariablesEx {    public static void main(String[] args) {        //주석기호(메모공간)        //타입 변수명(식별자) = 값;        //정수, 실수, 논리, 레퍼런스 타입(String)        //정수 byte, shor, int, long        byte value1 = 10; //-127~128까지 표현 가능        short value2=100; //-32236~32235        int value3=10000; //-21억~+21억        long value4 = 1000000000000000000L;         System.out.println(value1);        System.out.println(value2);        System.out.println(value3);        System.out.println(value4);        System.out.println();        //실수 float, double        float f =100000.11f; //정밀도가 떨어짐        double d = 1000000.2222;         System.out.println(f);        System.out.println(d);        System.out.println();        //논리 boolean        boolean t=true;        System.out.println(t);        System.out.println();        //레퍼런스 타입 String        String str = \"abc\";        System.out.println(str);    }}양수만 표현 - unsugned (ex.조회수) - 정수형, 실수형에 쓰임(char제외) - c언어 문법이라고 함. java에서는 못씀public class VariablesEx {    public static void main(String[] args) {        // int i=100;        // System.out.println(i);        // i=200;        // System.out.println(i);        // i=300;        // System.out.println(i);        // i=400;        // System.out.println(i);        // i=500;        // System.out.println(i);        long lnum =123456789012L;        int num=22234;        int num2=55;        double d= 12.34;        double d2=12.3333222;        String str = \"Hello World\";        char c= '$';        System.out.println(lnum);        System.out.println(num);        System.out.println(num2);        System.out.println(d);        System.out.println(d2);        System.out.println(str);        System.out.println(c);       }}camel case, snake case 이름 파악해 둘 것리터럴 : 그 자체로 값이 인정됨 (int a= ==10==; 에서 10이 리터럴)정수 리터럴 - int(10) / long(10L)실수 리터럴 -double(10.23) / float(10.23f)상수 : 변하지 않는 값 (최초에 지정한 값에서 변경 불가능). 모두 대문자로 쓰는것이 좋음. finalpublic class Naming {    public static void main(String[] args) {        // int int =10; //오류남        int Int=10; //되는데 권장 안함        int numberofstudents =29; //되는데 권장 안함. 그냥 가독성 문제임        int numberOfStudents=29;//camel case 이걸 더 많이 씀 둘중 하나로 통일 추천        int number_of_Students=29;//snake case                // int @#$#^^=10; //오류남        int $$$=1;        int $_$$$$ =1; //되는데 욕먹음                int 숫자 =1; //가능한데 추천 안함. 한영키누르면 속도 느려짐        // int a b c =1; //오류 띄어쓰기 안됨                // int number_of_Students=29;//같은이름 두번 써서 오류        //상수        final int MAX_COUNT=255;        // MAX_COUNT=200; //오류남 MAX_count는 final이 붙어서 수정 불가능함        final double PI = 3.141592653589793; //대표적인 final예시        //지수표현        System.out.println(10e+10); //10의 10제곱 1.0E11출력        System.out.println(10e-10); //10의 -10제곱  1.0E-9출력.        byte b= (byte)250;        System.out.println(b); //-6출력됨. 오버플로우    }}            자료형      초기값                  boolean      false              char      ‘/u0000’              byte      0              short      0              int      0              long      0L              double      0.0d 또는 0.0              String      null      String =”” - 0임String = null - null값임형변환(Type Casting)public class TypeCasting {    public static void main(String[] args) {        //묵시적 형변환        byte a = 10; //10은 int형인데 자동으로 byte형 변환해줌        System.out.println(a);        int b=a;        System.out.println(b); //10 출력됨. byte를 int로 자동 형변환한것        // short c=b; //에러남. short가 int보다 작기때문에 데이터유실이 일어날 수도 있음.         //형변환을 사용하려면 명시적 형변환을 사용해야함        //명시적 형변환        short c = (short)b;//데이터 유실 위험있음        System.out.println(c); //10출력        double d1 = 10.99;        System.out.println(d1);        int i1 = (int)d1;         System.out.println(i1); //10출력. 소수점 버림        i1=(int)(d1*10);        d1=i1/10.0;        System.out.println(d1); //강제로 잘랐기때문에 값이 비정확할수도있음        //long -&gt; int 형변환에서 가낭 오버플로우가 많이일어남        int i2 = (int)1000000000000000L;        System.out.println(i2); //-1530494976출력됨        char ch ='A';        int i3 = ch;        System.out.println(i3);    }}가능하면 명시적으로 해주는 것이 가독성이 좋음public static void main(String[] args)에서 args가 파라미터 java -version에서 -version에 해당함class Review{    public static void main(String[] args){        System.out.println(\"한 줄 출력하기\");        //주석 ctrl + /        // System.out.print(\"그냥 출력1\");        // System.out.print(\"그냥 출력2\");        //변수        //타입이름 변수이름; - 생성        //변수이름 = 값; - 초기화        //타입이름 변수이름 = 값;        //변수의 데이터타입 : 정수형, 실수형, 논리형, 문자형, 참조형        //정수형 - byte, shortm int long (default type = int)        //1Byte, 2Byte, 4Byte, 8Byte        byte bt1 = 10; //byte타입의 변수 bt1을 선언(정의)하고, 변수를 10으로 초기화        System.out.println(bt1);        bt1=20;        System.out.println(bt1);        // byte bt1 = 100; //에러, 변수 명 중복                //실수형(float, double)        double d1=10.23;        System.out.println(d1);        //문자형(char)        char ch ='A';        System.out.println(ch);        //논리형        boolean b1 = true;        System.out.println(b1);        b1 = false;        System.out.println(b1);        //참조형(reference Type)        String str = new String(\"Hello\");        System.out.println(str);        String str2=null;        System.out.println(str2); //null출력. 문자열null이 출력된게 아니고 빈공간이라는 뜻임        int a,b,c;        a=b=c=100; //한번에 같은값 변수 3개에 넣기. 잘안씀        System.out.println(a);        System.out.println(b);        System.out.println(c);                    }}char 잘 안씀. String으로 거의 다 처리가능메모리를 절약해야 트래픽 소모가 줄어서 비용이 덜 듬int - boolean은 상호호환이 됨식별자 : 임의로 이름을 지을 수 있는 모든 것"
  },
  
  {
    "title": "자바의 정석 연습문제 8장 - 예외",
    "url": "/posts/8%EC%9E%A5/",
    "categories": "",
    "tags": "java, 자바의정석, 연습문제, 예외",
    "date": "2022-10-16 00:00:00 +0900",
    





    
    "snippet": "[8-1] 예외처리의 정의와 목적정의 : 발생할 수 있는 예외(에러아님)를 미리 대비해놓는 것목적 : 이미 일어날 것을 예상한 예외를 무시하고 정삭적인 실행상태를 유지시키기위해 사용[8-2] 실행도중 예외가 발생하여 화면에 출력된 내용. 옳지않은것은?  [!important]java.lang.ArithmeticException : / by zero a...",
    "content": "[8-1] 예외처리의 정의와 목적정의 : 발생할 수 있는 예외(에러아님)를 미리 대비해놓는 것목적 : 이미 일어날 것을 예상한 예외를 무시하고 정삭적인 실행상태를 유지시키기위해 사용[8-2] 실행도중 예외가 발생하여 화면에 출력된 내용. 옳지않은것은?  [!important]java.lang.ArithmeticException : / by zero at ExceptionEx18.method2 (ExceptionEx18.java:12) at ExceptionEx18.method1 (ExceptionEx18.java:8) at ExceptionEx18.main (ExceptionEx18.java:4)  위의 내용으로 예외 발생 시 호출스택에 존재했던 메소드를 알 수 있음  예외가 발생한 위치는 method2 메소드이며 ExceptionEx18.java파일의 12번째 줄이다  발생한 예외는 AirthmeticException이며, 0으로 나누어서 예외가 발생했다  method2메소드가 method1메소드를 호출했고 그 위치는 ExceptionEx18.java파일의 8번째 줄이다. → main메소드가 method1을 호출했고 다음에 method2가 호출되었음public class test {\t\tstatic void method1(){\t\tmethod2();\t}\tstatic void method2(){\t\tmethod3();\t}\tstatic void method3(){\t\tSystem.out.println(\"hello\");\t\tSystem.out.println(1/0);\t}\tpublic static void main(String[] args) {\t\tmethod1();\t}}위의 예시를 실행시키면Exception in thread \"main\" java.lang.ArithmeticException: / by zero\tat test.method3(test.java:29)\tat test.method2(test.java:25)\tat test.method1(test.java:22)\tat test.main(test.java:35)라는 메세지가 뜬다.실제 method3에서 발생했지만 method3를 호출한 method2도 예외가 발생했다고 처리하고 method2를 호출한 method1과 method1을 호출한 main메소드도 호출한 라인에 예외가 발생한것으로 처리하기떄문임.[8-3] 오버라이딩이 잘못 된 것을 모두 고르시오void add(int a, int b) throws InvalidNumberException, NotANumberException {}class NumberException extends Exception{}class InvalidNumberException extends Exception{}class NotANumberException extends Exception{}  void add(int a, int b) throws InvalidNumberException, NotAnumberException {}  void add(int a, int b) throws InvalidNumberException {}  void add(int a, int b) throws NotAnumberException {}  void add(int a, int b) throws Exception {}  void add(int a, int b) throws NumberException {}오버라이딩시 조상보다 더 많은 예외를 선언할 수 없음. 더 높은 조상을 예외선언해도 마찬가지임. Exception은 모든 예외의 최고조상임.[8-4]다음 중 예외를 잘못 처리한 것은?void method() throws InvalidNumberException, NotANumberException {}\tclass NumberException extends RuntimeException{}class InvalidNumberException extends NumberException{}class NotANumberException extends NumberException {}  try {method();} catch(Exception e){}  try {method();} catch(NumberException e) {} catch(Exception e) {}  try {method();} catch(Exception e) {} catch(NumberException e) {}  try {method();} catch(InvalidNumberException e) {} catch(NotANumberException e) {}  try {method();} catch(NumberException e) {}  try {method();} catch(RuntimeException e) {}Exception은 모든 예외의 최고조상이라서 맨 마지막 catch문에 넣어야함. 첫번째 catch문에서 모든 예외를 처리했으니 다음 catch문에서 처리할 예외가 올 수가 없음[8-5] 실행결과를 적으시오package _2javajungsuktestEx8;public class ex8_5 {\tstatic void method(boolean b) {\t\ttry {\t\t\tSystem.out.println(1);\t\t\tif(b) throw new ArithmeticException();\t\t\tSystem.out.println(2);\t\t}catch(RuntimeException r) {\t\t\tSystem.out.println(3);\t\t\treturn;\t\t}catch(Exception e) {\t\t\tSystem.out.println(4);\t\t\treturn;\t\t}finally {\t\t\tSystem.out.println(5);\t\t}\t\tSystem.out.println(6);\t}\t\tpublic static void main(String[] args) {\t\tmethod(true);\t\tmethod(false);\t}}method(true)호출 →1 출력 → 매개변수 b가 true라서 ArithmeticException발생 → ArithmeticException이 RuntimeExcpetion의 자손이라서 첫번째 catch블럭으로 감 → 3 출력 → 예외가 처리 됐으니 finally블럭으로 감 → 5출력 → method(false) 호출 → 1출력 → 매개변수 b가 false니까 예외가 발생하지 않음 → 2출력 → 5 출력 → 6 출력최종적으로 1 3 5 1 2 5 6이 출력된다[8-6] 실행결과를 적으시오class Exercise8_6 {public static void main(String[] args) {\ttry {\t\tmethod1();\t} catch(Exception e) {\t\tSystem.out.println(5);\t}}static void method1() {\ttry {\t\tmethod2();\t\tSystem.out.println(1);\t} catch(ArithmeticException e) {\t\tSystem.out.println(2);\t} finally {\t\tSystem.out.println(3);\t}\tSystem.out.println(4);} // method1()static void method2() {\tthrow new NullPointerException();}mothod1 → mothod2에서 NullPointerException발생 → 다시 method1으로 돌아가서 발생한 NullPointerException때문에 finally블럭으로 이동 → 3 출력 → method1의 try-catch문 종료 → 발생한 NullPointerException이 해결되지못해서 4가 출력되지못하고 method1 종료 → 다시 method1으로 해결못한 NullPointerException이 main의 try-catch문을 만나(Exception이 최고조상이라 모든 Exception을 처리가능) 5출력최종적으로 3 5 출력됨[8-7] 실행결과를 적으세요class Exercise8_7 {\tstatic void method(boolean b) {\t\ttry {\t\t\tSystem.out.println(1);\t\t\tif(b) System.exit(0);\t\t\tSystem.out.println(2);\t\t} catch(RuntimeException r) {\t\t\tSystem.out.println(3);\t\t\treturn;\t\t} catch(Exception e) {\t\t\tSystem.out.println(4);\t\t\treturn;\t\t} finally {\t\t\tSystem.out.println(5);\t\t}\t\tSystem.out.println(6);\t}\tpublic static void main(String[] args) {\t\tmethod(true);\t\tmethod(false);\t} // main}main에서 매개변수에 true가 들어간 생태로 method실행 → try-catch문으로 들어가 1 출력 → if(b)가 true니까 프로그램이 종료최종적으로 1 만 출력되고 종료됨package Ex8;import java.util.InputMismatchException;import java.util.Scanner;import javax.swing.plaf.synth.SynthSeparatorUI;public class Ex8_8{    public static void main(String[] args) {        //1~100사이의 임의의 값을 얻어서 answer에 저장한다        int answer = (int)(Math.random()*100)+1;        int input=0;        int count=0;        do{            Scanner s = new Scanner(System.in);            try{                System.out.println(\"1과 100사이의 값을 입력하세요 : &gt;\");                input = s.nextInt();            } catch(InputMismatchException e){                System.out.println(\"유효하지 않은 값입니다. 다시 값을 입력해주세요.\");                continue;            }            count++;                if(answer&gt;input) System.out.println(\"더 큰수를 입력하세요.\");            else if(answer &lt;input) System.out.println(\"더 작은 수를 입력하세요.\");            else {                System.out.println(\"맞췄습니다.\");                System.out.println(\"시도횟수는 \"+count+\"번 입니다.\");                s.close();                break;            }        }while(true);    }}input을 받는 부분을 try-catch문에 넣어서 오류가 발생했을시 에러메세지를 출력하고 다시 try문으로 돌아가도록 continue;를 넣어주었다. catch에 들어갈 Exception은 예제에 적힌Exception in thread “main” java.util.InputMismatchExceptionat java.util.Scanner.throwFor(Scanner.java:819)at java.util.Scanner.next(Scanner.java:1431)at java.util.Scanner.nextInt(Scanner.java:2040)at java.util.Scanner.nextInt(Scanner.java:2000)at Exercise8_8.main(Exercise8_8.java:16)을 보고 그대로 사용하였다. 그냥 Exception을 써도 될 것같다.[8-9] 다음과 같은 조건의 예외클래스를 작성하시오package Ex8;class UnsupportedFunctionException extends RuntimeException {    final private int ERR_CODE;    UnsupportedFunctionException(String msg, int errCode){        super(msg); //조상의 생성자 RuntimeException(String msg)호출        ERR_CODE=errCode;    }    UnsupportedFunctionException(String msg){        this(msg,100);    }    public int getErrorCode(){        return ERR_CODE;    }    public String getMessage(){ //Exception의 getMessage를 오버라이딩        return \"[\" + getErrorCode()+\"]\"+super.getMessage();     }}public class Ex8_9 {    public static void main(String[] args) {        throw new UnsupportedFunctionException(\"지원하지 않는 기능입니다.\",100);    }    }상속이 좀 헷갈리는데 강의를 다시 들어야할거같다[8-10] 실행순서를 적으시오class Exercise8_10 {\tpublic static void main(String[] args) {\t\ttry {\t\t\tmethod1();\t\t\tSystem.out.println(6);\t\t} catch(Exception e) {\t\t\tSystem.out.println(7);\t\t\t}\t\t}\tstatic void method1() throws Exception {\t\ttry {\t\t\tmethod2();\t\t\tSystem.out.println(1);\t\t} catch(NullPointerException e) {\t\t\tSystem.out.println(2);\t\t\tthrow e;\t\t} catch(Exception e) {\t\t\tSystem.out.println(3);\t\t} finally {\t\t\tSystem.out.println(4);\t\t}\t\t\tSystem.out.println(5);\t\t} // method1()\tstatic void method2() {\t\tthrow new NullPointerException();\t}}main → method1 → method2 → NullPointerException발생, method2종료 후 method1으로 돌아감 → method1의 try-catch문의 첫번째 catch문으로 이동, 2출력 + Exception발생. → Exception이 해결하지못한채로 finally로 이동, 4출력 → Exception이 해결되지못해서 5가 출력되지못하고 method1종료 → main의 try-catch문으로 이동 → Exception으로 인해 6이 출력되지못하고 Exception catch문으로 이동 → 7 출력4 2 7 출력됨"
  },
  
  {
    "title": "[권오흠 영리한 프로그래밍을 위한 알고리즘 강좌] Recursion의 응용 - 멱집합",
    "url": "/posts/Recursion-%EB%A9%B1%EC%A7%91%ED%95%A9/",
    "categories": "알고리즘",
    "tags": "알고리즘, 권오흠알고리즘강좌",
    "date": "2022-10-11 00:00:00 +0900",
    





    
    "snippet": "멱집합: 모든 집합의 부분집합으로 이루어진 집합  n개의 집합의 모든 부분 집합의 개수 : 2의 n승개⭐ {a,b,c,d,e,f}의 부분집합  a를 제외한 {b,c,d,e,f}의 모든 부분집합 나열  {b,c,d,e,f}의 모든 부분 집합에 {a}를 추가한 집합들을 나열 : {c,d,e,f)의 모든 부분집합에 {a}를 추가한 집합을 나열한 후에 {c,...",
    "content": "멱집합: 모든 집합의 부분집합으로 이루어진 집합  n개의 집합의 모든 부분 집합의 개수 : 2의 n승개⭐ {a,b,c,d,e,f}의 부분집합  a를 제외한 {b,c,d,e,f}의 모든 부분집합 나열  {b,c,d,e,f}의 모든 부분 집합에 {a}를 추가한 집합들을 나열 : {c,d,e,f)의 모든 부분집합에 {a}를 추가한 집합을 나열한 후에 {c,d,e,f}의 모든 부분집합에 {a,b}를 추가한 집합을 나열함…..          여기서 {c,d,e,f}가 집합 S(K~마지막, 연속적임), {a,b}가 집합 P(처음~K-1번째, 원소 중 일부)      — Design RecursionpowerSet(s) if s is an empty printing nothing; else let t be the first element of s;find all subsets of s-{t} by calling powerSet(s-{t}); print the subsets;print the subsets with adding t;→ 위대로 하면 멱집합을 return하는 코드(메모리에 저장하는 코드)가 됨, 출력하는 코드가 필요함(성능상 효율적)그러나 출력한다면 print the subsets with adding t; 가 작동하지 않음. ==powerSet(s-{t})==를 return해주지 않기 때문임⇒ powerSet(P, S) if s is an empty set print P. else let t be the first elements of S; powerSet(P, S-{t}); power{PU{t}, S-{t});집합 S : data[k]~data[n-1]집합 P : i=0~k-1, includ[i] = true최종 코드"
  },
  
  {
    "title": "자바의 정석 연습문자 7장 - 상속 2",
    "url": "/posts/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D_%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C_7%EC%9E%A5_%EC%83%81%EC%86%8D_2/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 상속",
    "date": "2022-10-10 00:00:00 +0900",
    





    
    "snippet": "[7-17] 예제코드의 세 클래스에서 공통부분을 뽑아 Unit 클래스를 만들고 이 클래스를 상속받도록 코드를 변경  예제    class Marine{  int x,y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Tank{  int x, y;  void move(int x...",
    "content": "[7-17] 예제코드의 세 클래스에서 공통부분을 뽑아 Unit 클래스를 만들고 이 클래스를 상속받도록 코드를 변경  예제    class Marine{  int x,y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Tank{  int x, y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Dropship{  int x,y;  void move(int x, int y){}  void stop(){}  void load(){}  void unload(){}}        변경 코드package _2javajungsuktestEx7;class Unit{\tint x, y;\tvoid move(int x, int y) {}\tvoid stop() {}}class Marine extends Unit {\tvoid stimPack() {}}class Tank extends Unit {\tvoid changeMode() {}}class Droppship extends Unit{\tvoid load(){}\tvoid unload() {}}public class ex7_17 {\tpublic static void main(String[] args) {\t}}공통적으로 등장하는 부분만 Unit으로 묶어서 만들어준후 상속처리 해줬음  답지package _2javajungsuktestEx7;class Unit{\tint x, y;\tabstract void move(int x, int y) {}\tvoid stop() {}}class Marine extends Unit {\tvoid stimPack() {}}class Tank extends Unit {\tvoid changeMode() {}}class Droppship extends Unit{\tvoid load(){}\tvoid unload() {}}public class ex7_17 {\tpublic static void main(String[] args) {\t}}Unit클래스의 move메소드에 abstract를 붙여 추상메소드 처리를 해주었음. 각 클래스마다 이동방법이 다르기때문..[7-18] action메소드를 실행하면 매개변수에 해당하는 클래스의 메소드를 실행하도록 만드는 문제package _2javajungsuktestEx7;class Robot{}class DanceRobot extends Robot{\tvoid dance(){\t\tSystem.out.println(\"춤\");\t}}class SingRobot extends Robot{\tvoid sing(){\t\tSystem.out.println(\"노래\");\t}}class DrawRobot extends Robot{\tvoid draw(){\t\tSystem.out.println(\"그림\");\t}}public class ex7_18 {\t\tstatic void action(Robot r) {\t\tif(r instanceof DanceRobot) \t\t\t((DanceRobot) r).dance();\t\telse if(r instanceof SingRobot) \t\t\t((SingRobot) r).sing();\t\telse if(r instanceof DrawRobot) \t\t\t((DrawRobot) r).draw();\t}\tpublic static void main(String[] args) {\t\tRobot arr[] = {new DanceRobot(), new SingRobot(), new DrawRobot()};\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\taction(arr[i]);\t\t}\t}}Robot타입의 배열을 생성해서 서로 상속관계인 DrawRobot, SingRobot, DanceRobot을 배열에 넣어줬음. 다음에 배열의 i값이 특정 클래스와 상속관계라면 특정클래스의 메소드를 실행하도록 코드를 짰음.  답지package _2javajungsuktestEx7;class Robot{}class DanceRobot extends Robot{\tvoid dance() {\t\tSystem.out.println(\"춤을 춥니다.\");\t}}class SingRobot extends Robot{\tvoid sing() {\t\tSystem.out.println(\"노래를 합니다.\");\t\t}}class DrawRobot extends Robot{\tvoid draw() {\t\tSystem.out.println(\"그림을 그립니다.\");\t}}public class ex7_18 {\tstatic void action(Robot r) {\t\tif(r instanceof DanceRobot) {\t\t\tDanceRobot dr = (DanceRobot)r;\t\t\tdr.dance();\t\t}else if(r instanceof SingRobot) {\t\t\tSingRobot SR = (SingRobot)r;\t\t\tSR.sing();\t\t}else if(r instanceof DrawRobot) {\t\t\tDrawRobot Draw = (DrawRobot)r;\t\t\tDraw.draw();\t\t}\t}\t\tpublic static void main(String[] args) {\t\tRobot arr[] = {new DanceRobot(), new SingRobot(), new DrawRobot()};\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\taction(arr[i]);\t\t}\t}}if문에서 객체를 생성해서 메소드를 실행함.[7-19] Buyer 클래스의 제품구입 기능, 장바구니 추가기능, 구입물건 목록 조회기능, 남은 금액 출력 기능 구현package _2javajungsuktestEx7;class Buyer{\tint money =1000;\tProduct cart[] = new Product[3];\tint i=0;\t\tvoid buy(Product p) {\t\tif(money &lt; p.price) {\t\t\tSystem.out.println(p+\"를 구매할 돈이 부족합니다.\");\t\t\treturn;\t\t}else {\t\t\tmoney-=p.price;\t\t\tadd(p);\t\t}\t}\tvoid add(Product p) {\t\tif(i&gt;=cart.length) {\t\t\tProduct[] cart2 = new Product[cart.length*2];\t\t\tSystem.arraycopy(cart, 0, cart2, 0, cart.length);\t\t\tcart = cart2;\t\t}\t\tcart[i++] = p;\t}\tvoid summary() {\t\tint sum = 0;\t\tfor(int i=0;i&lt;cart.length;i++) {\t\t\tSystem.out.print(cart[i]+\", \");\t\t\tsum += cart[i].price;\t\t}\t\tSystem.out.println();\t\tSystem.out.println(\"쓴 돈 : \" + sum);\t\tSystem.out.println(\"남은 돈 : \"+  money);\t}}class Product{\tint price;\t\tProduct(int price){\t\tthis.price=price;\t}}class Tv2 extends Product{\tTv2(){super(100);}\tpublic String toString () {return \"Tv\";}}class Computer extends Product{\tComputer(){super(200);}\tpublic String toString () {return \"Computer\";}}class Audio extends Product{\tAudio(){super(50);}\tpublic String toString () {return \"Audio\";}}public class ex7_19 {\tpublic static void main(String[] args) {\t\tBuyer b = new Buyer();\t\tb.buy(new Tv2());\t\tb.buy(new Computer());\t\tb.buy(new Tv2());\t\tb.buy(new Audio());\t\tb.buy(new Computer());\t\tb.buy(new Computer());\t\tb.buy(new Computer());\t\t\t\tb.summary();\t\t\t}}일단 책에 적혀진 가이드대로 따라 만들어보았는데 가이드없이도 만들 줄 알아야할 것같다..컬렉션프레임워크의 List를 이용package Ex7;public class Product{  public int price;  public Product(int price){    this.price = price;  }}package Ex7;public class Tv extends Product{  public Tv(){    super(100);  }  public String toString(){    return \"Tv\";  }}package Ex7;public class Computer extends Product{  public Computer(){    super(200);  }  public String toString(){    return \"Computer\";  }}package Ex7;public class Audio extends Product{  public Audio(){    super(50);  }  public String toString(){    return \"Audio\";  }}package Ex7;import java.util.ArrayList;import java.util.List;public class Buyer {  int money = 1000;  List&lt;Product&gt; cart = new ArrayList&lt;Product&gt;();  void buy(Product p){    if(money&lt;p.price){      System.out.println(\"돈이 부족해서\"+p+\"을(를) 구매할 수 없습니다.\");      return;    }    money -= p.price;    add(p);    System.out.println(p+\"을(를) 구매했습니다.\");  }  void add(Product p){    cart.add(p);  }  void summary(){    System.out.print(\"구입한 물건 : \");    int sum=0;    for(Product p : cart){      System.out.print(p+\", \");      sum+=p.price;    }    System.out.println();    System.out.println(\"사용한 금액 : \"+sum);    System.out.println(\"남은 금액 : \"+money);  }  }package Ex7;public class ProductMain {  public static void main(String[] args) {    Buyer b = new Buyer();    b.buy(new Tv());    b.buy(new Computer());    b.buy(new Tv());    b.buy(new Audio());    b.buy(new Computer());    b.buy(new Computer());    b.buy(new Computer());        b.summary();  }}훨신 더 간단해졌다[7-20] 아래 코드의 실행결과는?class Parent{\tint x=100;\tvoid method() {\t\tSystem.out.println(\"Parent Method\");\t}}class Child extends Parent{\tint x=200;\tvoid method() {\t\tSystem.out.println(\"Child Method\");\t}}public class ex7_20 {\tpublic static void main(String[] args) {\t\tParent p = new Parent();\t\tChild c = new Child();\t\t\t\tSystem.out.println(\"p.x : \"+p.x);\t\tp.method();\t\tSystem.out.println(\"c.x : \"+c.x);\t\tc.method();\t}}순서대로p.x : 100Parent Methodc.x : 200Child Method가 출력됨.[7-21] attack메소드의 매개변수로 가능한 것 두가지는?interface Moveable{\tvoid move(int x, int y);}void attack(Moveable f){\t//내용 생략}null과 Moveable 인터페이스를 구현한 클래스나 그 자손의 인스턴스[7-22] Shape클래스를 조상으로 하는 Circle클래스와 Rectangle클래스를 작성하시오. 생성자도 각 클래스에 맞게 적절히 추가하시오package _3javajungsuktestEx7_3;abstract class Shape{\tPoint p;\t\tShape(){\t\tthis(new Point(0,0));\t}\tShape(Point p){\t\tthis.p=p;\t}\t\tabstract double calcArea(); //도형 면적 계산 후 반환\t\tPoint getPosition() {\t\treturn p;\t}\tvoid setPosition(Point p) {\t\tthis.p=p;\t}\t}class Point{\tint x, y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tpublic String toString() {\t\treturn \"[\" + x+\", \"+y+\"]\";\t}}class Circle extends Shape{\tdouble r; //반지름\t\tCircle(double r){\t\tthis(new Point(0,0),r);\t}\tCircle(Point p, double r){\t\tsuper(p); //조상의 멤버는 조상의 생성자가 초기화하도록 함\t\tthis.r=r;\t}\t\tdouble calcArea() {\t\treturn Math.PI*r*r;\t}}class Rectangle extends Shape{\tdouble width, height;\t\tRectangle(double width, double height){\t\tthis(new Point(0,0),width, height);\t}\tRectangle(Point p, double width, double height){\t\tsuper(p); //조상의 멤버는 조상의 생성자가 초기화하도록 함\t\tthis.height=height;\t\tthis.width=width;\t}\t\tdouble calcArea() {\t\treturn width *height;\t}\tboolean isSquare(){\t\tif(width == height) return true;\t\telse return false;\t}}public class ex7_22 {\t\tpublic static void main(String[] args) {\t}}[7-23] 면적을 구하는 sumArea 메소드를 작성하고 테스트package _3javajungsuktestEx7_3;abstract class Shape{\tPoint p;\t\tShape(){\t\tthis(new Point(0,0));\t}\tShape(Point p){\t\tthis.p=p;\t}\t\tabstract double calcArea(); //도형 면적 계산 후 반환\t\tPoint getPosition() {\t\treturn p;\t}\tvoid setPosition(Point p) {\t\tthis.p=p;\t}\t}class Point{\tint x, y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tpublic String toString() {\t\treturn \"[\" + x+\", \"+y+\"]\";\t}}class Circle extends Shape{\tdouble r; //반지름\t\tCircle(double r){\t\tthis(new Point(0,0),r);\t}\tCircle(Point p, double r){\t\tsuper(p);\t\tthis.r=r;\t}\t\tdouble calcArea() {\t\treturn Math.PI*r*r;\t}}class Rectangle extends Shape{\tdouble width, height;\t\tRectangle(double width, double height){\t\tthis(new Point(0,0),width, height);\t}\tRectangle(Point p, double width, double height){\t\tsuper(p);\t\tthis.height=height;\t\tthis.width=width;\t}\t\tdouble calcArea() {\t\treturn width *height;\t}\tboolean isSquare(){\t\tif(width == height) return true;\t\telse return false;\t}}public class ex7_22 {\tstatic double sumArea(Shape arr[]) {\t\tdouble sum=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tsum+=arr[i].calcArea();\t\t}\t\t\t\treturn sum;\t}\t\tpublic static void main(String[] args) {\t\tShape arr[] = {new Circle(5.0), new Rectangle(3,4), new Circle(1)};\t\tSystem.out.println(\"면적의 합 : \"+sumArea(arr));\t}}[7-24] 인터페이스의 장점이 아닌 것?  표준화를 가능하게 해줌  서로 관계없는 클래스들에게 관계를 맺어 줄 수 있음  독립적인 프로그래밍이 가능  다중상속을 가능하게 해줌  패키지간의 연결을 도와줌외에 개발시간 단축한다는 장점이 있음(동시에 여럿이서 개발 가능)"
  },
  
  {
    "title": "자바의 정석 연습문자 7장 - 상속 1",
    "url": "/posts/7%EC%9E%A5_%EC%83%81%EC%86%8D_1/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 상속",
    "date": "2022-10-07 00:00:00 +0900",
    





    
    "snippet": "[7-1] SutdaCard 배열을 초기화하는 문제. 숫자가 1,3,8인경우 isKwang이 true여야함.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int...",
    "content": "[7-1] SutdaCard 배열을 초기화하는 문제. 숫자가 1,3,8인경우 isKwang이 true여야함.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int i=0;i&lt;CARD_NUM;i++) {\t\t\tint num = i%10+1;\t\t\tboolean isKwang = i&lt;10&amp;&amp; (num==1 || num==3 || num==8);\t\t\t\t\t\tcards[i] = new SutdaCard(num, isKwang);\t\t}\t\t// for(int i=0;i&lt;10;i++){    //   isKwang = i==0 || i==2 || i==7;    //   cards[i] = new SutdaCard(i+1, isKwang);    //   cards[i+10] = new SutdaCard(i+1, false);    // } //이렇게해도됨\t\t//for(int i=0;i&lt;CARD_NUM;i++){    //   num = i+1;    //   isKwang = false;    //   if(i&gt;=10) num=i-9;    //   else if(i==0 || i==2 ||i==7) isKwang=true;    //   cards[i] = new SutdaCard(num, isKwang);    // } //이것도 됨\t}\t}class SutdaCard{\tint num;\tboolean isKwang;\t\tSutdaCard() {\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_1 {\tpublic static void main(String[] args) {\t\tSutdaDeck deck = new SutdaDeck();\t\t\t\tfor(int i=0;i&lt;deck.cards.length;i++) {\t\t\tSystem.out.print(deck.cards[i]+\" \");\t\t}\t}}[7-2] 클래스 SutdaDeck에 shuffle, pick메소드를 추가하는문제. pick은 매개변수가 있는것과 없는 것 둘다 만들 것.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int i=0;i&lt;CARD_NUM;i++) {\t\t\tint num = i%10+1;\t\t\tboolean isKwang = i&lt;10&amp;&amp; (num==1 || num==3 || num==8);\t\t\t\t\t\tcards[i] = new SutdaCard(num, isKwang);\t\t}\t}\t\tvoid shuffle() {\t\tSutdaCard tmp;\t\tfor(int i=0;i&lt;cards.length*2;i++) {\t\t\tint n = (int)(Math.random()*CARD_NUM);\t\t\tint n2 = (int)(Math.random()*CARD_NUM);\t\t\ttmp = cards[n];\t\t\tcards[n] = cards[n2];\t\t\tcards[n2]=tmp;\t\t}\t}\tSutdaCard pick(int index){\t\treturn cards[index];\t}\tSutdaCard pick() {\t\tint n = (int)(Math.random()*CARD_NUM);\t\treturn cards[n];\t}\t}class SutdaCard{\tint num;\tboolean isKwang;\t\tSutdaCard() {\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_1 {\tpublic static void main(String[] args) {\t\tSutdaDeck deck = new SutdaDeck();\t\t\t\tSystem.out.println(deck.pick(0));\t\tSystem.out.println(deck.pick());\t\tdeck.shuffle();\t\tfor(int i=0;i&lt;deck.cards.length;i++) {\t\t\tSystem.out.print(deck.cards[i]+\" \");\t\t}\t\tSystem.out.println();\t\tSystem.out.println(deck.pick(0));\t\t\t}}처음 shuffle메소드를 만들때void shuffle() {  \tSutdaCard tmp;  \tfor(int i=0;i&lt;cards.length;i++) {  \t\tint n = (int)(Math.random()*CARD_NUM);  \t\ttmp = cards[i];  \t\tcards[i] = cards[n];  \t\tcards[n]=tmp;  }  으로 만들었는데 cards.length가 배열을 충분히 섞기에 부족하다는 생각이 들어서 int n2을 추가로 만들어줬음.List로 변환public class SutdaCard {  int num;  boolean iskwang;  public SutdaCard(){    this(1,true);  }   public SutdaCard(int num, boolean isKwang){    this.num = num;    this.iskwang = isKwang;  }   String info(){    return num+(iskwang?\"K\":\"\");  }  @Override  public String toString(){    return num+(iskwang?\"K\":\"\");  }}import java.util.ArrayList;import java.util.List;public class SutdaDeck{  final int CARD_NUM = 20;  // SutdaCard[] cards = new SutdaCard[CARD_NUM];  List&lt;SutdaCard&gt; cards = new ArrayList&lt;SutdaCard&gt;();  public SutdaDeck(){    for(int i=0;i&lt;CARD_NUM;i++){      int num = i%10+1;      boolean isKwang = (i==1 || i==3 || i==8);      cards.add(new SutdaCard(num, isKwang));    }  }  SutdaCard pick(int index){    return cards.get(index);  }  SutdaCard pick(){    int r = (int)(Math.random()*CARD_NUM);        return cards.get(r);  }  void shuffle(){    List&lt;SutdaCard&gt; temp = new ArrayList&lt;SutdaCard&gt;();    while(cards.size()!=0){        int r = (int)(Math.random()*cards.size());        temp.add(cards.remove(r)); //temp에 저장 후 cards에서 삭제    }    cards = temp;  }}public class SutdaCardMain {  public static void main(String[] args) {    // SutdaCard card1 = new SutdaCard(3, false);    // SutdaCard card2 = new SutdaCard();    // System.out.println(card1.info());    // System.out.println(card2.info());    SutdaDeck deck = new SutdaDeck();        for(int i=0;i&lt;deck.cards.size();i++){      System.out.print(deck.cards.get(i)+\", \");    }    System.out.println();    System.out.println(deck.pick());    System.out.println(deck.pick(3));        deck.shuffle();    for(int i=0;i&lt;deck.cards.size();i++){      System.out.print(deck.cards.get(i)+\", \");    }  }}[7-3] 오버라이딩의 정의와 필요성 :조상클래스에게 상속받은 메소드를 수정할 수 있음. 자손클래스에서 그대로 사용할 수 없는 경우가 많아서 오버리이딩이 필요함.[7-4] 오버라이딩의 조건으로 옳지않은 것을 모두 고르시오  조상의 메소드와 이름이 같아야한다.  매개변수의 수와 타입이 모두 값아야한다.  리턴타입이 같아야한다.  접근 제어자는 조상의 메소드보다 좁은 범위로만 변경할 수 있다. - 조상 클래스의 메소드보다 좁은범위로 변경 불가  조상의 메소드보다 더 많은 예외를 선언할 수 있다. - 조상 클래스의 메소드보다 더 많은 예외 선언 불가오버로딩 : 이미 있는 이름의 메소드를 매개변수의 갯수나 타입을 다르게해서 새로 정의하는 것. 오버라이딩이랑은 관련 없음!!![7-5] 코드에서 오류가 나는 부분을 고치고 오류의 이유를 서술하시오package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}}class Tv extends Product{\tTv(){} //에러\tpublic String toStirng() {\t\treturn \"Tv\";\t}\t}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}class Tv extends Product{Tv(){}Tv(){}부분에서 오류가 난다 안에 super(매개변수); 를 넣어주면 해결된다.Product 클래스 안에 기본생성자가 없어서 발생하는 오류인데, Product클래스안에 기본생성자를 추가해주면 super()를 사용해주지않아도 된다.package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}\tProduct(){\t\tthis(100);\t}}class Tv extends Product{\tTv(){}\tpublic String toStirng() {\t\treturn \"Tv\";\t}}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}}class Tv extends Product{\tTv(){\t\tsuper(100);\t\t}\tpublic String toStirng() {\t\treturn \"Tv\";\t}\t}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}이런 식이다.[7-6] 자손 클래스의 생성자에서 조상 클래스의 생성자를 호출해야하는 이유는?조상 클래스에 정의된 인스턴스 변수들을 초기화해주어야함.직접 초기화해도 되지만 조상의 생성자를 호출하는 것이 더 효율적임.[7-7] 호출되는 생성자의 순서와 실행결과를 적으시오package _2javajungsuktestEx7;class Parent{\tint x=100;\t\tParent(){\t\tthis(200);\t}\tParent(int x){\t\tthis.x=x;\t}\tint getx() {\t\treturn x;\t}}class Child extends Parent{\tint x=3000;\tChild(){\t\tthis(1000);\t}\tChild(int x){\t\tthis.x=x;\t}}public class ex7_7 {\tpublic static void main(String[] args) {\t\tChild c = new Child();\t\t\t\tSystem.out.println(c.getx());\t}}main → child() → child(int x) → parent() → parent(int x) → Object()child(int x)와 Parent(int x)에는 생략되어있지만 super()이 존재함.x값은 200. child에 getx()가 없기때문에 Parent 클래스 내에서 구해야하는데 매개변수가 없으니 Parent()의 x값인 200이 나옴[7-8] 접근범위가 넚은 것에서 좁은 순으로 나열하시오public → protected → (default) → private[7-9] 다음 중 제어자 final을 붙일 수 있는 대상과 붙였을 때 그 의미를 적은 것 중 옳지 않은 것은?  지역변수 - 값 변경 불가능  클래스 - 상속을 통해 클래스에 새로운 멤버를 추가할 수 없음  메소드 - 오버로딩을 할 수 없음 - 오버라이딩을 할 수 없음  멤버변수 - 값 변경 불가[7-10] isPowerOn, channel, volume을 클래스 외부에서 접근 못하도록 제어자를 붙이고 이 멤버변수들의 값을 어디서나 읽고 변경할 수 있는 getter와 setter메소드를 추가하라package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}void setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t\t\tt.setVolume(20);\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t}}❗매개변수가 있는 메소드는 반드시 유효성검사를 해줘야함!![7-11] 이전채널로 이동하는 메소드를 추가package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\tprivate int prev;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tprev = this.channel;\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}\tvoid setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\tvoid gotoPrevChannel(){\t\tint tmp;\t\ttmp = channel;\t\tchannel = prev;\t\tprev = tmp;\t}\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t//\t\tt.setVolume(20);//\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t\t\t\tt.setChannel(20);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t}}int prev를 만들어준 뒤 getChannel에서 channel을 바꾸기 전에 prev에 저장해준 후gotoPrevChannel에서 channel과 prev의 값을 바꿔주게 만들었다.  답지package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\tprivate int prev;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tprev = this.channel;\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}\tvoid setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\tvoid gotoPrevChannel(){\t\tsetChannel(prev);\t}\t\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t//\t\tt.setVolume(20);//\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t\t\t\tt.setChannel(20);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t}}왜 있는 메소드를 활용할 생각을 못했을까ㅜ[7-12] 다음 중 접근제어자에 대한 설명으로 옳지 않은 것을 모두 고르시오  public은 접근 제한이 전혀 없는 접근 제어자이다  (default)가 붙으면, 같은 패키지 내에서만 접근 가능함  지역변수에도 접근 제어자를 사용할 수 있음  protected가 붙으면, 같은 패키지 내에서 접근 가능  protected가 붙으면, 다른 패키지의 자손 클래스에서 접근 가능[7-13] Math클래스의 생성자의 접근 제어자가 private인 이유?Math클래스의 모든 메소드가 static메소드이고 인스턴스 변수가 존재하지 않기 떄문에 객체를 생성할 필요가 없음.[7-14] 섯다 카드의 숫자와 종류를 변경할 수 없도록 코드를 수정하는 문제package _2javajungsuktestEx7;class SutdaCard{\t//인스턴스 변수라서 생성자에서 초기화해줘도 됨\tfinal int num;\tfinal boolean isKwang;\t\tSutdaCard(){\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_14 {\tpublic static void main(String[] args) {\t\tSutdaCard card = new SutdaCard();\t\tSystem.out.println(card.toString());\t}}[7-15] 형변환이 올바르지 않은 것은?class Unit() {}class AirUnit() extends Unit{}class GroundUnit() extends Unit{}class Tank extends GroundUnit{}class AirCraft extends AirUnit() {}Unit u = new GroundUnit();Tank t = new Tank();AirCraft ac = new AirCraft();  u = (Unit)ac;  u = ac;  GrountUnit gu = (GroundUnit)u;  u가 생성될때 GroundUnit을 참고하도록 설정해놨음 가능  AirUnit au = ac;  t = (Tank)u; 조상타입 인스턴스 → 자손타입 불가능  GroundUnit gu = t;[7-16] 다음 중 연산결과가 true가 아닌 것을 모두 골라라class Car{}class FireEngine extends Car implements Movable{}class Ambulance extends Car{}FireEngine fe = new FIreEngine();  fe instanceof FireEngine  fe instanceof Movable  fe instanceof Obeject  fe instanceof Car  fe instanceof Ambulanceinstanceof : 조상이나 구현한 인터페이스관계일경우 true를 반환함."
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 3",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_3/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-06 00:00:00 +0900",
    





    
    "snippet": "[6-20] 메소드 shuffle을 정의해 배열을 섞기package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_20 {\tstatic int[] shuffle(int arr[]) {\t\tif(arr==null || arr.length==0) return arr;\t\tint tmp=0;\t\tf...",
    "content": "[6-20] 메소드 shuffle을 정의해 배열을 섞기package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_20 {\tstatic int[] shuffle(int arr[]) {\t\tif(arr==null || arr.length==0) return arr;\t\tint tmp=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tint x = (int)(Math.random()*arr.length);\t\t\ttmp=arr[i];\t\t\tarr[i] = arr[x];\t\t\tarr[x] = tmp;\t\t}\t\treturn arr;\t}\t\tpublic static void main(String[] args) {\t\tint original[]= {1,2,3,4,5,6,7,8,9};\t\tSystem.out.println(Arrays.toString(original));\t\t\t\tint result[] = shuffle(original);\t\tSystem.out.println(Arrays.toString(result));\t}}배열을 몇번 섞을지 애매해서 일단 배열값만큼 섞어주었다. 더 크게 지정하면 또 Math.random으로 새 변수를 지정해줘야하기도해서..[6-21] MyTv클래스 완성하기package _2javajungsuktestEx6;class MyTv{\tboolean isPowerOn;\tint channel;\tint volume;\t\tfinal int MAX_VOLUME = 100;\tfinal int MIN_VOLUME = 0;\tfinal int MAX_CHANNEL = 100;\tfinal int MIN_CHANNEL = 1;\t\tvoid turnOnOff() {\t\tisPowerOn = !isPowerOn;\t}\tvoid volumeUp() {\t\tif(volume &lt; MAX_VOLUME) \t\tvolume++;\t}\tvoid volumeDown() {\t\tif(volume &gt; MIN_VOLUME) \t\tvolume--;\t}\tvoid channelUp() {\t\tif(channel == MAX_CHANNEL) \t\t\tchannel = MIN_CHANNEL;\t\telse channel++;\t}\tvoid channelDown() {\t\tif(channel == MIN_CHANNEL) { \t\t\tchannel = MAX_CHANNEL;\t\t} else {\t\t\tchannel--;\t\t}\t}}public class ex6_21 {\tpublic static void main(String[] args) {\t\tMyTv t = new MyTv();\t\t\t\tt.channel=100;\t\tt.volume=0;\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t\t\t\tt.channelDown();\t\tt.volumeDown();\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t\t\t\tt.volume=100;\t\tt.channelUp();\t\tt.volumeUp();\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t}}[6-22] 문자열 str이 숫자로만 이루어졌는지 확인하는 메소드를 작성하는 문제package _2javajungsuktestEx6;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex6_22 {\t\tstatic boolean isNumber(String str) {\t\tif(str.equals(\"\") || str == null) return false;\t\tfor(int i=0;i&lt;str.length();i++) {\t\t\tchar ch = str.charAt(i);\t\t\tif(!(ch&gt;='0' &amp;&amp; ch&lt;= '9')) return false;\t\t}\t\treturn true;\t}\tpublic static void main(String[] args) throws IOException {//\t\tString str = \"123\";//\t\tSystem.out.println(str +\"는 숫자입니까?\" + isNumber(str));////\t\tString str2 = \"123o\";//\t\tSystem.out.println(str2 +\"는 숫자입니까?\" + isNumber(str2));\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString str = br.readLine();\t\tSystem.out.println(str +\"는 숫자입니까?\" + isNumber(str));\t\t\t}}[6-23] 배열에서 가장 큰 값을 구하는 메소드를 작성package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_23 {\t\tstatic int max(int arr[]) {\t\tif(arr == null || arr.length==0) return -999999;\t\t\t\tint max=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tif(arr[i]&gt;=max) {\t\t\t\tmax=arr[i];\t\t\t}\t\t}\t\treturn max;\t}\tpublic static void main(String[] args) {\t\tint data[] = {3,2,9,4,7};\t\t\t\tSystem.out.println(Arrays.toString(data));\t\tSystem.out.println(\"최대값 : \"+max(data));\t\tSystem.out.println(\"최대값 : \"+max(null));\t\tSystem.out.println(\"최대값 : \"+max(new int[] {})); //크기가 0인 배열\t}}[6-24] 절대값을 구하는 메소드를 정의package _2javajungsuktestEx6;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex6_24 {\t\tstatic int abs(int value) {\t\treturn Math.abs(value);\t}\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\twhile(true) {\t\t\tSystem.out.println(\"절대값을 구할 수를 입력하세요. 종료하려면 0를 입력하세요. \");\t\t\tint value = Integer.parseInt(br.readLine());\t\t\tif(value == 0) {\t\t\t\tSystem.out.println(\"프로그램을 종료합니다.\");\t\t\t\tbreak;\t\t\t}\t\tSystem.out.println(value +\"의 절대값 : \"+abs(value));\t\t\t\t}\t}}간단하게 계속 반복하도록 만들어봤음 0을 입력하면 종료되게했음"
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 2",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_2/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-06 00:00:00 +0900",
    





    
    "snippet": "[6-8] 다음 코드에 정의된 변수들을 종류별로 구분해서 적기class PlayingCard{\tint kind;\tint num;\tstatic int width;\tstatic int height;\tPlayingCard(int k, int n){\t\tkind = k;\t\tnum = n;\t}\tpublic static void main(String[] args)...",
    "content": "[6-8] 다음 코드에 정의된 변수들을 종류별로 구분해서 적기class PlayingCard{\tint kind;\tint num;\tstatic int width;\tstatic int height;\tPlayingCard(int k, int n){\t\tkind = k;\t\tnum = n;\t}\tpublic static void main(String[] args){\t\tPlayingCard card= new PlayingCard(1,1);}  클래스변수 (static변수) : width, height  인스턴스변수 : kind, num  지역변수: k, n, card[6-9] static이 붙어야하는 것과 그 이유는?(모든 병사의 공격력과 방어력은 같아야함)class Marine{\tint x=0, y=0; //위치\tint hp = 60; //체력\tint weapon = 6; //공격력\tint armor = 0; //방어력\tvoid weaponUp(){\t\tweapon++;\t}\tvoid armorUp(){\t\tweapon++;\t}\tvoid move(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}}weapon과 armor. 메소드 weaponUP()과 armorUp()도 static이 붙어야함인스턴스 변수는 객체 생성해서 값을 수정하면 원본 값은 변하지 않음. 모든 병사의 공격력이 같아야하는데 공격력과 방어력이 인스턴스변수라면 각 병사마다 다른 공격력과 방어력을 가지는 일이 발생할 수도 있음.그래서 모든 병사의 공격력과 방어력을 관리하기위해서는 static변수로 관리해줘야함.체력은 각 병사마다 공격받은정도가 다르니까, 위치는 당연히 병사별로 달라야함. → 인스턴스변수 사용[6-10] 다음 중 생성자에 대한 설명으로 옳지 않은 것을 모두 고르시오  모든 생성자의 이름은 클래스의 이름과 동일해야한다  생성자는 객체를 생성하기 위한 것이다 - 객체 초기화 목적임. 객체를 생성하는 건 new 연산자임  클래스에는 생성자가 반드시 하나 이상 있어야 한다  생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다  생성자는 오버로딩 할 수 없다 - 가능함.[6-11] 다음 중this에 대한 설명으로 맞지 않은 것을 모두 고르시오  객체 자신을 가리키는 참조변수이다  클래스 내에서라면 어디서든 사용할 수 있다 - static이 붙은 변수나 메소드(클래스 멤버)에서는 사용 불가  지역변수와 인스턴스변수를 구별할 때 사용한다  클래스 메서드 내에서는 사용할 수 없다[6-12] 다음 중 오버로딩이 성립하기 위한 조건이 아닌 것을 모두 고르시오  메서드의 이름이 같아야 한다  매개변수의 개수나 타입이 달라야 한다  리턴타입이 달라야 한다 - 상관 없음  매개변수의 이름이 달라야 한다 - 상관없음[6-13] add 메소드를 올바르게 오버로딩한것은?                               long add(int a, int b) {return a+b;}        long add(int x, int y} {return x+y}  long add(long a, long b) {return a+b;} - 이름 같고, 매개변수의 타입이 달라 가능  int add(byte a, byte b) {return a+b;} - 이름 같고, 매개변수의 타입이 달라 가능  int add(long a, int b) {return (int)a+b;} - 이름 같고, 매개변수의 타입이 달라 가능[6-14] 다음 중 초기화에 대한 설명으로 옳지 않은 것을 모두 고르시오  멤버 변수는 자동 초기화되므로 초기화하지 않고도 값을 참조할 수 있다  지역변수는 사용하기 전에 반드시 초기화해야 한다  초기화 블럭보다 생성자가 먼저 수행된다 - 초기화 블럭이 먼저 수행됨  명시적 초기화를 제일 우선적으로 고려해야 한다  클래스변수보다 인스턴스변수가 먼저 초기화된다 - 클래스 변수가 먼저 초기화됨클래스 변수는 클래스가 처음 메모리에 로딩될 때, 자동 초기화 됨. → 인스턴스변수보다 먼저 초기화 됨. 그리고 초기화 블럭이 수행된 다음 생성자가 수행됨.==[6-15] 다음중 인스턴스변수의 초기화 순서가 올바른 것은?  기본값 - 명시적초기화 - 초기화블럭 - 생성자  기본값 - 명시적초기화 - 생성자 - 초기화블럭  기본값 - 초기화블럭 - 명시적초기화 - 생성자  기본값 - 초기화블럭 - 생성자 - 명시적초기화클래스 변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화가 이루어진다.클래스 변수의 초기화 순서 : 기본값 → 명시적 초기화 → 클래스 초기화 블럭인스턴스 변수의 초기화 순서 : 시본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자[6-16] 다음 중 지역변수에 대한 설명으로 옳지 않은 것을 모두 고르시오  자동 초기화되므로 별도의 초기화가 필요없다 - 자동초기화 안됨. 초기화 필수  지역변수가 선언된 메서드가 종료되면 지역변수도 함께 소멸된다  매서드의 매개변수로 선언된 변수도 지역변수이다  클래스변수나 인스턴스변수보다 메모리 부담이 적다  힙(heap) 영역에 생성되며 가비지 컬렉터에 의해 소멸된다 - 힙(heap)은 인스턴스가 생성되는 영역. 지역변수는 호출스택(call stack)에서 생성됨.[6-17] 호출스택이 다음과 같은 상황일 때 옳지 않은 설명을 모두 고르시오                                              println              method1              method2              main        제일 먼저 호출스택에 저장된 것은 main 메서드이다  println메서드를 제외한 나머지 메서드들은 모두 종료된 상태이다 - 종료된건 아니고 대기중인 상태  method2메서드를 호출한 것은 main메서드이다  println메서드가 종료되면 method1메서드가 수행을 재개한다  main-method2-method1-println의 순서로 호출되었다  현재 실행중인 메소드는 println뿐이다.[6-18] 컴파일 에러가 발생하는 라인과 이유를 설명class MemberCall{\tint iv=10;\tstatic int cv = 20;\t\tint iv2=cv;\tstatic int cv2= iv;    //라인 A\tstatic void staticMethod1(){\t\tSystem.out.println(cv);\t\tSystem.out.println(iv); //라인 b\t}\tvoid instanceMethod1(){\t\tSystem.out.println(cv);\t\tSystem.out.println(iv); //라인 c\t}\tstatic void staticMethod2(){\t\tstaticMethod1():\t\tinstanceMethod1(); //라인 d\t}\tvoid instanceMethod2(){\t\tstaticMethod1(); //라인 e\t\tinstanceMethod1();\t}}라인 a,b,d 오류.static변수 초기화시에 instance변수를 사용할 수 없으며, static메소드 안에서는 instance변수를 사용할 수 없음.instance메소드 안에서는 static변수를 사용 가능함.[6-19] 실행결과 예상하기class ex{\tpublic static void change(String str){\t\tstr+=\"456\";\t}\tpublic static void main(String[] args){\t\tString str = \"ABC123\";\t\tchange(str);\t\tSystem.out.println(\"After change : \"+str);\t}}결과 : ABC123오른쪽 그림 참고. 참조형 매개변수라서 x값도 같이 변경될 것 같지만 String객체는 수정이 불가능함.그래서 change에서 str+=”456”을 하려면 새로운 String객체를 하나 더 생성해야 함. 생성된 change()의 str객체는 change()가 종료될 때 함께 종료됨. 최종적으로 남은 str은 main메소드의 ABC123뿐이라서 출력은 ABC123이됨. change메소드에서 생성된 String객체 “ABC123456”은 나중에 가비지컬렉터가 제거해줌"
  },
  
  {
    "title": "[권오흠 영리한 프로그래밍을 위한 알고리즘 강좌] Recursion의 응용 - n queens problem",
    "url": "/posts/Recursion%EC%9D%98-%EC%9D%91%EC%9A%A9-n-queens-problem/",
    "categories": "알고리즘",
    "tags": "알고리즘, 권오흠알고리즘강좌",
    "date": "2022-10-06 00:00:00 +0900",
    





    
    "snippet": "n queens problemBackTracking 기법(되추적 기법)을 사용하여 문제풀이.  상태공간트리 : 찾는 해를 포함하는 트리. 즉, 해가 존재한다면 그것은 반드시 이 트리의 어떤 한 노드에 해당한다. 따라서 이 트리를 체계적으로 탐색하면 해를 구할 수 있다(모든 노드를 탐색 할 필요 없음)  되추적기법 : 상태공간 트리를 깊이 우선 방식으로...",
    "content": "n queens problemBackTracking 기법(되추적 기법)을 사용하여 문제풀이.  상태공간트리 : 찾는 해를 포함하는 트리. 즉, 해가 존재한다면 그것은 반드시 이 트리의 어떤 한 노드에 해당한다. 따라서 이 트리를 체계적으로 탐색하면 해를 구할 수 있다(모든 노드를 탐색 할 필요 없음)  되추적기법 : 상태공간 트리를 깊이 우선 방식으로 탐색 해 해를 찾는 방법— Design Recursionreturn type queens(agments) {if non-promising report failure and return;else if success report answer and return;else visit children recursively;}→ int []clos = new int[n+1];boolean queens(int level){if (!promising(level)) report failure and return;else if(leve == n) report answer and return;else for(int i=1;i&lt;n;i++){cols[i]=i;if(queens(level+1) return true;}return false;}      Promising Test : 현재 level의 값이 4이면, 4개의 말이 이미 놓여져 있으며 놓여진 말들 간의 충돌이 없음이 보장 된 상태임. = 지금 놓을 말만 검사하면 됨    → boolean promising(int level){    for(int i=1;i&lt;level);i++){    if(cols[i] == cols[level]) return false;    else if on the same diagonal return false;}    return true;    }                            → if on the same diagonal return? level - i ==          cols[level] - cols[i]                    — 최종 코드package algorithm;public class queens {\tstatic int n=8;\tstatic int cols[] = new int[n+1]; //전역변수(함수의 외부에서 선언된 변수). cols[1]=2 는 (1,2)을 뜻함. \t\tstatic boolean queens(int level) {\t\tif(!promising(level)) return false; //꽝이면 밑까지 가볼필요없음\t\telse if(level==n) { //답일 경우\t\t\tfor(int i=1;i&lt;=n;i++) {\t\t\t\tSystem.out.println(\"(\"+i+\", \"+cols[i]+\")\");\t\t\t}\t\t\treturn true;\t\t}\t\t//꽝도아니고 답도 아니라면 그 밑까지 가보고 답인지 판단함.\t\tfor(int i=1;i&lt;=n;i++) {\t\t\tcols[level+1]=i; //level+1번 말을 1~n번째 칸 중 어디에 놓을 것인지 결정.\t\t\tif(queens(level+1)) return true;\t\t}\t\treturn false;\t}\t\tstatic boolean promising(int level) {\t\tfor(int i=1;i&lt;level;i++) {\t\t\tif(cols[i]==cols[level]) return false; //i행에 놓인 말과 level행에 놓인 말의 열이 같을 경우\t\t\telse if(level-i == Math.abs(cols[i]-cols[level])) return false; //i행에 놓은 말과 level행에 놓인 말이 같은 대각선상에 있을경우\t\t}\t\treturn true;\t}\tpublic static void main(String[] args) {\t\tqueens(0);\t}}"
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 1",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_1/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-05 00:00:00 +0900",
    





    
    "snippet": "[6-1~6-2] SutdaCard클래스를 정의하고 두개의 생성자와 info()를 추가package _2javajungsuktestEx6;class SutdaCard{\tint num=3 ;\tboolean isKwang=true;\t\tSutdaCard(){\t\tthis(1,true);\t}\t\tSutdaCard(int num, boolean isKwang){\t...",
    "content": "[6-1~6-2] SutdaCard클래스를 정의하고 두개의 생성자와 info()를 추가package _2javajungsuktestEx6;class SutdaCard{\tint num=3 ;\tboolean isKwang=true;\t\tSutdaCard(){\t\tthis(1,true);\t}\t\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tString info() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex6_1 {\t\tpublic static void main(String[] args) {\t\tSutdaCard card1 = new SutdaCard(3,false);\t\tSutdaCard card2 = new SutdaCard();\t\t\t\tSystem.out.println(card1.info());\t\tSystem.out.println(card2.info());\t}}[6-3~6-4] Student클래스를 정의해서 안에 메소드 getTotal()과 getAverage()를 추가해서 총점과 평균을 구하는 문제package _2javajungsuktestEx6;class Student{\tString name;\tint ban;\tint no;\tint kor;\tint eng;\tint math;\t\tint getTotal(){\t\treturn kor+eng+math;\t}\tfloat getAverage() {\t\treturn Math.round(getTotal()*10/ 3f)/10f;\t}}public class ex6_3 {\tpublic static void main(String[] args) {\t\tStudent s = new Student();\t\ts.name = \"홍길동\";\t\ts.ban=1;\t\ts.no=1;\t\ts.kor=100;\t\ts.eng=60;\t\ts.math=76;\t\t\t\tSystem.out.println(\"이름 : \"+s.name);\t\tSystem.out.println(\"총점 : \"+s.getTotal());\t\tSystem.out.println(\"평균 : \"+s.getAverage());\t}}[6-5] 6-3~6-4에 생성자와 info추가package _2javajungsuktestEx6;class Student{\tString name;\tint ban;\tint no;\tint kor;\tint eng;\tint math;\t\tint getTotal(){\t\treturn kor+eng+math;\t}\tfloat getAverage() {\t\treturn Math.round(getTotal()*10/ 3f)/10f;\t}\tStudent(){\t\t\t}\tStudent(String name, int ban, int no, int kor, int eng, int math){\t\tthis.name=name;\t\tthis.ban=ban;\t\tthis.no=no;\t\tthis.kor = kor;\t\tthis.eng=eng;\t\tthis.math=math;\t}\tvoid info(){\t\tSystem.out.println(name+\", \"+ban+\", \"+no+\", \"+kor+\", \"+eng+\", \"+math);\t}}public class ex6_3 {\tpublic static void main(String[] args) {\t\tStudent s = new Student();\t\ts.name = \"홍길동\";\t\ts.ban=1;\t\ts.no=1;\t\ts.kor=100;\t\ts.eng=60;\t\ts.math=76;\t\t\t\tSystem.out.println(\"이름 : \"+s.name);\t\tSystem.out.println(\"총점 : \"+s.getTotal());\t\tSystem.out.println(\"평균 : \"+s.getAverage());\t\tSystem.out.println();\t\tStudent s2 = new Student(\"김길동\",1,1,95,80,63);\t\ts2.info();\t\tSystem.out.println(\"이름 : \"+s2.name);\t\tSystem.out.println(\"총점 : \"+s2.getTotal());\t\tSystem.out.println(\"평균 : \"+s2.getAverage());\t\t\t}}[6-6] 메소드 getDisrance()로 두 점 사이 거리 계산package _2javajungsuktestEx6;public class ex6_6 {\tstatic double getDistance(int x, int y, int x1, int y1) {\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}\t\tpublic static void main(String[] args) {\t\tSystem.out.println(getDistance(1,1,2,2));\t}}[6-7] MyPoint 클래스에 getDistance()를 인스턴스 메소드로 정의package _2javajungsuktestEx6;class MyPoint{\tint x;\tint y;\t\tMyPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tdouble getDistance(int x1, int y1){\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}}public class ex6_6 {\tstatic double getDistance(int x, int y, int x1, int y1) {\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}\t\tpublic static void main(String[] args) {\t\tSystem.out.println(getDistance(1,1,2,2));\t\t\t\tMyPoint p = new MyPoint(1,1);\t\tSystem.out.println(p.getDistance(2, 2));\t}}"
  },
  
  {
    "title": "[권오흠 영리한 프로그래밍을 위한 알고리즘 강좌] Recursion의 응용  - counting cell in a blob",
    "url": "/posts/Recursion%EC%9D%98-%EC%9D%91%EC%9A%A9-counting-cell-in-a-blob/",
    "categories": "알고리즘",
    "tags": "알고리즘, 권오흠알고리즘강좌",
    "date": "2022-10-05 00:00:00 +0900",
    





    
    "snippet": "  binary이미지.  각 픽셀은 backgound pixel이거나 혹은image pixel  서로 연결된 image pixel들의 집합을 blob이라 부름.  상하좌우 및 대각선 방향으로도 연결된 것으로 간주함.→ 입력 : n*n크기의 그리드(grid), 하나의 좌표(x,y)출력 : 픽셀 (x,y)가 포함된 blob의 크기, (x,y)가 어떤 bl...",
    "content": "  binary이미지.  각 픽셀은 backgound pixel이거나 혹은image pixel  서로 연결된 image pixel들의 집합을 blob이라 부름.  상하좌우 및 대각선 방향으로도 연결된 것으로 간주함.→ 입력 : n*n크기의 그리드(grid), 하나의 좌표(x,y)출력 : 픽셀 (x,y)가 포함된 blob의 크기, (x,y)가 어떤 blob에도 포함되지않으면 0— Recursive Thinking현재 픽셀이 image color가 x → 0현재 픽셀이 image color → count++,중복 카운트를 막기 위해 다른색으로 변경, 현재 픽셀이 이웃한 모든 픽셀이 속한 blob의 크기를 카운트해 카운터에 더해줌.⇒ 카운터 반환—&gt; if the pixel (x,y) is outside the grid → result 0;else if pixel (x,y) is not an image pixel or already counted → result 0;else set the color of the pixel (x,y) to a red color;the result is 1 plus the number of cell in each piece of the blob that includes a nearest neighbour;import java.util.*;public class Main {\tprivate static int n=8;\tprivate static int[][] grid = {\t\t\t{1,0,0,0,0,0,0,1},\t\t\t{0,1,1,0,0,1,0,0},\t\t\t{1,1,0,0,1,0,1,0},\t\t\t{0,0,0,0,0,1,0,0},\t\t\t{0,1,0,1,0,1,0,0},\t\t\t{0,1,0,1,0,1,0,0},\t\t\t{1,0,0,0,1,0,0,1},\t\t\t{0,1,1,0,0,1,1,1}\t};\tprivate static final int BACKGROUND_COLOR=0; //backgound pixel\tprivate static final int IMAGE_COLOR=1; //image pixel\tprivate static final int ALREADY_COLOR=2; //이미 셀렸음\t\tpublic static int countcells (int x, int y) {\t\tint result;\t\tif(x&lt;0 || y&lt;0 || x&gt;=n || y&gt;=n) return 0;\t\telse if(grid[x][y]!=IMAGE_COLOR) return 0;\t\telse {\t\t\tgrid[x][y] = ALREADY_COLOR;\t\t\treturn 1 + countcells(x-1,y+1) + countcells(x,y+1)+countcells(x+1,y+1)\t\t\t+countcells(x-1,y)+countcells(x+1,y)\t\t\t+countcells(x-1,y-1)+countcells(x,y-1)+countcells(x+1,y-1);\t\t\t}\t\t}\tprivate static void printgrid() {\t\tfor(int x=0;x&lt;n;x++) {\t\t\tfor(int y=0;y&lt;n;y++) {\t\t\t\tSystem.out.print(grid[x][y]+\" \");\t\t\t}\t\t\tSystem.out.println();\t\t}\t}\tpublic static void main(String[] args) {\t\tprintgrid();\t\tSystem.out.println();\t\tSystem.out.println(\"blob : \"+countcells(5,3));\t\tSystem.out.println();\t\tprintgrid();\t}}"
  },
  
  {
    "title": "[권오흠 영리한 프로그래밍을 위한 알고리즘 강좌] Recursion의 응용 - Maze",
    "url": "/posts/Recursion%EC%9D%98-%EC%9D%91%EC%9A%A9-(Maze)/",
    "categories": "알고리즘",
    "tags": "알고리즘, 권오흠알고리즘강좌",
    "date": "2022-10-04 00:00:00 +0900",
    





    
    "snippet": "Maze - 미로찾기— Decision problem : 답이 yes or no현재 위치~출구까지의 경로?  현재 위치 = 출구  이웃 셀 중 하나에서라도 현재 위치를 지나지 않고 출구까지 갈 수 있는 경로가 있음— Recursive Thinking      boolean findPath(x,y)    if(x,y) is the exit return ...",
    "content": "Maze - 미로찾기— Decision problem : 답이 yes or no현재 위치~출구까지의 경로?  현재 위치 = 출구  이웃 셀 중 하나에서라도 현재 위치를 지나지 않고 출구까지 갈 수 있는 경로가 있음— Recursive Thinking      boolean findPath(x,y)    if(x,y) is the exit return true; (x,y)가 출구일경우 true    else for each neighbouring cell (x’, y’) of (x,y) do if(x’,y’) is on the pathway and not visited    인근의 셀 (x’,y’)가 경로가 없거나 이미 방문한 셀일경우    if findePath(x’,y’) return true;    return false;        boolean findPath(x,y)    if (x,y) is either on the wall or a visited cell return false;    else if(x,y) is the exit return true; (x,y)가 출구일경우 true    else mark (x,y) as a visited cell;    for each nieghbouring cell (x’, y’) of (x,y) do    if findePath(x’,y’) return true;    return false;  ⇒ 코드로import java.util.*;public class Main {\tprivate static int n=8;\tprivate static int[][] maze = {\t\t\t{0,0,0,0,0,0,0,1},\t\t\t{0,1,1,0,1,1,0,1},\t\t\t{0,0,0,1,0,0,0,1},\t\t\t{0,1,0,0,1,1,0,0},\t\t\t{0,1,1,1,0,0,1,1},\t\t\t{0,1,0,0,0,1,0,1},\t\t\t{0,0,0,1,0,0,0,1},\t\t\t{0,1,1,1,0,1,0,0}\t};\tprivate static final int PATHWAY_COLOR=0; //지나갈 수 있는 길\tprivate static final int WALL_COLOR=1; //벽. 못지나감\tprivate static final int BLOCKED_COLOR=2; //가봤는데 경로없음\tprivate static final int PATH_COLOR=3; //가보긴했는데 경로있는지없는지 확실x\t\tpublic static boolean findMazePath(int x, int y) {\t\tif(x&lt;0 || y&lt;0 || x&gt;=n || y&gt;=n) \t\t\treturn false;\t\telse if(maze[x][y]!=PATHWAY_COLOR) \t\t\treturn false; //maze[x][y]가 visited(green, red) or wall(blue)인 경우 flase반환\t\telse if(x==n-1 &amp;&amp; y==n-1) {\t\t\tmaze[x][y] = PATH_COLOR;\t\t\treturn true;\t\t}else {\t\t\tmaze[x][y] = PATH_COLOR;\t\t\tif(findMazePath(x-1,y) || findMazePath(x,y-1) \t\t\t|| findMazePath(x+1,y) || findMazePath(x,y+1))\t\t //인근셀에 경로가있을경우(true일경우) true반환\t\t\t\treturn true;\t\t\t\t\t\tmaze[x][y] = BLOCKED_COLOR; //인근셀에 경로가 없다면 red처리\t\t\treturn false;\t\t}\t}public static void printMaze() {\tfor(int i=0;i&lt;maze.length;i++) {\t\tfor(int j=0;j&lt;maze[i].length;j++) {\t\t\tSystem.out.print(maze[i][j]+ \" \");\t\t}\t\tSystem.out.println(\"\");\t}\tSystem.out.println(\"\");}\t\tpublic static void main(String[] args) {\t\tprintMaze();\t\tfindMazePath(0,0);\t\tprintMaze();\t}}"
  },
  
  {
    "title": "자바의 정석 연습문제 5장 - 배열",
    "url": "/posts/5%EC%9E%A5_%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 배열",
    "date": "2022-10-03 00:00:00 +0900",
    





    
    "snippet": "[5-1] 잘못된것을 고르시오a. int[] arr[];b. int[] arr = {1,2,3,};c. int[] arr = new int[5];d. int[] arr = new int[5]{1,2,3,4,5}; - new int[5]나 {1,2,3,4,5} 둘중 하나를 지워야 함.e. int arr[5]; 선언하면서 크기지정 불가f. int[] ar...",
    "content": "[5-1] 잘못된것을 고르시오a. int[] arr[];b. int[] arr = {1,2,3,};c. int[] arr = new int[5];d. int[] arr = new int[5]{1,2,3,4,5}; - new int[5]나 {1,2,3,4,5} 둘중 하나를 지워야 함.e. int arr[5]; 선언하면서 크기지정 불가f. int[] arr[] = new int[3][];[5-2] arr[3].length의 값은?int [][] arr = {\t\t\t\t\t\t{5,5,5,5,5},\t\t\t\t\t\t{10,10,10},\t\t\t\t\t\t{20,20,20,20},\t\t\t\t\t\t{30,30}};arr[3]은 {30,30}를 뜻함. arr[3]은 값이 2개니까 length는 2.순서대로 5,3,4,2순임[5-3] 배열 arr에 담긴 모든 값의 합을 구하는 문제package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class ex5_3 {\tpublic static void main(String[] args) throws IOException {//\t\tint arr[] = {10,20,30,40,50};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint n= Integer.parseInt(br.readLine());\t\tint arr[] = new int[n];\t\tfor(int i=0;i&lt;n;i++) {\t\t\tarr[i]=Integer.parseInt(br.readLine());\t\t}\t\tint sum = 0;\t\t\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tsum+=arr[i];\t\t}\t\t\t\tSystem.out.println(\"sum = \"+sum);\t}}int arr[]을 입력값 n을 받아 크기를 결정하고, arr[]의 크기만큼 값을 입력받아 배열 arr[]을 만드는 방식으로 수정해서 풀어보았음[5-4] 2차원 배열 arr의 모든 값의 합과 평균package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_4 {\tpublic static void main(String[] args) throws IOException {//\t\tint arr[][] = {//\t\t\t\t{5,5,5,5,5},//\t\t\t\t{10,10,10,10,10},//\t\t\t\t{20,20,20,20,20},//\t\t\t\t{30,30,30,30,30}//\t\t\t\t};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint n= Integer.parseInt(br.readLine());\t\tint n2 = Integer.parseInt(br.readLine());\t\tint arr[][] = new int[n][n2];\t\tfor(int i=0;i&lt;n;i++) {\t\t\tfor(int j=0;j&lt;n2;j++) {\t\t\t\tarr[i][j]+=Integer.parseInt(br.readLine());\t\t\t}\t\t}\t\tint total = 0;\t\tfloat average=0;\t\t\t\tint count=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tfor(int j=0;j&lt;arr[i].length;j++) {\t\t\t\ttotal += arr[i][j];\t\t\t\tcount++;\t\t\t\t}\t\t\taverage = (float)total / count;\t\t}\t\tSystem.out.println(\"total = \"+total);\t\tSystem.out.println(\"average = \"+average);\t}}average를 구할때 나눌 수를 구하기가 애매해서 count를 새로 지정해줬음답지보니까 arr.length * arr[0].length를 해줬구나.. arr[i]를 넣었다가 그럼 for문 안에 넣어야해서 count를 만든건데 0을하면 되는구나!이후에 BufferedReader를 사용해서 arr값도 새로 입력값을 받아서 계산도 해봤음[5-5] 중복되지 않는 3가지 숫자 뽑아내는 문제package _2javajungsuktestEx5;import java.util.Arrays;public class ex5_5 {\tpublic static void main(String[] args) {\t\tint ballArr[] = {1,2,3,4,5,6,7,8,9};\t\tint ball3[] = new int[3];\t\t\t\tfor(int x=0;x&lt;20;x++) {\t\t\tint i=(int)(Math.random()*ballArr.length);\t\t\tint j=(int)(Math.random()*ballArr.length);\t\t\tint tmp=0;\t\t\t\t\t\ttmp=ballArr[i];\t\t\tballArr[i]=ballArr[j];\t\t\tballArr[j]=tmp;\t\t}\t\t\t\tSystem.arraycopy(ballArr,0,ball3,0,3);\t\tfor(int i=0;i&lt;ball3.length;i++) {\t\t\tSystem.out.print(ball3[i]);\t\t}\t}}[5-6] 필요한 동전 수를 구하는 문제package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_6 {\tpublic static void main(String[] args) throws IOException {\t\tint coinUnit[]= {500,100,50,10};//\t\tint money=2680;\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint money = Integer.parseInt(br.readLine());\t\tSystem.out.println(\"money = \"+money);\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint count = money/coinUnit[i];\t\t\tmoney %= coinUnit[i];\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+count);\t\t\t\t\t}\t}}/와 %를 이용하여 구했음[5-7] 필요한 동전의 수와 남은 동전의 수를 구하는 문제. 돈이 부족하다면 부족하다고 출력됨package _2javajungsuktestEx5;public class ex5_7 {\tpublic static void main(String[] args) {\t\tif(args.length!=1) {\t\t\tSystem.out.println(\"USAGE : java Exercise5_7 3120\");\t\t\tSystem.exit(0);\t\t}\t\tint money = Integer.parseInt(args[0]);\t\tSystem.out.println(\"money = \"+money);\t\t\t\tint coinUnit[] = {500,100,50,10};\t\tint coin[] = {5,5,5,5};\t\t\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint coinNum = 0;\t\t\tcoinNum = money/coinUnit[i];\t\t\tmoney %= coinUnit[i];\t\t\tif(coinNum&gt;coin[i]) {\t\t\t\tmoney+= (coinNum-coin[i])*coinUnit[i];\t\t\t\tcoinNum = coin[i];\t\t\t}\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coinNum);\t\t\tcoin[i]-=coinNum;\t\t}\t\tif(money&gt;0) {\t\t\tSystem.out.println(\"거스름돈이 부족합니다.\");\t\t\tSystem.exit(0);\t\t}\t\tSystem.out.println(\"=====남은 동전 개수=====\");\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coin[i]);\t\t}\t}}5-6과 비슷하게 했는데 만약 필요한 코인수가 소유 코인수보다 많다면 if문을 사용해서 money를 부족한 코인수만큼 채워주고 coinNum을 coin[i]로 맞춰주었음  답지package _2javajungsuktestEx5;public class ex5_7 {\tpublic static void main(String[] args) {\t\tif(args.length!=1) {\t\t\tSystem.out.println(\"USAGE : java Exercise5_7 3120\");\t\t\tSystem.exit(0);\t\t}\t\tint money = Integer.parseInt(args[0]);\t\tSystem.out.println(\"money = \"+money);\t\t\t\tint coinUnit[] = {500,100,50,10};\t\tint coin[] = {5,5,5,5};\t\t\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint coinNum =0;\t\t\tcoinNum = money/coinUnit[i];\t\t\tif(coin[i]&gt;=coinNum) {\t\t\t\tcoin[i]-=coinNum;\t\t\t}else {\t\t\t\tcoinNum = coin[i];\t\t\t\tcoin[i]=0;\t\t\t}\t\t\tmoney -= coinNum*coinNum;\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coinNum);\t\t}\t\tif(money&gt;0) {\t\t\tSystem.out.println(\"거스름돈이 부족합니다.\");\t\t\tSystem.exit(0);\t\t}\t\tSystem.out.println(\"=====남은 동전 개수=====\");\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coin[i]);\t\t}\t}}난 money를 먼저 구한 후에 돈이 부족하면 모자란 돈만큼 money를 수정해주고 coinNum을 보유동전수만큼 맞춰주었는데 답지의 코드는 coinNum을 먼저 맞춰주고 money를 구해줬구나이게 더 효율적이기는 한듯[5-8] 배열 answer에서 각 숫자의 개수를 세어 개수만큼 * 을 출력package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_8 {\tpublic static void main(String[] args) throws IOException {//\t\tint answer[] = {1,4,4,3,1,4,4,2,1,3,2};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint answer[] = new int[11];\t\tString str[] = br.readLine().split(\" \");\t\tfor(int i=0;i&lt;str.length;i++) {\t\t\tanswer[i] = Integer.parseInt(str[i]);\t\t}\t\tint counter[] = new int[4];\t\t\t\tfor(int i=0;i&lt;answer.length;i++) {\t\t\tint arr[] = {1,2,3,4};\t\t\tfor(int j=0;j&lt;arr.length;j++) {\t\t\t\tif(answer[i]==arr[j])\t\t\t\t\tcounter[arr[j]-1]+=1;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;counter.length;i++) {\t\t\tSystem.out.print(counter[i]);\t\t\tfor(int j=0;j&lt;counter[i];j++) {\t\t\t\tSystem.out.print(\"*\");\t\t\t}\t\t\t\t\t\tSystem.out.println();\t\t}\t}}생각해보니까 BufferedReader로 String형 배열을 입력받는 법은 알고 String을 int로 변환하는 법도 아는데 int형 배열을 입력받는법을 몰라서 한번 써봤음String형 배열을 먼저 받은 다음에 for문을 써서 int형 배열에 넣는 방법밖에 없는거같다.  답지package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_8 {\tpublic static void main(String[] args) throws IOException {//\t\tint answer[] = {1,4,4,3,1,4,4,2,1,3,2};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint answer[] = new int[11];\t\tString str[] = br.readLine().split(\" \");\t\tfor(int i=0;i&lt;str.length;i++) {\t\t\tanswer[i] = Integer.parseInt(str[i]);\t\t}\t\tint counter[] = new int[4];\t\t\t\tfor(int i=0;i&lt;answer.length;i++) {\t\t\tcounter[answer[i]-1]++;\t\t}\t\tfor(int i=0;i&lt;counter.length;i++) {\t\t\tSystem.out.print(counter[i]);\t\t\tfor(int j=0;j&lt;counter[i];j++) {\t\t\t\tSystem.out.print(\"*\");\t\t\t}\t\t\t\t\t\tSystem.out.println();\t\t}\t}}counter[answer[i]-1] 를 생각못해서 배열하나 더 만들었네..[5-9] 배열을 시계방향으로 90도 회전원본 배열이**  **  ***** ***** 인데 이걸****  ****  **  **  ** 이렇게 바꾸면됨  자리값으로 찍어보면00 0110 1120 21 22 23 2430 31 32 33 34 이걸30 20 10 0031 21 11 0132 2233 2334 24 이렇게 다.표현은 안해줬지만 공백값도 있어서 02 03 04도 다 있는 상태임.00→30, 01→20, 02→10, 03→0010→31, 11→21 .. 뭐 이런식. star의 x값과 result의 y값이 같은 상태라 x값만 구하면됨  1차시도(실패)package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tresult[j][i]=star[star.length-1][i];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}뭔가 잘못됐다.result[5][4]고 star[4][5]니까.. 아 star에 y값을 j로 해야하는구나 j가 범위를 5까지 잡아놨으니까star에 x값은 어떻게 하지? 지금 문제에 적힌 코드대로 하다보니까 x를 값을 먼저 바꿔가면서 구한다음에 y값을 바꾸면서 구하는게 돼버려서 좀 햇갈린다;;그니까 지금 x값이0→3 0→2 0→1 0→01→3 1→2 1→1 1→0+3 +2 +1 0+2 +1 0 -1이꼴인데.. 지금 y값이 고정인채로 x값이 바뀌는 상태니까0→3 1→3 2→3 3→30→2 1→2 2→2 3→20→1 1→1 2→1 3→1 이렇게 되는거잖아.. star.length가 4니까 -1에서 y값을 추가로 빼주면 되는거 아닌가?  2차시도(성공)package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tresult[j][i]=star[star.length-1-i][j];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}됐당!!package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star[0].length;i++) {\t\t\tfor(int j=0;j&lt;star.length;j++) {\t\t\t\tresult[i][j] = star[star.length-1-j][i];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}for문 순서때문에 약간 헷갈려서 순서바꿔서 한번 해봤당[5-10] 문자열 암호화package _2javajungsuktestEx5;public class ex5_10 {\tpublic static void main(String[] args) {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse result+=abcCode[ch-'a'];\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_10 {\tpublic static void main(String[] args) throws IOException {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString scr = br.readLine();//\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse if(ch&gt;='a' &amp;&amp; ch&lt;='z')\t\t\t\tresult+=abcCode[ch-'a'];\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}위 코드대로 했다가 BufferedReader를 통해 입력받았을때 대문자가 들어오니까 에러가 나길래 else if를 추가해줬음. 대문자가 들어오니까 공백으로 처리하고 남은것만 암호화하더라package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_10 {\tpublic static void main(String[] args) throws IOException {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString scr = br.readLine();//\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse if(ch&gt;='a' &amp;&amp; ch&lt;='z')\t\t\t\tresult+=abcCode[ch-'a'];\t\t\telse {\t\t\t\tSystem.out.println(\"입력값이 잘못됐습니다.\");\t\t\t\tSystem.exit(0);\t\t\t}\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}지정된 문자 말고 다른게 들어오면 경고문구띄우면서 종료되게 바꿔봄[5-11] 2차원 배열 score보다 가로, 세로로 한칸씩 더 큰 배열을 반들어 마지막에 각 열과 행의 합을 구하는 문제  1차시도 (실패)package _2javajungsuktestEx5;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tint sum=0;\t\t\tint sum2=0;\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tsum+=score[i][j];\t\t\t\tsum2+=score[i][j];\t\t\t\tresult[i][score[i].length] = sum;\t\t\t\tresult[score.length][j]=sum2;\t\t\t\tresult[score.length][score[i].length] += sum;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}일단 저 sum을 쓴거자체가 잘못된듯. 아니면 sum2를 for문 안으로 넣어서 계속 초기화를 시켜줘서 result[score].length +=sum2를 하거나.. 5,3값에도 +=sum2를 하면 될거같기는 한데 일단 아래처럼 수정해봄  2차시도(개선필요)package _2javajungsuktestEx5;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tint sum=0;\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tint sum2=0;\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tsum+=score[i][j];\t\t\t\tsum2+=score[i][j];\t\t\t\tresult[i][score[i].length] = sum;\t\t\t\tresult[score.length][j]+=sum2;\t\t\t\tresult[score.length][score[i].length] += sum2;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}이렇게 할거면 너무 비효율적이라서 굳이 sum, sum2를 고집할 필요가 없을듯..  3차시도 - 성공(sum,sum2 안씀)package _2javajungsuktestEx5;import java.util.Arrays;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tresult[i][score[i].length] += result[i][j];\t\t\t\tresult[score.length][j]+=result[i][j];\t\t\t\tresult[score.length][score[i].length] += result[i][j];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}더 쉽게하려고 변수 sum을 선언해줬는데 더 어렵게돼서 당황스럽다😭너무 꼬아서 생각하지말고 단순하게 생각도 해봐야겠음"
  },
  
  {
    "title": "자바의 정석 연습문제 4장 - 조건문, 반복문",
    "url": "/posts/4%EC%9E%A5_%EC%A1%B0%EA%B1%B4%EB%AC%B8_%EB%B0%98%EB%B3%B5%EB%AC%B8/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 조건문, 반복문",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "[4-1] 다음의 문장들을 조건식으로 표현하라.package _2javajungsuktestEx4;public class ex4_1 {\tpublic static void main(String[] args) {//\t\t1. int형 변수 x가 10보다 크고 20 보다 작을 때 true인 조건식\t\tint x=10;\t\tSystem.out.println(x&g...",
    "content": "[4-1] 다음의 문장들을 조건식으로 표현하라.package _2javajungsuktestEx4;public class ex4_1 {\tpublic static void main(String[] args) {//\t\t1. int형 변수 x가 10보다 크고 20 보다 작을 때 true인 조건식\t\tint x=10;\t\tSystem.out.println(x&gt;=10 &amp;&amp; x&lt;=20);//\t\t2. char형 변수 ch가 공백이나 탭이 아닐 때 true인 조건식\t\tchar ch = 'a';\t\tSystem.out.println(!(ch==' ' || ch=='\\t'));//\t\t3. char형 변수 ch가 ‘x'또는 ’X' 일 때 true인 조건식\t\tchar ch2 = 'x';\t\tSystem.out.println(ch2 =='x' || ch2 =='X');//\t\t4. char형 변수 ch가 숫자(‘0’~‘9’)일 때 true인 조건식\t\tchar ch3 = '9';\t\tSystem.out.println(ch3 &gt;='0' &amp;&amp; ch3 &lt;='9');//\t\t5. char형 변수 ch가 영문자(대문자 또는 소문자) 일 때 true인 조건식\t\tchar ch4= 'a';\t\tSystem.out.println((ch4&gt;='A' &amp;&amp; ch4&lt;='Z') || (ch4&gt;='a' &amp;&amp; ch4&lt;='z'));//\t\t6. int형 변수 year가 400으로 나눠떨어지거나 또는 4로 나눠떨어지고 100으로 나눠떨어지지않을 때 true인 조건식\t\tint year = 124;\t\tSystem.out.println(year%400==0 ||year%4==0 &amp;&amp; year%100!=0);//\t\t7. boolean형 변수가 powerOn false 일 때 true인 조건식\t\tboolean powerOn = false;\t\tSystem.out.println(!powerOn);//\t\t8. 문자열 참조변수 str이 “yes” 일 때 true인 조건식\t\tString str = \"yes\";\t\tSystem.out.println(str.equals(\"yes\"));\t\t\t}}[4-2] 1~20중 2또는 3의 배수가 아닌 수의 합package _2javajungsuktestEx4;public class ex4_2 {\tpublic static void main(String[] args) {\t\tint sum=0;\t\tfor(int i=1;i&lt;=20;i++) {\t\t\tif(!(i%2==0 || i%3==0))\t\t\t\tsum+=i;\t\t}\t\tSystem.out.println(sum);\t\tsum=0;    for(int i=1;i&lt;=20;i++){      if(i%2==0 || i%3==0) continue;      sum+=i;      }      System.out.println(sum);\t}}[4-3] 1+(1+2)+(1+2+3)+…(1+2+3+4+…+10)은?package _2javajungsuktestEx4;public class ex4_3 {\tpublic static void main(String[] args) {\t\tint sum=0;\t\tint result=0;\t\tfor(int i=1;i&lt;=10;i++) {\t\t\tsum+=i;\t\t\tresult+=sum;\t\t}\t\tSystem.out.println(result);\t}}답:220[4-4] 1+-2+3+-4+5+-6…일때 합이 100이상이 되려면 몇번 더해야하는가?package _2javajungsuktestEx4;public class ex4_4 {\tpublic static void main(String[] args) {\t\tint sum = 0;\t\tfor(int i=0;true;i++) {\t\t\tif(i%2==0) sum-=i;\t\t\telse sum+=i;\t\t\t\t\t\tif(sum&gt;=100) {\t\t\t\tSystem.out.println(i);\t\t\t\tbreak;\t\t\t}\t\t}\t}}음수값이 2의 배수이길래 if문을 써서 2의 배수면 -i를 하게 만들었음package _2javajungsuktestEx4;public class ex4_4 {\tpublic static void main(String[] args) {\t\tint sum=0,n=1;\t\tfor(int i=1;true;i++,n*=-1) {\t\t\tsum += i*n;\t\t\tif(sum&gt;=100) {\t\t\t\tSystem.out.println(i);\t\t\t\tbreak;\t\t\t}\t\t}\t}}이번엔 n값을 추가해서 n*=-1로 sum을 i값을 양수와 음수를 번갈아가게 나타나게 만들어봤음public class jungsukEx4_2 {    public static void main(String[] args) {        int sum=0;        int count = 0;        for(int i=1;true;i++){            if(i%2==0) i*=-1;            sum+=i;\t\t        count++;            if(sum&gt;=100) break;            i=Math.abs(i);        }        System.out.println(count);    }}i값을 마지막에 절대값처리해서 초기화도 시켜줘봄public class jungsukEx4_2 {    public static void main(String[] args) { \t\t\t\tsum=0;        int count = 0;        for(int i=1;true;i++){            if(i%2==0) i*=-1;            sum+=i;            if(sum&gt;=100) break;            count++;            i=Math.abs(i);        }\t}}while문 사용  답지 코드```javapackage _2javajungsuktestEx4;public class ex4_4 {public static void main(String[] args) {\tint sum=0,n=1,num=0;\tfor(int i=1;true;i++,n=-n) {\t\tnum=n*i;\t\tsum+=num;\t\tif(sum&gt;=100) break;\t}\tSystem.out.println(num);}}---### [4-5]```javapackage _2javajungsuktestEx4;public class ex4_5 {\tpublic static void main(String[] args) {\t\tfor(int i=0; i&lt;=10; i++) {\t\t\tfor(int j=0; j&lt;=i; j++)\t\t\tSystem.out.print(\"*\");\t\t\tSystem.out.println();\t\t}\t}}위 별찍기 for문을 while문으로 변환package _2javajungsuktestEx4;public class ex4_5 {\tpublic static void main(String[] args) {\t\tint i=0;\t\twhile(i&lt;=10) {\t\t\tint j=0;\t\t\twhile(j&lt;=i) {\t\t\t\tSystem.out.print(\"*\");\t\t\t\tj++;\t\t\t}\t\t\tSystem.out.println();\t\t\ti++;\t\t}\t\t\t}}처음에 int i와 j를 같이 선언해줬다가 이상하게 나와서 뭐지?했는데 while문안에 int j=0을 넣어서 매번 값을 초기화해줘야하는 걸 잊었다;; 일단 해결[4-6] 주사위 두개를 굴려 두 수의 합이 6이 나오는 모든 경우의 수package _2javajungsuktestEx4;public class ex4_6 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=6;i++) {\t\t\tfor(int j=1;j&lt;=6;j++) {\t\t\t\tif(i+j==6) System.out.println(i+\" + \"+j+\" = \"+(i+j));\t\t\t}\t\t}\t}}답 :1 + 5 = 62 + 4 = 63 + 3 = 64 + 2 = 65 + 1 = 6[4-7] value에 1~6까지의 랜덤 값을 Math.random()을 이용하여 받는 문제package _2javajungsuktestEx4;public class ex4_7 {\tpublic static void main(String[] args) {\t\tint value = (int) ((Math.random()*6))+1;\t\tSystem.out.println(value);\t}}Math.random()은 double형 결과값을 출력해서 소수점 까지 다 나오니까 원하는 값을 얻으려면 int형으로 변환해주어야함. 1.xxx값에 6을 곱한 후 int형으로 변환해 소수점을 버리면 0~5값이 나오기 때문에 +1까지 해주어야 한다.[4-8] 2x +4y =10인 모든 경우의 수 출력package _2javajungsuktestEx4;public class ex4_8 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;=10;i++) {\t\t\tfor(int j=0;j&lt;=10;j++) {\t\t\t\tif(i*2+4*j==10) System.out.println(\"x = \"+i+\", y = \"+j);\t\t\t}\t\t}\t}}[4-9] 문자열 str의 각 자리수의 합을 구하는 문제package _2javajungsuktestEx4;public class ex4_9 {\tpublic static void main(String[] args) {\t\tString str = \"12345\";\t\tint sum=0;\t\t\t\tfor(int i=0;i&lt;str.length();i++) {\t\t\tsum+= str.charAt(i)-'0';\t\t}\t\tSystem.out.println(\"sum=\"+sum);\t}}[4-10] 숫자 num의 각 자리수의 합을 구하는 문제package _2javajungsuktestEx4;public class ex4_10 {\tpublic static void main(String[] args) {\t\tint num=12345;\t\tint sum=0;\t\t\t\twhile(num&gt;0) {\t\t\tsum+=num%10;\t\t\tnum/=10;\t\t}\t\t\t\tSystem.out.println(\"sum=\"+sum);\t}}처음에 당당하게 num.length()쓰다가 자동완성이 안떠서 length()가 String클래스의 메소드인걸 생각해냄ㅋㅋ…그래서 for문을 쓰기엔 i값 범위 지정하기가 애매해서 그냥 while문을 사용하기로 결정함[4-11] 피보나치수열, 맨 앞 두 수가 1,1일때 10번째 값을 구하는 문제package _2javajungsuktestEx4;public class ex4_11 {\tpublic static void main(String[] args) {\t\tint num1= 1;\t\tint num2=1;\t\tint num3=0;\t\tSystem.out.print(num1+\",\"+num2);\t\tfor(int i=0;i&lt;8;i++) {\t\t\tnum3=num1+num2;\t\t\tSystem.out.print(\",\"+num3);\t\t\tnum1=num2;\t\t\tnum2=num3;\t\t}\t}}[4-12] 구구단 출력 문제이 형태임package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=2;i&lt;=9;i++) {\t\t\tfor(int j=1;j&lt;=3;j++) {\t\t\t\tSystem.out.println(i+\" * \"+j+\" = \"+i*j);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}모양이 복잡해 보여서 일단 찍어봄.2 * 1 = 22 * 2 = 42 * 3 = 63 * 1 = 33 * 2 = 63 * 3 = 94 * 1 = 44 * 2 = 84 * 3 = 125 * 1 = 55 * 2 = 105 * 3 = 156 * 1 = 66 * 2 = 126 * 3 = 187 * 1 = 77 * 2 = 147 * 3 = 218 * 1 = 88 * 2 = 168 * 3 = 249 * 1 = 99 * 2 = 189 * 3 = 27첫번째 for문의 System.out.println()을 print(”\\t”)으로 바꿔보면 진전이있을거같아서 해봤는데 3 * 1=3 4 * 1=4같이 첫 시작만 탭이 먹힘. 생각을 잘못한거같은게.. 저렇게 출력이되려면 맨 첫줄만 생각했을때 i값은 2~4가 계속 반복되고 j값은 1~3이 계속 반복됨. 일단 2~4단만 먼저 찍어보는게 나을것같음package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=3;i++) {\t\t\tfor(int j=2;j&lt;=4;j++) {\t\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\t\tSystem.out.print(\"\\t\");\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}추가로 i와 j값의 위치를 바꿔줌2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 12으로 2~4단은 잘 출력됨. 이제 다음걸 출력하려면.. j%3 == 2일때 println을 사용해본다면?package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=3;i++) {\t\t\tfor(int j=2;j&lt;=9;j++) {\t\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\t\tSystem.out.println();\t\t\t\t}\t\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\t\tSystem.out.print(\"\\t\");\t\t\t}\t\t}\t}}출력: 2 * 1 = 2 3 * 1 = 3 4 * 1 = 45 * 1 = 5 6 * 1 = 6 7 * 1 = 78 * 1 = 8 9 * 1 = 9 2 * 2 = 4 3 * 2 = 6 4 * 2 = 85 * 2 = 10 6 * 2 = 12 7 * 2 = 148 * 2 = 16 9 * 2 = 18 2 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 3 = 24 9 * 3 = 27예 이꼴났어요곱하는 수도 1~3이 계속 반복되어야하고 단도 3번은 반복되어야하는데.. if문안에 j-3값을 넣어봐야겠음..package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1,j=2;i&lt;=3&amp;&amp;j&lt;=9;j++) {\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\tSystem.out.println();\t\t\t\tj-=3;\t\t\t\ti++;\t\t\t\tif(i&gt;3) {\t\t\t\t\tSystem.out.println();\t\t\t\t\ti-=3;\t\t\t\t\tj+=3;\t\t\t\t}\t\t\t}\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\tSystem.out.print(\"\\t\");\t\t}\t}}출력2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 9좀만 더하면 될거같은데ㅜpackage _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1,j=2;i&lt;=3&amp;&amp;j&lt;=11;j++) {\t\t\tif(j==10&amp;&amp;i==3) break;\t\t\tif(j%10==0 &amp;&amp; i&lt;=3) continue;\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\tSystem.out.println();\t\t\t\tj-=3;\t\t\t\ti++;\t\t\t\tif(i&gt;3) {\t\t\t\t\tSystem.out.println();\t\t\t\t\ti-=3;\t\t\t\t\tj+=3;\t\t\t\t}\t\t\t}\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\tSystem.out.print(\"\\t\");\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 9 10 * 1 = 108 * 2 = 16 9 * 2 = 18 10 * 2 = 208 * 3 = 24 9 * 3 = 27일단 되긴 됐는데 이게 좋은 코드같지가않다…..ㅋㅋ내일 좀 더 생각해봐야겠음..for문을 한번 더 써보는게 나을 듯..package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;3;i++) {\t\t\tfor(int y=1;y&lt;=3;y++) {\t\t\t\tfor(int x=2;x&lt;=9;x++) {\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y);\t\t\t\t\tSystem.out.print(\"\\t\");\t\t\t\t\t}\t\t\t\tSystem.out.println();\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 272 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 272 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 27음…일단 x값을 ≤4로 해봐야겠음x값을 x≤4로한 다음에 i값이랑 x값이랑 같게해서 i를 +3씩 한다면.. 괜찮지않을까?package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=2;i&lt;9;i+=3) {\t\t\tfor(int y=1;y&lt;=3;y++) {\t\t\t\tfor(int x=i;x&lt;=i+2&amp;&amp;x&lt;=9;x++) {\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y);\t\t\t\t\tSystem.out.print(\"\\t\");\t\t\t\t\t}\t\t\t\tSystem.out.println();\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 98 * 2 = 16 9 * 2 = 188 * 3 = 24 9 * 3 = 27됐다!!!!!!!!!!!!!!!!!!!!!!!!11  답지\tpackage _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=9;i++) {\t\t\tfor(int j=1;j&lt;=3;j++) {\t\t\t//i가 3이상이 되면 x에 i-1값을 더해서 반복되는 단을 변경해줌(2~4-&gt;5~7-&gt;8~9)\t\t\t\tint x=j+1+ (i-1)/3*3;\t\t\t\tint y=i%3==0?3:i%3;  \t\t\t\t\t\t\t\tif(x&gt;9) break;\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y+\"\\t\");\t\t\t}\t\t\tSystem.out.println();\t\t\tif(i%3==0) System.out.println();\t\t}\t}}음.. 근데 int x구하는 식에서 굳이 +1을 해줘야 하나? for문쓸때 2~4로 해주면 되는거 아닌감..코드 이해는 했는데..ㅜㅜ어렵구만  for문을 한번만 쓰라는 조건이 없어서 for문을 3번적는 방법도 있다    public class Gugu {  public static void main(String[] args) {      for(int i=1;i&lt;=3;i++){          for(int j=2;j&lt;=4;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }      System.out.println();      for(int i=1;i&lt;=3;i++){          for(int j=5;j&lt;=7;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }      System.out.println();      for(int i=1;i&lt;=3;i++){          for(int j=8;j&lt;=9;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }  }}      [4-13] 문자열이 숫자로만 이루어졌는지 판단하는 문제package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_13 {\tpublic static void main(String[] args) throws IOException{\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString value = br.readLine();\t\tchar ch = ' ';\t\tboolean isNumber = true;\t\t\t\tfor(int i=0;i&lt;value.length();i++) {\t\t\tch=value.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') {\t\t\t\tisNumber=true;\t\t\t\t}\t\t\telse {\t\t\t\tisNumber = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif(isNumber) System.out.println(value+\"는 숫자입니다\");\t\telse System.out.println(value+\"는 숫자가 아닙니다.\");\t}}문자열은 BufferedReader를 통해 입력받아보았다.[4-14] 숫자맞추기 문제package _2javajungsuktestEx4;import java.util.Scanner;public class ex4_14 {\tpublic static void main(String[] args) {\t\tint answer = (int)(Math.random()*100)+1;\t\tint input=0;\t\tint count=0;\t\t\t\tScanner s = new Scanner(System.in);\t\t\t\tdo {\t\t\tcount++;\t\t\tSystem.out.println(\"1~100사이의 값을 입력하세요 : \");\t\t\tinput= s.nextInt();\t\t\t\t\t\tif(input&gt;answer) System.out.println(\"더 작은 수를 입력하세요.\");\t\t\telse if(input&lt;answer) System.out.println(\"더 큰 수를 입략하세요.\");\t\t\telse {\t\t\t\tSystem.out.println(\"정답입니다. 시도횟수는 \"+count+\"번 입니다.\");\t\t\t\tbreak;\t\t\t}\t\t}while(true);\t}}package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_14 {\tpublic static void main(String[] args) throws IOException {\t\tint answer = (int)(Math.random()*100)+1;\t\tint input=0;\t\tint count=0;\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\t\t\tdo {\t\t\tcount++;\t\t\tSystem.out.println(\"1~100사이의 값을 입력하세요 : \");\t\t\tinput= Integer.parseInt(br.readLine());\t\t\t\t\t\tif(input&gt;answer) System.out.println(\"더 작은 수를 입력하세요.\");\t\t\telse if(input&lt;answer) System.out.println(\"더 큰 수를 입략하세요.\");\t\t\telse {\t\t\t\tSystem.out.println(\"정답입니다. 시도횟수는 \"+count+\"번 입니다.\");\t\t\t\tbreak;\t\t\t}\t\t}while(true);\t}}Scanner대신 BufferedReader를 사용했다.import java.util.Scanner;public class UpAndDown {    public static void main(String[] args) {        int answer = (int)(Math.random()*100)+1 ;        int input = 0; // 사용자입력을 저장할 공간        int count = 0; // 시도횟수를 세기위한 변수        // Scanner 화면으로 부터 사용자입력을 받기 위해서 클래스 사용        Scanner s = new Scanner(System.in);        while (true) {            count++;            System.out.print(\"1과 100사이의 값을 입력하세요 :\");            input = s.nextInt(); // input . 입력받은 값을 변수 에 저장한다            if(input &lt; answer) System.out.println(\"입력한 값이 정답보다 큽니다.\");            else if(input &gt; answer) System.out.println(\"입력한 값이 정답보다 작습니다.\");            else {                 System.out.println(\"정답입니다.\");                System.out.println(\"시도횟수는 \"+count+\"번 입니다.\");                break;            }        }    }}그냥 while문 사용함[4-15] 회문수(앞뒤가 같은 수)를 구하는 문제package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_15 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint number = Integer.parseInt(br.readLine());\t\tint tmp=number;\t\t\t\tint result =0;\t\t\t\twhile(tmp!=0) {\t\t\tresult = tmp%10+result*10;\t\t\ttmp/=10;\t\t}\t\tif(number == result) System.out.println(number+\"는 회문수입니다.\");\t\telse System.out.println(number+\"는 회문수가 아닙니다.\");\t}}이것도 입력값 받는 문제로 바꿔서 풀었다"
  },
  
  {
    "title": "자바의 정석 연습문제 3장 - 연산자",
    "url": "/posts/3%EC%9E%A5_%EC%97%B0%EC%82%B0%EC%9E%90/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 연산자",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "3-1 출력값을 적어라class Exercise3_1 {public static void main(String[] args) {int x = 2;int y = 5;char c = 'A'; // 'A' 65 의 문자코드는System.out.println(1 + x &lt;&lt; 33);System.out.println(y &gt;= 5 || x &lt...",
    "content": "3-1 출력값을 적어라class Exercise3_1 {public static void main(String[] args) {int x = 2;int y = 5;char c = 'A'; // 'A' 65 의 문자코드는System.out.println(1 + x &lt;&lt; 33);System.out.println(y &gt;= 5 || x &lt; 0 &amp;&amp; x &gt; 2);System.out.println(y += 10 - x++);System.out.println(x+=2);System.out.println( !('A' &lt;= c &amp;&amp; c &lt;='Z') );System.out.println('C'-c);System.out.println('5'-'0');System.out.println(c+1);System.out.println(++c);System.out.println(c++);System.out.println(c);순서대로6true135false2566BBC이 출력됨.      System.out.println(1 + x &lt;&lt; 33);  +가 우선순위라 1+x부터 계산됨. 33은 int라서 int는 32bit니까 1만 계산하면 됨. 최종적으로 3«1        « : 비트이동 연산자. 왼쪽으로 이동 ⇒ 3을 왼쪽으로 1 이동  3«1 = 3*2 =6        System.out.println(y &gt;= 5 || x &lt; 0 &amp;&amp; x &gt; 2); | |보다 &amp;&amp;이 우선순위가 높음. 그럼 x&lt;0 &amp;&amp; x&gt;2는 false&amp;&amp;false임. y≥5는 true니까 최종 코드가 true | | false 로 true가 반환됨.        System.out.println(y += 10 - x++);  y=y+(10-x);    x++은 계산 후 1을 더해줌. 그럼 5+8로 13        System.out.println(x+=2);    위 식에서 x=3이됨. 5출력        System.out.println( !('A' &lt;= c &amp;&amp; c &lt;='Z') );    c가 A보다 크고 Z보다 작지 않을때 = c가 대문자가 아니면 true. c는 ‘A’니까 false        System.out.println('C'-c);    ‘C’ - ‘A’. C=67, A=65  2출력        System.out.println('5'-'0');    ‘5’-’0’ 53-48=5  5출력        System.out.println(c+1);    65(’A’) + 1 = ‘B’  c값의 변동은 없음        System.out.println(++c);    ++c는 먼저 값을 바꾸고 출력됨  B출력. c의 값이 B로 바뀜        System.out.println(c++);    c++은 출력 후 값이 바뀜. c=’B’니까 B 출력  출력후 c=’C’로 값 변동        System.out.println(c);  c=’C’니까 C출력  3-2 사과 박스의 \b갯수는?package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_2 {\tpublic static void main(String[] args) throws IOException {//\t\tint numOfApples = 123;\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint numOfApples = Integer.parseInt(br.readLine());\t\tint sizeOfBucket = 10;\t\tint numOfBucket = numOfApples/sizeOfBucket + (numOfApples%sizeOfBucket&gt;0?1:0);\t\tSystem.out.println(\"필요한 바구니의 수 : \"+numOfBucket);\t}}예제랑 다르게 bufferedReader를 사용해 입력값을 받아보았다3-3 삼항연산자를 2번 사용해서 num이 양수, 음수, 0중 어디에 해당하는가?package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_3 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num&gt;0?\"양수\":num&lt;0?\"음수\":0);\t\t\t}}삼항연산자 - 조건식?(true일때)값:(false일때)값3-4 백의자리 이하를 버려라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_4 {\tpublic static void main(String[] args) throws IOException{\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num/100*100);\t}}int는 소수점을 자동으로 버리기 때문에(반올림xxx) num을 100으로 나눈 후 100을 곱해줬음3-5 1의 자리를 1로 바꿔라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_5 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num/10*10+1);\t}}3-4처럼 일의자리를 버린 후 1을 더해줬다3-6 %연산자를 사용하여 크면서도 가까운 10의 배수에서 num값을 뺀 나머지를 구하라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_6 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(+num+\"의 크면서도 가까운 10의 배수 : \"+(10-num%10+num));\t\tSystem.out.println(\"나머지 수 : \"+(10-num%10));\t}}3-7 화씨를 섭씨로 변환  변환 공식 - 5/9 * (f-32)public class ex3_7 {\tpublic static void main(String[] args) {\t\tint fahrenheit = 100;\t\tfloat celcius = (int)(5/9f * (fahrenheit-32)*100+0.5)/100f;\t\tSystem.out.println(\"Fahrenheit : \"+fahrenheit);\t\tSystem.out.println(\"celcius : \"+celcius);\t}}섭씨로 바꾸는 공식을 사용하여 100을 곱하고 반올림을 위해 0.5를 더한다.+0.5를 했을때 일의 자리 수 값이 변한다면 어차피 반올림해도 변함 - 여기까지 int형으로 계산해서 3번째 자리수부터 버림그 후 다시 100f로 나눠 소수점을 만들어 준다3-8 정해진 값을 출력하라차례로c = 30ch = Cf = 1.5l = 1230196224result = true을 출력하는 문제package _2javajungsuktestEx3;public class ex3_8 {\tpublic static void main(String[] args) {\t\tbyte a=10;\t\tbyte b=20;\t\tbyte c =(byte) (a+b);\t\t\t\tchar ch ='A';\t\tch = (char)(ch+2);\t\tfloat f = 3/2f;\t\tlong l = 3000*3000*3000L;\t\t\t\tfloat f2 = 0.1f;\t\tdouble d = 0.1;\t\t\t\tboolean result = (float)d==f2;\t\t\t\tSystem.out.println(\"c = \"+c);\t\tSystem.out.println(\"ch = \"+ch);\t\tSystem.out.println(\"f = \" +f);\t\tSystem.out.println(\"l = \"+l);\t\tSystem.out.println(\"result = \"+result);\t\t\t}}byte c = a+b같은 경우에는 a+b가 int로 자동 형변환 되기때문에 앞에 (byte)를 붙여서 다시 byte로 형변환을 해주었다.ch =ch+2도 마찬가지로 앞에 (char)을 붙여서 형변환을 해주었다float f=3/2는 int/int라 2에 f를 붙여 float로 변환해주었다. long l = 300030003000도 뒤에 L이 빠져있었다. 3000중에 하나는 long타입이어야 오버플로우가 나타나지 않는다boolean result = d == f2는 d와 f2의 형식이 달라 false가 출력된다. float를 double로 형변환했을 때 오차가 발생할 수 있어서 d를 float으로 변환해주었다3-9 ch가 영어(대문자,소문자 둘다)거나 숫자일경우 true를 출력package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class cx3_9 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\tchar ch = br.readLine().charAt(0);\t\tboolean b= (ch&gt;='A'&amp;&amp; ch&lt;='z') || (ch&gt;='a' &amp;&amp; ch&lt;='z') || (ch&gt;='0' &amp;&amp; ch&lt;='9');\t\t\t\tSystem.out.println(b);\t}\t}char ch를 BufferedReader를 통해 입력받아보았다. char형을 입력받는 것은 처음이라 charAt()을 써보면 될거같아 시도해보았더니 성공했다!3-10 대문자를 소문자로 변환package _2javajungsuktestEx3;public class ex3_10 {\tpublic static void main(String[] args) {\t\tchar ch = 'A';\t\t\t\tchar lowerCase = (char) ((ch&gt;=65 &amp;&amp; ch&lt;97)?ch+32:ch);\t\t\t\tSystem.out.println(\"ch:\"+ch);\t\tSystem.out.println(\"ch to lowerCase : \"+lowerCase);\t}}"
  },
  
  {
    "title": "자바의 정석 연습문제 2장 - 변수",
    "url": "/posts/2%EC%9E%A5_%EB%B3%80%EC%88%98/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 변수",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "[2-1] 기본형 8개를 알맞은 자리에 적으시요            종류/크기      1byte      2byte      4byte      8byte                  논리형      boolean                                   문자형             char                     ...",
    "content": "[2-1] 기본형 8개를 알맞은 자리에 적으시요            종류/크기      1byte      2byte      4byte      8byte                  논리형      boolean                                   문자형             char                            정수형      byte      short      int      long              실수형                    float      double      [2-2] 주민등록번호를 초기화하는 코드 적기long regNo = 9701012222222L;int의 범위를 넘어서는 값이라 long을 사용함→ 원래는 이렇게 하면 됐는데 20000년생 부터는 long이 아닌 String으로 사용해야 온전한 값이 나옴[2-3] 리터럴, 변수, 상수, 키워드 구분하기int i = 100;long l =100L;final float PI = 3.14f;  리터럴 : 100,100L, 3.14f  변수 : i, l  키워드(=예약어) : int, long, final, float  상수 : PIPI는 final때문에 변경 불가능함[2-4] 기본형이 아닌 것.  int  ==Byte== - 기본형은 byte임.  double  boolean[2-5] 출력결과 적기System.out.println(“1” + “2”) → 12System.out.println(true + “”) → trueSystem.out.println(‘A’ + ‘B’) → 131 (A-65, b-66)System.out.println(‘1’ + 2) → 51 (’1’=49)System.out.println(‘1’ + ‘2’) → 99 (’1’=49, ‘2’=50)System.out.println(‘J’ + “ava”) → JavaSystem.out.println(true + null) → 오류![2-6] 키워드가 아닌 것  if  ==True== - true는 키워드임  ==NULL==  ==Class==  ==System== - 클래스명임키워드 :abstract, do, if, package, synchronized, boolean, double, implements, private, this, break, else, import, protected, throw, byte, enum, instanceof, public, throws, case, extends, int, return, transient, catch, false, interface, short, true, char, final, long, static, try, class, finally, native, strictfp, void, continue, float, new, super, volatile, default, for, null, switch, while[2-7] 변수이름으로 사용가능 한 것.==a. $ystem==b. channel==#==5 - # 불가c.==7==eleven - 숫자로 시작 불가==d. If====e. 자바==f.==new== - 예약어라 불가능==g. $MAX_NUM==h. hello==@==com - @불가[2-8] 참조형변수(reference type)과 같은 크기의 기본형(primitive type)  ==int== - 4byte  long - 8byte  short - 2byte  ==float== - 4byte  double - 8byte참조형 변수는 4byte임[2-9] 형변환 생략 가능한 것byte b=10;char ch = ‘A’;int i =100;long l = 1000L;  b = (byte) i; int(4byte) &gt; byte(1byte) 불가능  ch = (char)b; byte(1byte) &lt; char(2byte). 범위가 달라서 해줘야함  short s = (short) ch; char(2byte) = short(2byte). 범위가 달라서 해줘야함  float f = (float)l; long(8byte) &gt; float(4byte). 그러나 범위가 float이 더 커서 생략가능  i = (int)ch; char(2byte) &lt; int(4byte) 생략가능선생님은 정답 없다고하심[2-10] char타입에 저장될 수 있는 정수 값의 범위(10진수로)0~65535[2-11] 변수를 잘못 초기화 한것은?  ==byte b = 256;== byte의 범위값을 넘음  ==char c = ‘’;== 띄어쓰기 해야함 ‘ ‘  ==char answer = ‘no’;== 두글자 안됨  ==float f = 3.14== f 빠짐  double d = 1.4e3f;[2-12] main메소드의 선언부로 알맞은것은?  ==public static void main(String[] args)==  ==public static void main(String args[])==  ==public static void main(String[] arv)==  public void static main(String[] args) void는 main앞에 와야함  static public void main(String[] args)[2-13] 타입과 기본형의 연결이 잘못된 것  boolean = false  char = ‘\\u0000’  ==float - 0.0== f빠짐  int = 0  ==long = 0== L빠짐  ==String = “”== String의 기본형은 null임"
  },
  
  {
    "title": "[권오흠 영리한 프로그래밍을 위한 알고리즘 강좌] Recursion의 기본 개념과 기본 예제",
    "url": "/posts/Recursion%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B8%B0%EB%B3%B8-%EC%98%88%EC%A0%9C/",
    "categories": "알고리즘",
    "tags": "알고리즘, 권오흠알고리즘강좌",
    "date": "2022-09-29 00:00:00 +0900",
    





    
    "snippet": "Recursion(순환, 재귀함수)자기 자신을 호출하는 함수(메소드)단순하고 알기 쉬우나, 오버해드(매개변수 전달, 엑티베이션 프레임 생성)가 있음ex)void func(...){\tSystem.out.println(\"hello\");\tfunc(...);}❗항상 무한 루프에 빠지는 것은 아님ex)public static void main(String[] ...",
    "content": "Recursion(순환, 재귀함수)자기 자신을 호출하는 함수(메소드)단순하고 알기 쉬우나, 오버해드(매개변수 전달, 엑티베이션 프레임 생성)가 있음ex)void func(...){\tSystem.out.println(\"hello\");\tfunc(...);}❗항상 무한 루프에 빠지는 것은 아님ex)public static void main(String[] args){\tfunc(4);\t}public static void func(int k){\tif(k&lt;=0) return;\telse {\t\tSystem.out.println(\"hello\");\t\tfunc(k-1);\t}  Base case : 적어도 하나의 recursion에 빠지지 않는 경우가 존재해야 함  Recursion case : recursion을 반복하다 보면 결국 base case로 수렴해야 함. (위의 예시에서 func(k+1)을 사용하면 에러남)class Main {\tpublic static void main(String[] args) {\t\tint result = func(4);\t\tSystem.out.println(result); //10출력. 4+3+2+1+0\t}\tpublic static int func(int n) {\t\tif(n&lt;=0)\t\t\treturn 0;\t\telse \t\t\treturn n+func(n-1);\t}}  팩토리얼 사용 예시class Main {\tpublic static void main(String[] args) {\t\tint result = factorial(4);\t\tSystem.out.println(result); //24출력. 4*3*2*1*1=24\t}\tpublic static int factorial(int n) {\t\tif(n==0)\t\t\treturn 1; //0!은 1이기 때문\t\telse \t\t\treturn n*factorial(n-1);\t}}  x의 n승 예시class Main {\tpublic static void main(String[] args) {\t\tdouble result = power(4,3);\t\tSystem.out.println(result); //64.0출력, 54+16+4=64\t}\tpublic static double power(double x,int n) {\t\tif(n==0)\t\t\treturn 1; \t\telse \t\t\treturn x*power(x,n-1);\t}}  피보나치 수열 예시class Main {\tpublic static void main(String[] args) {\t\tSystem.out.println(fibonacci(4)); //5출력. 피보나치수열 4번째 자리가 5임\t}\tpublic static double fibonacci(int n) {\t\tif(n&lt;2)\t\t\treturn 1; \t\telse \t\t\treturn fibonacci(n-1) + fibonacci(n-2);\t}}  최대 공약수 예시class Main {\tpublic static void main(String[] args) {\t\tint result = gcd(30,20);\t\tSystem.out.println(result); //10출력\t}//\tpublic static int gcd(int m, int n) {//\t\tif(m&lt;n) {//\t\t\tint tmp=m; m=n; n=tmp; //m과 n값 교환//\t\t}//\t\tif(m%n==0)//\t\t\treturn n;//\t\telse return gcd(n, m%n);\t//단순한 버전\tpublic static int gcd(int p, int q) {\t\tif(q==0)\t\t\treturn p;\t\telse return gcd(q,p%q);\t}}수학함수 외에도 다른 문제들도 해결할 수 있다.Recursive thinking순환적으로 사고하기.      문자열 길이 계산하기 : 첫번째 문자를 제외한 문자열 길이+1     import java.util.*;     public class Main { \tpublic static int length(String str) { \t\tif(str.equals(\"\")) return 0; \t\telse return 1+length(str.substring(1)); \t}     \tpublic static void main(String[] args) { \t\tSystem.out.println(length(\"abcd\")); \t\t} \t}            문자열 출력하기     import java.util.*;     public class Main { \tpublic static void printChars(String str) { \t\tif(str.length()==0) return ; \t\telse { \t\t\tSystem.out.print(str.charAt(0)); \t\t\tprintChars(str.substring(1)); \t\t} \t}     \tpublic static void main(String[] args) { \t\tprintChars(\"abcd\"); \t} }            문자열 뒤집기     import java.util.*;     public class Main { \tpublic static void printCharsReverse(String str) { \t\tif(str.length()==0) return ; \t\telse { \t\t\tprintCharsReverse(str.substring(1)); \t\t\tSystem.out.print(str.charAt(0)); \t\t} \t}     \tpublic static void main(String[] args) { \t\tprintCharsReverse(\"abcd\"); \t} }            2진수로 변환하기     import java.util.*;     public class Main { \tpublic static void printBinary(int n) { \t\tif(n&lt;2) System.out.print(n); \t\telse { \t\t\tprintBinary(n/2);  \t\t\tSystem.out.print(n%2); \t\t} \t}     \tpublic static void main(String[] args) { \t\tprintBinary(10); \t\tprintBinary(12); \t} }            배열 합 구하기     import java.util.*;     import javax.xml.crypto.Data;     public class Main { \tstatic int data[] = {1,2,3,4,5,6,7,8,9,10}; \tpublic static int sum(int n, int data[]) { \t\tif(n&lt;=0) return 0; \t\telse return sum(n-1,data) + data[n-1]; \t}     \tpublic static void main(String[] args) { \t\tSystem.out.println(sum(10,data)); \t} }            데이터 파일로부터 n개의 정수 읽어오기     import java.util.*;     import javax.xml.crypto.Data;     public class Main { \tstatic int data[] = new int[10]; \tstatic Scanner in  = new Scanner(System.in); \tpublic static void readFrom(int n, int data[], Scanner in) { \t\tif(n==0) return; \t\telse { \t\t\treadFrom(n-1,data,in); \t\t\tdata[n-1]=in.nextInt(); \t\t} \t}     \tpublic static void main(String[] args) { \t\treadFrom(10,data,in); \t\tSystem.out.println(Arrays.toString(data)); \t} }      ⭐모든 순환 함수는 반복문(iteration)으로 변경 가능하며 그 반대도 가능함Designing Recursion순환 알고리즘의 설계암시적(implicit) 매개변수를 명시적(explicit) 매개변수로 바꾸어라  순차탐색                  암시적 매개변수ver          import java.util.*;          public class Main {          \tpublic static int search(int data[], int n, int target) {  \t\tfor(int i=0;i&lt;n;i++) {  \t\t\tif(data[i]==target) return i;  \t\t}  \t\treturn -1; // 값이 없으면 -1을 반환함  \t}        \t  \tpublic static void main(String[] args) {  \t\tint data[] = {1,2,3,4,5};  \t\tSystem.out.println(search(data,4,3));  \t}  }                            명시적 매개변수ver(시작점, 끝점의 위치가 명시적임)          import java.util.*;          public class Main {          \tpublic static int search(int data[], int begin, int end, int target) {  \t\tif(begin&gt;end) return -1;  \t\telse if(target==data[begin]) return begin;  \t\telse return search(data, begin+1,end,target);  \t}        \t  \tpublic static void main(String[] args) {  \t\tint data[] = {1,2,3,4,5};  \t\tSystem.out.println(search(data,1,4,2));  \t}  }                  import java.util.*;          public class Main {          \tpublic static int search(int data[], int begin, int end, int target) {  \t\tif(begin&gt;end) return -1;  \t\telse if(target==data[begin]) return begin;  \t\telse return search(data, begin,end-1,target);  \t}        \t  \tpublic static void main(String[] args) {  \t\tint data[] = {1,2,3,4,5};  \t\tSystem.out.println(search(data,1,4,2));  \t}  }                  import java.util.*;          public class Main {          \tpublic static int search(int data[], int begin, int end, int target) {  \t\tif(begin&gt;end) return -1;  \t\telse {  \t\t\tint middle = (begin+end)/2;  \t\t\tif(data[middle] == target) return middle;  \t\t\tint index=search(data,begin,middle-1,target);  \t\t\tif(index!=-1) return index; //찾았을경우  \t\t\telse return search(data,middle+1,end,target);  \t\t}  \t}        \t  \tpublic static void main(String[] args) {  \t\tint data[] = {1,2,3,4,5};  \t\tSystem.out.println(search(data,0,4,2));  \t}  }                          최대값 찾기      import java.util.*;      public class Main {      \tpublic static int findmax(int data[], int begin, int end) {  \t\tif(begin==end) return data[begin];  \t\telse return Math.max(data[begin], findmax(data,begin+1,end));  \t}    \t  \tpublic static void main(String[] args) {  \t\tint data[] = {1,6,4,5,7};  \t\tSystem.out.println(findmax(data,0,4));  \t}  }          import java.util.*;      public class Main {      \tpublic static int findmax(int data[], int begin, int end) {  \t\tif(begin==end)   \t\t\treturn data[begin];  \t\telse {  \t\t\tint middle = (begin+end)/2;  \t\t\tint max1=findmax(data,begin,middle);  \t\t\tint max2=findmax(data,middle+1,end);  \t\t\treturn Math.max(max1, max2);  \t\t}  \t}    \t  \tpublic static void main(String[] args) {  \t\tint data[] = {1,6,4,5,7};  \t\tSystem.out.println(findmax(data,0,4));  \t}  }        2진 검색import java.util.*;public class Main {\tpublic static int binarySearch(String items[], String target, int begin, int end) {\t\tif(begin&gt;end) return -1;\t\telse {\t\t\tint middle = (begin+end)/2;\t\t\tint compResult = target.compareTo(items[middle]); //맨 중간값을 비교\t\t\tif(compResult==0) return middle; \t\t\telse if(compResult&lt;0) return binarySearch(items, target,begin,middle-1); //중간 값이 target보다 작을 경우, 앞쪽에서 찾기\t\t\telse return binarySearch(items, target,middle+1,end);//중간값이 target보다 클 경우, 뒤쪽에서 찾기\t\t}\t}\t\tpublic static void main(String[] args) {\t\tString data[] = {\"aaa\",\"bbb\",\"ccc\",\"ddd\",\"eee\"};\t\tSystem.out.println(binarySearch(data,\"ccc\",0,data.length));\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - 람다와 스트림(Lambda & Stream)",
    "url": "/posts/%EB%9E%8C%EB%8B%A4%EC%99%80-%EC%8A%A4%ED%8A%B8%EB%A6%BC(Lambda&Stream)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-09-02 00:00:00 +0900",
    





    
    "snippet": "람다식(Lambda Experssion): 함수(메소드)를 간단한 식으로 표현하는 법 (ex. (a, b) → a &gt; b ? a : b )  익명함수(이름이 없는 함수, anonymous function) : 반환타입, 이름을 지우고 사이에 →를 붙인다  함수와 메소드는 근본적으로 동일하나 함수는 일반적 용어, 메소드는 객체지향개념 용어. 함수는...",
    "content": "람다식(Lambda Experssion): 함수(메소드)를 간단한 식으로 표현하는 법 (ex. (a, b) → a &gt; b ? a : b )  익명함수(이름이 없는 함수, anonymous function) : 반환타입, 이름을 지우고 사이에 →를 붙인다  함수와 메소드는 근본적으로 동일하나 함수는 일반적 용어, 메소드는 객체지향개념 용어. 함수는 클래스에 독립적(클래스 바깥에 있는것. 자바에서는 불가능), 메소드는 클래스에 종속적(클래스안에 있음)  작성 법                  메소드의 이름과 반환타입 제거 후 ‘ →’를 블럭{}앞에 추가 ( ex. (int a, int b) → return a&gt;b? a:b;)                    반환값이 있는 경우, 식이나 값만 적고 return문 생략 가능. 끝에 ; 안붙임 (ex. (int a, int b) → a&gt;b? a:b)                    매개변수의 타입이 추론 가능하면, 생략 가능(대부분의 경우 생략가능) (ex. (a, b) → a&gt;b?a:b              주의사항                  매개변수가 하나인 경우, 괄호() 생략가능(타입이 없을 때만)  (a) → aa ⇒ a → aa 가능, (int a) → aa ⇒ int a → aa 불가능.                    블록안의 문장이 하나일 겅우 {}생략가능. 끝에 ; 안붙음. (return문은 생략안됨)  (int i) → { System.out.println(i);} ⇒ (int i) → System.out.println(i) 가능            — 예시      int max(int a, int b){ retrun a&gt;b?a:b;} ⇒ (a, b) → a&gt;b? a:b;        int printVar(String name, int i){System.out.println(name+”=”+i);} ⇒ (name, i) → System.out.println(name+”=”+i)        int square(int x){return x * x; } ⇒ x→ x*x        int roll(){return (int)(Math.random()6); ⇒ () → (int)(Math.random()6)        익명 함수가 아니고 익명 객체임  new Object(){ int max(int a, int b){ return a&gt;b? a:b;} 를 (a, b) → a&gt;b? a:b;으로 쓴거라 객체임.        람다식(익명 객체)를 다루기 위해 참조변수가 필요함.  class  Main{\tpublic static void main(String[] args) throws Exception {//\tObject obj = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체 에러남\t\tObject obj = new Object() {\t\t\tint max(int a, int b) {\t\t\t\treturn a&gt;b? a:b;\t\t\t}\t\t};//\t\tint value = obj.max(3,5); //에러, Object리모컨인 obj는 max를 호출할 수 없음\t\t//=&gt; 함수형 인터페이스가 필요\t}}함수형 인터페이스: 단 하나의 추상 메소드만 선언된 인터페이스@FunctionalInterface //붙이는게 좋음interface MyFunction{ \tpublic abstract int max(int a, int b);}class  Main{\tpublic static void main(String[] args) throws Exception {\t\tMyFunction f= new MyFunction(){\t\t\tpublic int max(int a, int b){ \t\t\t\treturn a&gt;b? a:b; \t\t\t}\t\t};\t\tint value = f.max(3, 5);//가능. MyFunction에 max()가 있음\t\tSystem.out.println(value);  \t}}  함수형 인터페이스 타입의 참조변수로 람다식을 참고 가능 (단, 함수형 인터페이스의 메소드와 람다식의 매개변수 개수와 반환타입이 일치해야 함)  Myfunction f = (a,b) →a&gt;b?a:b;  int value = f.max(3,5);class  Main{\tpublic static void main(String[] args) throws Exception {//\tObject obj = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체 에러남//\t\tMyfunction f = new Myfunction() {//\t\t\tpublic int max(int a, int b) { //오버라이딩 규칙, 접근제어자는 좁게 못바꿈//\t\t\t\treturn a&gt;b? a:b;//\t\t\t}//\t\t};\t\t//람다식을 다루기 위한 참조변수의 타입은 함수형 인터페이스로 한다\t\tMyfunction f = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체\t\t//람다식을 사용하려면 이름이 있어야해서 이름을 붙여준거임(추상메소드와 연결)\t\tint value = f.max(3, 5);\t\tSystem.out.println(\"value : \"+value);\t}}@FunctionalInterface //함수형 인터페이스는 단 하나의 추상메소드만 가질 수 있다.interface Myfunction{//\tpublic abstract int max(int a, int b);\t\t\t\t\tint max(int a, int b); //public abstract 생략가능}— 예시      익명 객체를 람다식으로 대체      import java.util.*;      class  Main{  \tpublic static void main(String[] args)  {  \t\tList&lt;String&gt; list = Arrays.asList(\"abc\",\"aaa\",\"bbb\",\"ddd\",\"aaa\");    \t\t  //\t\tCollections.sort(list, new Comparator&lt;String&gt;() {  //\t\t\tpublic int compare(String s1, String s2) {  //\t\t\t\treturn s2.compareTo(s1);  //\t\t\t}  //\t\t});    \t\t  \t\tCollections.sort(list, (s1,s2)-&gt;s2.compareTo(s1));  \t\tSystem.out.println(list);  \t}  }  @FunctionalInterface  interface Comparator&lt;T&gt;{  \tint compare(T o1, T o2);  }        함수형 인터페이스타입의 매개변수, 반환타입                  함수형 인터페이스타입의 매개변수        @FunctionalInterface  interface MyFunction{  void myMethod(); }  void aMethod(MyFuction f) {  f.myMethod(); //람다식 호출  }  aMethod(()→System.out.println(”myMethod()”));                  함수형 인터페이스 타입의 반환타입    MyFunction myMethod(){ //람다식 반환  return ()→{}; }      import java.util.*;  @FunctionalInterface  interface MyFunction{  \tvoid run();  }      class  Main{  \tstatic void execute(MyFunction f) {//매개변수 타입이 MyFunction인 메소드  \t\tf.run();  \t}  \tstatic MyFunction getMyFunction() { //반환타입이 MyFunction인 메소드  //\t\tMyFunction f = () -&gt; System.out.println(\"f3.run()\");  //\t\treturn f;  \t\treturn ()-&gt;System.out.println(\"f3.run()\");  \t}  \tpublic static void main(String[] args)  {  \t\t//람다식으로 MyFunction의 run()을 구현  \t\tMyFunction f1 = ()-&gt;System.out.println(\"f1.run()\");    \t\t  \t\tMyFunction f2 = new MyFunction() {  \t\t\tpublic void run() {  \t\t\t\tSystem.out.println(\"f2.run()\");  \t\t\t}  \t\t};  \t\tMyFunction f3 = getMyFunction();    \t\t  \t\tf1.run();  \t\tf2.run();  \t\tf3.run();    \t\t  \t\texecute(f1);  \t\texecute(()-&gt;System.out.println(\"run()\"));  \t}  }      java.util.function패키지      자주 사용되는 다양한 함수형 인테페이스를 제공.        Predicate isEmptyStr = s→ s.length() == 0;    String s=””;    if(isEmptyStr.test(s) //if(s.length()==0)    Sysout(”This is an empty String”)  ![[assets/images/java/2022-09-02-람다와 스트림(Lambda&amp;Stream) 1/IMG-20240902151633.png]]  — 예시Supplier f = ()→(int)(Math.random()*100)+1; (공급자)Consumer f = i→ System.out.print(i+””);Predicate f = i→ i%2==0;Function f = i→ i/10*10; //25를 넣으면 20으로 반환  매개변수가 두개인 함수형 인터페이스Bi가 2개를 의미      매개변수가 3개인경우엔 만들어서 쓸것.  @FunctionalInterface  interface TriFunction&lt;T,U,V,R&gt;{  R apply(T t, U u, V v); //매개변수 3개  }        매개변수의 타입과 반환타입이 일치하는 함수형 인터페이스  UnaryOperator : 단항 연산자BinaryOperator : 이항 연산자@FunctionalInterfacepublic interface UnaryOperator extends Function&lt;T,T&gt;{  static UnaryOperrator  identity(){  return t→ t;} //입출력 타입 일치@FunctionalInterfacepublic interface Function&lt;T,R&gt;{R apply(T t);}import java.util.ArrayList;import java.util.List;import java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\t\tSupplier&lt;Integer&gt; s = () -&gt;(int)(Math.random()*100)+1; //1~100사이 양수\t\tConsumer&lt;Integer&gt; c = i-&gt;System.out.print(i+\", \");\t\tPredicate&lt;Integer&gt; p = i-&gt;i%2==0; //짝수인지 검사\t\tFunction&lt;Integer, Integer&gt; f = i-&gt;i/10*10; //i의 일의 자리수 버림\t\t\t\tList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\t\tmakeRandomList(s, list); //s에서 값(랜덤값)을 꺼내 list를 채운다\t\tSystem.out.println(list);\t\tprintEvenNum(p,c,list); //짝수 출력\t\tList&lt;Integer&gt; newList = doSomething(f,list); //새로운 list를 생성\t\tSystem.out.println(newList);\t}\t\tstatic&lt;T&gt; List&lt;T&gt; doSomething(Function&lt;T,T&gt; f, List&lt;T&gt; list){\t\tList&lt;T&gt; newList = new ArrayList&lt;T&gt;(list.size());\t\t\t\tfor(T i : list) {\t\t\tnewList.add(f.apply(i)); //list안의 값에서 1의 자리수를 버려 newlist 생성\t\t}\t\treturn newList;\t}\tstatic&lt;T&gt; void printEvenNum(Predicate&lt;T&gt; p, Consumer&lt;T&gt; c, List&lt;T&gt; list) {\t\tSystem.out.print(\"[\");\t\tfor(T i:list) {\t\t\tif(p.test(i)) //짝수인지 검사\t\t\t\tc.accept(i); //짝수면,System.out.print(i+\", \");로 화면에 i 출력\t\t}\t\tSystem.out.println(\"]\");\t}\tstatic&lt;T&gt; void makeRandomList(Supplier&lt;T&gt; s, List&lt;T&gt; list) {\t\tfor(int i=0;i&lt;10;i++) {\t\t\tlist.add(s.get()); //Supplier로 부터 1~100까지의 난수를 받아서 list에 10번 추가\t\t}\t}}Predicate의 결합      and(), or(), negate()로 두 Predicate를 하나로 결합(default메소드)    Predicate p = i → i&lt;100;    Predicate q = i → i&lt;200;    Predicate r = i → i%2 ==0;    Predicate notP = p.negate(); //i≥100    Predicate all = notP.and(q).or(r); //100≤i &amp;&amp; i&lt;200 || i%2==0    Predicate all2 = notP.and(q.or(r))//100≤i &amp;&amp; (i&lt;200 || i%2==0 )    System.out.println(all.test(2)); //true  System.out.println(all2.test(2)); //false        등가비교를 위한 predicate의 작성에는 isEqual()를 사용(static메소드)  Predicate [ =Predicate.isEqual(str1); //isEquals()은 static메소드    Boolean result = p.test(str2); //str1과 str2가 같은지 비교한 결과를 반환    ⇒ Boolean result = Predicate.isEqual(str1).test(str2);  import java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\tFunction&lt;String, Integer&gt; f = (s)-&gt;Integer.parseInt(s,16); //문자열을 16진수로\tFunction&lt;Integer, String&gt; g = (i)-&gt;Integer.toBinaryString(i); //2진수로\t\t//andThen : 두 function을 하나로 연결\t//f가 String입력, Integer출력. 출력된 Integer를 g에 입력, String출력하는 함수 h를 생성함\tFunction&lt;String, String&gt; h = f.andThen(g); //f적용하고 g를 적용. String입력, String출력\t//compose : f가 뒤에오고 g가 앞에옴\tFunction&lt;Integer, Integer&gt; h2 = f.compose(g); //Integer입력, Integer출력\t\tSystem.out.println(h.apply(\"FF\")); //\"FF\" -&gt; 255 -&gt; \"11111111\"\tSystem.out.println(h2.apply(2)); //2 -&gt; \"10\" -&gt; 16\t\tFunction&lt;String, String&gt; f2 = x-&gt;x; //항등함수(identity function)\tSystem.out.println(f2.apply(\"AAA\")); //AAA가 그대로 출력됨\t\tPredicate&lt;Integer&gt; p = i -&gt; i&lt;100;\tPredicate&lt;Integer&gt; q = i -&gt; i&lt;200;\tPredicate&lt;Integer&gt; r = i -&gt; i%2==0;\tPredicate&lt;Integer&gt; notP = p.negate(); //i&gt;=100\t\tPredicate&lt;Integer&gt; all = notP.and(q.or(r)); //i&gt;=100 &amp;&amp; (i&lt;200 || i%2==0)\tSystem.out.println(all.test(150)); //true\tSystem.out.println(all.test(149)); //true\tSystem.out.println(all.test(300)); //true\tSystem.out.println(all.test(10)); //false\t\tString str1 = \"abc\";\tString str2 = \"abc\";\t\t//str1과 str2가 같은지 비교\tPredicate&lt;String&gt; p2 = Predicate.isEqual(str1);\tboolean result = p2.test(str2);\tSystem.out.println(result); //true\t\tString str3 = new String(\"abc\");\t\t//str1과 str2가 같은지 비교//\tPredicate&lt;String&gt; p3 = Predicate.isEqual(str2);//\tboolean result2 = str1.equals(str2);\tboolean result2 = Predicate.isEqual(str2).test(str3);\tSystem.out.println(result2); //true\t}}컬렉션 프레임웍과 함수형 인터페이스  함수형 인터페이스를 사용하는 컬렉션 프레임웍의 메소드(와일드카드 생략)forEach는 consumer임(입력값만 있음)import java.util.*;class  Main{\tpublic static void main(String[] args)  {\t\tArrayList&lt;Integer&gt; list = new ArrayList();\t\tfor(int i=0;i&lt;10;i++) {\t\t\tlist.add(i);\t\t}\t\t\t\t//list의 모든 요소 출력\t\t//\t\tIterator it = list.iterator();//\t\twhile(it.hasNext()) {//\t\t\tSystem.out.print(it.next()+\",\");//\t\t}//\t\tSystem.out.println();\t\t//아래 한문장으로\t\tlist.forEach(i-&gt; System.out.print(i+\", \"));\t\tSystem.out.println();\t\tSystem.out.println(list); //이것도 되긴함\t\t\t\t\t\t//list에서 2또는 3의 배수를 제거\t\tlist.removeIf(x-&gt;x%2==0 || x%3==0); \t\tSystem.out.println(list);\t\t\t\tlist.replaceAll(i-&gt;i*10);\t\tSystem.out.println(list);\t\t\t\tMap&lt;String, String&gt; map = new HashMap();\t\tmap.put(\"1\", \"1\");\t\tmap.put(\"2\", \"2\");\t\tmap.put(\"3\", \"3\");\t\tmap.put(\"4\", \"4\");\t\t\t\t//map의 모든 요소를 {k,v}형식으로 출력//\t\tIterator it2 = map.entrySet().iterator();//\t\twhile(it2.hasNext()) {//\t\t\tSystem.out.print(\"{\"+it2.next()+\"}\");//\t\t}//\t\tSystem.out.println();\t\t//위에꺼 한문장으로\t\tmap.forEach((k,v)-&gt;System.out.print(\"{\"+k+\", \"+v+\"}\"));\t\tSystem.out.println();\t}}메소드 참조(method reference)  클래스이름 :: 메소드이름: 하나의 메소드만 호출하는 람다식을 ‘메소드 참조’로 더 간단히 할 수 있다            종류      람다      메소드 참조                  static메소드 참조      (x) → ClassName.method(x)      ClassName::method              인스턴스 메소드 참조      (obj,x) → obj.method(x)      ClassName::method              특정 객체 인스턴스 메소드 참조      (x)→ obj.method(x)      obj::method      import java.util.function.Function;class  Main{\tpublic static void main(String[] args)  {//\t\tFunction&lt;String, Integer&gt; f = (String s) -&gt; Integer.parseInt(s);\t\tFunction&lt;String, Integer&gt; f = Integer::parseInt; //메소드 참조. 위랑 같음\t\t\t\tSystem.out.println(f.apply(\"100\")+200); //f.apply(\"100\")이 숫자로 바뀜\t}}  생성자의 메소드 참조 - 클래스이름::new  배열과 메소드 참조 - 타입[]::newimport java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\t\t//매개변수 없는 경우//\t\tSupplier&lt;MyClass&gt; s = ()-&gt;new MyClass(); //입력x, 출력o\t\tSupplier&lt;MyClass&gt; s = MyClass::new;\t\t\t\tMyClass mc = s.get(); //객체 값 반환\t\tSystem.out.println(mc); \t\tSystem.out.println(s.get()); //위랑 다른 새로운 객체 생성\t\t\t\t//매개변수 있는 경우//\t\tFunction &lt;Integer, MyClass2&gt; f = (i)-&gt;new MyClass2(i); //입력o, 출력o\t\tFunction &lt;Integer, MyClass2&gt; f = MyClass2::new;\t\t\t\tMyClass2 mc2 = f.apply(100);\t\tSystem.out.println(mc2.iv); \t\tSystem.out.println(f.apply(100).iv); \t\t//\t\tFunction&lt;Integer, int[]&gt; f2 = (i)-&gt;new int[i];\t\tFunction&lt;Integer, int[]&gt; f2 = int[]::new;\t\tint[] arr = f2.apply(500);\t\tSystem.out.println(arr.length); //길이가 500인 배열\t}}class MyClass{}class MyClass2{\tint iv;\tMyClass2(int iv){\t\tthis.iv=iv;\t}}스트림(Stream): 다양한 데이터 소스를 표준화한 방법으로 다루기 위한 것  스트림이 제공하는 기능 - 중간 연산과 최종 연산— 스트림 만들기 3단계      스트림만들기                  컬렉션 - Collection인터페이스의 stream()으로 컬렉션을 스트림으로 변환  Stream stream() //Collection인터페이스의 메소드            배열                              객체 배열로부터 스트림 생성하기  Stream Stream.of(가변인자) or Stream Arrays.stream(T[])                                기본형 배열로부터 스트림 생성하기(Stream이 아니라 IntStream)  IntStream IntStream.of(int….value) or IntStream Arrays.Stream(int[])                                      임의의 수(난수)를 요소로 갖는 스트림 생성          import java.util.Random;  import java.util.stream.IntStream;          class  Main{  \tpublic static void main(String[] args)  {        \t\t  \t\tIntStream intStream = new Random().ints();   \t\tintStream.limit(5).forEach(System.out::println);  \t\tSystem.out.println();  \t\tIntStream intStream2 = new Random().ints(5);   \t\tintStream2.forEach(System.out::println);  \t\tSystem.out.println();  \t\tIntStream intStream3 = new Random().ints(10,5,10);   \t\tintStream3.forEach(System.out::println);  \t}  }                            특정범위의 정수를 요소로 갖는 스트림 생성하기(IntStream, LongStream)  IntSream IntStream.range(int begin, int end)                    람다식으로 스트림만들기  static  Stream iterate(T seed, UnaryOperator f) //이전요소에 종속적    static  Stream generate(Supplier s) //이전요소에 독립적                              iterate() : 이전요소를 seed로 해서 다음 요소를 계산  Stream evenStream = Stream.iterate(0, n→n+2); //0,2,4,6,..                                generate() : seed를 사용하지 않음  Stream randomStream = Stream.generate(Math::random);    Stream oneStream = Stream.generate(()→1); //1,1,1,1,…..                            import java.util.Random;  import java.util.stream.IntStream;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\t//iterate(T seed, UnaryOperator f)  단항연산자  \t\tStream&lt;Integer&gt; intStream = Stream.iterate(0, n-&gt;n+2);  \t\tintStream.limit(10).forEach(System.out::println);  \t\tSystem.out.println();  \t\tStream&lt;Integer&gt; intStream2 = Stream.iterate(1, n-&gt;n+2);  \t\tintStream2.limit(10).forEach(System.out::println);  \t\tSystem.out.println();  \t\t//generate(Supplier s)  입력x, 출력o  \t\tStream&lt;Integer&gt; oneStream = Stream.generate(()-&gt;1);  \t\toneStream.limit(5).forEach(System.out::println);  \t}  }                            파일을 소스로 하는 스트림생성  Stream Files.list(Path dir); //Path는 파일 또는 디렉토리    Stream Files.lines(Path path)    Stream Files.lines(Path path, Charset cs)    Stream lines() //BufferedReader클래스의 메소드            비어있는 스트림 생성하기  Stream emptyStream = Stream.empty(); //empty()는 빈 스트림을 생성해서 반환  long count = emptyStream.count(); //count의 값은 0         List&lt;Integer&gt; list =Arrays.asList(1,2,3,4,5); \t\tStream&lt;Integer&gt; intStream = list.stream(); //컬렉션 \t\tStream&lt;String&gt; strStream = Stream.of(new String[] {\"a\",\"b\",\"c\"}); //배열 \t\tStream&lt;Integer&gt; evenStream = Stream.iterate(0,n-&gt;n+2); //0,2,4,6... \t\tStream&lt;Double&gt; randomStream = Stream.generate(Math::random);//람다식 \t\tIntStream intStream2 = new Random().ints(5); //난수 스트림. 크기가 5     //컬렉션으로 스트림 생성 \t\tintStream.forEach(System.out::print); //최종연산 //\tintStream.forEach(System.out::print); //최종연산을 해서 Stream이 닫힘    \t\t \t\tintStream=list.stream(); \t\tintStream.forEach(System.out::print); //최종연산         import java.util.Arrays; import java.util.stream.IntStream; import java.util.stream.Stream;     class  Main{ \tpublic static void main(String[] args)  { //\t\tList&lt;Integer&gt; list =Arrays.asList(1,2,3,4,5); //\t\tStream&lt;Integer&gt; intStream = list.stream(); //list를 Stream으로 변환 //\t\tintStream.forEach(System.out::print); //최종연산 ////\t\tintStream.forEach(System.out::print); //최종연산을 해서 Stream이 닫힘 //\t\t //\t\tintStream=list.stream(); //\t\tintStream.forEach(System.out::print); //최종연산    \t\t \t\tStream&lt;String&gt; strstream = Stream.of(new String[] {\"a\",\"b\",\"c\",\"d\"}); \t\tstrstream.forEach(System.out::println);    \t\t \t\t//기본형 \t\tint[] intArr = {1,2,3,4,5}; \t\tIntStream intStream = Arrays.stream(intArr); //\t\tintStream.forEach(System.out::println); //\t\tSystem.out.println(\"count = \"+intStream.count()); //최종연산 //\t\tSystem.out.println(\"sum = \"+intStream.sum()); //최종연산 \t\tSystem.out.println(\"avg = \"+intStream.average()); //최종연산    \t\t \t\t//참조형 //\t\tInteger[] intArr = {1,2,3,4,5}; //\t\tStream&lt;Integer&gt; intStream = Arrays.stream(intArr); //\t\tintStream.forEach(System.out::println); //\t\tSystem.out.println(\"count = \"+intStream.count()); //count말고 다른건 안됨(sum, avg 등) \t\t//Stream&lt;T&gt;는 숫자 외에도 여러타입의 스트림이 가능해서 숫자 스트림에서만 사용할 수 있는 sum(), average()는 뺌 \t} }        중간연산(0~n번) : 연산결과가 스트림인 연산. 반복적으로 적용가능          스트림 자르기 - skip(long n)[앞에서부터 n개 건너뛰기), limit()[잘라내기]      스트림의 요소 걸러내기- filter()[조건에 맞는요소만 남김], distinct()[중복제거]              스트림 정렬 - sorted()[정렬기준안주면 스트림요소의 기본정렬]                                      Comparator의 comparing()으로 정렬기준을 제공  comparing(Function&lt;T,U&gt; keyExteactor)  comparing(Function&lt;T,U&gt; keyExteactor, Comparator, keyComparetor)                                추가정렬기준을 제공할 때는 thenComparing()사용  thenComparing(Function&lt;T,U&gt; keyExteactor)  thenComparing(Function&lt;T,U&gt; keyExteactor, Comparator, keyComparetor)              import java.util.Comparator;  import java.util.stream.Stream;              class  Main{  \tpublic static void main(String[] args)  {  \t\tStream&lt;Student&gt; studentStream = Stream.of(  \t\t\t\tnew Student(\"이자바\",3,300),  \t\t\t\tnew Student(\"김자바\",1,200),  \t\t\t\tnew Student(\"안자바\",2,100),  \t\t\t\tnew Student(\"박자바\",2,150),  \t\t\t\tnew Student(\"소자바\",1,200),  \t\t\t\tnew Student(\"나자바\",3,290),  \t\t\t\tnew Student(\"감자바\",3,180));            \t\t  \t\tstudentStream.sorted(Comparator.comparing(Student::getBan) //반별정렬  \t\t\t\t.thenComparing(Comparator.naturalOrder()))//기본정렬  \t\t\t\t.forEach(System.out::println);  \t}  }              class Student implements Comparable&lt;Student&gt;{  \tString name;  \tint ban;  \tint totalScore;            \t  \tStudent(String name, int ban, int totalScore){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.totalScore=totalScore;  \t}  \tpublic String toString() {  \t\treturn String.format(\"[%s, %d, %d]\",name,ban,totalScore);  \t}            \t  \tString getName() {return name;}  \tint getBan() {return ban;}  \tint getTotalScore() {return totalScore;}            \t  \t//총점 내림차순을 기본정렬로 한다  \tpublic int compareTo(Student s) {  \t\treturn s.totalScore - this.totalScore;  \t}  }                                          스트림의 요소 변환 - map()              forEach(의 중간연산버전(스트림소비x : 반환타입 void) - peek() : 중간점검          import java.io.File;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\tFile fileArr[] = { new File(\"Ex1.java\"), new File(\"Ex1.bak\"), new File(\"ex2.java\"), new File(\"java\"), new File(\"Ex1.txt\")};  \t\tStream&lt;File&gt; fileStream = Stream.of(fileArr);  \t\t//map()으로 Stream&lt;File&gt;을 Stream&lt;String&gt;으로 변환  \t\tStream&lt;String&gt; filenameStream = fileStream.map(File::getName);  \t\tfilenameStream.forEach(System.out::println); //모든 파일이름 출력        \t\t  \t\tfileStream = Stream.of(fileArr); //스트림 재생성  \t\tfileStream.map(File::getName)  \t\t\t.filter(s-&gt;s.indexOf('.')!=-1)///확장자가 없는 것 제외  \t\t\t.peek(s-&gt;System.out.printf(\"filename=%s%n\",s))  \t\t\t.map(s-&gt;s.substring((s.indexOf('.')+1))) //확장자만 추출  \t\t\t.peek(s-&gt;System.out.printf(\"extension=%s%n\",s))  \t\t\t.map(String::toUpperCase) //모두 대문자로 변환  \t\t\t.distinct() //중복제거  \t\t\t.forEach(System.out::print); //JAVABAKTXT        \t\t  \t\tSystem.out.println();        \t\t  \t}  }                            스트림의 스트림을 스트림으로 변환 : 여러 스트림 배열을 하나의 스트림배열로 변환 - flatmap()          import java.io.File;  import java.util.Arrays;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\tStream&lt;String[]&gt; strArrStrm = Stream.of(  \t\t\t\tnew String[] {\"abc\",\"def\",\"jkl\"},  \t\t\t\tnew String[] {\"ABC\",\"GHI\",\"JKL\"}  \t\t\t\t);        \t\t  //\t\tStream&lt;Stream&lt;String&gt;&gt; strStrmStrm = strArrStrm.map(Arrays::stream);  //\t\tstrStrmStrm.forEach(System.out::println);  //\t\tSystem.out.println();  \t\t//두 스트림배열을 하나의 스트림배열로 합침  \t\tStream&lt;String&gt; strStrm = strArrStrm.flatMap(Arrays::stream);        \t\t  \t\tstrStrm.map(String::toLowerCase) //대문자-&gt;소문자  \t\t.distinct()  \t\t.sorted()  \t\t.forEach(System.out::println);  \t\tSystem.out.println();        \t\t  \t\tString lineArr[] = {  \t\t\t\t\"Believe or not It is true\",  \t\t\t\t\"Do or not There is no try\"  \t\t};        \t\t  \t\tStream&lt;String&gt; lineStream = Arrays.stream(lineArr);  \t\tlineStream.flatMap(line -&gt; Stream.of(line.split(\" +\")))  \t\t.map(String::toLowerCase)  \t\t.distinct()  \t\t.sorted()  \t\t.forEach(System.out::println);  \t}  }                          최종연산(1번) : 연산결과가 스트림이 아닌 연산. 단 한번만 적용가능(스트림의 요소를 소모)          스트림의 모든 요소에 지정된 작업을 수행 - forEach(), forEachOrdered()                  sequential() : 직렬스트림(생략가능)          parallel() : 병렬 스트림 (순서보장x) - forEachOrdered를 써야 순서유지가 됨                    조건검사                  allMatch() : 모든 요소가 조건을 만족시키면 true          anyMatch() : 한 요소라도 조건을 만족시키면 true          noneMatch() : 모든 요소가 조건을 만족시키지 않으면 true          findFirst() : 첫번째 요소를 반환, 순차 스트림에 사용(결과가 null일수도 있어 Optional사용)          findAny() : 아무거나 하나를 반환, 병렬 스트림에 이용(결과가 null일수도 있어 Optional사용)                    reduce() : 스트림의 요소를 하나씩 줄여가며 누적연산 수행 (count, max, min, sum, collect는 reduce를 바탕으로 만든것). 전체 리듀싱                  identity : 초기값(대부분 0)          accumulator : 이전연산결과와 스트림의 요소에 수행할 연산                       import java.util.Optional; import java.util.OptionalInt; import java.util.stream.IntStream; import java.util.stream.Stream;     class  Main{ \tpublic static void main(String[] args)  { \t\tString strArr[] = { \t\t\t\t\"Ingeritance\",\"Java\",\"Lambda\",\"stream\",\"OptionalDouble\", \t\t\t\t\"IntStream\",\"count\",\"sum\", \t\t\t\t}; \t\tStream.of(strArr) \t\t.parallel() //병렬정렬 \t\t.forEachOrdered(System.out::println); //순서유지 \t\tSystem.out.println(\"---------------------------\");    \t\t \t\tboolean noEmptyStr = Stream.of(strArr).noneMatch(s-&gt;s.length()==0); //문자열길이가 0인게 없으면 true //\t\tOptional&lt;String&gt; sWord = Stream.of(strArr).parallel().filter(s-&gt;s.charAt(0)=='s').findAny(); //시작이 's'인 것 중 아무거나 가져옴 - 실행할때마다 값이 다름 \t\tOptional&lt;String&gt; sWord = Stream.of(strArr).filter(s-&gt;s.charAt(0)=='s').findFirst(); //시작이 's'인 것 중 첫번째 거만 가져옴    \t\t \t\tSystem.out.println(\"noEmptyStr=\"+noEmptyStr); \t\tSystem.out.println(\"-----------------\"); \t\tSystem.out.println(\"sWord=\"+sWord.get()); \t\tSystem.out.println(\"---------------------------\");    \t\t \t\t//Stream&lt;String&gt;을 String&lt;Integer&gt;로 변환 //\t\tStream&lt;Integer&gt; intStream = Stream.of(strArr).map(String::length);    \t\t \t\t//Stream&lt;String[]&gt;을 IntStream으로 변환. 성능이 더 놓음 \t\tIntStream intStream1 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream2 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream3 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream4 = Stream.of(strArr).mapToInt(String::length);    \t    \t\t \t\tint count = intStream1.reduce(0,(a,b)-&gt;a+1); \t\tint sum = intStream2.reduce(0,(a,b)-&gt;a+b); //단어길이 모두 더하기    \t\t \t\tOptionalInt max = intStream3.reduce(Integer::max); //가장긴거 \t\tOptionalInt min = intStream4.reduce(Integer::min); //가장 짧은거 \t\tOptionalInt max2 = IntStream.empty().reduce(Integer::max); //가장긴거 \t\tSystem.out.println(\"count = \"+count); \t\tSystem.out.println(\"sum = \"+sum); \t\tSystem.out.println(\"max = \"+max.getAsInt()); \t\tSystem.out.println(\"min = \"+min.getAsInt()); \t\tSystem.out.println(\"max2 = \"+max2.orElse(0)); //결과가 없으면 0을 반환 \t\tSystem.out.println(\"max2 = \"+max2.orElseGet(()-&gt;0)); //결과가 없으면 0을 반환 \t} }                      collect() : Collector(interface)를 매개변수로 하는 스트림의 최종 연산. 그룹별 리듀싱이 가능함                  Collector : 수집(collect)에 필요한 메소드를 정의해 놓은 인터페이스, Collectors클래스에서 구현해놔서 다 할 필요 없음                  interface Collector&lt;T, A, R&gt;{//T(요소)를 A에 누적한 다음, 결과를 R로 변환해서 반환  \tSupplier&lt;A&gt;\t\t\t\tsupplier(); //StringBuilder::new  누적할 곳 - A  \tBiConsumer&lt;A, T&gt;\t\taccumulator();//(sb, s)-&gt;sb.appens(s) 누적방법  \tBinaryOperator&lt;A&gt;\t\tcombiner();//(sb1,sb2)-&gt;sb1.append(sb2) 결합방법(병렬)  \tFunction&lt;A, R&gt; \t\t\tfinisher();//sb-&gt;ab.toString() 최종변환  \tSet&lt;Characteristics&gt; \tcharacteristics();//컬렉터의 특성이 담긴 set을 반환 - R  }                                      Collectors : 클래스. 다양한 기능의 컬렉터(Collector를 구현한 클래스)를 제공                          변환 - mapping(), toList(), toSet(), toCollection() 등              통계 - counting(), summingInt(), averagingInt(), maxBy(), minBy(), summarizingInt() 등              문자열 결합 - joining()              리듀싱 - reducing() : 그룹별 리듀싱 가능              그룹화와 분할 - groupingBy(), partitioningBy(), collectingAndThen()                        — 스트림을 컬렉션으로 변환 - toList(), toSet(), toMap(), toCollection()            Collectors.toList() 이렇게 사용함            — 스트림을 배열로 변환 - toArray()                              ex) stream.distinct().limit(5).sorted().forEach(System.out::println)Stream&lt;String&gt; stream = Stream.of(strArr); //문자열배열이 소스인 스트림생성\t\tStream&lt;String&gt; filteredStream = stream.filter(); //걸러내기(중간연산)\t\tStream&lt;String&gt; distinctedStream = stream.distinct(); //중복 제거(중간연산)\t\tStream&lt;String&gt; sortedStream = stream.sorted();//정렬(중간연산)\t\tStream&lt;String&gt; limitedStream = stream.limit(5);//스트림자르기(중간연산);\t\tint total = stream.count(); //요소 개수 세기(최종연산)  스트림의 특징          데이터소스로부터 데이터를 읽기만 할 뿐, 변경하지 않음(원본을 건들지 않음. read only)      Iterator처럼 일회용이다(필요하면 다시 스트림을 생성해야함) : 최종연산 후 스트림이 닫혀 사용할 수 없음      최종연산 전까지 중간연산이 수행되지 않는다. - 지연된 연산      작업을 내부 반복으로 처리한다.      작업을 병렬로 처리 - stream.parallel() : 병렬스트림으로 전환(속성만 변경)      기본형 스트림 - IntStream, LongStream, DoubleStream                  오토박싱&amp;언박싱의 비효율이 제거(Stream대신 IntStream사용) - 데이터소스가 기본형일때 사용가능          숫자와 관련된 유용한 메소드를 Stream보다 더 많이 제공                          스트림의 그룹화와 분할                  partitioningBy()는 스트림을 2분할함(다중분할 가능)          import java.util.*;  import java.util.function.*;  import java.util.stream.*;  import static java.util.stream.Collectors.*;  import static java.util.Comparator.*;          class Student{  \tString name;  \tboolean isMale; // 성별  \tint hak;        // 학년  \tint ban;        // 반  \tint score;          \tStudent(String name, boolean isMale, int hak, int ban, int score) {   \t\tthis.name\t= name;  \t\tthis.isMale\t= isMale;  \t\tthis.hak\t= hak;  \t\tthis.ban\t= ban;  \t\tthis.score  = score;  \t}  \tString\tgetName()    { return name;\t}  \tboolean  isMale()     { return isMale;\t}  \tint      getHak()     { return hak;\t}  \tint      getBan()     { return ban;\t}  \tint      getScore()   { return score;}        \t  \tpublic String toString() {  \t\treturn String.format(\"[%s, %s, %d학년 %d반, %3d점]\",name, isMale ? \"남\":\"여\", hak, ban, score);   \t}        \t  \t   // groupingBy()에서 사용  \t\tenum Level { HIGH, MID, LOW }  // 성적을 상, 중, 하 세 단계로 분류  }  class  Main{  \tpublic static void main(String[] args)  {  \t\tStudent[] stuArr = {  \t\t\t\tnew Student(\"나자바\", true,  1, 1, 300),\t  \t\t\t\tnew Student(\"김지미\", false, 1, 1, 250),\t  \t\t\t\tnew Student(\"김자바\", true,  1, 1, 200),\t  \t\t\t\tnew Student(\"이지미\", false, 1, 2, 150),\t  \t\t\t\tnew Student(\"남자바\", true,  1, 2, 100),\t  \t\t\t\tnew Student(\"안지미\", false, 1, 2,  50),\t  \t\t\t\tnew Student(\"황지미\", false, 1, 3, 100),\t  \t\t\t\tnew Student(\"강지미\", false, 1, 3, 150),\t  \t\t\t\tnew Student(\"이자바\", true,  1, 3, 200),\t  \t\t\t\tnew Student(\"나자바\", true,  2, 1, 300),\t  \t\t\t\tnew Student(\"김지미\", false, 2, 1, 250),\t  \t\t\t\tnew Student(\"김자바\", true,  2, 1, 200),\t  \t\t\t\tnew Student(\"이지미\", false, 2, 2, 150),\t  \t\t\t\tnew Student(\"남자바\", true,  2, 2, 100),\t  \t\t\t\tnew Student(\"안지미\", false, 2, 2,  50),\t  \t\t\t\tnew Student(\"황지미\", false, 2, 3, 100),\t  \t\t\t\tnew Student(\"강지미\", false, 2, 3, 150),\t  \t\t\t\tnew Student(\"이자바\", true,  2, 3, 200)\t  \t\t\t};  \t\tSystem.out.printf(\"1. 단순분할(성별로 분할)%n\");  \t\tMap&lt;Boolean, List&lt;Student&gt;&gt; stuBySex =  Stream.of(stuArr).collect(partitioningBy(Student::isMale));        \t\t  \t\tList&lt;Student&gt; maleStudent   = stuBySex.get(true);  \t\tList&lt;Student&gt; femaleStudent = stuBySex.get(false);        \t\t  \t\tfor(Student s : maleStudent)   System.out.println(s);  \t\tfor(Student s : femaleStudent) System.out.println(s);        \t\t  \t\tSystem.out.printf(\"%n2. 단순분할 + 통계(성별 학생수)%n\");  \t\tMap&lt;Boolean, Long&gt; stuNumBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale, counting()));\t          \t\tSystem.out.println(\"남학생 수 :\"+ stuNumBySex.get(true));  \t\tSystem.out.println(\"여학생 수 :\"+ stuNumBySex.get(false));        \t\t  \t\tSystem.out.printf(\"%n3. 단순분할 + 통계(성별 1등)%n\");  \t\tMap&lt;Boolean, Optional&lt;Student&gt;&gt; topScoreBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale, maxBy(comparingInt(Student::getScore))));  \t\tSystem.out.println(\"남학생 1등 :\"+ topScoreBySex.get(true));  \t\tSystem.out.println(\"여학생 1등 :\"+ topScoreBySex.get(false));        \t  \t\tMap&lt;Boolean, Student&gt; topScoreBySex2 = Stream.of(stuArr).collect(partitioningBy(Student::isMale,collectingAndThen(maxBy(comparingInt(Student::getScore)), Optional::get)));  \t\tSystem.out.println(\"남학생 1등:\"+topScoreBySex.get(true));  \t\tSystem.out.println(\"여학생 1등:\"+topScoreBySex.get(false));        \t\t  \t\tSystem.out.printf(\"%n4.다중분할(성적 불합격자, 100점 이하)%n\");        \t\t  \t\tMap&lt;Boolean, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; failedstuBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale,partitioningBy(s-&gt;s.getScore()&lt;=100)));        \t\t  \t\tList&lt;Student&gt; failedMaleStu   = failedstuBySex.get(true).get(true);  \t\tList&lt;Student&gt; failedFemaleStu = failedstuBySex.get(false).get(true);        \t\t  \t\tfor(Student s : failedMaleStu)   System.out.println(s);  \t\tfor(Student s : failedFemaleStu) System.out.println(s);        \t  \t}  }                            groupingBy()는 스트림을 n분할함                import java.util.*;  import java.util.function.*;  import java.util.stream.*;  import static java.util.stream.Collectors.*;  import static java.util.Comparator.*;      class Student3 {  \tString name;  \tboolean isMale; // 성별  \tint hak;        // 학년  \tint ban;        // 반  \tint score;      \tStudent3(String name, boolean isMale, int hak, int ban, int score) {   \t\tthis.name\t= name;  \t\tthis.isMale\t= isMale;  \t\tthis.hak   \t= hak;  \t\tthis.ban\t= ban;  \t\tthis.score \t= score;  \t}      \tString\tgetName() \t { return name;    }  \tboolean isMale()  \t { return isMale;  }  \tint\t\tgetHak()   \t { return hak;\t   }  \tint\t\tgetBan()  \t { return ban;\t   }  \tint\t\tgetScore()\t { return score;   }      \tpublic String toString() {  \t\treturn String.format(\"[%s, %s, %d학년 %d반, %3d점]\", name, isMale ? \"남\" : \"여\", hak, ban, score);  \t}      \tenum Level {  \t\tHIGH, MID, LOW  \t}  }      class Main {  \tpublic static void main(String[] args) {  \t\tStudent3[] stuArr = {  \t\t\tnew Student3(\"나자바\", true,  1, 1, 300),\t  \t\t\tnew Student3(\"김지미\", false, 1, 1, 250),\t  \t\t\tnew Student3(\"김자바\", true,  1, 1, 200),\t  \t\t\tnew Student3(\"이지미\", false, 1, 2, 150),\t  \t\t\tnew Student3(\"남자바\", true,  1, 2, 100),\t  \t\t\tnew Student3(\"안지미\", false, 1, 2,  50),\t  \t\t\tnew Student3(\"황지미\", false, 1, 3, 100),\t  \t\t\tnew Student3(\"강지미\", false, 1, 3, 150),\t  \t\t\tnew Student3(\"이자바\", true,  1, 3, 200),\t  \t\t\tnew Student3(\"나자바\", true,  2, 1, 300),\t  \t\t\tnew Student3(\"김지미\", false, 2, 1, 250),\t  \t\t\tnew Student3(\"김자바\", true,  2, 1, 200),\t  \t\t\tnew Student3(\"이지미\", false, 2, 2, 150),\t  \t\t\tnew Student3(\"남자바\", true,  2, 2, 100),\t  \t\t\tnew Student3(\"안지미\", false, 2, 2,  50),\t  \t\t\tnew Student3(\"황지미\", false, 2, 3, 100),\t  \t\t\tnew Student3(\"강지미\", false, 2, 3, 150),\t  \t\t\tnew Student3(\"이자바\", true,  2, 3, 200)\t  \t\t};      \t\tSystem.out.printf(\"1. 단순그룹화(반별로 그룹화)%n\");  \t\tMap&lt;Integer, List&lt;Student3&gt;&gt; stuByBan = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getBan));      \t\tfor(List&lt;Student3&gt; ban : stuByBan.values()) {  \t\t\tfor(Student3 s : ban) {  \t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}      \t\tSystem.out.printf(\"%n2. 단순그룹화(성적별로 그룹화)%n\");  \t\tMap&lt;Student3.Level, List&lt;Student3&gt;&gt; stuByLevel = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(s-&gt; {  \t\t\t\t\t\t if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\telse                         return Student3.Level.LOW;  \t\t\t\t}));      \t\tTreeSet&lt;Student3.Level&gt; keySet = new TreeSet&lt;&gt;(stuByLevel.keySet());      \t\tfor(Student3.Level key : keySet) {  \t\t\tSystem.out.println(\"[\"+key+\"]\");      \t\t\tfor(Student3 s : stuByLevel.get(key))  \t\t\t\tSystem.out.println(s);  \t\t\tSystem.out.println();  \t\t}      \t\tSystem.out.printf(\"%n3. 단순그룹화 + 통계(성적별 학생수)%n\");  \t\tMap&lt;Student3.Level, Long&gt; stuCntByLevel = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(s-&gt; {  \t\t\t\t\t     if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\telse                         return Student3.Level.LOW;  \t\t\t\t}, counting()));  \t\tfor(Student3.Level key : stuCntByLevel.keySet())  \t\t\tSystem.out.printf(\"[%s] - %d명, \", key, stuCntByLevel.get(key));  \t\tSystem.out.println();  /*  \t\tfor(List&lt;Student3&gt; level : stuByLevel.values()) {  \t\t\tSystem.out.println();  \t\t\tfor(Student3 s : level) {  \t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}  */  \t\tSystem.out.printf(\"%n4. 다중그룹화(학년별, 반별)\");  \t\tMap&lt;Integer, Map&lt;Integer, List&lt;Student3&gt;&gt;&gt; stuByHakAndBan =            Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getHak,  \t\t\t\t\t\t groupingBy(Student3::getBan)  \t\t\t\t));      \t\tfor(Map&lt;Integer, List&lt;Student3&gt;&gt; hak : stuByHakAndBan.values()) {  \t\t\tfor(List&lt;Student3&gt; ban : hak.values()) {  \t\t\t\tSystem.out.println();  \t\t\t\tfor(Student3 s : ban)  \t\t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}      \t\tSystem.out.printf(\"%n5. 다중그룹화 + 통계(학년별, 반별 1등)%n\");  \t\tMap&lt;Integer, Map&lt;Integer, Student3&gt;&gt; topStuByHakAndBan =            Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getHak,  \t\t\t\t\t\t groupingBy(Student3::getBan,  \t\t\t\t\t\t     collectingAndThen(  \t\t\t\t\t\t         maxBy(comparingInt(Student3::getScore))  \t\t\t\t\t\t         , Optional::get  \t\t\t\t\t\t     )  \t\t\t\t\t\t )  \t\t\t\t));      \t\tfor(Map&lt;Integer, Student3&gt; ban : topStuByHakAndBan.values())  \t\t\tfor(Student3 s : ban.values())  \t\t\t\tSystem.out.println(s);      \t\tSystem.out.printf(\"%n6. 다중그룹화 + 통계(학년별, 반별 성적그룹)%n\");  \t\tMap&lt;String, Set&lt;Student3.Level&gt;&gt; stuByScoreGroup = Stream.of(stuArr)  \t\t\t.collect(groupingBy(s-&gt; s.getHak() + \"-\" + s.getBan(),  \t\t\t\t\tmapping(s-&gt; {  \t\t\t\t\t\t if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\t\t else                    return Student3.Level.LOW;  \t\t\t\t\t} , toSet())  \t\t\t));      \t\tSet&lt;String&gt; keySet2 = stuByScoreGroup.keySet();      \t\tfor(String key : keySet2) {  \t\t\tSystem.out.println(\"[\"+key+\"]\" + stuByScoreGroup.get(key));  \t\t}  \t}    }      Optional: T타입 객체의 래퍼클래스. null을 간접적으로 사용하기 위해 씀null을 Optional객체 안에 넣어서 사용. null값이 필요할떄 빈Optional객체의 주소값을 받음  Optional객체의 값 가지고 오기 - get(), orElse(), orElseGet(), orElseThrow()  isPresent() : Optional객체의 값이 null이면 false, 아니면 true - null이 아닐때만 작업 수행— 사용이유  null을 직접 다루는 것은 위험 - nullPointException 위험 → 간접적으로 null을 사용하기 위해 사용  null체크는 if문 필수 : 코드가 지저분해짐 → 코드를 깔끔히 하기위해 사용import java.util.Optional;class  Main{\tpublic static void main(String[] args)  {//\t\tint arr[] = null; //nullpointException발생\t\tint arr[] = new int[0];\t\tSystem.out.println(\"arr.length = \"+arr.length);\t\t//\t\tOptional&lt;String&gt; opt = null; //가능한데 바람직하지않음\t\tOptional&lt;String&gt; opt = Optional.empty();//\t\tOptional&lt;String&gt; opt = Optional.of(\"abc\");\t\tSystem.out.println(\"opt=\"+opt);//\t\tSystem.out.println(\"opt.get()=\"+opt.get()); //에러. 값이없어서. 이래서 잘 안씀//\t\tString str = \"\";//\t\ttry {//\t\t\tstr = opt.get(); //\t\t} catch (Exception e) {//\t\t\tstr = \"\"; //예외 발생시 빈문자열(\"\")로 초기화//\t\t}//\t\tSystem.out.println();\t\t\t\t//Optional에 저장된 값이 null이면 \"\"반환//\t\tString str = opt.orElse(\"\");//\t\tString str = opt.orElseGet(()-&gt;new String());\t\tString str = opt.orElseGet(String::new);\t\tSystem.out.println(\"str=\"+str);\t}}      기본형을 감싸는 래퍼클래스 - OptionalInt, OptionalLong, OptionalDouble - Optional를 써도 되지만 성능이 떨어짐                            Optional클래스          값을 반환하는 메소드                                      Optional          T get()                          OptionalInt          int gerAsInt()                          OptionalLong          long gerAsLong()                          OptionalDouble          double getAsDouble()                            빈 Optional객체와의 비교 - OptionalInt.of(0)과 OptionalInt.empty() 구별에 isPresent()를 사용  OptionalInt.of(0)은 true, OptionalInt.empty()는 false. 두개 equals해도 false나옴          import java.util.Optional;  import java.util.OptionalInt;      class  Main{  \tpublic static void main(String[] args)  {  \t\tOptional&lt;String&gt; optStr = Optional.of(\"abcde\");  \t\tOptional&lt;Integer&gt; optInt = optStr.map(String::length);  \t\tSystem.out.println(\"optStr=\"+optStr.get());  \t\tSystem.out.println(\"optInt=\"+optInt.get());    \t\t  \t\tint result1 = Optional.of(\"123\")  \t\t\t\t.filter(x-&gt;x.length() &gt;0)  \t\t\t\t.map(Integer::parseInt).get();    \t\t  \t\tint result2 = Optional.of(\"\")  \t\t\t\t.filter(x-&gt;x.length() &gt;0) //false  \t\t\t\t.map(Integer::parseInt).orElse(-1); //값이 없으면 -1 반환    \t\t  \t\tSystem.out.println(\"result1 = \"+result1);  \t\tSystem.out.println(\"result2 = \"+result2);    \t\t  \t\tOptional.of(\"456\").map(Integer::parseInt)  \t\t.ifPresent(x-&gt;System.out.printf(\"result3 = %d%n\",x)); //ifPresent : 값이 있으면    \t\t  \t\tOptionalInt optInt1 = OptionalInt.of(0); //0을 저장  \t\tOptionalInt optInt2 = OptionalInt.empty(); //빈 객체 생성    \t\t  \t\tSystem.out.println(optInt1.isPresent()); //true  \t\tSystem.out.println(optInt2.isPresent()); //false  \t\tSystem.out.println(\"optInt1=\"+optInt1);  \t\tSystem.out.println(\"optInt2=\"+optInt2);  \t\tSystem.out.println(\"opt1.equals(optInt2)?\"+optInt1.equals(optInt2));//false  \t}  }      "
  },
  
  {
    "title": "자바의 정석 강의 - 쓰레드(thread)",
    "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C(thread)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 쓰레드",
    "date": "2022-08-28 00:00:00 +0900",
    





    
    "snippet": "프로세스와 쓰레드(process &amp; thread)  프로세스 : 실행중인 프로그램. 자원(resources)과 쓰레드로 구성 (공장)  쓰레드 : 프로세스 내에서 실제 작업을 수행. 모든 프로세서는 최소 하나의 쓰레드를 가지고 있다. (일꾼)      싱글 쓰레드 프로세스 = 자원 + 쓰레드      public class  Main {    ...",
    "content": "프로세스와 쓰레드(process &amp; thread)  프로세스 : 실행중인 프로그램. 자원(resources)과 쓰레드로 구성 (공장)  쓰레드 : 프로세스 내에서 실제 작업을 수행. 모든 프로세서는 최소 하나의 쓰레드를 가지고 있다. (일꾼)      싱글 쓰레드 프로세스 = 자원 + 쓰레드      public class  Main {      \tpublic static void main(String[] args) {  \t\tlong startTime = System.currentTimeMillis();    \t\t  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.printf(\"%s\", new String(\"-\"));  \t\t}    \t\t  \t\tSystem.out.println(\"소요시간 1 : \"+(System.currentTimeMillis()-startTime));    \t\t  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.printf(\"%s\", new String(\"|\"));  \t\t}  \t\tSystem.out.println(\"소요시간 2 : \"+(System.currentTimeMillis()-startTime));  \t} // 싱글쓰레드라 작업이 겹치지 않음  }        멀티 쓰레드 프로세스 = 자원 + 쓰레드 + 쓰레드…+쓰레드 (대부분이 멀티쓰레드)          장점                  시스템 자원을 보다 효율적으로 사용가능          사용자에 대한 응답성(responsencess)이 향상된다.          작업이 분리되어 코드가 간결해짐                            단점 : 고려할 사항이 많음                  동기화(synchronization)에 주의          교착상태(dead-lock)가 발생하지 않도록 주의          각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야함          context switching(쓰레드 전환)으로 시간이 좀 더 걸림                  public class  Main {          \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tThread2 t2 = new Thread2();  \t\tt1.start();  \t\tt2.start();  \t}   }          class Thread1 extends Thread{  \tpublic void run () {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t}  }  class Thread2 extends Thread{  \tpublic void run () {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(\"|\");  \t\t}  \t}  }  //멀티쓰레드라 번갈아가면서 실행됨                  public class  Main {  \tstatic long startTime = 0;          \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tt1.start();   \t\tstartTime = System.currentTimeMillis();        \t\t  \t\tfor(int i=0; i&lt;300; i++)   \t\t\tSystem.out.printf(\"%s\",new String(\"-\"));        \t\t  \t\tSystem.out.println(\"소요시간1 : \"+(System.currentTimeMillis() - startTime));  \t}  }          class Thread1 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++)   \t\t\tSystem.out.printf(\"%s\", new String(\"|\"));        \t\t  \t\tSystem.out.println(\"소요시간2 : \"+(System.currentTimeMillis() - Main.startTime));  \t}  }  // 멀티쓰레드라 번갈아가면서 실행됨                      쓰레드 구현과 실행                  Thread클래스를 상속(자바는 단일상속만 허용해서 쓰레드를 상속받으면 다른 것은 상속받을수 없음  class MyThread wxtends Thread { public void run(){ /Thread클래스의 run()을 오버라이딩/ }}  MyThread t = new MyThread(); //쓰레드 생성  t1.start(); //쓰레드의 실행                    Runnable인터페이스를 구현        class TyThread implements Runnable { public void run() { /Runnable인터페이스의 추상메소드 run()을 구현/}}  Runnable r = new MyThread();  Thread t = new Thread(r); //Thread(Runnable r)  //Thread t = new Thread(new MyThread()); //위에꺼 한줄로 줄임  t.start();                  쓰레드의 실행 - start() : 쓰레드를 생성한 후에 start를 호출해야 쓰레드가 작업을 시작함    — 각각의 쓰레드가 각각의 호출 스택을 가지고 있어 서로 독립적으로 작업을 수행함      public class  Main {  \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();    \t\t  \t\tRunnable r = new Thread2();  \t\tThread t2 = new Thread(r);  //생성자 Thread(Runnable target)    \t\t  \t\tt1.start(); //start했다고 바로 실행 안됨  \t\tt2.start(); //OS의 스케줄러가 실행순서를 결정. t1이 먼저 실행될 확률이 높기는 하나 100프로는 아님  \t}  }      class Thread1 extends Thread { //쓰레드 클래스를 상속해서 구현  \tpublic void run() { //쓰레드가 수행할 작업을 작성  \t\tfor(int i=0; i&lt;500; i++) {  \t\t\tSystem.out.print(getName()); //조상인 Thread의 getName()을 호출  \t\t}  \t}  }      class Thread2 implements Runnable{ //Runnable인터페이스를 구현해서 쓰레드를 구현  \tpublic void run() { ////쓰레드가 수행할 작업을 작성  \t\tfor(int  i=0;i&lt;500;i++) {  \t\t\t//Thread.currentThread() - 현재 실행중인 Thread를 반환  \t\t\tSystem.out.print(Thread.currentThread().getName());  \t\t}  \t}  }  //순서대로 실행되는게 아니라 번갈아서 실행됨        start()와 run()      main쓰레드 : main메소드의 코드를 수행하는 쓰레드.      public class  Main {  \tstatic long startTime = 0;      \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tThread2 t2 = new Thread2();  \t\tt1.start();   \t\tt2.start();   \t\tstartTime = System.currentTimeMillis();    \t\t  \t\ttry {  \t\t\tt1.join(); //main쓰레드가 th1의 작업이 끝날 떄까지 기다린다.  \t\t\tt2.join(); //main쓰레드가 th2의 작업이 끝날 때까지 기다린다.  \t\t}catch(InterruptedException e) {}    \t\t  \t\tSystem.out.println(\"소요시간 : \"+(System.currentTimeMillis() - startTime));  \t}  }      class Thread1 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t}  }  class Thread2 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"|\");   \t\t}  \t}  }              사용자 쓰레드                  메인쓰레드.          실행중인 사용자쓰레드가 하나도 없을때, 프로그램 종료                            데몬 쓰레드(daemon Thread)                  일반 쓰레드(non-daemon thread)의 작업을 돕는 보조적인 역할을 수행          일반쓰레드가 모두 종료되면 자동적으로 종료된다          가비지 컬렉터(쓰지않는 메모리 정리), 자동저장, 화면 자동갱신 등에 사용됨          무한루프와 조건문(while(true) 등)을 이용해서 실행 후 대기하다가 특정조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다.                  boolean inDaemon() //쓰레드가 데몬 쓰레드인지 확인. 데몬쓰레드이면 true반환  void setDaemon(boolean on) //쓰레드를 데몬쓰레드로 또는 사용자 쓰레드로 변경. 매개변수 on을 true로 지정하면 데몬쓰레드가 된다.                  public class  Main implements Runnable {  \tstatic boolean autoSave = false;          \tpublic static void main(String[] args) {  \t\tThread t = new Thread(new Main()); //Thread(Runnable r)  \t\tt.setDaemon(true); //이부분이 없이면 종료되지 않음  \t\tt.start();        \t\t  \t\tfor(int i=1;i&lt;=10;i++) {  \t\t\ttry {  \t\t\t\tThread.sleep(1000);  \t\t\t}catch (InterruptedException e) {}  \t\t\tSystem.out.println(i);        \t\t\t  \t\t\tif(i==5) autoSave = true;  \t\t}  \t\tSystem.out.println(\"프로그램을 종료합니다.\");  \t}  \tpublic void run() {  \t\twhile(true) { //무한루프지만 메인쓰레드가 종료되면(일반쓰레드가 하나도 없으면) 같이 종료될 예정임(데몬쓰레드라서)  \t\t\ttry {  \t\t\t\tThread.sleep(3*1000);//3초마다  \t\t\t}catch(InterruptedException e) {}        \t\t\t  \t\t\tif(autoSave) autoSave();  \t\t}  \t}  \tprivate void autoSave() {  \t\tSystem.out.println(\"파일이 자동저장되었습니다\");  \t}\t  }                          쓰레드의 I/O블락킹(blocking) : 사용자가 입력할때까지 아무것도 하지않고 멈춤(멀티쓰레드는 이때에 다른 쓰레드가 일하면 됨)  ⇒ 멀티쓰레드일때 더 빠름          싱글쓰레드          import javax.swing.JOptionPane;      public class  Main {      \tpublic static void main(String[] args) {  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은 \" +input+\"입니다.\");    \t\t  \t\tfor(int i=10; i&gt;0; i--) {  \t\t\tSystem.out.println(i);  \t\t\ttry {  \t\t\t\tThread.sleep(100); //1초간 정지  \t\t\t}catch (Exception e) {}  }  \t}  }              멀티쓰레드          import javax.swing.JOptionPane;      public class  Main {      \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tth1.start();    \t\t  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은 \" +input+\"입니다.\");    \t\t  \t\t}\t  \t}      class Thread1 extends Thread{  \tpublic void run() {  \t\tfor(int i=10; i&gt;0; i--) {  \t\t\tSystem.out.println(i);  \t\t\ttry {  \t\t\t\tThread.sleep(100); //1초간 정지  \t\t\t}catch (Exception e) {}  \t\t}  \t}  }  //입력을 안해도 카운트다운이 진행됨. -&gt; 프로그램 먼저 종료            쓰레드의 우선순위(priority of thread) : 작업의 중요도에 따라 쓰레드의 우선순위를 다르게 하여 특정 쓰레드가 더 많은 작업시간을 갖게 할 수 있다. (1~10까지 부여. 10이 최대 우선순위, 5가 보통 우선순위, 1이 최소 우선순위)      void setPriority(int new Priority); //쓰레드의 우선순위를 지정한 값으로 변경  int getPriority();      public static final int MAX_PRIORITY = 10; //최대 우선순위  public static final int MIN_PRIORITY = 1; //최소 우선순위  public static final int NORM_PRIORITY = 5; //보통 우선순위            쓰레드 그룹          서로 관련된 쓰레드를 그룹으로 묶어서 다루기위한 것      모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함되어 있어야한다.      쓰레드 그룹을 지정하지 않으면 생성한 쓰레드는 ‘main쓰레드 그룹’에 속한다      자신을 생성한 쓰레드(부모 쓰레드)의 그룹과 우선순위를 상속받는다.          Thread(ThreadGroup group, String name)  Thread(ThreadGroup group, Runnable target)  Thread(ThreadGroup group, Runnable target, String name)  Thread(ThreadGroup group, Runnable target, String name, long stackSize)      ThreadGroup getThreadGroup() //자신이 속한 쓰레드 그룹을 반환한다.  void uncaughtException(Thread t, Throwable e) //처리되지 않은 예외에 의해 쓰렏  //그룹에 의해 쓰레드가 실행종료되었을 때, JVM에 의해 매소드가 자동적으로 호출된가.                                ![[IMG-20240902151251.png          IMG-20240902151251.png]]                          쓰레드의 상태                            상태          설명                                      NEW          쓰레드가 _생성_되고 아직 start가 호출되지 않은 상태                          RUNNABLE          실행 중 또는 실행 가능한 상태(대기열에 대기중)                          BLOCKED          동기화 블럭에 의해 _일시정지_된 상태(lock이 풀릴 때 까지 기다리는 상태)                          WAITING TIMED_WAITING          쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnalble) 일시정지상태, TIMED_WAITING은 _일시정지시간_이 지정된 경우를 의미                          TERMINATED          쓰레드의 작업이 _종료_된 상태                          쓰레드의 실행제어          쓰레드의 실행을 제어할 수 있는 메소드가 제공된다.                                ![[IMG-20240902151251-1.png          IMG-20240902151251-1.png]]                      static붙은건 자기 자신에게만 적용됨                  sleep() : 현재 스레드를 지정된 시간동안 멈추게 한다.  static void sleep(long millis) //천분의 1초 단위  static void sleep(long millis, int nanos) //천분의 일초 + 나노초                              예외처리를 해줘야 한다. 예외 필수처리(InterruptedException이 발생하면 깨어남)            try { Thread.sleep(1,500000); //쓰레드를 0.0015초동안 멈추게한다  } catch (InterruptedException e){} //누가 깨운 상태                                특정 쓰레드를 지정해서 멈추게 하는 것은 불가능하다.(th1.sleep()으로 쓰면 가능은 하지만 오해의 여지가 있어서 Thread.sleep()으로 써야함)                            class  Main{  \tstatic void delay(long millis) {  \t\ttry {  //\t\t\tth1.sleep(2000); //th1을 2초 잠자게가 아니고 main쓰레드가 잠이드는데, 이렇게 쓰면 헷갈림  \t\t\tThread.sleep(millis);  \t\t}catch (InterruptedException e){}  \t}  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tThread2 th2 = new Thread2();  \t\tth1.start();  \t\tth2.start();        \t\t  \t\tdelay(2*1000);        \t\t  \t\tSystem.out.println(\"&lt;&lt;main 종료&gt;&gt;\");  \t}  }  class Thread1 extends Thread {  \tpublic void run(){  \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t\tSystem.out.println(\"&lt;&lt;th1 종료&gt;&gt;\");  \t}  }  class Thread2 extends Thread {  \tpublic void run(){  \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"|\");  \t\t}  \t\tSystem.out.println(\"&lt;&lt;th2 종료&gt;&gt;\");  \t}  }                            interrupt()                  대기상태(WAITING)의 쓰레드를 실행대기 상태(RUNNABLE) 로 만든다                  import javax.swing.JOptionPane;          class  Main{  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tth1.start();        \t\t  \t\tSystem.out.println(\"interrupted() : \"+th1.isInterrupted()); //true반환  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은\"+input+\"입니다\");  \t\tth1.interrupt();  \t\tSystem.out.println(\"isInterrupted() : \"+th1.isInterrupted()); //true반환  \t\tSystem.out.println(\"isInterrupted() : \"+th1.isInterrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+th1.interrupted()); //false반환. static메소드임. main쓰레드의 Interrupt되었는지 확인  \t\t//카운트 세는 도중, 입력값을 주면 카운트 종료  \t\t//게임에서 계속하시겠습니까?하고 카운트세다가 y/n선택하면 카운트 종료되는거 이거임  \t}  }  class Thread1 extends Thread{  \tpublic void run() {  \t\tint i=10;        \t\t  \t\twhile (i!=0 &amp;&amp; !isInterrupted()) {  \t\t\tSystem.out.println(i--);  \t\t\tfor(long x=0;x&lt;2500000000L;x++); //시간지연  \t\t}  \t\tSystem.out.println(\"isInterrupted() : \"+this.isInterrupted()); //true반환  \t\tSystem.out.println(\"isInterrupted() : \"+this.isInterrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+this.interrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+this.interrupted()); //false 위에서 확인 후 초기화 됨.  \t\t//isInterrupted()와 달리 interrupted는 interrupted라는 상태변수를 false로 초기화  \t\tSystem.out.println(\"카운트가 종료되었습니다.\");  \t}  }                      — 아래 3개 모두 deprecated되었음. 사용 권장안함. dead-lock가능성이 있음          suspend() : 쓰레드 일시정지      resume() : suspend()에 의해 일시정지 된 쓰레드를 실행대기상태로 만든다. (재개)      stop() : 완전 정지. 즉시종료          class  Main{  \tpublic static void main(String[] args) {  \t\tMyThread th1 = new MyThread(\"*\");  \t\tMyThread th2 = new MyThread(\"**\");  \t\tMyThread th3 = new MyThread(\"***\");    \t\t  \t\tth1.start();  \t\tth2.start();  \t\tth3.start();    \t\t  \t\ttry {  \t\t\tThread.sleep(2000);  \t\t\tth1.suspend(); //쓰레드 th1을 잠시 중단  \t\t\tThread.sleep(2000);  \t\t\tth2.suspend();   \t\t\tThread.sleep(3000);  \t\t\tth1.resume(); //쓰레드 th1 재 동작  \t\t\tThread.sleep(3000);  \t\t\tth1.stop();  \t\t\tth2.stop();  \t\t\tThread.sleep(2000);  \t\t\tth3.stop();  \t\t} catch (InterruptedException e) {}  \t}  }      class MyThread implements Runnable{  \tvolatile boolean suspended = false;   \t//volatile : 쉽게 바뀌는 변수(cpu의 코어는 복사본을 가지고 있는데(가끔 원본의 값이 변경됐을때 복사본의 값은 안바뀌는 경우 발생), volatile을 사용하면 원본을 바로 사용함  \t//자주 바뀌는 값이니까 복사본말고 원본 쓰라는 의미  \tvolatile boolean stopped = false;     \t  \tThread th;    \t  \tMyThread(String name){  \t\tth = new Thread(this,name);  \t}  \tvoid start() {  \t\tth.start();  \t}    \t  \tvoid stop() {  \t\tstopped = true;  \t}    \t  \tvoid suspend() { //일시정지  \t\tsuspended = true;  \t}    \t  \tvoid resume() { //재실행  \t\tsuspended = false;  \t}  \tpublic void run() {  \t\twhile(!stopped) {  \t\t\tif(!suspended) {  \t\t\tSystem.out.println(Thread.currentThread().getName());  \t\t\ttry {  \t\t\t\tThread.sleep(1000); //1초마다 쓰레드 이름찍기  \t\t\t} catch(InterruptedException e) {}  \t\t\t}  \t\t}  \t}  }              join() : 지정된 시간동안 특정 쓰레드가 작업하는 것을 기다린다. 예외처리 필수 (InterruptedException이 발생하면 작업 재개)          class  Main{  \tstatic long starttime = 0;  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tThread2 th2 = new Thread2();  \t\tth1.start();  \t\tth2.start();  \t\tstarttime = System.currentTimeMillis();    \t\t  \t\ttry {  \t\t\tth1.join(); //main쓰레드가 th1의 작업이 끝날때까지 기다린다.  \t\t\tth2.join(); //main쓰레드가 th2의 작업이 끝날때까지 기다린다.  \t\t}catch(InterruptedException e) {}  \t\t//이거 안해주면 main쓰레드가 먼저 끝나서 소요시간이 제대로 안나옴. 덜끝났는데 시간을 계산해버림    \t\t  \t\tSystem.out.println(\"소요시간 : \"+(System.currentTimeMillis()-starttime));    \t\t  \t}  }  class Thread1 extends Thread{  \tpublic void run() {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(new String(\"-\"));  \t\t}  \t}  }  class Thread2 extends Thread{  \tpublic void run() {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(new String(\"|\"));  \t\t}  \t}  }          public void run() {  \twhile(true) {  \t\ttry {  \t\tThread.sleep(10*1000); //10초 기다림  \t\t}catch(InterruptedException e) {}  \t\tSystem.out.println(\"Awaken by interrupt().\");  \t}  \tgc(); //garbage collection을 수행 : 사용하지 않는 객체 제거  \tSystem.out.println(\"Garbage Collection. Free Memory : \"+freeMemory());  }      for(int i=0;i&lt;20;i++) {  \trequiredMemory = (int)(Math.random()*10)*20; //requiredMemory 필요한 메모리  \t//필요한 메모리가 사용할 수 있는 양보다 적거나 전체 메모리의 60%이상 사용했을 경우 gc를 깨운다  \tif(gc.freeMemry()&lt; requireMemory || gc.freeMemory()&lt;gc.totalMemory()*0.4) { //메모리 부족한 경우  \t\tgc.interrupt(); //잠자고있는 쓰레드 gc를 깨운다  \t\ttry {  \t\t\tgc.join(100); //gc가 작업(메모리정리)할 시간을 줌. 0.1초  \t\t}catch(InterruptedException e) {}  \t}  \tgc.usedMemory += requiredMemory; //메모리 사용  \tSystem.out.println(\"usedMemory : \"+gc.usedMemory);  }              yield() : 남은 시간을 다음 쓰레드에게 양보하고, 자신(현재 쓰레드)은 실행대기한다. yield()와 interrupt()를 적절히 사용하면, 응답성과 효율을 높일 수 있다.          class  Main{  \tpublic static void main(String[] args) {  \t\tMyThread th1 = new MyThread(\"*\");  \t\tMyThread th2 = new MyThread(\"**\");  \t\tMyThread th3 = new MyThread(\"***\");    \t\t  \t\tth1.start();  \t\tth2.start();  \t\tth3.start();    \t\t  \t\ttry {  \t\t\tThread.sleep(2000);  \t\t\tth1.suspend(); //쓰레드 th1을 잠시 중단  \t\t\tThread.sleep(2000);  \t\t\tth2.suspend();   \t\t\tThread.sleep(3000);  \t\t\tth1.resume(); //쓰레드 th1 재 동작  \t\t\tThread.sleep(3000);  \t\t\tth1.stop();  \t\t\tth2.stop();  \t\t\tThread.sleep(2000);  \t\t\tth3.stop();  \t\t} catch (InterruptedException e) {}  \t}  }      class MyThread implements Runnable{  \tvolatile boolean suspended = false;   \t//volatile : 쉽게 바뀌는 변수(cpu의 코어는 복사본을 가지고 있는데(가끔 원본의 값이 변경됐을때 복사본의 값은 안바뀌는 경우 발생), volatile을 사용하면 원본을 바로 사용함  \t//자주 바뀌는 값이니까 복사본말고 원본 쓰라는 의미  \tvolatile boolean stopped = false;     \t  \tThread th;    \t  \tMyThread(String name){  \t\tth = new Thread(this,name);  \t}  \tvoid start() {  \t\tth.start();  \t}    \t  \tvoid stop() {  \t\tstopped = true;  \t\tth.interrupt(); //쓰레드가 자고있을 확률이 있어서 깨워줌  \t}    \t  \tvoid suspend() { //일시정지  \t\tsuspended = true;  \t\tth.interrupt(); //쓰레드가 자고있을 확률이 있어서 깨워줌  \t}    \t  \tvoid resume() { //재실행  \t\tsuspended = false;  \t}  \tpublic void run() {  \t\twhile(!stopped) {  \t\t\tif(!suspended) {  \t\t\tSystem.out.println(Thread.currentThread().getName());  \t\t\ttry {  \t\t\t\tThread.sleep(1000); //1초마다 쓰레드 이름찍기  \t\t\t} catch(InterruptedException e) {}  \t\t\t}else {  \t\t\t\tThread.yield(); //쓰레드가 일시정지 상태이면, 다른 쓰레드에게 순서를 양보함. os에게 통보는 하지만 반드시 작동한다는 보장은 없음.(써도 큰 차이는 없음..^^  \t\t\t}  \t\t}  \t}  }        쓰레드의 동기화(synchronization)          멀티 쓰레드 프로세스에서는 다른 쓰레드의 작업에 영향을 미칠 수 있다.      진행중인 작업이 다른 쓰레드에게 간섭받지 않게 하려면 ‘동기화’가 필요      쓰레드 동기화 : 한 스레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는것      동기화 하려면 간섭받지 않아야 하는 문장들을 ‘임계 영역(critical section)’으로 설정      임계영역은 락(lock)을 얻은 단 하나의 쓰레드만 출입가능(객체 1개에 락 1개)            synchronized를 이용한 동기화          synchronized로 임계영역(lock이 걸리는 영역)을 설정하는 방법 2가지                      메소드 전체를 임계 영역으로 지정(많을수록 성능이 떨어져서 최소한으로 좁은 영역에 쓰는 것이 좋음. 메소드 전체를 임계영역으로 지정하는 것은 비효율적)        Public synchronized void calcSum(){ /**/ }                    특정한 영역을 임계 영역으로 지정 synchronized(객체의 참조변수){ /**/ }                class Account{  \t//계좌에 1000있음  \tprivate int balance = 1000; //private로 해야 동기화가 의미있음    \t  \tpublic int getBalance() {  \t\treturn balance;  \t}  \t//출금 메소드. 잔고뺄떄 쓰레드 여러개가 들어오면 마이너스잔고가 뜰수도 잇음. 임계영역 지정  \tpublic synchronized void withdraw(int money) { //synchronized로 메소드를 동기화  \t\tif(balance&gt;=money) { //잔고보다 출금하려는 돈이 많아야 출금 가능  \t\t\ttry{Thread.sleep(1000); //별 의미없는 코드  \t\t\t} catch(InterruptedException e) {}  \t\t\tbalance -= money;  \t\t}//임계영역  \t}  }      class RunnableEx1 implements Runnable {  \tAccount acc = new Account();      \tpublic void run() {  \t\twhile(acc.getBalance()&gt;0) {  \t\t\t//100,200,300 중 한 값을 임으로 선택해서 출금(withdraw)  \t\t\tint money = (int)(Math.random()*3+1)*100;  \t\t\tacc.withdraw(money);  \t\t\tSystem.out.println(\"balance : \"+acc.getBalance());  \t\t}  \t}   }  class  Main{  \tpublic static void main(String[] args) {  \t\tRunnableEx1 r = new RunnableEx1();  \t\tnew Thread(r).start(); //ThreadGroup에 의해 참조되므로 gc대상이 아니다  \t\tnew Thread(r).start(); //ThreadGroup에 의해 참조되므로 gc대상이 아니다    \t\t  \t}  }            wait(), notify()          동기화의 효율을 높이기 위해 사용      Object클래스에 정의되어 있으며, 동기화 블록 내에서만 사용할 수 있다.      wait() : 객체의 lock을 풀고 쓰레드를 해당 객체의 waiting pool에 넣는다      notify() : waiting pool에서 대기중인 쓰레드 중의 하나를 깨운다.      notifyAll() : waiting pool에서 대기중인 모든 쓰레드를 깨운다.          class Account{  \t//계좌에 1000있음  \tprivate int balance = 1000; //private로 해야 동기화가 의미있음    \t  \tpublic synchronized void withdraw(int money) { //synchronized로 메소드를 동기화  \t\tif(balance &lt;money) {  \t\t\ttry{  \t\t\t\twait(); //대기, 락을 풀고 기다린다. 통지를 받으면 락을 재획득  \t\t\t} catch(InterruptedException e) {}  \t\t\tbalance -= money;  \t\t}//임계영역  \t}    \t  \tpublic synchronized void deposit(int money) {  \t\tbalance += money;  \t\tnotify(); //통지. 대기중인 쓰레드 중 하나에게 알림  \t}  }      class  Main{  \tpublic static void main(String[] args) {  \t}  }          import java.util.ArrayList;;      class Customer implements Runnable{  \tprivate Table table;  \tprivate String food;    \t  \tCustomer(Table table, String food){  \t\tthis.table = table;  \t\tthis.food = food;  \t}    \t  \tpublic void run() {  \t\twhile(true) {  \t\t\ttry { Thread.sleep(0);} catch(InterruptedException e) {}  \t\t\tString name = Thread.currentThread().getName();    \t\t\t  \t\t\ttable.remove(food);  \t\t\tSystem.out.println(name + \" ate a \"+food);  \t\t}  \t}  }    \t  class Cook implements Runnable{  \tprivate Table table;    \t  \tCook(Table  table){ this.table = table;}    \t  \tpublic void run() {  \t\twhile(true) {  \t\t\tint idx = (int)(Math.random()*table.dishNum());  \t\t\ttable.add(table.dishNames[idx]);  \t\t\ttry {Thread.sleep(10);} catch(InterruptedException e) {}  \t\t}  \t}  }  class Table {  \tString [] dishNames = {\"donut\",\"donut\", \"burger\"}; //donut의 확률을 높인다  \tfinal int MAX_FOOD = 6;  \tprivate ArrayList&lt;String&gt; dishes = new ArrayList&lt;&gt;();    \t  \tpublic synchronized void add(String dish) {  \t\twhile(dishes.size()&gt;=MAX_FOOD) {  \t\t\tString name = Thread.currentThread().getName();  \t\t\tSystem.out.println(name+\" is waiting.\");  \t\t\ttry {  \t\t\t\twait(); //COOK쓰레드(요리사)를 기다린다.  \t\t\t\tThread.sleep(500);  \t\t\t}catch(InterruptedException e) {}  \t\t}  \t\tdishes.add(dish);  \t\tnotify(); //기다리고 있는 CUST를 깨우기 위함.  \t\tSystem.out.println(\"Dishes : \"+dishes.toString());  \t}  \tpublic void remove(String dishName) {  \t\tsynchronized(this) {  \t\t\tString name = Thread.currentThread().getName();    \t\t\t  \t\t\twhile(dishes.size()==0) {  \t\t\t\tSystem.out.println(name + \" is waiting. \");  \t\t\t\ttry {  \t\t\t\t\twait();  \t\t\t\t\tThread.sleep(500);  \t\t\t\t}catch(InterruptedException e) {}  \t\t\t}  \t\t\twhile(true) {  \t\t\t\tfor(int i =0; i&lt;dishes.size();i++) {  \t\t\t\t\tif(dishName.equals(dishes.get(i))) {  \t\t\t\t\tdishes.remove(i);  \t\t\t\t\tnotify(); //자고있는 COOK을 깨우기 위함  \t\t\t\t\treturn;  \t\t\t\t\t}  \t\t\t\t}  \t\t\t\ttry {  \t\t\t\t\tSystem.out.println(name+\" is waiting.\");  \t\t\t\t\twait();  \t\t\t\t\tThread.sleep(500);  \t\t\t\t}catch(InterruptedException e) {}  \t\t\t}  \t\t}  \t}  \tpublic int dishNum() {return dishNames.length;}  }  class  Main{  \tpublic static void main(String[] args) throws Exception {  \t\tTable table = new Table();    \t\t  \t\tnew Thread(new Cook(table), \"COOK\").start();  \t\tnew Thread(new Customer(table, \"donut\"), \"CUST1\").start();  \t\tnew Thread(new Customer(table, \"burger\"), \"CUST2\").start();  \t\tThread.sleep(2000);  \t\tSystem.exit(0);    \t\t  \t}  }      "
  },
  
  {
    "title": "자바의 정석 강의 - 지네릭스, 열거형, 애너테이션",
    "url": "/posts/%EC%A7%80%EB%84%A4%EB%A6%AD%EC%8A%A4_%EC%97%B4%EA%B1%B0%ED%98%95_%EC%95%A0%EB%84%88%ED%85%8C%EC%9D%B4%EC%85%98/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-26 00:00:00 +0900",
    





    
    "snippet": "지네릭스(Generics): 컴파일시 타입을 체크해주는 기능(compile-time type check) - JDK1.5객체의 타입 안정성을 높이고 형변환의 번거로움을 줄임.⇒ 코드가 간결해짐, ClassCastException(형변환 에러) 방지import java.util.ArrayList;public class  Main {\t\tpublic sta...",
    "content": "지네릭스(Generics): 컴파일시 타입을 체크해주는 기능(compile-time type check) - JDK1.5객체의 타입 안정성을 높이고 형변환의 번거로움을 줄임.⇒ 코드가 간결해짐, ClassCastException(형변환 에러) 방지import java.util.ArrayList;public class  Main {\t\tpublic static void main(String[] args) {//\t\tArrayList list = new ArrayList(); //JDK1.5이전, 지네릭스 도입이전에는 이렇게 썻음//\t\tlist.add(10);//\t\tlist.add(20);//\t\tlist.add(\"30\");  //String//\t\t//\t\tInteger i = (int)list.get(2);  //[10, 20, 30]중 30을 꺼냄. 30이 String임//\t\t// =&gt; Object를 int로 형변환 해서 컴파일은 ok 에러없음//\t\t//그러나 실행하면 에러남. java.lang.ClassCastException 형변환 에러//\t\t//컴파일러의 한계. 30이 String인걸 체크 못함.//\t\t//\t\tSystem.out.println(list);\t\t\t\t//위 같은 사항을 방지하기 위해 지네릭스 등장\t\t\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\t\tlist.add(10);\t\tlist.add(20);//\t\tlist.add(\"30\");  //String이라 에러남. 위에서 &lt;Integer&gt;로 지정해줘서 잘못된 타입인걸 컴파일러가 잡아줌\t\tlist.add(30);\t\t\t\tInteger i = list.get(2);  //[10, 20, 30]중 30을 꺼냄. 어차피 Integet만 올 수 있어서 형변환 안해줘도 됨\t\t\t\tSystem.out.println(list);\t\tSystem.out.println(i);\t\t\t\tArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;(); //모든 타입 저장가능 JKD1.5이후부터 이렇게 씀\t\tlist2.add(10);\t\tlist2.add(20);\t\tlist2.add(\"30\");  //String\t\t\t\tString i2= (String)list2.get(2);\t\tSystem.out.println(list2);\t\tSystem.out.println(i2);\t\tObject i3 = list2.get(1);\t\tObject i4 = list2.get(2);\t\tSystem.out.println(i3);\t\tSystem.out.println(i4);\t}}      타입변수          클래스 작성 시, Object타입 대신 타입 변수(T or E)를 선언해서 사용      객체 생성 시, 타입변수 대신 실제타입을 지정(대입)  ⇒ 형변환 생략가능.          //public class ArrayList extends AbstractList{   //\tprivate transient Object[] elementData;  //\tpublic boolean add(Object o) {/*생략*/}  //\tpublic Object get(int inex); {/*생략*/}  //}  //   ↓ JDK1.5부터 아래코드로 변경  public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;{   \tprivate transient E[] elementData;  \tpublic boolean add(E o) {/*생략*/}  \tpublic E get(int inex); {/*생략*/}  }  class Main{  public static void main(String[] args){  \t\t//타입변수 대신 실제 타입을 대입시킴. 참조변수와 생성자에 지정  \t\t//생상자의 실제타입과 참조변수의 실제타입이 일치해야함  \t\t//Tv가 E에 대입됨  \t\tArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();  \t\ttvList.add(new Tv());  //\tTv v = (Tv)tvList.get(0); //반환타입이 Object가 아닌 Tv라 형변환 필요없음. 주석처리  \t\tTv v = tvList.get(0);  \t}  }          import java.util.*;      class Tv{}  class Audio{}      public class  Main {    \t  \tpublic static void main(String[] args) {  //\t\tArrayList List = new ArrayList();  //\t\tList.add(new Tv());  //\t\tList.add(new Audio());    \t\t  \t\tArrayList list2 = new ArrayList();  \t\tTv v2 = (Tv)list2.get(0); //list2의 첫번째 요소를 꺼냄 Tv로 형변환 필수    \t\t  \t\tArrayList&lt;Tv&gt; list = new ArrayList&lt;Tv&gt;();  \t\tlist.add(new Tv());  //\t\tlist.add(new Audio()); //위와 다르게 Tv객체만 저장하게 지정돼서 에러남.  \t\tTv v = list.get(0); //형변환 불필요. 어차피 Tv객체만 저장하게 돼있음  \t}  }        지네릭스 용어          Box : 지네릭 클래스. ‘T의 Box’ or ‘T Box’라고 읽는다.      T : 타입변수 or 타입 매개변수(T는 타입문자)      Box : 원시타입(raw type). 일반클래스가 지네릭클래스로 바뀌어서 원 Box클래스를 원시타입이라 부름      대입된 타입(매개변수화된 타입, parameterized) : Box b = new Box();에서 String. 객체를 만들때마다 변경가능.            지네릭 타입과 다형성          참조변수와 생성자의 대입된 타입은 일치해야 한다.(조상과 자손관계여도 안됨)      지네릭클래스간의 타형성 성립은 성립.(여전히 대입된 타입은 일치해야함)      매개변수 다형성도 성립됨.          import java.util.*;      class Product{}  class Tv extends Product{}  class Audio extends Product{}      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tArrayList&lt;Product&gt; productList = new ArrayList&lt;Product&gt;();  \t\tArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();  //\t\tArrayList&lt;Product&gt; tvList1 = new ArrayList&lt;Tv&gt;(); //에러. 조상자손관계여도 안됨  \t\tList&lt;Tv&gt; tvList2 = new ArrayList&lt;Tv&gt;(); //가능. 다형성이지만 대입된 타입이 일치함    \t\t   \t\tproductList.add(new Tv()); //다형성. public boolean add(Product e)라서 Product의 자손인 Tv도 가능  \t\tproductList.add(new Audio());    \t\t  \t\ttvList.add(new Tv()); //public boolean add(Tv e)  //\t\ttvList.add(new Audio()); //Tv와 Audio는 공통 조상을 가진것이지 상속관계는 아니라 에러      \t\tprintAll(productList);  \t\t//printAll(tvList) //컴파일 에러. printAll은 Product타입임.   \t}      \tpublic static void printAll(ArrayList&lt;Product&gt; list){  \t\tfor(Product p : list) {  \t\t\tSystem.out.println(p);  \t\t}  \t}  }            Iterator          클래스를 작성할 때, Object타입 대신 T와 같은 타입 변수를 사용          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();  \t\tlist.add(new Student(\"자바왕\",1,1));  \t\tlist.add(new Student(\"자바짱\",1,2));  \t\tlist.add(new Student(\"홍길동\",2,1));    \t\t  \t\tIterator&lt;Student&gt; it =list.iterator();  \t\twhile(it.hasNext()) {  //\t\t\tStudent s = (Student)it.next(); //지네릭스를 사용해서 형변환 필요없음. Iterator it =list.iterator(); 였다면 형변환 해줘야함  //\t\t\tStudent s = it.next();  //\t\t\tSystem.out.println(s.name); //밑의 한줄로 줄임  //\t\t\tSystem.out.println(((Student)it.next()).name); //형변환 필요없음.  \t\t\tSystem.out.println(it.next().name);  \t\t}  \t}  }  class Student{  \tString name = \"\";  \tint ban; //반  \tint no; //번호    \t  \tStudent(String name, int ban, int no){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.no = no;  \t}  }            HashMap&lt;K,V&gt;          여러 개의 타입 변수가 필요한 경우, 콤마(,)를 구분자로 선언          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tHashMap&lt;String, Student&gt; map = new HashMap&lt;&gt;(); //JDK1.7부터 생성자의 타입지정 생략가능  \t\tmap.put(\"자바왕\", new Student(\"자바왕\",1,1,100,100,100));  \t\tmap.put(\"자바짱\", new Student(\"자바짱\",1,2,100,100,100));  \t\tmap.put(\"홍길동\", new Student(\"홍길동\",2,1,100,100,100));    \t\t  \t\t//public Student get(Object Key){}  \t\tStudent s = map.get(\"자바왕\"); //형변환 생략    \t\t  \t\tSystem.out.println(map.get(\"자바왕\").name);  \t}  }  class Student{  \tString name = \"\";  \tint ban; //반  \tint no; //번호  \tint kor;  \tint eng;  \tint math;    \t  \tStudent(String name, int ban, int no, int kor, int eng, int math){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.no = no;  \t\tthis.kor=kor;  \t\tthis.eng=eng;  \t\tthis.math=math;  \t}  }            제한된 지네릭 클래스          extends로 대입할 수 있는 타입을 제한 - class avg                  Student의 자손만 타입으로 지정가능.                    인터페이스인 경우에도 extends를 사용(implement안씀)          import java.util.*;      interface Eatable{};      class Fruit implements Eatable{  \tpublic String toString() {return \"fruit\";}  }      class Apple extends Fruit{public String toString() {return \"Apple\";} }  class Grape extends Fruit{public String toString() {return \"Grape\";} }  class Toy {public String toString() {return \"Toy\";} }  public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; fruitBox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; appleBox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Grape&gt;();  //\t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Apple&gt;(); //에러. 타입 불일치  //\t\tFruitBox&lt;Toy&gt; toyBox = new FruitBox&lt;Toy&gt;(); //에러. Toy클래스는 Fruit의 자손이 아님  \t\tBox&lt;Toy&gt; toyBox = new Box&lt;Toy&gt;();     \t\t  \t\tfruitBox.add(new Fruit());                     \t\tfruitBox.add(new Apple());                     \t\tfruitBox.add(new Grape());                     \t\tappleBox.add(new Apple());                     //\t\tappleBox.add(new Grape()); //Grape는 Apple의 자손이 아님              \t\tgrapeBox.add(new Grape());            \t\t  \t\tSystem.out.println(\"fruitBox - \"+fruitBox);  \t\tSystem.out.println(\"appleBox - \"+appleBox);  \t\tSystem.out.println(\"grapeBox - \"+grapeBox);  \t}  }  class FruitBox&lt;T extends Fruit &amp; Eatable&gt; extends Box&lt;T&gt;{}       class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); //아이템을 저장할 list  \tvoid add(T item)\t\t{list.add(item);} //박스에 추가  \tT get(int i) \t\t\t{return list.get(i);} //박스에서 아이템 꺼냄  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  \t}        지네릭스의 제약                  타입변수에 대입은 인스턴스 별로 다르게 가능        ⇒ static멤버에 타입 변수 사용불가.(모든 인스턴스에 공통이기 때문)        class BOX{    static T item; //에러    static int compare(T t1, T t2); //에러 }                    배열 생성할 떄 타입 변수 사용 불가. 타입 변수로 배열 선언은 가능        class Box{    T[] itemArr; //Ok, T타입의 배열을 위한 참조변수    T[] toArray() {    T[] tmpArr = new T[itemArr.length]; //에러. 지네릭 배열 생성불가 } }                  와일드 카드 &lt;?&gt; : 하나의 참조변수로 대입된 타입이 다른 객체를 참조 가능          &lt;? extends T&gt; : 와일드 카드의 상한 제한. T와 그의 자손들만 가능      &lt;? super T&gt; : 와일드 카드의 하한 제한. T와 그의 조상들만 가능      &lt;?&gt; == &lt;? extends Object&gt; : 제한없음. 모든 타입이 가능.        — 메소드의 매개변수에 와일드카드를 사용    static Juice makeJuice(FruitBox&lt;? extends Fruit&gt; box) {  String tmp = “”;  for(Fruit f : box.getList()) tmp += f +””;  return new Juice(tmp); }      import java.util.*;      class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }      class Juice{  \tString name;    \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }      class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";    \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; fruitBox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; appleBox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Grape&gt;();    \t\t  \t\t//appleBox에 Fruit와 그 자손(Apple, Grape)들 사용 가능  //\t\tFruitBox&lt;? extends Fruit&gt; appleBox = new FruitBox&lt;Apple&gt;();  //\t\tappleBox = new FruitBox&lt;Fruit&gt;();  //\t\tappleBox = new FruitBox&lt;Apple&gt;();  //\t\tappleBox = new FruitBox&lt;Grape&gt;();  //일단 주석처리해놓음 전부 에러안뜨고 잘 됨    \t\t   \t\tfruitBox.add(new Apple());  \t\tfruitBox.add(new Grape());  \t\tappleBox.add(new Apple());  \t\tgrapeBox.add(new Grape());     \t\t  \t\tSystem.out.println(Juicer.makeJuice(fruitBox));  \t\tSystem.out.println(Juicer.makeJuice(appleBox));  \t\tSystem.out.println(Juicer.makeJuice(grapeBox));  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}      class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }        지네릭 메소드                  지네릭 타입이 선언된 메소드(타입 변수는 메소드 내에서만 유효)  static  void sort(List list, Comparator&lt;? super T&gt; c)                    클래스의 타입 매개변수 와 메소드의 타입 매개변수 는 별개    class FruitBox{ /….    static  void sort(List list, Comparator&lt;? super T&gt; c){/*..*/} }        → class와 메소드의 타입변수가 다를수도 있음. 가까운 쪽의 것을 따름                    메소드를 호출할 때마다 타입을 대입해야함(대부분 생략가능)        FruitBox fruitBox = new FruitBox();    FruitBox appleBox = new FruitBox();    System.out.println(Juicer.makeJuice(fruitBox)); //생략 가능    System.out.println(Juicer.makeJuice(appleBox)); //생략가능                    메소드를 호출할 때 타입을 생략하지 않았을 때는 클래스 이름 생략 불가(아주 드뭄)  System.out.println(makeJuice(fruitBox));//에러. 클래스 생략 불가    System.out.println(this.makeJuice(fruitBox));    System.out.println(Juicer.makeJuice(fruitBox));            — 와일드카드메소드는 하나의 참조변수로 대입된 타입이 다른 여러 지네릭 객체를 다루기위해서 사용, 지네릭 메소드는 호출할때마다 다른 타입을 대입할 수 있음. 용도가 다름. (보통 와일드카드 못쓸때 지네릭 씀)  지네릭형 변환          지네릭 타입과 원시타입간의 형변환은 바람직하지 않음(경고발생, 가능은 함) 원시 타입을 사용하는 것부터 비효율적.              와일드 카드가 사용된 지네릭타입으로는 형변환 가능          import java.util.*;          class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }          class Juice{  \tString name;        \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }          class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";        \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tBox b = null;  \t\tBox&lt;String&gt; bstr = null;        \t\t  \t\tb = (Box)bstr;  //Box&lt;String&gt;-&gt;Box 가능은 하나 경고. 바람직하지않음  \t\tbstr = (Box&lt;String&gt;)b; //Box -&gt; Box&lt;String&gt;  가능은 하나 경고. 바람직하지않음        \t\t  \t\tBox b2 = new Box&lt;String&gt;();//가능 원래는 Box&lt;String&gt; b2 = new Box&lt;String&gt;();로 사용햐여함  \t\tb2.add(100);  \t\tb2.add(200);  \t\tSystem.out.println(b2);        \t\t  \t\tBox&lt;String&gt; b3 = new Box&lt;String&gt;();//가능 원래는 Box&lt;String&gt; b2 = new Box&lt;String&gt;();로 사용햐여함  //\t\tb3.add(100);  //\t\tb3.add(200);  //에러. b3는 &lt;String&gt;으로 타입을 지정해놔서 에러뜸  \t\t//어지간하면 섞어쓰지말고 꼭 지네릭으로 써줄 것.        \t\t  \t\tBox&lt;Object&gt; objBox = null;  //\t\tobjBox = (Box&lt;Object&gt;)bstr; //Box&lt;String&gt; -&gt; Box&lt;Objecte&gt; 불가능  //\t\tbstr = (Box&lt;String&gt;)objstr; //Box&lt;Object&gt; -&gt; Box&lt;String&gt; 불가능  //\t\tBox&lt;Sting&gt; b4 = new Box&lt;Object&gt;(); //불가능. 타입안맞음        \t\t  \t\tBox&lt;? extends Object&gt; wBox = (Box&lt;? extends Object&gt;)new Box&lt;String&gt;(); //가능  \t\tBox&lt;? extends Object&gt; wBox2 = new Box&lt;String&gt;(); //위 문장과 동일. 형변환 생략됨.        \t\t  \t\tFruitBox&lt;? extends Fruit&gt; Fbox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;? extends Fruit&gt; Fbox2 = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;? extends Fruit&gt; Fbox3 = new FruitBox&lt;Grape&gt;();        \t\t  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}          class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }                  import java.util.*;          class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }          class Juice{  \tString name;        \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }          class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";        \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; box = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; abox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; gbox = new FruitBox&lt;Grape&gt;();        \t\t  \t\tFruitBox&lt;? extends Fruit&gt; box2 = new FruitBox&lt;Fruit&gt;();  \t\t//FruitBox&lt;Apple&gt; -&gt; FruitBox&lt;? extends Fruit&gt;  \t\tFruitBox&lt;? extends Fruit&gt; abox2 = new FruitBox&lt;Apple&gt;();  \t\t//FruitBox&lt;Grape&gt; -&gt; FruitBox&lt;? extends Fruit&gt;  \t\tFruitBox&lt;? extends Fruit&gt; gbox2 = new FruitBox&lt;Grape&gt;();        \t\t  \t\t//FruitBox&lt;? extends Fruit&gt; -&gt; FruitBox&lt;Apple&gt;   \t\tFruitBox&lt;Apple&gt; abox3 = (FruitBox&lt;Apple&gt;)abox2; //가능. 경고발생  \t\t//FruitBox&lt;? extends Fruit&gt; -&gt; FruitBox&lt;Grape&gt;   \t\tFruitBox&lt;Grape&gt; gbox3 = (FruitBox&lt;Grape&gt;)gbox2;  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}          class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }                      지네릭타입의 제거          컴파일러는 지네릭타입을 제거하고, 필요한 곳에 형변환을 넣는다.                              지네릭 타입의 경계(bound)를 제거( → Object) - 하위호환성때문에 타입을 제거하기로 결정 ⇒ 안정성 증가            class box{void att(T t) } → class box{void add(Fruit t)} 으로 변경                                지네릭 타입 제거 후에 타입이 불일치하면, 형변환을 추가 T get(int i){return list.get(i);} → Fruit get(int i){return (Fruit)list.get(i);}                                와일드 카드가 포함된 경우, 적절한 타입으로 형변환 추가                                    열거형(enum) : 관련된 상수들을 같이 묶어놓은 것. java는 타입에 안전한 열거형을 제공. ==연산자 사용시 값과 타입 둘다 체크함          정의 방법 - enum 열거형 이름{ 상수명1, 상수명2, 상수명3 ,…}      열거형 타입의 변수를 선언, 사용          enum Direction { EAST, SOUTH, WEST, NORTH}      class Unit {  \tint x, y; //유닛의 위치  \tDirection dir; //열거형 인스턴스 변수를 선언    \t  \tvoid init() {  \t\tdir = Direction.EAST; //유닛의 방향을 EAST로 초기화\t\t  \t}  }              열서형 상수의 비교에 ==와 compareTo() 사용가능          void init() {  \t\tdir = Direction.EAST; //유닛의 방향을 EAST로 초기화\t\t  \t\tif(dir == Direction.EAST) {  \t\t\tx++; }  //\t\telse if(dir &gt; Direction.WEST) { //에러, 열거형 상수에 비교 연산자 사용 불가능  \t\telse if(dir.compareTo(Direction.WEST)&gt;0) {  /*compare은 사용 가능*/}  \t}                      열거형의 조상 - java.lang.Enum                  모든 열거형은 Enum의 자손이며, 아래의 메소드를 상속받는다.                                                    메소드              설명                                                          Class getDeclaringClass()              열거형의 Class객체를 반환                                      String name()              열거형 상수의 이름을 문자열로 반환                                      int ordinal()              열거형 상수가 정의된 순서를 반환(0부터 시작)                                      T valueOf(Class enumType, String name)              지정된 열거형에서 name과 일치하는 열거형 상수를 반환                                                values(), valueOf()는 컴파일러가 자동으로 추가                  static E[] values()  \t\tstatic E valueOf(String name)        \t\t  \t\tDirection [] dArr = Direction.values();        \t\t  \t\tfor(Direction d : dArr) {  \t\t\tSystem.err.printf(\"%s = $d%n\",d.name(),d.ordinal());  \t\t}                  import java.util.*;          enum Direction { EAST, SOUTH, WEST, NORTH}          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tDirection d1 = Direction.EAST;  \t\tDirection d2 = Direction.valueOf(\"WEST\");  \t\tDirection d3 = Enum.valueOf(Direction.class, \"EAST\");        \t\t  \t\tSystem.out.println(\"d1 = \" + d1);  \t\tSystem.out.println(\"d2 = \" + d2);  \t\tSystem.out.println(\"d3 = \" + d3);        \t\t  \t\tSystem.out.println(\"d1==d2 ? \"+(d1==d2));  \t\tSystem.out.println(\"d1==d3 ? \"+(d1==d3));  \t\tSystem.out.println(\"d1.equals(d3) \"+(d1.equals(d3)));  //\t\tSystem.out.println(\"d2&gt;d3 ? \"+(d1&gt;d3)); //에러. 객체가 없어서 비교연산자 사용 불가  \t\tSystem.out.println(\"d1.compareTo(d3) ? \"+(d1.compareTo(d3)));  \t\tSystem.out.println(\"d1.compareTo(d2) ? \"+(d1.compareTo(d2))); //0-2 = -2 출력        \t\t  \t\tswitch(d1) {  \t\tcase EAST: //Direction.EAST라고 못씀  \t\t\tSystem.out.println(\"The direction is EAST. \"); break;  \t\tcase SOUTH:   \t\t\tSystem.out.println(\"The direction is SOUTH. \"); break;  \t\tcase WEST:   \t\t\tSystem.out.println(\"The direction is WEST. \"); break;  \t\tcase NORTH:   \t\t\tSystem.out.println(\"The direction is NORTH. \"); break;  \t\tdefault:  \t\t\tSystem.out.println(\"Invalid direction\"); break;  \t\t}  \t\tDirection[] dArr = Direction.values(); //열겨형의 모든 상수를 배열로 반환  \t\tfor(Direction d : dArr) { //for(Direction d : Direction.values()  \t\t\tSystem.out.printf(\"%s = %d%n\",d.name(),d.ordinal());  \t\t}  \t}  }                            열거형에 멤버 추가하기                  불연속적인 열거형 상수의 경우 원하는 값을 괄호()안에 넣는다. 여러개도 가능          괄호를 사용하려면, 인스턴스 변수와 생성자를 새로 추가해줘야 함                  import java.util.*;          enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10);  \tprivate final int value;// 정수를 저장할 필드(인스턴스변수)를 추가  \tDirection(int value) {this.value = value;} //생성자 추가, private 생략        \t  \tpublic int getValue() {return value;}          }          public class  Main {        \t  \tpublic static void main(String[] args) {  //\t\tDirection d = new Direction(1); //에러, 열거형의 생성자는 외부에서 호출불가(무조건 private라서)   \t}  }                  import java.util.*;          enum Direction { EAST(1,\"&gt;\"), SOUTH(2,\"V\"), WEST(3,\"&lt;\"), NORTH(4,\"^\");        \t  \tprivate static final Direction[] DIR_ARR = Direction.values();  \tprivate final int value;// 정수를 저장할 필드(인스턴스변수)를 추가  \tprivate final String symbol;        \t  \tDirection(int value, String symbol) {  \t\tthis.value = value;  \t\tthis.symbol=symbol;  \t} //생성자 추가, private 생략        \t  \tpublic int getValue() {return value;}  \tpublic String getSymbol() {return symbol;}        \t  \tpublic static Direction of(int dir) {  \t\tif(dir&lt;1 || dir&gt;4) //1~4이외의 값이면 x  \t\t\tthrow new IllegalArgumentException(\"Invalid value : \"+dir);  \t\treturn DIR_ARR[dir-1];   \t}  \t//방향 회전 메소드, num의 값만큼 90도씩 시계방향으로 회전  \tpublic Direction rotate(int num) {  \t\tnum = num%4;        \t\t  \t\tif(num&lt;0) num +=4;  //num이 음수일때는 시계 반대방형으로 회전        \t\t  \t\treturn DIR_ARR[(value-1+num)];  \t}        \t  \tpublic String toString() {  \t\treturn name()+getSymbol();  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tfor(Direction d : Direction.values()) {  \t\t\tSystem.out.printf(\"%s = %d%n\",d.name(),d.ordinal());  \t\t}  \t\tSystem.out.println();  \t\t\tDirection d1 = Direction.EAST;  \t\t\tDirection d2 = Direction.of(1); //DIR_ARR[0]반환        \t\t\t  \t\t\tSystem.out.printf(\"d1 = %s, %d%n\",d1.name(),d1.getValue());  \t\t\tSystem.out.printf(\"d2 = %s, %d%n\",d2.name(),d2.getValue());  \t\t\tSystem.out.println();  \t\t\tSystem.out.println(Direction.EAST.rotate(1)); //EAST에서 한번 회전  \t\t\tSystem.out.println(Direction.EAST.rotate(2));  \t\t\tSystem.out.println(Direction.EAST.rotate(-1));//EAST에서 시계반대방향으로 한번 회전  \t\t\tSystem.out.println(Direction.EAST.rotate(-2));  \t}  }                            애너테이션                  주석처럼 프로그래밍 언어에 영향을 미치지 않으며, (프로그램에게)유용한 정보를 제공          /*~~~/ : javadoc.exe주석          애너테이션 사용 예  @Text //이 메소드가 테스트 대상임을 테스트 프로그램에게 알림  public void method{}                                                    ![[IMG-20240902151155.png              IMG-20240902151155.png]]                                      메타애너테이션 : 애너테이션을 만들때 사용                  @Override : 오버라이딩을 올바르게 했는지 컴파일러가 체크. 메소드 이름 잘못적을때가 많음. 오버라이딩 하기전에 적어줄 것.                      @Deprecated : 앞으로 사용하지 않을 것을 권장하는 필드, 메소드에 붙임 (ex. Date클래스의 getDate())  ⇒ @Deprecate가 붙은 대상을 사용하면 에러는 안뜨나 경고메세지(이클립스에선 취소선)가뜸                    @FunctionalInterface : 함수형 인터페이스(14장)에 붙이면, 컴파일러가 올바르게 작성했는지 체크, 함수형 인터페이스는 하나의 추상 메소드만 가질수 있다는 제약이 있음                      @SuppressWarings                          컴파일러의 경고메세지가 나타나지않게 억제              ()안에 억제하고자 하는 경고의 종류를 문자열로 지정 (경고를 확인했다는 의미)              여러 경고를 동시에 억제 가능함.              ‘-Xlint’옵션으로 컴파일 하면, 경고메세지를 확인할 수 있음. []안이 경고의 종류.                          class Parent{  \tvoid parentMethod() {}  \tvoid parentMethod2() {}  }              class Child extends Parent{  \t@Override  \t@Deprecated  \tvoid parentMethod() {};  //\t@Override  //\tvoid parentmethod2() {}; //에러. 이름불일치로 오버라이딩이 안됨.(@Override가 없으면 에러 안뜸)\t  }              @FunctionalInterface  interface Testable{ //함수형 인터페이스는 하나의 추상메소드만 가질 수 있음  \tvoid test(); //추상메소드  //\tvoid check(); //추상메소드 //추상메소드가 두개라서 에러, @FunctionlInterface가 없으면 가능함  }  public class  Main {  @SuppressWarnings(\"deprecation\")//이클립스에서는 차이가 없으나 cmd에서 컴파일하면 경고가 안뜸.  \tpublic static void main(String[] args) {  \t\tChild c = new Child();  \t\tc.parentMethod();  \t}  }                                메타애너테이션 : 애너테이션을 위한 에터테이션. java.lang.annotation 패키지에 포함                                          @Target : 애너테이션 정의할 때, 적용대상 지정에 사용                                                                            ![[IMG-20240902151156.png                      IMG-20240902151156.png]]                                                                                  @Retention : 애너테이션이 유지(retrntion)되는 기간을 지정하는데 사용                                  SOURCE : 소스파일에만 존재. 클래스파일에는 없음. 컴파일러에 의해 사용되는 애너테이션의 유지정책                  ==CLASS : 클래스파일에 존재. 실행시 사용불가. 기본값==                  RUNTIME : 클래스파일에 존재. 실행시 사용가능                                            @Documented : javadoc으로 작성한 문서에 포함시킴              @Ingerited : 애너테이션을 자손 클래스에 상속시킴              @Repeatable : 반복해서 붙일 수 있는 애너테이션을 정의. @ToDo를 하나로 묶을 컨테이너 애너테이션도 정의해야함                                            애너테이션 타입 정의                          직접 만들 수 있음 : @Interface 애너테이션이름{}              애너테이션의 메소드는 추상 메소드이며, 애너테이션을 적용할 때 지정(순서x)              애너테이션의 요소                                  적용시 값을 지정하지 않으면, 사용될 수 있는 기본 값 지정가능(null제외)                  요소가 하나이고 이름이 value일때는 요소의 이름 생략 가능                  요소의 타입이 배열인경우, {}를 사용(값이 여러개일때만, 값이 없을땐 빈{}라도 반드시 적어줘야함)                                            모든 애너테이션의 조상 - java.lang.annotation.Annotation                                  Annotation은 모든 애너테이션의 조상이지만 상속 불가능.                  사실 Annotation은 인터페이스임                                            마커 애너테이션(Marker Annotation) : 요소가 하나도 정의되지 않은 애너테이션              애너테이션 요소의 규칙                                  요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용됨                  ()안에 매개변수 선언 불가                  예외 선언 불가                  요소를 타입 매개변수로 정의 불가                                                        import java.lang.annotation.*;              @Deprecated  @SuppressWarnings(\"1111\") //유효하지 않은 애너테이션은 무시  @TestInfo(testedBy =\"aaa\", testTools= {\"JUnit\",\"JUnit5\"}, testDate = @DateTime(yymmdd=\"160101\",hhmmss=\"235959\"))  public class  Main {  \tpublic static void main(String[] args) {  \t\tClass&lt;Main&gt; cls = Main.class;            \t\t  \t\tTestInfo anno = cls.getAnnotation(TestInfo.class);  \t\tSystem.out.println(\"anno.testedBy() = \"+anno.testedBy());  \t\tSystem.out.println(\"anno.testDate().yymmdd()=\" +anno.testDate().yymmdd());  \t\tSystem.out.println(\"anno.testDate().hhmmss()=\" +anno.testDate().hhmmss());            \t\t  \t\tfor(String str : anno.testTools())   \t\t\tSystem.out.println(\"testTools = \" +str);            \t\t  \t\tSystem.out.println();            \t\t  \t\t//Main에 적용된 모든 애너테이션을 가져온다.  \t\tAnnotation[] annoArr = cls.getAnnotations();            \t\t  \t\tfor(Annotation a : annoArr)  \t\t\tSystem.out.println(a);  \t}  }  @Retention(RetentionPolicy.RUNTIME) //실행시 사용 가능하도록 지정  @interface TestInfo{  \tint count() default 1;  \tString testedBy();  \tString[] testTools() default \"JUnit\";  \tTestType TestType() default TestType.FIRST;  \tDateTime testDate();  }              @Retention(RetentionPolicy.RUNTIME) //실행시 사용 가능하도록 지정  @interface DateTime{  \tString yymmdd();  \tString hhmmss();  }              enum TestType{FIRST, FINAL}                                          "
  },
  
  {
    "title": "자바의 정석 강의 - 컬렉션 프레임웍(collections framework)",
    "url": "/posts/%EC%BB%AC%EB%A0%89%EC%85%98_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8D(collections_framework)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, collection",
    "date": "2022-08-21 00:00:00 +0900",
    





    
    "snippet": "컬렉션 프레임웍(collections framework)      컬렉션(collection)    : 여러 객체(데이터)를 모아놓은 것        프레임웍(framework)    : 표준화, 정형화된 체계적인 프로그램 방식 (Spring)        컬렉션 프레임웍(collections framework)    : 컬렉션(다수의 객체)를 다루기...",
    "content": "컬렉션 프레임웍(collections framework)      컬렉션(collection)    : 여러 객체(데이터)를 모아놓은 것        프레임웍(framework)    : 표준화, 정형화된 체계적인 프로그램 방식 (Spring)        컬렉션 프레임웍(collections framework)    : 컬렉션(다수의 객체)를 다루기 위한 표준화된 프로그래밍 방식    컬랙션을 쉽고 편리하게 다룰 수 있는 다양한 클래스 제공(객체 저장, 삭제, 검색, 정렬 등)    java.util 패키지에 포함. JDK1.2부터 제공(그전엔 표준화가 안됨)        컬렉션 클래스(collections class)    : 다수의 데이터를 저장할 수 있는 클래스(ex. Vector, ArrayList, HashSet)  ❗❗컬렉션 크레임웍의 핵심 인터페이스Map구현 클래스 이름에 Map이 없는 것은 표준화되기 전 옛날에 생긴 것— List와 Set의 공통부분 만 모아서 Collection이라는 인터페이스를 정의함. Map은 성격이 달라서 공통부분이 없음  Collection인터페이스의 메소드 - 순서ox,중복ox(상관없음)      List인터페이스 - (저장)순서o, 중복o          ArrayList (배열기반):                              기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일  (Vector써도 되지만[동기화o] 가능하면 ArrayList[동기화x]쓸것.)                    List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용          데이터의 저장공간으로 배열을 사용(배열기반)                      ArrayList의 메소드                          생성자                                  ArrayList() - 기본생성자                  ArrayList(Collection) - 컬렉션들 끼리 변환할때 많이 씀                  ArrayList(int initialCapacity) - 배열의 길이를 지정해주어야함(원래 배열은 길이를 조절못해서. 만들때 넉넉하게 만드는게 좋음)                                            추가                                  boolean add(Object o) - 객체 추가. 성공하면 true, 실패하면 false                  void add(int index, Object element) - 저장위치 지정(안하면 맨 뒤에 저장됨)                  boolean addAll(Collection c) - 컬렉션이 가진 요소를 그대로 저장                  boolean addAll(int index, Collection c) - 컬렉션의 저장위치지정                                            삭제                                  boolean remove(Object o) - 삭제                  Object remove(int index) - 특정위치 객체 삭제                  boolean removeAll(Collection c) - 컬렉션에 있는 객체 삭제                  void clear() - Array의 모든 객체 삭제                                            검색                                  int indexOf(Object o) - 객체가 몇번째에 저장됐는지(못찾으면 -1)                  int lastIndexOf(Object o) - 끝에서 부터 객체를 찾음                  boolean contains(Object o) - 객체가 있는지(있으면 true, 없으면 false)                  Object get(int index) - 객체 읽기                  Object set(int index, Object element) - 특정 위치 객체를 다른 걸로 변경                                                            기타                                  List subList(int fromIndex, int toIndex) -from부터 to까지 객체를 뽑아서 새로운 List를 만듦                  Object[] toArray() - ArrayList의 객체배열을 반환                  Object[] toArray(Object[] a)                  boolean isEmpty() - ArrayList가 비어있는지 확인                  void trimToSize() - 빈공간 제거                  int size() - 저장된 객체의 갯수                                  import java.util.*;                  public class  Main {  \tpublic static void main(String[] args) {  \t\t//기본길이(용량, capacity)가 10인 ArrayList를 생성  \t\tArrayList list1 = new ArrayList(10);  //\t\tlist1.add(new Integer(5));  //\t\tlist1.add(new Integer(4));  //\t\tlist1.add(new Integer(2));  //\t\tlist1.add(new Integer(0));  //\t\tlist1.add(new Integer(1));  //\t\tlist1.add(new Integer(3));  \t\t//ArrayList는 객체만 저장되나 autoboxing에 의해 기본형이 참조형으로 자동변환되서 밑처럼 써도 됨  \t\tlist1.add(5);  \t\tlist1.add(4);  \t\tlist1.add(2);  \t\tlist1.add(0);  \t\tlist1.add(1);  \t\tlist1.add(3);                \t\t  \t\t//ArrayList(Collection c)  //\t\tList sub = list1.subList(1, 4);  //\t\tArrayList list2 = new ArrayList(sub);  \t\tArrayList list2 = new ArrayList(list1.subList(1, 4));                \t\t  \t\tprint(list1, list2);                \t\t  \t\t//Collection은 인터페이스, Collections는 유틸클래스  \t\tCollections.sort(list1); //list1과 list2를 정렬한다  \t\tCollections.sort(list2); //Collections.sort(list1)  \t\tprint(list1, list2);                \t\t  \t\t//list1이 list2의 모든 요소를 포함하고 있는가?  \t\tSystem.out.println(\"list1.conrainsAll(list2) : \"+list1.containsAll(list2));                \t\t  \t\tlist2.add(\"B\");  \t\tlist2.add(\"C\");  \t\tlist2.add(3,\"A\"); //기존 값은 삭제되니 신중히  \t\tprint(list1, list2);                \t\t  \t\tlist2.set(3, \"AA\");  \t\tprint(list1, list2);                \t\t  \t\tlist1.add(0,\"1\");  \t\t//list1에서 \"1\"이 어느 위치에 있는지 출력   \t\tSystem.out.println(\"\\\"1\\\"의 index = \"+list1.indexOf(\"1\")); //0  \t\tSystem.out.println(\"1의 index = \"+list1.indexOf(1)); //2  \t\tprint(list1,list2);  \t\tlist1.remove(0); //list1[0]자리의 값을 0으로(String이라)  \t\tprint(list1, list2);  \t\tlist1.remove(5); //list1[5]를 삭제  \t\tprint(list1, list2);                \t\t  \t\tlist1.remove(new Integer(1)); //값이 1인 것을 삭제  \t\tprint(list1, list2);                \t\t  \t\t// list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제  \t\tSystem.out.println(\"list1.retainAll(list2) : \"+list1.retainAll(list2));  \t\tprint(list1, list2);                \t\t  \t\t//list2에서 list1에 포함된 객체들을 삭제  \t\tfor(int i = list2.size()-1;i&gt;=0;i--) {  \t\t\tif(list1.contains(list2.get(i)))  \t\t\t\t\tlist2.remove(i);  \t\t}  \t\tprint(list1, list2);  \t}                  \tprivate static void print(ArrayList list1, ArrayList list2) {  \t\tSystem.out.println(\"list1:\"+list1);  \t\tSystem.out.println(\"list2:\"+list2);  \t\tSystem.out.println();  \t}  }                                                            ArrayList에 저장된 객체의 삭제 과정                                                      삭제할 데이터 아래의 데이터를 한 칸씩 위로 복사해서 삭제할 데이터 덮어쓰기(부담 많이감.) System.arraycopy(data, 3, data, 2, 2) data[3]에서 data[2]로 2개의 데이터를 복사함                                                        데이터가 모두 한 칸씩 이동했으므로 마지막 데이터는 null로 변경 data[size-1]=null;                                                        데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 감소시킨다 size–;                                                        마지막데이터를 삭제하는 경우 1번은 안해도됨.                                                  — for문으로 모든 객체 지우기                for(int i =list.size()-1;i&gt;=0;i–) { list.remove(i); }  이렇게안하면 배열이 자꾸 위로 올라가서 다 안지워짐                                                                LinkedList : 배열의 단점을 보완 (연결기반)                  배열의 장단점                          배열의 장점 : 구조가 간단, 데이터를 읽는데 걸리는 시간이(접근시간, access time) 짧음              배열의 단점                                  크기 변경x : 변경 시 새로운 배열을 생성한 후 데이터를 복사해야함. 미리 넉넉하게 배열크기를 지정하면 메모리가 낭비됨                                          더 큰 배열 생성                      복사                      참조 변경                                                        비순차적인 데이터의 추가, 삭제에 시간이 많이 걸림  → 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.  그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠름                                                              배열과 달리 LinkedList는 불연속적으로 존재하는 데이터를 연결          데이터의 삭제 : 단 한번의 참조 변경만으로 가능          데이터 추가 : 한번의 Node객체 생성과 두번의 참조 변경만으로 가능                      단점                          접근성이 나쁨. (불연속적이라서)  첫번째 배열에서 마지막 배열까지 가려면 모든 배열을 거쳐서 가야함                        ⇒ 서큘러 링크드 리스트(이중 원형리스트, doubly circular linked list)[첫번째애서 마지막으로 이동이 편리) , 이중연결리스트(doubly linked list)[앞뒤 이동만 편해짐]로 , 접근성 향상                                      [!important]ArrayList vs Linked List데이터를 순차적 추가/삭제 - ArrayList데이터를 비순차적으로 추가/삭제 - LinkedList접근시간(access time) - ArrayList⇒ 읽기는 ArrayList, 추가/삭제는 LinkedList가 빠르다      Collection인터페이스의 메소드는 제외됨(자손이라 쓸 수 있음)  Set인터페이스 - 순서x, 중복x (집합)                  HashSet : Set인터페이스를 구현한 대표적인 컬렉션 클래스. 순서를 유지하려면 LInkedHashSet을 사용 (중복 방지를 위해 객체 저장 전에 기존에 같은 객체가 있는지 확인함)                  생성자                          HashSet()              HashSet(Collection c) : 지정된 컬렉션에 모든 객체 저장              HashSet(int initialCapacity) : 초기용량 지정(보통 2배)              HashSet(int initialCapacity, float loadFactor) : 언제 용량을 늘릴건지(보통2배)                                추가/삭제                          boolean add(Object o) : 추가 - 중복 확인을 위해 저장할 객체의 equals()와 hashCode()를 호출, equals()와 hashCode()가 오버라이딩 되어있어야함(equals()만 해도되나 hashCode()까지 오버라이딩 해주는 것이 정석임)              boolean addAll(Collection c) : 추가(합집합)              boolean remove(Object o) : 삭제              boolean removeAll(Collection c) : 삭제 (교집합)              boolean retainAll(Collection c) : Collection에 있는거만 남기고 삭제(조건부삭제, 차집합)              void clear() : 모두 삭제                                포함                          boolean contains(Object o) : set이 객체를 포함했다면 true, 아니라면 false              boolean containsAll(Collection c) : Collection에 담긴 여러 객체가 모두 포함되어있는지              Iterator iterator() : 컬랙션의 요소를 읽어옴                                확인                          boolean isEmpty() : 비었는지              int size() : 저장된 객체의 갯수              Object[] toArray() : set에 저장된 객체를 객체배열로 반환              Object[] toArray(Object[] a)                                        import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tObject [] objarr = {\"1\", new Integer(1),\"2\",\"2\",\"3\",\"3\",\"4\",\"4\",\"4\"};  \t\tSet set = new HashSet();  \t\tfor(int i=0;i&lt;objarr.length;i++) {  \t\t\tSystem.out.println(objarr[i]+\"=\"+set.add(objarr[i])); //HashSet에 objarr의 모든 요소를 저장  \t\t}  \t\t//HashSet에 저장된 요소를 출력(set이라서 중복된 것 제외됨)  \t\tSystem.out.println();  \t\tSystem.out.println(set);        \t\t  \t\t//HashSet에 저장된 요소들을 출력(Iterator이용)  \t\tIterator it = set.iterator();        \t\t  \t\twhile(it.hasNext()) { //읽을 요소가 남아있는지 확인  \t\t\tSystem.out.println(it.next()); //요소 하나 꺼내오기  \t\t}// =&gt; 읽은 요소가 없을때까지 꺼내옴  \t}                }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tSet set = new HashSet();        \t\t  \t\t//set의 크기가 6보다 작은 동안 1~45사이의 난수를 저장  \t\tfor(int i=0; set.size()&lt;6 ;i++) {  \t\t\tint num = (int)(Math.random()*45+1);  \t\t\tset.add(num);  \t\t}  \t\tSystem.out.println(set);  \t\t//set은 정렬(순서유지) 안됨 -&gt; LinkedList사용   \t\tList list = new LinkedList(set); //LinkedList(Collection c)  \t\tCollections.sort(list);  //Collections.sort(List list)  \t\tSystem.out.println(list);  \t}                }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashSet set = new HashSet();        \t\t  \t\tset.add(\"abc\");  \t\tset.add(\"abc\");  \t\tset.add(new Person(\"Daivd\",10));  \t\tset.add(new Person(\"Daivd\",10));        \t\t  \t\tSystem.out.println(set);  \t}                }  //equals와 hashCode를 오버라이딩 안해주면 david,10이 두번 다 저장됨  class Person{  \tString name;  \tint age;        \t  \tPerson(String name, int age){  \t\tthis.name=name;  \t\tthis.age = age;  \t}        \t  \tpublic String toString() {  \t\treturn name+\" : \"+age;  \t}          \tpublic int hashCode() {  \t\t//int hash(Object... values);//가변인자  \t\treturn Objects.hash(name,age);  \t}          \tpublic boolean equals(Object obj) {  \t\tif(!(obj instanceof Person)) return false;        \t\t  \t\tPerson p =(Person)obj;  \t\t//나자신의 이름과 나이를 p와 비교  \t\treturn this.name.equals(p.name) &amp;&amp; this.age==p.age;  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashSet setA = new HashSet();  \t\tHashSet setB = new HashSet();  \t\tHashSet setHab = new HashSet();  \t\tHashSet setKyo = new HashSet();  \t\tHashSet setCha = new HashSet();        \t\t  \t\tsetA.add(\"1\"); setA.add(\"2\"); setA.add(\"3\"); setA.add(\"4\"); setA.add(\"5\");  \t\tSystem.out.println(\"A = \"+setA);        \t\t  \t\tsetB.add(\"4\"); setB.add(\"5\"); setB.add(\"6\"); setB.add(\"7\"); setB.add(\"8\");  \t\tSystem.out.println(\"B = \"+setB);        \t\t  \t\t//교집합  \t\tIterator it = setB.iterator();  \t\twhile(it.hasNext()) {  \t\t\tObject tmp = it.next();  \t\t\tif(setA.contains(tmp)) { //setB의 구성요소를 하나씩 빼서 setA에 있는지 확인  \t\t\t\tsetKyo.add(tmp);  \t\t\t}  \t\t}        \t\t  \t\t//차집합  \t\tit = setA.iterator();  \t\twhile(it.hasNext()) {  \t\t\tObject tmp = it.next();  \t\t\tif(!setB.contains(tmp)) {  \t\t\t\tsetCha.add(tmp);  \t\t\t}  \t\t}        \t\t  \t\t//합집합  \t\tit = setA.iterator();  \t\twhile(it.hasNext()) {  \t\t\tsetHab.add(it.next());  \t\t}  \t\tit = setB.iterator();  \t\twhile(it.hasNext()) {  \t\t\tsetHab.add(it.next());  \t\t} //어차피 set은 중복 제거 돼서 중복제거안해줘도됨        \t\t  \t\tSystem.out.println(\"A ∩ B = \"+setKyo);  \t\tSystem.out.println(\"A ∪ B = \"+setHab);  \t\tSystem.out.println(\"A - B = \"+setCha);        \t\t  \t\t//교집합(위에거 간단히)  //\t\tsetA.retainAll(setB);  //\t\tSystem.out.println(\"A ∩ B = \"+setA);  \t\t//합집합  //\t\tsetA.addAll(setB);  //\t\tSystem.out.println(\"A ∪ B = \"+setA);  \t\t//차집합  //\t\tsetA.removeAll(setB);  //\t\tSystem.out.println(\"A - B = \"+setA);  \t}  }                            TreeSet : 범위 검색과 정렬에 유리한 컬렉션 클래스. HashSet보다 데이터 추가, 삭제에 시간이 더 걸림. 이진 탐색 트리(binary search tree)로 구현.                  이진트리는 모든 노드(요소)가 최대 2개의 하위노드(요소)를 갖음. 각 요소가 나무 형태로 연결(LinkedList의 변형)          이진 탐색 트리(binary search tree) : 부모보다 작은 값은 왼쪽에, 큰 값은 오른쪽에 저장(이진트리는 값의 크기랑은 상관없음). 데이터가 많이질 수록 추가, 삭제에 시간이 더 걸림(비교횟수 추가)          데이터 저장 과정 : boolean add(Object o) - 중복이면 false반환, 저장안됨                        Comparator : 비교기준            import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tSet set = new TreeSet();        \t\t  //\t\tfor(int i =0; set.size()&lt;6;i++) {  //\t\t\tint num = (int)(Math.random()*45)+1;  //\t\t\tset.add(num); //set.add(new Integer(num));  //\t\t}  //\t\tSystem.out.println(set);  \t\t//TreeSet이라서 정렬안해도 해줌(Hashset은 정렬 필요)  //\t\tset.add(new Test());   //\t\tset.add(new Test());   //\t\tset.add(new Test());   \t\tset.add(new Test());   \t\tSystem.out.println(set); //[Test@77459877, Test@5b2133b1, Test@72ea2f77, Test@33c7353a]  \t}  }                  //class TestComp implements Comparator{  //  //\t@Override  //\tpublic int compare(Object o1, Object o2) {  //\t\treturn -1; //같은 객체가 아님을 지정  //\t}  //}  class Test implements Comparable{//비교기준이 없다면 에러.           \t@Override  \tpublic int compareTo(Object o) {  \t\treturn -1;  \t}         \t  }  //결론 : \tSet set = new TreeSet(new TestComp);, set.add(new Test()); 처럼 둘중에 하나는 비교기준을 지정해 줘야함                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tTreeSet set = new TreeSet(); //범위검색에 유리        \t\t  \t\tString from = \"b\";  \t\tString to = \"d\";        \t\t  \t\tset.add(\"abc\"); set.add(\"alien\"); set.add(\"bat\");  \t\tset.add(\"car\"); set.add(\"Car\"); set.add(\"disc\");  \t\tset.add(\"dance\"); set.add(\"dZZZZ\"); set.add(\"dzzzz\");  \t\tset.add(\"elephant\"); set.add(\"elevator\"); set.add(\"fan\");  \t\tset.add(\"flower\");        \t\t  \t\tSystem.out.println(set);  \t\tSystem.out.println(\"range search : from \"+from + \" to \"+to);  \t\tSystem.out.println(\"result1 : \"+set.subSet(from, to));  \t\tSystem.out.println(\"result2 : \"+set.subSet(from, to+\"zzz\")); //\"b\"~~~zzz으로 끝나는 부분까지 출력  \t\t/* result1 : [bat, car]  \t\tresult2 : [bat, car, dZZZZ, dance, disc] */  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tTreeSet set = new TreeSet();   \t\tint score[]= {80,95,50,35,45,65,10,100};        \t\t  \t\tfor(int i=0;i&lt;score.length;i++) {  \t\t\tset.add(new Integer(score[i]));  \t\t}        \t\t  \t\tSystem.out.println(\"50보다 작은 값 : \"+set.headSet(50));  \t\tSystem.out.println(\"50보다 큰 값 : \"+set.tailSet(50));  \t\tSystem.out.println(\"50보다 큰 값 : \"+set.subSet(40,80));  \t}  }                — 트리 순회(tree traversal) : 이진트리의 모든 노드를 한번 씩 읽는 것                  전위순회 : 부모 먼저 읽음          후위순위 : 자식 먼저 읽음                      중위순외 : (좌)자식-부모-(우)자식순으로 읽음 (오름차순 정렬됨)  ⇒ treeSet이 정렬에 유리한 이유                    레벨순회 : 순서대로 위에서부터 좌우로 읽음                    Set인터페이스의 메소드 == Collection인터페이스의 메소드              집합과 관련된 메소드(Collection에 변화가 있으면 true, 아니면 false                          Map인터페이스 - 순서x, 중복(키x,값o)                  HashMap(동기화x) : Map인터페이스를 구현한 대표적인 클래스, 데이터를 키와 값의 쌍으로 저장, Hashtable의 신버전. Hashtable은 동기화가 됨.  해싱(hashing)기법으로 데이터를 저장. 데이터가 많아도 검색이 빠름                  LinkedHashMap : 순서 필요할때 사용          해싱(hashing) : 해시함수를 이용해서 헤시테이블(hash table)에 데이터를 저장, 검색                          해시함수(hash function) : key를 넣으면 index를 반환 - 같은 키를 넣으면 항상 같은 값이 나옴              해시테이블(hash table) : 배열과 LikedList가 조합된 형태                              해시테이블에 저장된 데이터를 가져오는 과정                                  키로 해시함수를 호출, 해시코드를 얻는다.                  해시코드(해시함수의 반환값)에 대응하는 LikedList를 배열에서 찾는다.                  LikedList에서 키와 일치하는 데이터를 찾는다.                                — 해시함수는 같은 키에 대해 항상 같은 해시코드를 반환해야 한다. 서로 다른 키일지라도 같은 값의 해시코드를 반환할 수도 있다.                                              주요 메소드                          생성자                                  HashMap()                  HashMap(int initialCapacity) :                  HashMap(int initalCapacity, float loadFactor)                  HashMap(Map m) : 다른 Map을 HashMap으로 변경 가능                                            저장/삭제/수정                                  Object put(Object key, Object value) : 데이터 저장                  void putAll(Map m) : 지정된 Map을 모두 저장                  Object remove(Object key, Object value) : 삭제                  boolean replace(Object key, Object odlValue, Object newValue) : 기존 키를 새로운 키로 변경                                            읽기                                  Set entrySet() : 키과 값으로 이루어진 set을 얻을 수 있음                  Set keySet() : 키 값만 가져옴                  Collection values() : 값만 가져옴                                            기타                                  Object get(Object key) : 키를 넣으면 값이 반환됨                  Object getOr Default(Object key, Object defaultValue) : 저장된 키가 없다면 지정된 값을 반환                  boolean containsKey(Object key) : 지정된 키가 있는지. 있으면 t, 없으면 f                  boolean containsValue(Object value) : 지정된 값이 있는지 있으면 t, 없으면 f                                                                      import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashMap map = new HashMap();  \t\tmap.put(\"myId\",\"1234\");  \t\tmap.put(\"asdf\",\"1111\");   //\t\tSystem.out.println(map);  \t\tmap.put(\"asdf\",\"1234\");  //\t\tSystem.out.println(map);  //\t\t//마지막값으로 입력됨        \t\t  \t\tScanner s = new Scanner(System.in);        \t\t  \t\twhile(true) {  \t\t\tSystem.out.println(\"id와 password를 입력해주세요\");  \t\t\tSystem.out.println(\"id : \");  \t\t\tString id = s.nextLine().trim();        \t\t\t  \t\t\tSystem.out.println(\"password : \");  \t\t\tString password = s.nextLine().trim();  \t\t\tSystem.out.println();        \t\t\t  \t\t\tif(!map.containsKey(id)) {  \t\t\t\tSystem.out.println(\"입력하신 아이디는 존재하지 않습니다. 다시 시도해주세요\");  \t\t\t\tcontinue;  \t\t\t}  \t\t\tif(!(map.get(id).equals(password))) {  \t\t\t\tSystem.out.println(\"비밀번호가 일치하지 않습니다. 다시 시도해주세요\");  \t\t\t\tcontinue;  \t\t\t}else {  \t\t\t\tSystem.out.println(\"로그인 되었습니다!\");  \t\t\t\tbreak;  \t\t\t}  \t\t}  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashMap map = new HashMap();  \t\tmap.put(\"김자바\", new Integer(90));  \t\tmap.put(\"김자바\", new Integer(100));  \t\tmap.put(\"이자바\", new Integer(100));  \t\tmap.put(\"강자바\", new Integer(80));  \t\tmap.put(\"안자바\", new Integer(90));        \t\t  \t\t//entry는 map인터페이스의 내부 인터페이스  \t\tSet set = map.entrySet();  \t\tIterator it = set.iterator();        \t\t  \t\twhile(it.hasNext()) {  \t\t\tMap.Entry e = (Map.Entry)it.next();  \t\t\tSystem.out.println(\"이름 : \"+e.getKey() + \", 점수 : \"+e.getValue());  \t\t}  \t\tset = map.keySet();  \t\tSystem.out.println(\"참가자 명단 : \"+set);        \t\t  \t\tCollection values = map.values();  \t\tit = values.iterator();        \t\t  \t\tint total=0;        \t\t  \t\twhile(it.hasNext()) {  \t\t\tint i = (int)it.next();  \t\t\ttotal += i;  \t\t}  \t\tSystem.out.println(\"총점 : \"+total);  \t\tSystem.out.println(\"평균 : \"+(float)total/set.size());  \t\tSystem.out.println(\"최고 점수 : \"+Collections.max(values));  \t\tSystem.out.println(\"최저 점수 : \"+Collections.min(values));  \t}  }                            TreeMap : 이진탐색트리. 범위검색과 정렬에 유리하며, HashMap보다 데이터 추가, 삭제에 시간이 더 걸림                import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tString data[] = {\"A\",\"K\",\"A\",\"K\",\"D\",\"K\",\"A\",\"K\",\"k\",\"K\",\"Z\",\"D\"};  \t\tHashMap map = new HashMap();    \t\t  \t\tfor(int i=0;i&lt;data.length;i++) {  \t\t\tif(map.containsKey(data[i])) {  \t\t\t\tint value = (int)map.get(data[i]); //map.get() 키를 넣으면 값이 반환  \t\t\t\tmap.put(data[i], value+1);  \t\t\t} else {  \t\t\t\tmap.put(data[i], 1);  \t\t\t}  \t\t}  \t\tIterator it = map.entrySet().iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tMap.Entry entry = (Map.Entry)it.next();  \t\t\tint value = (int)entry.getValue();  \t\t\tSystem.out.println(entry.getKey()+\" : \"+printBar('*',value)+\" \"+value);  \t\t}  \t}  \tpublic static String printBar(char ch, int value) {  \t\tchar bar[] = new char[value];  \t\tfor(int i=0;i&lt;bar.length;i++) {  \t\t\tbar[i] = ch;  \t\t}  \t\treturn new String(bar);  \t}  }      스택과 큐(Stack &amp; Queue)import java.util.*;public class  Main {\tpublic static void main(String[] args) {\t\tStack st = new Stack();\t\tQueue q = new LinkedList(); //Queue인테페이스의 구현체인 LinkedList사용\t\t\t\tst.push(\"0\");\t\tst.push(\"1\");\t\tst.push(\"2\");\t\t            \t\tq.offer(\"0\");\t\tq.offer(\"1\");\t\tq.offer(\"2\");\t\t\t\tSystem.out.println(\"=====Stack=====\");\t\twhile(!st.empty()) {\t\t\tSystem.out.println(st.pop()); //스택요소 하나하나 꺼내기\t\t}\t\tSystem.out.println(\"=====Queue=====\");\t\twhile(!q.isEmpty()) {\t\t\tSystem.out.println(q.poll()); //스택요소 하나하나 꺼내기\t\t}\t}}      스택 : LIFO(Last In First Out, 후입선출)구조. 저장(push), 추출(pop) — 배열이 효율적(순차적이라서)          활용 예 : 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로          import java.util.*;      public class  Main {  \tpublic static void main(String[] args) {  \t\tif(args.length !=1) {  \t\t\tSystem.out.println(\"usage : java Ex11_3 \\\"EXPRESSIN\\\"\");  \t\t\tSystem.out.println(\"Example : java Ex11_3 \\\"((2+3)*1)3\\\"\");  \t\t\tSystem.exit(0);  \t\t}    \t\t  \t\tStack st = new Stack();  \t\tString expression = args[0];    \t\t  \t\tSystem.out.println(\"expression : \"+expression);    \t\t  \t\ttry {  \t\t\tfor(int i=0;i&lt;expression.length();i++) {  \t\t\t\t//입력된 수식에서 하나씩 꺼내기  \t\t\t\tchar ch = expression.charAt(i);     \t\t\t  \t\t\tif(ch=='(') {  \t\t\t\t//여는괄호라면, 스택에 집어넣고  \t\t\t\tst.push(ch+\"\");  \t\t\t\t//닫는 괄호라면, 스택에서 꺼냄  \t\t\t}else if(ch==')') {  \t\t\t\tst.pop();  \t\t\t}  \t\t}  \t\t\t//스택이 비었다면?  \t\t\tif(st.isEmpty()) {  \t\t\t\tSystem.out.println(\"괄호가 일치합니다\");  \t\t\t}else {  \t\t\t\tSystem.out.println(\"1.괄호가 일치하지 않습니다\");  \t\t\t}  \t\t}catch (EmptyStackException e) {  \t\t\t//(2+3)*1)))) 이런식으로 꺼낼 괄호가 없는데 자꾸 추출하려해서 에러날떄  \t\t\tSystem.out.println(\"2.괄호가 일치하지 않습니다\");  \t\t}  }      }            큐 : FIFO(First in First Out, 선입선출)구조, 저장(offer), 추출(poll) — 링크드리스트가 효율적(비순차적이라서) - 인터페이스라 객체생성안됨          활용 예 : 최근사용문서(Recent Files), 인쇄작업 대기목록, 버퍼(buffer)      Queue를 직접 구현                  Queue를 구현할 클래스를 사용(LinkeList 등 공식문서 참조)  ⇒ Queue q = new LinkedList();                        import java.util.*;      public class  Main {  \tstatic Queue q = new LinkedList();  \tstatic final int MAX_SIZE = 5; //Queue에 최대 5개까지 저장됨(최근 5개의 명령어를 저장)    \t  \tpublic static void main(String[] args) {  \t\tSystem.out.println(\"help를 입력하면 도움말을 볼 수 있습니다.\");    \t\t  \t\twhile(true) {  \t\t\tSystem.out.println(\"&gt;&gt;\");  \t\t\ttry {  \t\t\t\t//화면으로부터 라인단위로 입력받음  \t\t\t\tScanner s = new Scanner(System.in);  \t\t\t\tString input = s.nextLine().trim();    \t\t\t\t  \t\t\t\tif(\"\".equals(input)) continue;    \t\t\t\t  \t\t\t\tif(input.equalsIgnoreCase(\"q\")) {  \t\t\t\tSystem.out.println(\"프로그램 종료\");  \t\t\t\tSystem.exit(0);  \t\t\t\t}  \t\t\t\tif(input.equalsIgnoreCase(\"help\")) {  \t\t\t\t\tSystem.out.println(\"help - 도움말을 표시합니다\");  \t\t\t\t\tSystem.out.println(\"q 또는 Q - 프로그램을 종료합니다\");  \t\t\t\t\tSystem.out.println(\"history - 최근에 입력한 명령어를 \"+MAX_SIZE+\"개 보여줍니다\");  \t\t\t\t}else if(input.equalsIgnoreCase(\"history\")) {  \t\t\t\t\tsave(input); //입력한 명령어 저장    \t\t\t\t\t  \t\t\t\t\t//LinkedList의 내용 표시  \t\t\t\t\tLinkedList list = (LinkedList)q;    \t\t\t\t\t  \t\t\t\t\tfinal int size = list.size();  \t\t\t\t\tfor(int i = 0 ; i&lt;size;i++)  \t\t\t\t\t\tSystem.out.println((i+1)+\".\"+list.get(i));  \t\t\t\t}else {  \t\t\t\t\tsave(input);  \t\t\t\t\tSystem.out.println(input);  \t\t\t\t} //if(input.equalsIgnoreCase(\"q\"))  \t\t\t}catch(Exception e) {  \t\t\t\tSystem.out.println(\"입력오류입니다\");  \t\t\t}  \t\t}  \t}      \tprivate static void save(String input) {  \t\t//queue에 저장(빈문자열은 저장안함)  \t\tif(!\"\".equals(input)) {  \t\t\tq.offer(input);    \t\t\t  \t\t\t//queue의 최대크기를 넘으면 제일 처음 입력된 것을 삭제  \t\t\tif(q.size()&gt;MAX_SIZE) //size()는 Collection인터페이스에 정의  \t\t\t\tq.remove(); // == q.pool();  \t\t}  \t}      }      peek : 꺼내지 않고 맨 위에 있는 것을 보는 것밑에 세 개가 예외발생x, 중점으로 쓸것Iterator(새버전), ListIterator, Enumeration(구버전): 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스      Iterator : 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한 것.  컬렉션에 iterator()를 호출해서 Iterator를 구현한 객체를 얻어서 사용          boolean hasNext() : 읽어올 요소가 남아있는지 확인, 있으면 true, 없으면 false(확인)      Object next() : 다음 요소를 읽어온다. next()를 호출하기 전에 hasnext()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다.(읽기)      Map에는 iterator()가 없다. keySet(), entrySet(), values()를 호출해야함                  Map map = new HashMap(); Iterator it =  map.entrySet().iterator();                        import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tList list = new ArrayList(); //다른컬렉션으로 변경할때 이거만 수정하면 됨  \t\tIterator it =list.iterator();    \t\t  \t\twhile (it.hasNext()) { //boolean hasNext() 읽어올 요소가 있는지 확인  \t\t\tSystem.out.println(it.next()); //Object next() 다음요소 읽음  \t\t}  \t}  }          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\t//Set은 Collection의 자손  //\t\tCollection c = new HashSet(); //for문의 get이 오류남  \t\tArrayList list = new ArrayList();  \t\tlist.add(\"1\");  \t\tlist.add(\"2\");  \t\tlist.add(\"3\");  \t\tlist.add(\"4\");  \t\tlist.add(\"5\");    \t\t  \t\t//Iterator를 사용했다면 표준화되어있기때문에 List나 Set 둘다 작동함  \t\tIterator it = list.iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t}    \t\t  \t\twhile(it.hasNext()) { //이미 한번 실행됐기때문에 false반환, 실행 안됨  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t\t//즉,Iterator는 1회용 코드임  \t\t}  \t\tSystem.out.println();  \t\t//새로운 iterator객체 얻어옴  \t\tit = list.iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t}  \t\tSystem.out.println();  \t\tfor(int i=0;i&lt;list.size();i++) {  \t\t\tObject obj = list.get(i);  \t\t\tSystem.out.println(obj);  \t\t}  \t}  }        Enumeration          boolean hasMoreElements() : 읽어올 요소가 남아있는지 확인, 있으면 true, 없으면 false(확인)      Object nextElement() : 다음 요소를 읽어온다. nextElements()를 호출하기 전에 hasMoreElements()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다.(읽기)        Listiterator : Iterator의 접근성을 향상시킨 것. (단방향 → 양방향 : 이전요소도 읽어올 수 있음)Array: 배열을 다루기 편한 메소드(static)을 제공  배열의 출력 -toString()  배열의 복사 - copyOf(), copyOfRange()  배열 채우기 - fill(), setAll()  배열의 정렬과 검색 - sort(), binarySearch()          sort()로 배열 정렬      binarySearch()로 위치 찾기        다차원 배열의 출력 - deepToString()  다차원 배열의 비교 - deepEquals()  배열을 List로 변환 - asList(Object…a)  람다와 스트임(14장)관련 - parallelXXX(). spliterator(), stream()import java.util.*;public class  Main {\t\tpublic static void main(String[] args) {\t\tint arr[] = {0,1,2,3,4};\t\tint arr2D[][] = { {11,12,13},{21,22,23} };\t\t\t\tSystem.out.println(\"arr = \"+Arrays.toString(arr));\t\tSystem.out.println(\"arr2D = \"+Arrays.toString(arr2D)); //arr2D = [[I@6b884d57, [I@38af3868]\t\tSystem.out.println(\"arr2D = \"+Arrays.deepToString(arr2D));\t\t        \t\tint arr2[] = Arrays.copyOf(arr, arr.length); //arr을 똑같이 복사\t\tint arr3[] = Arrays.copyOf(arr, 3);\t\tint arr4[] = Arrays.copyOf(arr, 7); //남는 공간에 0 채워넣음\t\tint arr5[] = Arrays.copyOfRange(arr, 2,4);\t\tint arr6[] = Arrays.copyOfRange(arr, 0,7);\t\t\t\tSystem.out.println(\"arr2 = \"+Arrays.toString(arr2));\t\tSystem.out.println(\"arr3 = \"+Arrays.toString(arr3));\t\tSystem.out.println(\"arr4 = \"+Arrays.toString(arr4));\t\tSystem.out.println(\"arr5 = \"+Arrays.toString(arr5));\t\tSystem.out.println(\"arr6 = \"+Arrays.toString(arr6));\t\t\t\tint arr7[] = new int[5];\t\tArrays.fill(arr7,9); //arr7 전부를 9로 채움 \t\tSystem.out.println(\"arr7 = \"+Arrays.toString(arr7));\t\t\t\tArrays.setAll(arr7,  i-&gt;(int)(Math.random()*6)+1);\t\tSystem.out.println(\"arr7 = \"+Arrays.toString(arr7));\t\t\t\t//향상된 for문. arr7에서 한개씩 꺼내서 i에 집어넣음 \t\tfor(int i : arr7) {\t\t\tchar graph[] = new char[i];\t\t\tArrays.fill(graph, '*');\t\t\tSystem.out.println(new String(graph)+i);\t\t}\t\t\t\tString str2D[][] = new String[][] { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\",\"CCC\"} };\t\tString str2D2[][] = new String[][] { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\",\"CCC\"} };\t\t\t\tSystem.out.println(Arrays.equals(str2D, str2D2)); //false\t\tSystem.out.println(Arrays.deepEquals(str2D, str2D2));\t\t\t\tchar charr[] = {'A','D','C','B','E'};\t\t\t\tSystem.out.println(\"charr = \"+Arrays.toString(charr));\t\tSystem.out.println(\"index of B = \"+Arrays.binarySearch(charr, 'B')); //정렬 전이라 안나옴\t\tSystem.out.println(\"= After sorting = \");\t\tArrays.sort(charr);\t\tSystem.out.println(\"charr = \"+Arrays.toString(charr));\t\tSystem.out.println(\"index of B = \"+Arrays.binarySearch(charr, 'B'));\t}              }— 순차 검색(탐색)과 이진 검색(탐색)  순차 검색 - 순차적으로 찾음  이진 검색 - 정렬 후 반씩 잘라서 특정지점만 찾기Comparator와 Comparable: 객체 정렬에 필요한 메소드(정렬기준 제공)를 정의한 인터페이스  Comparator : 기본 정렬기준을 구현, 두 객체를 비교  Comparable : 기본 정렬기준 외에 다른 기준으로 정렬, 주어진 객체를 자신과 비교  Compare()과 CompareTo()는 두 객체의 비교결과를 반환하도록 작성. 같으면 0, 오른쪽이 크면 음수, 오른쪽이 작으면 양수import java.util.*;public class  Main {\t\tpublic static void main(String[] args) {\t\tString strArr[] = {\"dog\",\"cat\",\"Tiger\",\"lion\"};\t\tSystem.out.println(\"strArrArray = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr); //Comparable구현에 의해 정렬\t\t//원래 Arrays.sort(정렬대상, 정렬기준)인데 String자체에 기본정렬기준[사전순]이 있어[String 안에 comparable 구현돼있음]지정안해줌\t\tSystem.out.println(\"strArrArray = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr, String.CASE_INSENSITIVE_ORDER); //대소문자 구분x\t\tSystem.out.println(\"strArr = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr, new Descending());\t\tSystem.out.println(\"strArr = \"+Arrays.toString(strArr));\t}              }class Descending implements Comparator{\tpublic int compare(Object o1, Object o2) {\t\tif(o1 instanceof Comparable &amp;&amp; o2 instanceof Comparable) {\t\t\tComparable c1 = (Comparable)o1;\t\t\tComparable c2 = (Comparable)o2;\t\t\treturn c1.compareTo(c2)*-1;\t\t\t//-1을 곱해서 기본정렬방식의 역순으로 변경. \t\t}\t\treturn -1;\t}}      Integer와 Comparable          버블정렬(불변)          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t}                static void sort(int [] intarr) {  \tfor(int i=0;i&lt;intarr.length-1;i++) {  \t\tfor(int j=0;j&lt;intarr.length-1-i;i++) {  \t\t\tint tmp = 0;    \t\t\t  \t\t\tif(intarr[j] &gt; intarr[j+1]) {  \t\t\t\ttmp = intarr[j];  \t\t\t\tintarr[j] = intarr[j+1];  \t\t\t\tintarr[j+1]=tmp;  \t\t\t}  \t\t}  \t}  }  }      Collections: 컬렉션을 위한 메소드(static)을 제공  컬렉션 채우기, 복사, 정렬, 검색 - fill(), copy(), sort(), binarySearch() 등      컬렉션의 동기화 - synchronized-0~~~()  List syncList = Colloections.synchronizedList(new ArrayList(…));  ⇒ 동기화 안된 synchronizedList를 넣으면 동기화된 List(Vector와 똑같은 효과)인 syncList가 반환됨    변경불가(readOnly)컬렉션 만들기 - unmodifiable~~~()  싱글톤 컬렉션 만들기 - singleton~~~() : 객체 1개만 저장하는 컬렉션      한종류의 객체만 저장하는 컬력션 만들기 - checked~~~() : 한가지 타입의 객체만 저장가능    List list = new ArrayList();  List checkedList = checkedList(list, String.class); //String만 저장가능  checkedList.add(“abc”);  checkedList.add(3); //에러  import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import static java.util.Collections.*; //Collections를 생략 기능public class  Main {\t\tpublic static void main(String[] args) {\t\tList list = new ArrayList();\t\tSystem.out.println(list);\t\t\t\taddAll(list,1,2,3,4,5); //원래 Collections.addAll()로 써야함\t\tSystem.out.println(list);\t\t\t\trotate(list,2);//반시계방향으로두번회전\t\tSystem.out.println(list);\t\t\t\tswap(list,0,2); //첫번째와 세번쨰를 교환\t\tSystem.out.println(list);\t\t\t\tshuffle(list); //저장된요소의 위치를 임의로 변경\t\tSystem.out.println(list);\t\t\t\tsort(list,reverseOrder()); \t\tSystem.out.println(list);\t\t\t\tsort(list); \t\tSystem.out.println(list);\t\t\t\tint idx = binarySearch(list,3);\t\tSystem.out.println(\"index of 3 = \"+idx);\t\t\t\tSystem.out.println(\"max = \"+max(list));\t\tSystem.out.println(\"min = \"+min(list));\t\tSystem.out.println(\"min = \"+max(list,reverseOrder()));\t\t\t\tfill(list,9); //9로 채움\t\tSystem.out.println(list);\t\t\t\t//list와 같은 크기의 새로운 list생성, 2로 채움\t\tList newlist = nCopies(list.size(),2);\t\tSystem.out.println(\"newList=\"+newlist);\t\t\t\t//공통요소가 없으면 true\t\tSystem.out.println(disjoint(list, newlist));\t\t\t\tcopy(list, newlist);\t\tSystem.out.println(\"newlist=\"+newlist);\t\tSystem.out.println(\"list=\"+list);\t\t\t\t//2를 1로 변경\t\treplaceAll(list,2,1);\t\tSystem.out.println(\"list=\"+list);\t\t\t\tEnumeration e = enumeration(list);\t\tArrayList list2 = list(e);\t\t\t\tSystem.out.println(\"list2 = \"+list2);\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - 날짜와 시간 & 형식화",
    "url": "/posts/%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84-&-%ED%98%95%EC%8B%9D%ED%99%94/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-21 00:00:00 +0900",
    





    
    "snippet": "날짜와 시간      java.util.Date : 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)  date의 메소드는 거의 사용되지 않지만(deprecated), 여전히 쓰이고 잇다.    java.util.Calendar :Date클래스를 개선한 새로운 클래스(JDK1.1), 여전히 단점이 있다 (실무에는 아직 쓰이는 곳이 많음    ...",
    "content": "날짜와 시간      java.util.Date : 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)  date의 메소드는 거의 사용되지 않지만(deprecated), 여전히 쓰이고 잇다.    java.util.Calendar :Date클래스를 개선한 새로운 클래스(JDK1.1), 여전히 단점이 있다 (실무에는 아직 쓰이는 곳이 많음          날짜와 시간을 같이 다루는 것이 단점        java.time 패키지 : Date와 Calendar의 단점을 개선한 새로운 클래스들을 제공(JDK1.8=JDK8)          날짜와 시간의 클래스를 나누어 놓음(LocalDate, LocalTime, LocalDateTime)      Calender클래스추상클래스. getinstace()를 통해 구현된 객체를 얻어야 한다.Calendar cal = new Calendar.getInstance(); //사용자 시스템에 기반해서 서양력, 불교력, 일본력 중 하나를 가져온다. (달력을 지정하는것 보다 애매하게 쓰는게 나중에 달력변경 시 조금만 수정해도 사용할 수 있음 - 추상화 )  get()으로 날짜와 시간 가져오기 - int ger(int field)import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar cal = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tint thisYear = cal.get(Calendar.YEAR); //현재 몇년도인지\t\tint lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);//이달의 마지막 날\t\tSystem.out.println(lastDayOfMonth);\t\t}}            필드명      설명                  YEAR      년              MONTH      월(0부터 시작)              WEEK_OF_MONTH      그 달의 몇 번째 주              WEEK_OF_YEAR      그 해의 몇 번째 주              DATE      일              DAY_OF_MONTH      그 달의 몇 번째 일              DAY_OF_YEAR      그 해의 몇 번째 일              DAY_OF_WEEK      요일              DAY_OF_WEEK_IN_MONTH      그 달의 몇 번째 요일              HOUR      시간(0~11)              HOUR_OF_DAY      시간(0~23)              MINUTE      분              SECOND      초              MILLISECOND      천분의 1초              ZONE_OFFSET      GMT기준 시차(천분의 1초단위)  (한국은 GMT시간보다 9시간빨라서 9로 표시)              AM_PM      오전/오후      import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar cal = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tint thisYear = cal.get(Calendar.YEAR); //현재 몇년도인지\t\tint lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);//이달의 마지막 날\t\tSystem.out.println(lastDayOfMonth);\t\tSystem.out.println(cal.get(Calendar.DAY_OF_WEEK_IN_MONTH));\t\tSystem.out.println(cal.get(Calendar.MONTH)); //0부터시작해서 7나옴 8월임\t\tSystem.out.println(cal.get(Calendar.WEEK_OF_YEAR)); //0부터시작해서 7나옴 8월임\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar today = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tSystem.out.println(\"이 해의 연도 : \"+today.get(Calendar.YEAR));\t\tSystem.out.println(\"월(0~11, 0:1월) : \"+today.get(Calendar.MONTH));\t\tSystem.out.println(\"이 해의 몇 째 주 : \"+today.get(Calendar.WEEK_OF_YEAR));\t\tSystem.out.println(\"이 달의 몇 째 주 : \"+today.get(Calendar.WEEK_OF_MONTH));\t\t\t//DATE와 DAY_OF_MONTH는 같다\t\tSystem.out.println(\"이 달의 며칠 : \"+today.get(Calendar.DATE));\t\tSystem.out.println(\"이 달의 며칠 : \"+today.get(Calendar.DAY_OF_MONTH));\t\tSystem.out.println(\"이 해의 며칠 : \"+today.get(Calendar.DAY_OF_YEAR));\t\tSystem.out.println(\"요일(1~7, 1은 일요일) : \"+today.get(Calendar.DAY_OF_WEEK));\t\tSystem.out.println(\"이 달의 몇 째 요일 : \"+today.get(Calendar.DAY_OF_WEEK_IN_MONTH));\t\tSystem.out.println(\"오전/오후(0:오전,1:오후) : \"+today.get(Calendar.AM_PM));\t\tSystem.out.println(\"시간(0~11) : \"+today.get(Calendar.HOUR));\t\tSystem.out.println(\"시간(0~23) : \"+today.get(Calendar.HOUR_OF_DAY));\t\tSystem.out.println(\"분(0~59) : \"+today.get(Calendar.MINUTE));\t\tSystem.out.println(\"초(0~59) : \"+today.get(Calendar.SECOND));\t\tSystem.out.println(\"1000분의 1초(0~999) : \"+today.get(Calendar.MILLISECOND));\t\t//천분의 1초를 시간으로 표시하기 위해 360000으로 나눔(1시간 = 60*60초)\t\tSystem.out.println(\"TimeZone : \"+today.get(Calendar.ZONE_OFFSET/(60*60/1000)));\t\tSystem.out.println(\"이 달의 마지막 날 : \"+today.getActualMaximum(Calendar.DATE));\t}}  set()으로 날짜와 시간 지정하기datel = Calendar.getInstance();//\t\tdatel.set(Calendar.YEAR, 2022);//\t\tdatel.set(Calendar.MONTH, 10); //11월//\t\tdatel.set(Calendar.DATE, 20);\t\tdatel.set(2022,10,20); //2022년 11월 20일\t\t\t\tCalendar timel = Calendar.getInstance();//\t\tdatel.set(Calendar.HOUR_OF_DAY, 10); //10시//\t\tdatel.set(Calendar.MINUTE, 20); //20분 //\t\tdatel.set(Calendar.SECOND, 30); //30초\t\ttimel.set(10,20,30); //10시import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\t//요일 숫자-&gt;문자열로 바꾸어 표시\t\tfinal String[] DAY_OF_WEEK = {\"\",\"일\",\"월\",\"화\",\"수\",\"목\",\"금\",\"토\",\"일\"};\t\tCalendar date1 = Calendar.getInstance();\t\tCalendar date2 = Calendar.getInstance();\t\t\t\t//month의 경우 0부터 시작하기 때문에 4월인경우 3으로 지정\t\tdate1.set(2022, 3,29);//2022년 4월 29일\t\tSystem.out.println(\"date1은 \" +toString(date1)+DAY_OF_WEEK[date1.get(Calendar.DAY_OF_WEEK)]+\"요일이고, \");\t\tSystem.out.println(\"date2는 \" +toString(date2)+DAY_OF_WEEK[date2.get(Calendar.DAY_OF_WEEK)]+\"요일입니다.\");\t\t//두 날짜간의 차이를 얻으려면, gerTimeInMillis()-날짜,시간을 초단위로 바꿔줌[/1000해줘야함]- 천분의 일초단위로 변환\tlong difference = (date2.getTimeInMillis() - date1.getTimeInMillis())/1000;\tSystem.out.println(\"date1부터 date2까지 \"+difference+\"초가 지났습니다.\");\tSystem.out.println(\"일(day)로 계산하면 \"+difference/(24*60*60)+\"일입니다\");\t//1일 = 24*60*60\t}\tpublic static String toString(Calendar date) {\t\treturn date.get(Calendar.YEAR)+\"년 \"+(date.get(Calendar.MONTH)+1)+\"월 \"+date.get(Calendar.DATE)+\"일\";\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tfinal int[] TIME_UNIT = {3600,60,1};\t\tfinal String[] TIME_UNIT_NAME= {\"시간\",\"분\",\"초\"};\t\tCalendar time1 = Calendar.getInstance();\t\tCalendar time2 = Calendar.getInstance();\t\t\t\ttime1.set(Calendar.HOUR_OF_DAY,10);\t\ttime1.set(Calendar.MINUTE,20);\t\ttime1.set(Calendar.SECOND,30);\t\ttime2.set(Calendar.HOUR_OF_DAY,20);\t\ttime2.set(Calendar.MINUTE,30);\t\ttime2.set(Calendar.SECOND,10);\t\t\t\tSystem.out.println(\"time1 : \"+time1.get(Calendar.HOUR_OF_DAY)+\"시 \"+time1.get(Calendar.MINUTE)+\"분 \"+time1.get(Calendar.SECOND)+\"초\");\t\tSystem.out.println(\"time2 : \"+time2.get(Calendar.HOUR_OF_DAY)+\"시 \"+time2.get(Calendar.MINUTE)+\"분 \"+time2.get(Calendar.SECOND)+\"초\");\t\t\t\t//Math.abs:절대값\t\tlong different = Math.abs(time2.getTimeInMillis()-time1.getTimeInMillis())/1000;\t\tSystem.out.println(\"time1과 time2의 차이는 \"+different+\"초 입니다\");\t\t\t\tString tmp=\"\";\t\tfor(int i=0;i&lt;TIME_UNIT.length;i++) {\t\t\ttmp += different/TIME_UNIT[i]+TIME_UNIT_NAME[i];\t\t\tdifferent %= TIME_UNIT[i];\t\t}\t\tSystem.out.println(\"시분초로 변환하면 \"+tmp+\"입니다.\");\t}}  clear()는 Calendar객체의 모든 필드를 초기화 → 1970년 1월 1일 00:00:00으로 초기화  clear(int field)는 Calendar객체의 특정 필드를 초기화 → 0초 or 0분 or …import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tSystem.out.println(getDaydiff(\"20010103\",\"20010101\")); //2\t\tSystem.out.println(getDaydiff(\"20010103\",\"20010103\")); //0\t\tSystem.out.println(getDaydiff(\"20010103\",\"200103\")); //형식안맞음.\t}\tpublic static int getDaydiff(String yyyymmdd1, String yyyymmdd2) {\t\tint diff=0;\t\ttry{\t\tint year1 = Integer.parseInt(yyyymmdd1.substring(0,4));\t\tint month1 = Integer.parseInt(yyyymmdd1.substring(4,6));\t\tint day1 = Integer.parseInt(yyyymmdd1.substring(6,8));\t\tint year2 = Integer.parseInt(yyyymmdd2.substring(0,4));\t\tint month2 = Integer.parseInt(yyyymmdd2.substring(4,6));\t\tint day2 = Integer.parseInt(yyyymmdd2.substring(6,8));\t\t\t\tCalendar date1 = Calendar.getInstance();\t\tCalendar date2 = Calendar.getInstance();\t\t//date1, date2사이의 약간의(0.000...초 정도)차이 발생//\t\tSystem.out.println(\"date1 : \"+date1);//\t\tSystem.out.println(\"date2 : \"+date2);\t\t//time세팅을 clear해줘야함\t\tdate1.clear();\t\tdate2.clear();\t\tdate1.set(year1, month1,day1);\t\tdate2.set(year2, month2,day2);\t\tdiff=(int)((date1.getTimeInMillis()-date2.getTimeInMillis())/(24*60*60*1000));\t\t} catch(Exception e) {\t\t\tdiff = 0;//substring, parseInt에서 예외 발생시\t\t}\t\treturn diff;\t}}            add()는 특정 필드의 값을 증가 또는 감소(다른 필드에 영향o)      8월 31일에서 일에 +1하면 월도 +1됨                  roll()은 특정 필드의 값을 증가 또는 감소(다른 필드에 영향x)      8월 31일에서 일에 +1해도 월은 그대로임      import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar date = Calendar.getInstance();\t\tdate.set(2022, 7,31);\t\t\t\tSystem.out.println(toString(date)); //8/31\t\tSystem.out.println(\"1일 후\");\t\tdate.add(Calendar.DATE, 1);\t\tSystem.out.println(toString(date)); //9/1\t\tSystem.out.println();\t\tSystem.out.println(\"6달 전\");\t\tdate.add(Calendar.MONTH, -6);\t\tSystem.out.println(toString(date));//3/1\t\tSystem.out.println();\t\tSystem.out.println(\"31일 후(roll)\"); //다른필드(월)에 영향x\t\tdate.roll(Calendar.DATE,31);\t\tSystem.out.println(toString(date)); //3/1\t\tSystem.out.println();\t\tSystem.out.println(\"31일 후(add)\");\t\tdate.add(Calendar.DATE,31);\t\tSystem.out.println(toString(date)); //4/1\t}\tpublic static String toString(Calendar date) {\t\treturn date.get(Calendar.YEAR)+\"년 \"+(date.get(Calendar.MONTH)+1)+\"월 \"+date.get(Calendar.DATE)+\"일\";\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {//달력찍기\t\tif(args.length !=2) {\t\t\tSystem.out.println(\"usage : java Ex10\");\t\t\treturn;\t\t}\t\tint year = Integer.parseInt(args[0]);\t\tint month = Integer.parseInt(args[1]);\t\tint START_DAY_OF_WEEK = 0;\t\tint END_DAY_OF_WEEK = 0;\t\t\t\tCalendar sDay = Calendar.getInstance();//시작일\t\tCalendar eDay = Calendar.getInstance();//끝일\t\t\t\t//월의 경우 -1해줘야함 (0~11)\t\tsDay.set(year,month-1,1);\t\teDay.set(year,month,1);\t\t\t\t//다음 달 첫날에서 하루를 빼면 현재달의 마치막 날이 출력\t\teDay.add(Calendar.DATE, -1);\t\t\t\t//첫번째요일이 무슨 요일인지\t\tSTART_DAY_OF_WEEK = sDay.get(Calendar.DAY_OF_WEEK);\t\t\t\t//eDay의 지정된 날짜\t\tEND_DAY_OF_WEEK=eDay.get(Calendar.DATE);\t\t\t\tSystem.out.println(\"       \"+args[0]+\"년 \"+args[1]+\"일\");\t\tSystem.out.println(\" SU MO TU WE TH FR SA\");\t\t\t\t//해당 월의 1일이 어느 요일인지에 따라서 공백을 출력(일요일부터 시작)\t\tfor(int i=1;i&lt;START_DAY_OF_WEEK;i++) {\t\t\tSystem.out.print(\"   \");\t\t}\t\tfor(int i = 1, n=START_DAY_OF_WEEK;i&lt;=END_DAY_OF_WEEK;i++,n++) {\t\t\tSystem.out.print((i&lt;10)?\"  \"+i:\" \"+i);\t\t\tif(n%7==0) System.out.println();\t\t}\t}}      Date와 Calendar간의 변환          Date의 메소드는 대부분 deprecated되었지만 여전히 사용됨(하위호환성-옛날 기능도 계속 지원해주려고 신경씀)          import java.util.Calendar;      public class  Main {  \tpublic static void main(String[] args) {  \t\t//Calendar-&gt;Date  \t\tCalendar cal = Calendar.getInstance();  \t\tDate d = new Date(cal.getTimeInMillis()); //Date(long date)    \t\t  \t\t//Date -&gt; Calendar  \t\tDate d = new Date();  \t\tCalendar cal = Calendar.getInstance();  \t\tcal.setTime(d);  \t}  }      형식화클래스: java.text 패키지의 DecimalFormat(10진수숫자형식) SimpleDateFormat(날짜형식화)  숫자와 날짜를 원하는 형식으로 쉽게 출력 가능 (숫자, 날짜 → 형식문자열)import java.text.DecimalFormat;public class  Main {\tpublic static void main(String[] args) {\t\tdouble num = 1234567.89;\t\tDecimalFormat df = new DecimalFormat(\"#.\\#E0\"); //지수형식 \t\tSystem.out.println(df); //java.text.DecimalFormat@5c8\t\tString result = df.format(num);\t\tSystem.out.println(result); //1.2E6\t}}  형식 문자열에서 숫자와 날짜를 뽑아내는 기능(형식문자열→숫자, 날짜)import java.text.DecimalFormat;import java.text.ParseException;public class  Main {\tpublic static void main(String[] args) throws ParseException {\t\tDecimalFormat df = new DecimalFormat(\"#,###.##\"); //지수형식 \t\tNumber num = df.parse(\"1,234,567.89\");\t\tdouble d = num.doubleValue();\t\tSystem.out.println(d); //1234567.89\t}}      DecimalFormat                  숫자를 형식화 할때 사용(숫자 → 형식문자열)                            특정 형식의 문자열을 숫자로 변환할 때도 사용(형식 문자열→숫자)          import java.text.DecimalFormat;          public class  Main {  \tpublic static void main(String[] args) {  \t\tdouble num = 1234567.89;  \t\tString[] pattern = {  \t\t\t\t\"0\",  \t\t\t\t\"#\",  \t\t\t\t\"0.0\",  \t\t\t\t\"#.#\",  \t\t\t\t\"0000000000.0000\",  \t\t\t\t\"##########.####\",  \t\t\t\t\"#.\\#-\",  \t\t\t\t\"-#.#\",  \t\t\t\t\"#,###.##\",  \t\t\t\t\"#,####.##\",  \t\t\t\t\"\\#E0\",  \t\t\t\t\"0E0\",  \t\t\t\t\"#\\#E0\",  \t\t\t\t\"00E0\",  \t\t\t\t\"###\\#E0\",  \t\t\t\t\"0000E0\",  \t\t\t\t\"#.\\#E0\",  \t\t\t\t\"0.0E0\",  \t\t\t\t\"0.000000000E0\",  \t\t\t\t\"00.00000000E0\",  \t\t\t\t\"000.0000000E0\",  \t\t\t\t\"#.########\\#E0\",  \t\t\t\t\"##.#######\\#E0\",  \t\t\t\t\"###.######\\#E0\",  \t\t\t\t\"#,###.##+;\\#m###.#\\#-\",  \t\t\t\t\"#.#%\",  \t\t\t\t\"#,#\\u2030\",  \t\t\t\t\"\\u00A4 #,####\",  \t\t\t\t\"'#'#,###\",  \t\t\t\t\"''#,###\",  \t\t};  \t\tfor(int i=0;i&lt;pattern.length;i++) {  \t\t\tDecimalFormat df = new DecimalFormat(pattern[i]);  \t\t\tSystem.out.printf(\"%19s : %s\\n\",pattern[i],df.format(num));  \t\t}  \t}  }  /*  0 : 1234568  # : 1234568  0.0 : 1234567.9  #.# : 1234567.9  0000000000.0000 : 0001234567.8900  ##########.#### : 1234567.89  #.\\#- : 1234567.9-  -#.# : -1234567.9  #,###.## : 1,234,567.89  #,####.## : 123,4567.89  \\#E0 : .1E7  0E0 : 1E6  #\\#E0 : 1.2E6  00E0 : 12E5  ###\\#E0 : 123.5E4  0000E0 : 1235E3  #.\\#E0 : 1.2E6  0.0E0 : 1.2E6  0.000000000E0 : 1.234567890E6  00.00000000E0 : 12.34567890E5  000.0000000E0 : 123.4567890E4  #.########\\#E0 : 1.23456789E6  ##.#######\\#E0 : 1.23456789E6  ###.######\\#E0 : 1.23456789E6  #,###.##+;\\#m###.#\\#- : 1,234,567.89+  #.#% : 123456789%  #,#‰ : 1,2,3,4,5,6,7,8,9,0‰  ¤ #,#### : ? 123,4568  '#'#,### : \\#1,234,568  ''#,### : '1,234,568  */                      ⚠️ Integer,parseInt는 콤마(,)가 포함된 문자열을 숫자로 변환 못함      import java.text.DecimalFormat;      public class  Main {  \tpublic static void main(String[] args) {  \t\tDecimalFormat df = new DecimalFormat(\"#,###.#\");  \t\tDecimalFormat df2 = new DecimalFormat(\"#.##\\#E0\");    \t\t  \t\ttry {  //\t\t\tSystem.out.println(Double.parseDouble(\"1,234,567.89\")); //콤마때매 변환 불가로 에러  \t\t\tSystem.out.println(Double.parseDouble(\"1234567.89\"));   \t\t\tNumber num = df.parse(\"1,2 34,567.89\");  \t\t\tSystem.out.print(\"1,234,567.89\"+\" -&gt; \");    \t\t\t  \t\t\tdouble d = num.doubleValue();  \t\t\tSystem.out.print(d+\" -&gt; \"); //1234567.89    \t\t\t  \t\t\tSystem.out.println(df2.format(num)); //1.235E6  \t\t} catch(Exception e) {  \t\t}  \t}  }            SimpleDateFormat          날짜와 시간을 다양한 형식으로 출력할 수 있게 해줌          import java.text.SimpleDateFormat;  import java.util.Date;      public class  Main {  \tpublic static void main(String[] args) {  \t\tDate today = new Date();  \t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");//소문자 mm은 분이 출력    \t\t  \t\tString result = df.format(today);  \t\tSystem.out.println(result);  \t}  }              특정 형식으로 된 문자열에서 날짜와 시간 뽑아내기          import java.text.DateFormat;  import java.text.ParseException;  import java.text.SimpleDateFormat;  import java.util.Date;      public class  Main {  \tpublic static void main(String[] args) throws ParseException {  \t\tDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");  \t\tDateFormat df2 = new SimpleDateFormat(\"yyyy/MM/dd\");    \t\t  \t\tDate d = df.parse(\"2015년 11월 23일\"); //문자열에서 날짜 뽑기  \t\tString result = df2.format(d); //뽑은 날자 문자열로 바꾸기  \t\tSystem.out.println(result); //2015/11/23    \t\t  \t}  }      월은 MM으로import java.text.SimpleDateFormat;import java.util.Date;public class  Main {\tpublic static void main(String[] args) {\t\tDate today = new Date();\t\t\t\tSimpleDateFormat sdf1, sdf2,sdf3,sdf4;\t\tSimpleDateFormat sdf5, sdf6,sdf7,sdf8,sdf9;\t\t\t\tsdf1=new SimpleDateFormat(\"yyyy-MM-dd\");\t\tsdf2=new SimpleDateFormat(\"''yy년 MMM dd일 E요일\");\t\tsdf3=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\t\tsdf4=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss a\");\t\t\t\tsdf5=new SimpleDateFormat(\"오늘은 올 해의 D번째 날입니다\");\t\tsdf6=new SimpleDateFormat(\"오늘은 이 달의 d번째 날입니다\");\t\tsdf7=new SimpleDateFormat(\"오늘은 올 해의 w번째 주입니다\");\t\tsdf8=new SimpleDateFormat(\"오늘은 이 달의 W번째 날입니다\");\t\tsdf9=new SimpleDateFormat(\"오늘은 이 달의 F번째 E요일입니다\");\t\t\t\tSystem.out.println(sdf1.format(today));\t\tSystem.out.println(sdf2.format(today));\t\tSystem.out.println(sdf3.format(today));\t\tSystem.out.println(sdf4.format(today));\t\tSystem.out.println(sdf5.format(today));\t\tSystem.out.println(sdf6.format(today));\t\tSystem.out.println(sdf7.format(today));\t\tSystem.out.println(sdf8.format(today));\t\tSystem.out.println(sdf9.format(today));\t}}import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;public class  Main {\tpublic static void main(String[] args) {\t\tDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");\t\tDateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd\");\t\t\t\ttry {\t\t\tDate d = df.parse(\"2022년 9월 30일\");\t\t\tSystem.out.println(df2.format(d));\t\t}catch(Exception e) {}\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - java.lang 패키지와 유용한 클래스",
    "url": "/posts/java.lang%ED%8C%A8%ED%82%A4%EC%A7%80%EC%99%80_%EC%9C%A0%EC%9A%A9%ED%95%9C_%ED%81%B4%EB%9E%98%EC%8A%A4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-15 00:00:00 +0900",
    





    
    "snippet": "Object 클래스: 모든 클래스의 최고 조상. 오직 11개의 메소드만을 가지고 있다.nitity(), wait() 등은 쓰레드(13장)와 관련된 메소드이다            Object클래스의 메소드      설명                  protected Object clone()      객체 자신의 복사본을 반환              ...",
    "content": "Object 클래스: 모든 클래스의 최고 조상. 오직 11개의 메소드만을 가지고 있다.nitity(), wait() 등은 쓰레드(13장)와 관련된 메소드이다            Object클래스의 메소드      설명                  protected Object clone()      객체 자신의 복사본을 반환              public boolean equals(Object obj)      객체 자신과 객체 obj가 같은 객체인지 알려준다(같으면 true)              protected public void finalize()      객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출. 이 때 수행되어야하는 코드가 있을 때 오버라이딩(거의 사용안함)              public Class getClass()      객체 자신의 클래스 정보를 담고있는 Class 인스턴스를 반환              public int hashCode      객체 자신의 해시코드를 반환              public String toString()      객체 자신의 정보를 문자열로 반환              public void notify()      객체 자신을 사용하려고 기다리는 쓰레드 하나만 깨움              public void notifyAll()      객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨움              public void wait()  public void wait(long time out)  public void wait(long timeout, int nanos)      다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다. (timeout은 천분의 1초, nanos는 10의9제곱분의 1초)        [!important]Class처럼 앞글자가 대문자인 Class는 클래스 정보를 담기위한 클래스이다.자바 파일을 저장할때 class파일이 생성되고, class 객체가 생성됨. Class를 호출하면 이때 생성된 class객체를 가지고옴이것을 가지고 객체 생성도 하고 정보를 얻을 수 있게 하는 것이 ReflectionAPI라고 한다.equals(Object obj): 객체 자신(this)과 주어진 객체(obj)를 비교한다. 같으면 true, 다르면 falseObject클래스의 equal()는 객체의 주소를 비교(참조변수 값 비교)— == 는 각 객체의 주소가 같을 경우에만 true. 서로 다른 두 객체는 항상 주소가 다르다.//Object의 equals()를 오버라이딩 해서 주소가 아닌 value값을 비교하도록 함class Value{\tint value;\t\tValue(int value){\t\tthis.value = value;\t}\tpublic boolean equals(Object obj) { //오버라이딩\t\t//참조변수의 형변환 전에는 반드시 instaceof로 확인해야 함.\t\tif(!(obj instanceof Value)) return false;\t\tValue v = (Value)obj; //obj를 value로 형변환. obj안에 value라는 멤버가 없음\t\t//return this == obj; //주소비교. 서로 다른 객체는 항상 다른 주소를 가져서 거짓이 나옴\t\treturn this.value == v.value;\t}}public class  Main {\tpublic static void main(Strin] args) {\t\tValue v1 = new Value(10);\t\tValue v2 = new Value(10);\t\tSystem.out.println(v1.value);\t\tSystem.out.println(v2.value);\t\tSystem.out.println(v1);\t\tSystem.out.println(v2);\t\tSystem.out.println(\"=====================\");\t\tif(v1 == v2) \t\t\tSystem.out.println(\"v1과 v2의 값이 같습니다\");\t\t\t\telse \t\t\tSystem.out.println(\"v1과 v2의 값이 다릅니다\"); //출력됨\t\tSystem.out.println(\"=================\");\t\tif(v1.equals(v2)) \t\t\tSystem.out.println(\"v1과 v2의 값이 같습니다\"); //출력됨\t\t\t\telse \t\t\tSystem.out.println(\"v1과 v2의 값이 다릅니다\");\t\t\t}}  인스턴스 변수의 값을 비교하도록 equals()를 오버라이딩class person{\tlong id;\t\tpublic boolean equals(Object obj) {\t\tif(obj instanceof person) {\t\t\treturn id == ((person)obj).id; //obj가 Object타입 값이므로 id값을 참조하기 위해서 person타입으로 형변환 필요\t\t}\t\telse \t\t\treturn false; //타입이 person이 아니라면 값을 비교할 필요도 없다.\t}}class Person{\tlong id;\t\tpublic boolean equals(Object obj) {\t\tif(!(obj instanceof Person)) {\t\t\treturn false; //타입이 person이 아니라면 값을 비교할 필요도 없다.\t}//\t\treturn id == ((Person)obj).id;\t\tPerson p = (Person)obj;\t\treturn id == p.id;\t}\tPerson(long id){\t\tthis.id = id;\t}}public class  Main {\tpublic static void main(Strin] args) {\t\tPerson p1 = new Person(8011081111222L);\t\tPerson p2 = new Person(8011081111222L);\t\t\t\tif(p1.equals(p2))\t\t\tSystem.out.println(\"p1과 p2는 같은 사람입니다\"); //출력\t\telse\t\t\tSystem.out.println(\"p1과 p2는 다른 사람입니다.\");\t}}hashCode(): 객체의 해시코드(hash code)를 반환하는 메소드Object클래스의 hashCode()는 객체의 주소를 int로 변환해서 반환⇒ 객체의 지문이라고 부르기도 함.public class Object{\tpublic native int hashcode();}      equals()를 오버라이딩하면, hashCode()도 오버라이딩해야한다.    : 둘다 객체의 주소를 가지고 작업하기 때문에 둘다 주소를 iv를 사용하여 작업하도록 오버라이딩 해야함    equals()의 결과가 true인 두 객체의 해시코드는 같아야 하기 때문      public class  Main {      \tpublic static void main(Strin] args) {  \t\tString str1 = new String(\"abc\");  \t\tString str2 = new String(\"abc\");  \t\tSystem.out.println(str1.equals(str2)); //true  \t\tSystem.out.println(str1.hashCode()); //96354  \t\tSystem.out.println(str2.hashCode()); //96354  \t\t//equals값이 같으면 hashCode값도 같아야 함    \t\t  \t\t//System.identityHashCode(str1) == Object클래스의 hashCode  \t\tSystem.out.println(System.identityHashCode(str1));  \t\tSystem.out.println(System.identityHashCode(str2));  \t\t//오버라이딩 하기 전의 기능이 필요할 때 사용. 객체마다 다른 해시코드를 반환함.  \t}  }      toString(), toString()의 오버라이딩      toString() : 객체를 문자열(string)으로 반환하기 위한 메소드  -&gt; ‘객체 == iv집합’이므로 객체를 문자열로 변환한다는 것은 iv값을 문자열로 변환한다는 것과 같은 의미    public String toString() { //Object클래스의 toString()  return  getClass().getName()+”@”+Integer.toHexString(hashCode());  }      class Card{  \tpublic String toString() {    //Object클래스의 toString()  \t\treturn \"kind : \"+kind+\", number : \"+number;  \t} //toString 오버라이딩  \tString kind;  \tint number;    \t  \tCard(){  \t\tthis(\"SPADE\",1);  \t}    \t  \tCard(String kind, int number){  \t\tthis.kind = kind;  \t\tthis.number = number;  \t}  }  public class  Main {  \tpublic static void main(Strin] args) {  \t\tSystem.out.println(new Card().toString()); //Card@7a81197d, kind : SPADE, number : 1  \t\tSystem.out.println(new Card(\"HEART\",10).toString()); //Card@5ca881b5 , kind : HEART, number : 10  \t}  }          import java.util.Objects;      class Card{  \tString kind;  \tint number;    \t  \tCard(){  \t\tthis(\"SPADE\",1);  \t}    \t  \t//============================  \t////Source탭의 Generate hashCode()and equals()가 자동으로 해준 hashCode와 equals의 오버라이딩  //\t@Override  //\tpublic int hashCode() {  //\t\treturn Objects.hash(kind, number);  //\t}  //  //\t@Override  //\tpublic boolean equals(Object obj) {  //\t\tif (this == obj)  //\t\t\treturn true;  //\t\tif (obj == null)  //\t\t\treturn false;  //\t\tif (getClass() != obj.getClass())  //\t\t\treturn false;  //\t\tCard other = (Card) obj;  //\t\treturn Objects.equals(kind, other.kind) &amp;&amp; number == other.number;  //\t} //별로 안어려워서 직접 만드는게 더 직관적이고 좋을 확률이 큼!!  //================================================  \tpublic boolean equals(Object obj) {  \t\tif(!(obj instanceof Card))  \t\t\treturn false;    \t\t  \t\tCard c = (Card)obj;  \t\treturn this.kind.equals(c.kind) &amp;&amp; this.number==c.number;  \t\t//kind가 문자열이라서 equals 써줌  \t}  \tequals() 오버라이딩 해주면 hashCode도 오버라이딩 해줘야함  \tpublic int hashCode() {  \t\treturn Objects.hash(kind, number /*더 넣어도 됨*/);   \tint hash(Object... value){...} : 매개변수가 가변인자(Object...)라서 호출시 지정하는 값의 개수가 정해져 있지 않다.  \t}//iv가 같으면 같은 값이 나오게 됨    \t    \t  \tCard(String kind, int number){  \t\tthis.kind = kind;  \t\tthis.number = number;  \t}  \tpublic String toString() {    //Object클래스의 toString()  \t\treturn \"kind : \"+kind+\", number : \"+number;  \t} //toString 오버라이딩  }  public class  Main {  \tpublic static void main(Strin] args) {  \t\tCard c1 = new Card();  \t\tCard c2 = new Card();  \t\tSystem.out.println(c1.toString()); //Card@7a81197d, kind : SPADE, number : 1  \t\tSystem.out.println(c2.toString()); //Card@5ca881b5 , kind : HEART, number : 10  \t\tSystem.out.println(\"===================\");  \t\tSystem.out.println(c1.equals(c2));  \t\tSystem.out.println(c1.hashCode()); //-1842861219  \t\tSystem.out.println(c2.hashCode()); //-1842861219  \t\t//equals가 true면 hashCode가 똑같이 나와야 함  \t\tSystem.out.println(\"===================\");  \t\tCard c3 = new Card(\"HEART\",10);  \t\tCard c4 = new Card(\"DIAMON\",5);  \t\tSystem.out.println(c3.toString()); //kind : HEART, number : 10  \t\tSystem.out.println(c4.toString()); //kind : DIAMON, number : 5  \t\tSystem.out.println(c3.equals(c4)); //false  \t\tSystem.out.println(c3.hashCode()); //2127040613  \t\tSystem.out.println(c4.hashCode()); //-1921929034  \t\t//equals가 false라서 hashCode도 다른 값이 출력됨  \t}  }      String클래스: 문자열을 다루기 위한 클래스String클래스 = 데이터(char[]) + 메소드(문자열관련)내용을 변경할 수 없는 불변(immutable) 클래스String a = “a”; String b = “b”; a=a+b;일때 a의 “a”값이 사라지고 “ab”가 들어오는게 아니라 “ab”라는 객체가 새로 생성되어 a에 “ab”객체의 주소가 들어가고 “a” 객체는 사라지지않음.⇒ 덧셈 연산자를 이용한 문자열 결합은 성능이 떨어짐(매번 객체가 새로 생성됨)문자열의 변경이나 결합이 잦다면, 내용을 변경 가능한 StringBuffer(내용변경가능)를 사용      문자열 비교      public class  Main {  \tpublic static void main(Strin] args) {  \t\t//하나의 문자열을 여러 참조변수가 공유  \t\tString str1 = \"abc\"; //문자열 리터럴 \"abc\"의 주소가 str1에 저장됨  \t\tString str2 = \"abc\"; //문자열 리터럴 \"abc\"의 주소가 str1에 저장됨  \t\tSystem.out.println(str1 == str2); //true  \t\tSystem.out.println(\"equals 비교 : \"+str1.equals(str2)); //true    \t\t  \t\t//항상 새로운 객체 생성  \t\tString str3 = new String(\"abc\");//새로운 String인스턴스 생성  \t\tString str4 = new String(\"abc\");//새로운 String인스턴스 생성  \t\tSystem.out.println(str3 == str4); //false  \t\tSystem.out.println(\"equals 비교 : \"+str3.equals(str4)); //true  \t\t//String은 변경 불가라 굳이 이렇게 할 필요는 없음  \t}  }        문자열 리터럴 : 프로그램 실행시 자동으로 생성 (constant pool에 저장”          같은 내용의 문자열 리터럴은 하나만 만들어짐(불변이라)ㅈ            빈 문자열 (””, empty string)    : 내용이 없는 크기가 0인 char형 배열을 저장하는 문자열        크기가 0인 배열을 생성하는 것은 어느 타입이나 가능.      public class  Main {  \tpublic static void main(Strin] args) {  \t\tchar charr[] = new char[0]; //길이가 0인 배열 = 데이터 저장 불가  \t\tint iarr[] = {}; //길이가 0인 배열 = 데이터 저장 불가  \t\t//주로 숫자를 문자로 바꿀때나(\"\"+5=\"5\") 배열초기화시(null보다 빈문자열이 편리) 사용함  \t}  }      CharSequence : 인터페이스. CharBuffer, Segment, String, StringBuffer, StringBuilder 클래스들의 공통 조상이 없어서 CharSequence 인터페이스로 묶어준거임.regex : 정규식join()과 StringJoinner: 여러 문자열 사이에 구분자를 넣어서 결합한다. (static메소드)import java.util.Arrays;public class  Main {\tpublic static void main(Strin] args) {\t\tString animals = \"dog,cat,bear\";\t\tString arr[] = animals.split(\",\"); //위 문자열을 ,별로 나눠서 배열로 저장\t\tSystem.out.println(Arrays.toString(arr));/dog, cat, bear]\t\tString str = String.join(\"-\", arr); //배열의 문자열을 '-'로 구분해서 결합(배열x 문자열o)\t\tSystem.out.println(str); //dog-cat-bear\t}}문자열과 기본형 간의 변환      숫자를 문자열로 바꾸는 법      \t\tint i = 100;  \t\tString str1 = i+\"\";  \t\tString str2 = String.valueOf(i);            문자열을 숫자로 바꾸는 법      \t\tint i2 = Integer.parseInt(\"100\"); //옛날 방법  \t\tint i3 = Integer.valueOf(\"100\"); //새로운 방법. 위 방법이 종류가 많아져서 통합해버림  \t\tInteger i4 = Integer.valueOf(\"100\"); //반환타입이 Integer  \t\tint i5 = new Integer(100).intValue(); //밑에서 자세히              [!important]byte, short을 문자열로 변경할 때는 String valueOf(int)를 사용하면 됨      public class  Main {\tpublic static void main(Strin] args) {\t\tint iVal = 100;//\t\tString strVal = String.valueOf(iVal);\t\tString strVal = iVal+\"\";\t\t\t\tdouble dVal = 200.0;//\t\tString strVal2 = String.valueOf(dVal);\t\tString strVal2 = dVal + \"\";\t\t\t\tdouble sum = Integer.parseInt(\"+\"+strVal) //문자열-&gt;숫자\t\t\t\t\t\t\t\t+Double.parseDouble(strVal2);\t\tdouble sum2 = Integer.valueOf(strVal)+Double.valueOf(strVal2);\t\t\t\t\t\tSystem.out.println(String.join(\"\",strVal,\"+\",strVal2,\"=\")+sum);\t\tSystem.out.println(strVal+\"+\"+strVal2+\"=\"+sum2); //성능 떨어짐\t}}      n진법 문자열을 숫자로      public class  Main {  \tpublic static void main(Strin] args) {  //\t\tint i5 = Integer.parseInt(\"FF\"); //에러. NumberFormatException. 10진수에 ff가 없음  \t\tSystem.out.println(\"i = \" +Integer.parseInt(\"100\")); //100  \t\tSystem.out.println(\"i = \" +Integer.parseInt(\"100\",10)); //100 위랑 같은거임  \t\tSystem.out.println(\"i1 = \"+Integer.parseInt(\"100\",2)); //4  \t\tSystem.out.println(\"i2 = \"+Integer.parseInt(\"100\",8)); //64  \t\tSystem.out.println(\"i3 = \"+Integer.parseInt(\"100\",16)); //256  \t\tSystem.out.println(\"i4 = \"+Integer.parseInt(\"FF\",16)); //255  \t}  }      StringBuffer의 생성자와 메소드StringBuffer sb = new StringBuffer(”Hi”) 는 16+2(”h”, “i”로 총 2칸)=18문자를 저장할 수 있는 StringBuffer인스턴스를 생성버퍼크기 = char[] 크기⚠️ 자바에서는 범위가 주어졌을때 start ≤ x &lt;end 라 끝 값은 언제나 포함안됨import javax.xml.transform.Source;public class  Main {\tpublic static void main(Strin] args) {\t\tStringBuffer sb = new StringBuffer(\"01\");\t\tStringBuffer sb2 = sb.append(23);\t\tsb.append(\"4\").append(56); //56도 문자로 들어감\t\t\t\tStringBuffer sb3 = sb.append(78);\t\tsb3.append(9.0);\t\t\t\tSystem.out.println(\"sb = \"+sb); //0123456789.0\t\tSystem.out.println(\"sb2 = \"+sb2); //0123456789.0\t\tSystem.out.println(\"sb3 = \"+sb3); //0123456789.0\t\t\t\tSystem.out.println(\"sb = \"+sb.deleteCharAt(10)); //01234567890\t\tSystem.out.println(\"sb = \"+sb.delete(3, 6)); //01267890\t\tSystem.out.println(\"sb = \"+sb.insert(3, \"abc\")); //012abc67890\t\tSystem.out.println(\"sb = \"+sb.replace(6, sb.length(), \"END\")); //012abcEND\t\t\t\tSystem.out.println(\"capacity : \"+sb.capacity()); //18. 처음 sb객체 생성시 \"01\"로 생성해서 16+2\t\tSystem.out.println(\"length : \"+sb.length()); //9\t}}StringBuilder      StringBuffer : 동기화 돼있다. 멀티 쓰레드(13장)에 안전(thread-safe)  → 멀티 쓰레드 프로그램이 아닌경우, 동기화는 불필요한 성능저하를 불러옴        StringBuilder : 동기화 안되어있다. 싱글 쓰레드일때는 StringBuilder를 사용하면 성능이 향상됨  Math: 수학관련 static 메소드의 집합  E : 자연로그의 밑  PI : 원주율  round : 반올림  — double d = 90.7552; d = (Math.round(d*100))/100.0; ⇒ 90.76            ![image](/assets/images/java/2022-08-15-javalang/IMG-20240818214102-9.png      ]      public class  Main {\tpublic static void main(Strin] args) {\t\tdouble sum=0;\t\tdouble sum1=0;\t\tdouble sum2=0;\t\tfor(double d = 1.5; d&lt;=10.5; d++) {\t\t\tdouble d1= Math.round(d);\t\t\tdouble d2= Math.rint(d); //반올림하는데 .5는 짝수를 출력\t\t\t\t\t\tSystem.out.printf(\"%4.1f %4.1f, %4.1f%n\",d,d1,d2);\t\t\t\t\t\tsum+=d;\t\t\tsum1+=d1;\t\t\tsum2+=d2;\t\t\tSystem.out.println(\"====================\");\t\t\tSystem.out.printf(\"%4.1f %4.1f, %4.1f%n\",sum,sum1,sum2);\t\t\tSystem.out.println(\"******************\");\t\t/*\t\t 1.5  2.0,  2.0\t\t====================\t\t 1.5  2.0,  2.0\t\t******************\t\t 2.5  3.0,  2.0\t\t====================\t\t 4.0  5.0,  4.0\t\t******************\t\t 3.5  4.0,  4.0\t\t====================\t\t 7.5  9.0,  8.0\t\t******************\t\t 4.5  5.0,  4.0\t\t====================\t\t12.0 14.0, 12.0\t\t******************\t\t 5.5  6.0,  6.0\t\t====================\t\t17.5 20.0, 18.0\t\t******************\t\t 6.5  7.0,  6.0\t\t====================\t\t24.0 27.0, 24.0\t\t******************\t\t 7.5  8.0,  8.0\t\t====================\t\t31.5 35.0, 32.0\t\t******************\t\t 8.5  9.0,  8.0\t\t====================\t\t40.0 44.0, 40.0\t\t******************\t\t 9.5 10.0, 10.0\t\t====================\t\t49.5 54.0, 50.0\t\t******************\t\t10.5 11.0, 10.0\t\t====================\t\t60.0 65.0, 60.0\t\t******************\t\t\t *///rint가 최종 합산이 더 정확함. \t\t}\t}}래퍼(wrapper)클래스: 기본형 값을 감싸는 클래스. 8개의 기본형을 객체로 다뤄야할 때 사용.public class  Main {\tpublic static void main(Strin] args) {\t\tInteger i = new Integer(100);\t\tInteger i2 = new Integer(100);\t\t\t\tSystem.out.println(\"i==i2 ? \"+(i==i2)); //false\t\tSystem.out.println(\"i.equals(i2)? \"+i.equals(i2)); //true\t\tSystem.out.println(\"i.compareTo(i2) \"+i.compareTo(i2)); //0, 같으면 0, 오른쪽이 작으면 양수, 오른쪽이 크면 음수\t\tSystem.out.println(\"i.toString() = \"+i.toString()); //100(문자열)\t\t\t\tSystem.out.println(\"MAX_VALUE = \"+Integer.MAX_VALUE); //2147483647 . 최댓값 (+20억)\t\tSystem.out.println(\"MIN_VALUE = \"+Integer.MIN_VALUE); //-2147483648 . 최솟값(-20억)\t\tSystem.out.println(\"SIZE = \"+Integer.SIZE+\"bits\"); //32bits\t\tSystem.out.println(\"BYTES = \"+Integer.BYTES+\"BYTES\"); //4BYTES\t\tSystem.out.println(\"TYPE = \"+Integer.TYPE); //int\t}}  타입Value - 래퍼객체 → 기본형 (new Integer → int)  래퍼클래스 → 문자열 - toString() 사용Number클래스: 모든 숫자 래퍼 클래스의 조상— byte, short, integer, long, float, double, BigInteger, BigDecimal오토박싱 &amp; 언박싱오토박싱 : 기본형 → 객체 자동변환 (int → Integer)언박싱 : Integer → int  JDK1.5부터는 기본형과 참조형간의 연산이 가능해짐(컴파일러가 바꿔줌)int i = 5; Integer iobj = new Integer(7); int sum = i+iobg;⇒ int i = 5; Integer iobj = new Integer(7); int sum = i+ iobg.intValue();로 자동 컴파일됨import java.util.ArrayList;public class  Main {\tpublic static void main(Strin] args) {\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\t\tlist.add(10); //오토박싱. 10-&gt; new Integer(10);  \t\t//↑ 원래는 list.add(new Integer)처럼 객체를 넣어줘야 함.JDK1.5이후에만 가능.(컴파일러가 자동변환)\t\t\t\t//list에 저장된 객체를 꺼내기. //\t\tint value = list.get(0).intValue();// 원래는 이렇게 써줘야함. intValue()로 Integer를 int로 변환\t\tint value = list.get(0);  //언박싱. new Integer(10) -&gt; 10;\t}}import java.util.ArrayList;public class  Main {\tpublic static void main(Strin] args) {\t\tint i = 10;\t\t\t\t//기본형 -&gt; 참조형\t\t//Integer intg = Integer.Value(i);\t\tInteger intg = (Integer)i;  \t\t//Object obg = (Object)Integer.Value(i);\t\tObject obg = (Object)i;\t\t\t\t//Long lng = new Long(100L);\t\tLong lng = 100L; //원래는 객체를 생성해줘야 하나 기본형을 바로 저장하도록 컴파일러가 바꿔줌\t\t\t\tint i2 = intg + 10; //참조형+기본형 가능\t\tLong l = intg + lng; //참조형+참조형 가능. \t\t\t\tInteger intg2 = new Integer(20);\t\tint i3 = (int)intg2; //참조형 -&gt; 기본형 가능\t\t\t\t/*컴파일 전 코드 \t\t\t\t\t\t컴파일 후 코드\t\t * Integer intg = (Integer)i;\t\tInteger intg = Integer.Value(i);\t\t *Object obg = (Object)i;\t\t\tObject obg = (Object)Integer.Value(i);\t\t *Long lng = 100L;\t\t\t\t\tLong lng =  new Long(100L);\t\t */\t\t\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - 예외처리",
    "url": "/posts/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 예외",
    "date": "2022-08-14 00:00:00 +0900",
    





    
    "snippet": "프로그램 오류system.out.println(args[0]); //컴파일 에러System.out.println(args[0]); //런타임 에러 : 실행중 발생하는 에러. 매개변수로 받은 값이 없는데 실행해서 생김  논리적에러(logical error) : 작성 의도와 다르게 동작  컴파일러에러(compile-time error) : 컴파일 할 때 ...",
    "content": "프로그램 오류system.out.println(args[0]); //컴파일 에러System.out.println(args[0]); //런타임 에러 : 실행중 발생하는 에러. 매개변수로 받은 값이 없는데 실행해서 생김  논리적에러(logical error) : 작성 의도와 다르게 동작  컴파일러에러(compile-time error) : 컴파일 할 때 발생하는 에러번호          컴파일러                  구문체크          번역          최적화 (ex. int i = 3+5를 8로 변경)                      런타임에러(runtime error) : 실행할 때 발생하는 에러. 프로그램종료                  에러 (error) : 프로그램코드에 의해 수습될 수 없는 심각한 오류  ex)Out Of Memory Error - OOME : 메모리부족으로 일어나는 오류                    예외 (exception) : 프로그램코드에 의해 수습될 수 있는 다소 미약한 오류  ex)RuntimeException, IOException                              Excepton클래스들 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외            — checked예외 : 컴파일러가 예외처리 여부를 체크(예외처리 필수)                                RuntimeException 클래스들 : 프로그래머의 실수로 발생하는 예외            — unchecked예외 : 컴파일러가 예외처리 여부를 체크 안함.(예외처리 선택)              throw new Exception(\"고의로 발생\");  //try-catch문이 없어 컴파일 조차 안됨  \t\tthrow new RuntimeException(\"고의로 발생\");  //try-catch가 없어도 컴파일은 됐으나 실행중 에러. 비정상 종료                                            예외처리(exception handling) : 프로그램 실행시 발생할 수 있는 예외의 발생에 대비한 코드를 작성.  프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지  — try - catch문 사용 - {}생략불가.            try { /예외가 발생할 가능성이 있는 문장을 넣는다/  } catch (Exception1 e1) { /* Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣음/  } catch (Exception2 e2) { / Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 넣음/  catch (ExceptionN eN) { / ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 넣음*/                          try블럭에서 예외가 발생한 경우                                  발생한 예외와 일치하는 catch블럭이 있는지 확인                  일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.                                                            try블럭 내에서 예외가 발생하지 않은 경우                                  catch블럭을 거치지 않고 전체 try-catch문을 빠져나가 수행을 계속한다.                                  public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\ttry {  \t\t\tSystem.out.println(2);  \t\t\tSystem.out.println(3);  \t\t} catch (Exception e) {  \t\t\tSystem.out.println(4); //예외가 발생하지 않아서 출력안됨.   \t\t}//try-catch문의 끝  \t\tSystem.out.println(5);  //1 2 3 5 출력됨  \t\tSystem.out.println(\"=============\");  \t\tSystem.out.println(1);  \t\ttry {  \t\t\tSystem.out.println(0/0); //예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(2);  \t\t} catch (ArithmeticException e) {  \t\t\tSystem.out.println(3);  \t\t}//try-catch문의 끝  \t\tSystem.out.println(4);  //1 3 4 출력됨  \t}//main 메소드의 끝  }                                                              printStackTrace() : 예외발생 당시의 호출스택(Call strack)에 있었던 메소드의 정보와 예외 메시지를 화면에 출력한다.                      getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메세지를 얻을 수 있다.              public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\tSystem.out.println(2);  \t\ttry {  \t\t\tSystem.out.println(3);  \t\t\tSystem.out.println(0/0); //ArithmeticException예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(4); //실행안됨  \t\t} catch (ArithmeticException ae) {  \t\t\tae.printStackTrace();  \t\t\tSystem.out.println(\"예외 메세지 : \"+ae.getMessage());   \t\t} catch (Exception e) {  //Exception : 모든 예외의 최고조상, 모든 예외를 처리함(맨 마지막에 와야함)  \t\t\tSystem.out.println(\"Exception\"); //실행안됨  \t\t}//try-catch문의 끝  \t\tSystem.out.println(6);    \t\t//1 2 3   java.lang.ArithmeticException: / by   zero 예외 메세지 : / by zero   6 출력됨  \t}//main 메소드의 끝  }                                예외 발생시키기                                          연산자 new를 이용해 발생시키려는 예외 클래스의 객체를 만든다 Exception e = new Exception(”고의로 발생시켰음”);                                            키워드 throw를 이용해 예외 발생 throw e;                                              예외 처리방법                                          멀티 catch블럭(try - catch문) : 내용이 같은 catch블럭을 하나로 합친 것 (JDK1.7부터)  try { /…/ } catch (ExceptionA | ExceptionB) { e.printStackTrace (); }                멀티catch블록에 쓰는 두 클래스가 부모자식관계면 에러. 부모만써도 같은 의미라서 에러표시됨                  public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\tSystem.out.println(2);  \t\ttry {  \t\t\tSystem.out.println(3);  \t\t\tSystem.out.println(0/0); //ArithmeticException예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(4); //실행안됨  \t\t} catch (ExceptionA | ExceptionB e) {  //Exception : 모든 예외의 최고조상, 모든 예외를 처리함(맨 마지막에 와야함)  //\t\t\te.methodA(); //에러, e에 ExceptionA가 들어올지 ExceptionB가 들어올지 알수 없음. methodA는 ExceptionA의 멤버라서 에러  \t\t\t//ExceptionA,ExceptionB의 공통멤버는 사용 가능  \t\t\tif(e instanceof ExceptionA) {  \t\t\t\tExceptionA e1 = (ExceptionA)e;  \t\t\t\te1.methodA();  \t\t\t}  \t\t\telse {  \t\t\t\tExceptionB e2 = (ExceptionB)e;  \t\t\t\te2.methodB();  \t\t\t}  \t\t}//try-catch문의 끝  \t\tSystem.out.println(6);    \t}//main 메소드의 끝  }                                                            메소드에 예외 선언하기 : 빈catch블럭을 사용함                ❗예외를 발생시키는 키워드 throw와 메소드에 선언할 때 쓰이는 throws를 잘 구분 할 것.                  static void startInstall() throws SpaceException, MemoryException{  \tif(!enoughSpace()) //설치공간이 부족하다면  \t\tthrow new SpaceException(\"설치공간 부족\");  \tif(!enoughMemory()) //메모리가 부족하다면  \t\tthrow new MemoryException(\"메모리 부족\");  } //내가 처리할 수 없는 것들. 사용자에게 해결하고 오라고 떠넘김                                  public class ex {  \tpublic static void main(String[] args) throws Exception{  \tmethod1(); //같은 클래스 내의 static멤버이므로 객체생성없이 직접 호출 가능  \t}  \tstatic void method1()throws Exception {  \t\tmethod2();  \t}  \tstatic void method2() throws Exception{  \t\tthrow new Exception();  \t}  } //method2에서 발생한 Exception이 try-catch문을 만나지 못해 method1-main까지 올라갔다가 JVM까지 올라감 -&gt; 비정상종료  //try-catch문이 하나는 있어야 해결이됨.                                  import java.io.*;                  public class ex {  \tpublic static void main(String[] args) {  \t\t\tFile f = createFile(\"\");  \t\t\tSystem.out.println(f.getName()+\" 파일이 성공적으로 생성되었습니다\");  \t\t}                   static File createFile(String fileName){  \ttry {  \t\tif(fileName == null || fileName.equals(\"\"))  \t {  \t\t throw new Exception(\"파일 이름이 유효하지 않습니다.\");  \t }  \t} catch(Exception e) {  \t\t fileName = \"제목없음.txt\";  \t }  \t File f = new File(fileName); //File클래스의 객체 생성  \t try {  \t\tf.createNewFile();  \t} catch (IOException e) {  \t\te.printStackTrace();  \t}finally{  \t\t//예외 발생 여부와 상관없이 무조건 실행해야함. 코드 중복 박기 위해  \t}  \t return f;  \t}   }                                                            finally블럭 : 예외 발생 여부와 관계없이 수행되어야 하는 코드                ⚠️ try블럭안에 return문이 있어서 try블럭을 벗어나갈 때도 finally블럭이 실행 됨                                                          사용자정의 예외 만들기            : 우리가 직접 예외 클래스를 정의할 수 있다.            조상은 Exception과 RuntimeException중에 선택 (웬만하면 RuntimeException으로 할것. try-catch문 꼭 안써줘도 됨)              class MyException extends Exception{  \tMyException(String msg){ //문자열을 매개변수로 받는 생성자  \t\tsuper(msg); //조상인 Exception의 생성자를 호출  \t}  }                          class MyException extends Exception{  \t//에러코드 값을 저장하기 위한 필드 추가  \tprivate final int ERR_CODE;  \t MyException(String msg, int errCode){ //생성자  \t\t super(msg);  \t\t ERR_CODE = errCode;  \t }  \t MyException(String msg){ //생성자  \t\t this(msg, 100); //ERR_CODE를 100(기본값)으로 초기화  \t }  \t public int getErrCode() { //에러코드를 얻을 수 있는 메소드도 추가  \t\t return ERR_CODE; //주로 getMessage()와 함께 사용될 것.  \t }  \t}                                            예외 되던지기(exception re-throwing)            : 예외를 처리한 후에 다시 예외를 발생시킴              public class Main {  \tpublic static void main(String[] args) {  \t\ttry {  \t\t\tmethod1();  \t\t} catch (Exception e) {  \t\t\tSystem.out.println(\"main메소드에서 예외처리 되었습니다\");  \t\t} //예외 2번처리 = 예외 되던지기 = 예외 양쪽에서 처리  \t}  static void method1() throws Exception{  \t\ttry {  \t\t\tthrow new Exception();  \t\t}catch (Exception e) {  \t\t\tSystem.out.println(\"method1에서 예외가 처리되었습니다\");  \t\t\tthrow e;  \t\t}  \t}  }                                            연결된 예외(chained exception)            : 한 예외가 다른 예외를 발생시킬 수 있다.            예외 A가 예외 B를 발생시키면 A는 B의 원인예외(cause exception)            Throwable initCause(Throwable cause) : 지정된 예외를 원인 예외로 등록            Throwable getCause() : 원인 예외를 반환              public class Throwable implements Serializable{  \t//...  \tprivate Throwable cause = this; //객체 자신(this)을 원인 예외로 등록  \t//...  \tpublic synchronized Throwable initCause(Throwable cause) {  \t\t//...  \t\tthis.cause = cause; //cause를 원인 예외로 등록  \t\treturn this;  \t}  }                          void install() throws InstallException{ //실제로는 SpaceException이 발생했으나 InstallException안에 포함시켜서 예외 처리됨  \ttry {  \t\tstartInstall(); //SpaceException 발생, 저장공간 부족  \t\tcopyFiles();  \t} catch (SpaceException e) {  \t\tInstallException ie = new InstallException(\"설치 중 예외 발행\");  \t\tie.initCause(e); //ie(InstallException)의 원인 예외를 e(SpaceException)으로 지정  \t\tthrow ie; //InstallException 발생  \t}catch (MemoryException me) {  \t\t//......  \t}   }                        — 이유 1 : 여러 예외를 하나로 묶어서 다루기 위해              void install() throws InstallException{ //실제로는 SpaceException이 발생했으나 InstallException안에 포함시켜서 예외 처리됨  \ttry {  \t\tstartInstall(); //SpaceException 발생, 저장공간 부족  \t\tcopyFiles();  \t} catch (SpaceException e) {  \t\tInstallException ie = new InstallException(\"설치 중 예외 발행\");  \t\tie.initCause(e); //ie(InstallException)의 원인 예외를 e(SpaceException)으로 지정  \t\tthrow ie; //InstallException 발생  \t}catch (MemoryException me) {  \t\t//......  \t}   }  public class Main {              \tpublic static void main(String[] args) {  //\t\ttry {  //\t\t\tinstall();  //\t\t} catch (SpaceException e) {  //\t\t\te.printStackTrace();  //\t\t} catch (MemoryException e) {  //\t\t\te.printStackTrace();  //\t\t} catch (Exception e) {  //\t\t\te.printStackTrace();  \t\ttry {  \t\t\tinstall();  \t\t} catch (InstallException e) {  \t\t\te.printStackTrace();  \t\t} catch (Exception e) {  \t\t\te.printStackTrace();  \t\t}  \t}  }                        — 이유 2 : checked예외를 unchecked예외로 변경할때              static void startInstall() throws SpaceException, MemoryException{  \tif(!enoughSpace())  \t\tthrow new SpaceException(\"설치할 공간이 부족합니다.\");  \tif(!enoughMemory())  \t\tthrow new RuntimeException(new MemoryException(\"메모리가 부족합니다.\"));\t\t  }//MemoryException을 RuntimeException으로 위장해 try-catch문은 사용하지않아도됨  //class SpaceException extends Exception{  //\tSpaceException(String msg){  //\t\tsuper(msg);  \t}  }                                          "
  },
  
  {
    "title": "자바의 정석 강의 - 상속(Ingeritance)",
    "url": "/posts/%EC%83%81%EC%86%8D-(Ingeritance)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 상속",
    "date": "2022-08-05 00:00:00 +0900",
    





    
    "snippet": "상속~는 ~이다 (is - a) - ex.원(circle)은 점(point)다. (x)class 자식클래스 extends 부모클래스  기존의 클래스로 새로운 클래스를 작성(코드 재사용)  두 클래스를 부모와 자식 관계로 이어줌  자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화 블럭 제외 (자식클래스에 멤버가 안적혀있어도 있는거임)  자손의 멤버...",
    "content": "상속~는 ~이다 (is - a) - ex.원(circle)은 점(point)다. (x)class 자식클래스 extends 부모클래스  기존의 클래스로 새로운 클래스를 작성(코드 재사용)  두 클래스를 부모와 자식 관계로 이어줌  자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화 블럭 제외 (자식클래스에 멤버가 안적혀있어도 있는거임)  자손의 멤버 개수가 조상보다 적을 수는 없음.(같거나 많다.)  자손의 변경은 조상에게 영향을 미치지 않음.  부모 클래스의 변경은 자식 클래스에 영향을 미침.class point {\tint x, y;}class point3D extends point {\tint z;}  상속을 받지않고 중복으로 멤버들을 지정해줘도 결과는 똑같음.class Tvclass {\tboolean power;//전원상태(on/off)\tint channel;\t\tvoid power() {power = !power;}\t\tvoid channelUp() {++channel;}\t\tvoid channelDown() {--channel;}}\tclass SmartTv extends Tvclass{ //SmartTv는 Tv에 캡션(자막)을 보여주는 기능을 지원\tboolean caption; //캡션상태 (on/off)\tvoid displayCapion(String text) {\t\tif(caption) { \t\t\t//캡션의 상태가 on(true)일때만 text를 보여줌\t\t\tSystem.out.println(text);\t\t}\t}}public class Ex7_1 {\tpublic static void main(String[] args) {\t\tSmartTv stv = new SmartTv();\t\tstv.channel=10; //조상에게 상속받은 멤버\t\tstv.channelUp(); //조상에게 상속받은 멤버\t\tSystem.out.println(stv.channel);\t\tstv.displayCapion(\"ssssssssssss\"); //자막 off상태\t\tstv.caption = true;\t\tSystem.out.println(\"ssssssssssssssssssssssss\");\t\t\t\t\t}}포함(composite)~은 ~을 가지고 있다. (has - a) - ex. 원(circle)은 점(point)를 가지고 있다.(o)  — 90%가 포함이라고 보면 됨      클래스의 멤버로 참조변수를 선언함  class Point {\tint x; //원점의 x좌표\tint y; //원점의 y좌표}class circle {\tPoint c =new Point(); //c가 또 객체를 만들어서 Point를 가르킴\tint r; //반지름}//class circle { int x; int y; int r;}과 같은 거임.public class Ex7_1 {\tpublic static void main(String[] args) {\t\tcircle c = new circle();\t\tc.c.x = 5;\t\tc.c.y = 10;\t\tc.r = 15;\t\t//x,y는 circle c의 point c를 불러야 사용가능class Point{\tint x, y;}class Circle extends Point{\tint r;}class Circle2{\tPoint p = new Point();\tint r;}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\tc.x=1;\t\tc.y=2;\t\tc.r=3;\t\tSystem.out.println(\"c.x = \"+c.x);\t\tSystem.out.println(\"c.y = \"+c.y);\t\tSystem.out.println(\"c.r = \"+c.r);\t\t\t\tSystem.out.println();\t\t\t\tCircle2 c2 = new Circle2();\t\tc2.p.x = 10;\t\tc2.p.y = 15;\t\tc2.r=20;\t\tSystem.out.println(\"c2.p.x = \"+c2.p.x);\t\tSystem.out.println(\"c2.p.y = \"+c2.p.y);\t\tSystem.out.println(\"c2.p.r = \"+c2.r);\t\t\t}}단일상속(Single Inheritance)자바는 단일 상속만을 허용함. (c++은 다중상속 허용) → 인터페이스를 이용하면 비슷한 기능을 쓸 수 있음  비중이 높은 클래스 하나만 상속으로 나머지는 포함으로 작성 가능Object class - 모든 클래스의 조상  부모가 없는 클래스는 자동적으로 object 클래스를 상속받게 됨.      모든 클래스는 object클래스에 정의된 11개의 메소드를 상속받음  toString(), equals(Object obj), hashCode() ……..등등(9장)    상속계층도를 따라올라가면 맨 위에 Object가 있음class Point{\tint x, y;}class Circle extends Point{\tint r;}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\tSystem.out.println(c.toString()); //Circle@5ca881b5 클래스이름@객체주소값\t\tSystem.out.println(c); //Circle@5ca881b5 클래스이름@객체주소값\t\tCircle c2 = new Circle();\t\tSystem.out.println(c2.toString()); //Circle@24d46ca6 클래스이름@객체주소값\t\tSystem.out.println(c2); //Circle@24d46ca6 클래스이름@객체주소값\t}}println이 참조변수가 들어오면 내부적으로 toString을 호출오버라이딩 (overriding)상속받은 조상의 메소드를 자신에 맞게 변경하는 것.  조건          선언부가 조상클래스의 메소드와 일치해야함      접근 제어자(public, protect, defalt, private) 를 조상클래스의 메소드보다 좁은 범위로 변경불가      예외는 조성 클래스의 메소드보다 많이 선언할 수 없다. (8장)      class Point{\tint x, y;String getLocation(){\treturn \"x : \"+x+\", y : \"+y;\t}}class Point3D extends Point{\tint z;\tString getLocation() { //오버라이딩 (선언부 변경 불가 내용[ {} 구현부 ]만 변경가능)\t\treturn \"x : \"+x+\", y: \"+y+\", z : \"+z;\t\t}\t}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tPoint3D p = new Point3D();\t\tp.x = 3;\t\tp.y=5;\t\tp.z=7;\t\tSystem.out.println(p.getLocation()); //x : 3, y: 5, z : 7\t}}class Point{\tint x, y;\t\tPoint(int x, int y){\t\tthis.x= x;\t\tthis.y=y;\t}\t\t//object클래스의 toString()을 오버라이딩\tpublic String toString(){\treturn \"x : \"+x+\", y : \"+y;\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tPoint p = new Point(3,5);\t\tSystem.out.println(p.toString()); //x : 3, y : 5\t\tSystem.out.println(p); //x : 3, y : 5\t}}오버로딩 (overloading)기존에 없는 새로운 (이름이 같은)메소드를 정의하는 것. 오버라이딩이랑은 관계없음.class Parent{\tvoid parentMethod() {\t\t\t}\tclass child extends Parent{\t\tvoid parentMethod() {}\t\tvoid parentMethod(int i) {}\t\t\t\tvoid childMethod() {}\t\tvoid childMethod(int i) {}\t\tvoid childMethod() {}\t\t\t}}참조변수 superthis와 비슷함  객체 자신을 가르치는 참조변수. 인스턴스 메소드(생성자)내에서만 존재  조상의 멤버를 자신의 멤버와 구분할 떄 사용class Parent{\tint x=10;}class child extends Parent{ //구성멤버 3개\tint x = 20;\t\tvoid method() { \t\tSystem.out.println(\"x = \"+x);  //가까이있는 x(20)\t\tSystem.out.println(\"this.x = \"+this.x);//20\t\tSystem.out.println(\"super.x = \"+super.x); //부모클래스의 x (10)\t\t\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tchild c = new child();\t\tc.method();\t}}class Parent{\tint x=10;}class child extends Parent{ //구성멤버 2개\tvoid method() { \t\tSystem.out.println(\"x = \"+x);  //가까이있는 x\t\tSystem.out.println(\"this.x = \"+this.x);\t\tSystem.out.println(\"super.x = \"+super.x); //부모클래스의 x\t\t//중복이 없으면 !! 조상멤버기도하지만 내꺼기도해서 this, super 모두 같은 x를 가르킴\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tchild c = new child();\t\tc.method();\t}}super() - 조상의 생성자참조변수 super와 상관없음  조상의 생성자를 호출할 때  조상의 멤버는 조상의 생성자를 호출해서 초기화  생자와 초기화 블럭은 상속이 xclass Point {\tint x,y;\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y; //초기화\t}}class Point3D extends Point {\tint z;\t\tPoint3D(int x, int y, int z) {\t\tsuper(x, y); //조상class에서 초기화\t\tthis.z=z; //초기화\t}}  생성자의 첫 줄에는 반드시 생성자(super(); or this();)를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입함.class Point {\tint x,y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tsuper();  //object(); 안넣어주면 컴파일러가 자동으로 넣어줌\t\tthis.x=x;\t\tthis.y=y;에러 예시 중요!!class Point {\tint x, y;\tPoint(int x, int y){\t\tsuper(); //컴파일러 자동 추가\t\tthis.x=x;\t\tthis.y=y;\t}\tString getLocation() {\t\treturn \"x : \"+x+\", y : \"+y;\t}}class MyPoint3D extends Point{\tint z;\t//\tMyPoint3D(int x, int y, int z){//\tsuper();  //컴파일러 자동 추가 Point()를 호출 -&gt; Point에 Point();가 없어서 에러남//\tthis.x=x;//\tthis.y=y;//\tthis.z=z;//\t}\t\tMyPoint3D(int x, int y, int z){\t\tsuper(x,y);\t\tthis.z=z;  \t}  //에러 없애는 방법 다른방법은 Pointclass에 Point();추가하기\t\tString getLocation() { //오버라이딩\t\treturn \"x : \"+x+\", y : \"+y+\", z : \"+z;\t}\t}public class Ex_test {\tpublic static void main(String[] args) {\t\tMyPoint3D p3 = new MyPoint3D(1,2,3);\t\t\t}}패키지(package)  서로 연관된 class의 묶음  클래스는 클래스파일(*.class), 패키지는 폴더. 하위 패키지는 하위폴더      클래스의 실제 이름 (full name)은 패키지를 포함.(java.lang.String)    rt.jar는 클래스들을 압축한 파일.(JDK설치경로\\jre\\lib에 위치) - 자바9부터 rt.jar는 없어짐    패키지 선언          패키지는 소스파일의 첫 번째 문장으로 단 한번 선언      같은 소스파일의 클래스들은 모두 같은 패키지에 속하게 된다.      패키지 선언이 없으면 이름없는(unnamed)에 속하게 된다. - defaultpackage        클래스 패스(classpath)          클래스 파일(*.class)의 위치를 알려주는 경로(path)      환경변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용      classpath(환경변수)에 패키지의 루트를 등록해줘야 함      import문클래스를 사용할 때 패키지 이름을 생략할 수 있다.  컴파일러에게 클래스가 속한 패키지를 알려줌  ctrl + shift + o ⇒ 자동으로 import문을 추가해줌.(import java.lang.*[모든클래스];) -  java.lang 패키지(String, Object, System, Thread…)의 클래스는 import하지않고도 사용 가능함.  패키지문과 클래스선언 사이에 선언함.  이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.  static import문          static멤버를 사용할 떄 클래스 이름을 생략가능              import static java.lang.Math.random;  import static java.lang.System.  out;        ⇒ out.println(random()); 가능함.            코드가 길어져서 class이름도 거추장스러운순간이 옴. 코드를 짧게하려고 쓰는 방법. 꼭 필요할때만 사용할것. 헷갈릴수도      제어자(modifier)클래스와 클래스의 멤버(멤버 변수, 메소드)에 부가적인 의미 부여 - 형용사                                             접근 제어자      public, protecred, (default)[아무것도안붙임], private      1개만 사용가능              그외      static, final, abstract, transient, synchronized, volatile, strictfp               하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만). 순서는 상관없으나 보통 접근제어자를 맨 왼쪽에 씀      static - 클래스의, 공통적인                            대상          의미                                      멤버변수          모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다  클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.  클래스가 메모리에 로드될 때 생성된다.                          메소드          인스턴스를 생성하지 않고도 호출이 가능한 static메소드가 된다.  static메소드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다                      final - 마지막의, 변경될 수 없는                                      클래스      변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.  그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다              메소드      변경될 수 없는 메소드. final로 지정된 메소드는 오버라이딩을 통해 재정의 될 수 없다.              멤버변수  지역변수      변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.      final class Finaltest{ //조상이 될 수 없는 클래스\tfinal int MAX_SIZE=10; //값을 변경할 수 없는 멤버변수(상수)\t\tfinal void getMaxsize() {  //오버라이딩 할 수 없는 메소드(변경불가)\t\tfinal int LV = MAX_SIZE; //값을 변경할 수 없는 지역변수(상수)\t\treturn MAX_SIZE;\t}}  abstract - 추상의, 미완성의                                      클래스      클래스 내에서 추상 메소드가 선언되어 있음을 의미한다              메소드      선언부만 작성하고 구현부는 작성하지 않은 추상 메소드임을 알린다.      abstract class abstracttest{ //추상 클래스(추상 메소드를 포함한 클래스\tabstract void move(); //추상 메소드(구현부가 없는 메소드)}//미완성상태 - 미완성 설계도. 제품제작불가 = 인스턴스 생성 불가public class Ex_test {\tpublic static void main(String[] args) {\t\tabstracttest a = new abstracttest();  //에러. 추상클래스의 인스턴스 생성 불가\t}}추상 클래스를 상속받아서 완전한 클래스를 만든 후에 객체생성가능접근 제어자(access modifier) - 1개만 사용 가능  private : 같은 클래스 내에서만 접근이 가능하다.  (default) : 같은 패키지 내에서만 접근이 가능하다.  protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.  public : 접근 제한이 전혀 없다.            제어자      같은 클래스      같은 패키지      자손 클래스      전체                  public      o      o      o      o              protected      o      o      o                     (default)      o      o                            private      o                           ❗클래스 앞에는 public or (default)만 붙일 수 있다. (아무것도 안붙이면 default)클래스 멤버들에게는 4가지 모두 붙일 수 있다.package pkg1;class MyParent{\t\tprivate \tint prv; //같은 클래스\t\t\t\t\t\t\tint dft; //같은 패키지\tprotected \tint prt; //같은 패키지, 자손(다른패키지)\t\tpublic \t\tint pub; //접근제한 없음\t\tpublic void printMembers(){\t\tSystem.out.println(prv);\t\tSystem.out.println(dft);\t\tSystem.out.println(prt);\t\tSystem.out.println(pub);\t}}public class MyParentTest {\tpublic static void main(String[] args) {\t\t\tMyParent p = new MyParent();\t\t\tSystem.out.println(p.prv); //에러. 다른 클래스라서\t\t\tSystem.out.println(p.dft);\t\t\tSystem.out.println(p.prt);\t\t\tSystem.out.println(p.pub);\t}}package pkg1;public class MyParentTest{  //접근 제어자 public\t\tprivate \tint prv; //같은 클래스\t\t\t\t\t\t\tint dft; //같은 패키지\tprotected \tint prt; //같은 패키지, 자손(다른패키지)\t\tpublic \t\tint pub; //접근제한 없음\t\tpublic void printMembers(){\t\tSystem.out.println(prv);\t\tSystem.out.println(dft);\t\tSystem.out.println(prt);\t\tSystem.out.println(pub);\t}}class MyParent {  //접근 제어자 default\tpublic static void main(String[] args) {\t\t\tMyParentTest p = new MyParentTest();//\t\t\tSystem.out.println(p.prv); //에러. 다른 클래스라서\t\t\tSystem.out.println(p.dft);\t\t\tSystem.out.println(p.prt);\t\t\tSystem.out.println(p.pub);\t}}package pkg2;import pkg1.MyParentTest; //ctrl +shift + oclass MyChild extends MyParentTest{\tpublic void printMembers(){//\tSystem.out.println(prv); //에러. 다른 클래서//\tSystem.out.println(dft); //에러. 다른 패키지\t\tSystem.out.println(prt); //자손클래스라서 가능\t\tSystem.out.println(pub);\t}}public class MyParentTest2 {\tpublic static void main(String[] args) {\t\tMyParentTest p = new MyParentTest();//\tSystem.out.println(p.prv); //에러. 다른 클래스라서//\tSystem.out.println(p.dft); //에러. 다른 패키지//\tSystem.out.println(p.prt); //에러. 다른 패키지, 자손관계 없음\t\tSystem.out.println(p.pub);\t}}캡슐화와 접근 제어자  접근 제어자를 사용하는 이유                  외부로부터 데이터를 보호하기 위해(캡슐화)          public class Ex_test{  \tprivate int hour;  //접근 제어자를 private로 하여 외부에서 접근 못하도록 막음  \tprivate int minute;  \tprivate int second;        \t  \tpublic int gethour() {  \t\treturn hour;  \t}  \tpublic void sethour(int hour) {  \t\tif(hour&lt;0 || hour &gt;23) return;  \t\tthis.hour=hour;  //메소드를 통해서 지역변수에 간접접근하도록 만들어 놓음  \t}  }  class test {  \tpublic static void main(String[] args) {  \t\tEx_test T=new Ex_test();  \t\tT.sethour(25);  //조건에 안맞아서 값이 바뀌지 않음. = 값이 보호됨  \t\tT.sethour(21);  \t}  }                    다형성(polymorphism)여러가지 형태를 가질 수 있는 능력  조상 타입 참조변수로 자손 타입 객체를 다루는 것. - 타입 불일치.  Tv t = new SmartTv();                  객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?  조상클래스의 참조변수는 자식 클래스의 멤버를 사용할 수 없다.                    자손타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.        SmartTv s = new Tv 불가능 - 없는 멤버를 호출해서 에러날 가능성 있음              참조변수의 형변환                  사용할 수 있는 멤버의 갯수를 조절하는 것. 멤버 갯수 외 요소는 바뀌지 않음  기본형 형변환 - (double)3.5 → (int)3                    조상 자손 관계의 참조변수는 서로 형변환 가능          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFireEngine f = new FireEngine();  \t\tCar c = (Car)f; //조상인 Car타입으로 형변환  \t\tFireEngine f2 = (FireEngine)c; //자손인 FireEngine타입으로 형변환(생략불가)  \t//Ambulance a = (FireEngine)f; //에러. 상속관계가 아닌 클래스간의 형변환 불가  \t}  }                Car c= (Car)f;경우 자손 클래스의 멤버를 조상클래스의 멤버가 사용할 수 없으니 c는 FireEngine의 모든 멤버를 사용할 수 없음(예시의 경우 c.water사용 불가능)        FireEngine f2 = (FireEngine)c는 f→c→f로 변환되었으니 FireEngine의 모든 멤버를 사용할 수 있음.                  class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tCar car = null;  \t\tFireEngine fe = new FireEngine();  \t\tFireEngine fe2 = null;        \t\t  \t\tfe.water();  \t\tcar = fe; //car = (car)fe; 에서 형변환이 생략됨.  //\t\tcar.water(); //에러  \t\tfe2=(FireEngine)car;  //자손타입&lt;-조상타입. 생략불가  \t\tfe2.water();  \t}  }                ❗fe2=(FireEngine)car;의 경우 사용할 수 있는 멤버의 수가 증가해서 불안정함. 그래서 꼭! 형변환을 써줘야함. 생략불가능        ]          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tCar car = null;  \t\tFireEngine fe = new FireEngine();        \t\t  \t\tFireEngine fe2= (FireEngine)car; //조상 -&gt; 자손  \t\tCar car2 = (Car)fe2; // 자손 -&gt; 조상  \t\t//객체가 없어도 형변환에는 문제없음.  \t\t//car2.drive(); //에러  NullPointerException발생. 객체가 없다는 뜻  \t\t//실제 인스턴스가 뭔지가 중요함.        \t\t  \t\tCar c2 = new Car();  \t\tFireEngine fe3 = (FireEngine)c2; // 형변환 실행 에러. java.lang.ClassCastException  \t\tfe3.water(); //컴파일 ok. 리모컨에는 water가 있음.  \t\t//객체를 Car로 만들어서 객체안에 water자체가 없음!! 그래서 에러나는거임!!  \t}  }                      instanceof 연산자          참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환      형변환 전에 반드시 instanceof로 확인해야 함              인스턴스의 원래 기능을 모두 사용하려고 형변환을 함.          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFireEngine fe = new FireEngine();        \t\t  \t\tSystem.out.println(fe instanceof Object); //true. FireEngine의 조상  \t\tSystem.out.println(fe instanceof Car); //true. FireEngine의 조상  \t\tSystem.out.println(fe instanceof FireEngine); //true  \t\tObject obg = (Object)fe;  \t\tCar c2 = (Car)fe;  \t\tFireEngine fe2 = (FireEngine)fe;  \t\t}  \tCar c = new Car();  \tvoid doWork(Car c) {  \t\tif(c instanceof FireEngine) {//형변환이 가능한지 확인  \t\t\tFireEngine fe = (FireEngine)c; //형변환  \t\t\tfe.water();  \t\t}  \t\telse if (c instanceof Ambulance) {  \t\t\tAmbulance a = (Ambulance)c;  \t\t}  \t}        \t  }                      다형성의 장점                  다형적 매개변수 - 매개변수의 다형성                              참조형 매개변수는 메소드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.              class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  }  class Tvvv extends Product{}  class Computer extends Product{}  class Audio extends Product{}              class Buyer { //물건사는사람  \tint money = 10000; //소지금  \tint bonusPoint = 0; //누적 적립금            \t  //\tvoid buy(Tv t1) {  //\t\tmoney -= t1.price;  //\t\tbonusPoint += t1.bonusPoint;  //\t}  //\tvoid buy(Computer c) {  //\t\tmoney -= c.price;  //\t\tbonusPoint += c.bonusPoint;  //\t}  //\tvoid buy(Audio a) {  //\t\tmoney -= a.price;  //\t\tbonusPoint += a.bonusPoint;  //\t}  \tvoid buy(Product p){  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();            \t\t  //\t\tTvvv tv = new Tvvv();  //\t\ttv.price=5000;  //\t\ttv.bonusPoint= (int) (tv.price*0.01);  //\t\tb.buy(tv);  //\t\tComputer com = new Computer();  //\t\tcom.price=3000;  //\t\tcom.bonusPoint= (int) (com.price*0.01);  //\t\t  //\t\tb.buy(com);            \t\t  \t\tProduct p1= new Tvvv();  \t\tProduct p2= new Computer();  \t\tProduct p3= new Audio();  \t\tp1.price=5000;  \t\tp1.bonusPoint=(int) (5000*0.01);  \t\tb.buy(p1);  \t\tp2.price=3000;  \t\tp2.bonusPoint=(int)(p2.price*0.01);  \t\tb.buy(p2);  \t\tSystem.out.println(b.money);  \t\tSystem.out.println(b.bonusPoint);            \t\t  \t}            \t  }                          class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  \tProduct(int price){  \t\tthis.price=price;  \t\tbonusPoint = (int) (price/10.0);  \t}  }  class Tv extends Product{  \tTv() {  \t\t//조상 클래스의 product(int price)를 호출  \t\tsuper(100); //100만원  \t}  \t//Object 클래스의 toString()을 오버라이딩  \tpublic String toString() {return \"tv\";}  }  class Computer extends Product{              \tComputer() {  \t\tsuper(200);  \t}  \tpublic String toString() {return \"computer\";}  }  class Audio extends Product{              \tAudio() {  \t\tsuper(50);  \t}  \tpublic String toString() {return \"audio\";}  }              class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금            \t  \tvoid buy(Product p){   \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}            \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();            \t\t  \t\tb.buy(new Tv()); //Product tv1 = new Product; b.buy(tv1)  \t\t//짧게 쓸 수 있으나 참조변수가 없어서 리모컨을 사용할 수 없음. b.buy에서 임시로 쓰는 것.  \t\tb.buy(new Computer()); //Product com1 = new Product; b.buy(com1)            \t\t  \t\tSystem.out.println(\"현재 남은 돈은 \"+b.money+\"만원입니다\");  \t\tSystem.out.println(\"현재 보너스 점수는 \"+b.bonusPoint+\"점 입니다.\");  \t}  }                                      ⇒장점 1.하나의 메소드로 여러타입의 객체를 받을 수 있음                    하나의 배열로 여러 종류의 객체를 다루기        : 조상 타입의 배열에 자손들의 객체를 담을 수 있다. =        장점2. 하나의 배열에 여러종류의 객체를 저장할 수 있음          // product p1 = new tv();  // product p2 = new computer();  // product p3 = new audio();          Product p[] = new Product();  p[0] = new tv();  p[1] = new computer();  p[2] = new audio();                ]          class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금        \t  \tProduct cart[] = new Product[10]; //구매한 물건을 담을 배열 (장바구니)        \t  \tint i = 0;        \t  \tvoid buy(Product p){  \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}        \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tcart[i++] = p; //cart에 담고 배열+1해서 새 장바구니칸에 담고..  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  }                  public class Vector extends AbstractList //Vector = 가변배열기능. object배열을 멤버로 가지고 있음.  \t\timplements List, Cloneable, java.io.serializable{  \tprotected Object elementDate[];  }                  class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  \tProduct(int price){  \t\tthis.price=price;  \t\tbonusPoint = (int) (price/10.0);  \t}  }  class Tvvv extends Product{  \tTvvv() {  \t\tsuper(100); //100만원  \t}  \tpublic String toString() {return \"tv\";}  }  class Computer extends Product{          \tComputer() {  \t\tsuper(200);  \t}  \tpublic String toString() {return \"computer\";}  }  class Audio extends Product{          \tAudio() {  \t\tsuper(50);  \t}  \tpublic String toString() {return \"audio\";}  }          class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금        \t  \tProduct cart[] = new Product[10]; //구매한 물건을 담을 배열 (장바구니)        \t  \tint i = 0;        \t  \tvoid buy(Product p){  \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}        \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tcart[i++] = p; //cart에 담고 배열+1해서 새 장바구니칸에 담고..  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  \tvoid summary() { //구매 물품 정보 요약표시  \t\tint sum = 0; //구입한 물품의 가격 합계  \t\tString itemList = \"\"; //구입한 물품 목록        \t\t  \t\t//반복문을 사용해 구입한 물품의 총 가격과 목록을 만든다.  \t\tfor(int i=0; i&lt;cart.length;i++) {  \t\t\tif(cart[i]==null) break;  \t\t\tsum+=cart[i].price;  \t\t\titemList += cart[i]+\", \";  \t\t}  \t\tSystem.out.println(\"구입하신 물건의 총 금액은 \"+sum+\"만원입니다.\");  \t\tSystem.out.println(\"구입하신 제품은 \"+itemList+\"입니다.\");  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();        \t\t  \t\tb.buy(new Tvvv(  ));  \t\tb.buy(new Computer());  \t\tb.buy(new Audio());        \t\t  \t\tSystem.out.println(\"현재 남은 돈은 \"+b.money+\"만원입니다\");  \t\tSystem.out.println(\"현재 보너스 점수는 \"+b.bonusPoint+\"점 입니다.\");  \t\tb.summary();  \t}  }                    추상클래스(abstract calss): 미완성 설계도. 미완성 메소드 -구현부(몸통{})이 없는 메소드- 를 갖고 있는 클래스. 객체 생성 불가능. 일반클래스인데 미완성 메소드를 가지고 있는 것abstract 리턴타입 메소드 이름();abstract class Player { //추상클래스(미완성 클래스)\t\tabstract void play(int pos); //몸통{}이 없는 추상메소드\tabstract void stop(); //몸톰{}이 없는 추상메소드}\t//추상클래스가 다른 클래스를 작성하는데 도움이 됨.//추상클래스는 상속을 통해 완성해야 객체 생성가능class AudioPlayer extends Player{\tvoid play(int pos) {\t\tSystem.out.println(pos+\"위치부터 play합니다.\");\t\t}//추상메소드 구현 = 몸통만들어줌.\tvoid stop() {\t\tSystem.out.println(\"재생을 멈춥니다.\");\t}//추상메소드 구현=몸통 만들어줌}public class PlayerTest {\tpublic static void main(String[] args) {//\t\tPlayer p = new Player();  //에러. 추상클래스의 인스턴스화 불가\t\tAudioPlayer ap = new AudioPlayer(); //인스턴스 생성 가능.\t\tap.play(100);\t\tap.stop();\t\tPlayer p2 = new AudioPlayer(); //Player가 조상타입이라 가능함. 다형성\t\tp2.play(500);\t\tp2.stop();\t\t}\t}abstract class Player{\tboolean pause; //일시정지상태를 저장하기위한 변수\tint currentPos;//현재 play되고 있는 위치를 저장하기 위한 변수\t//플레이어의 종류마다 플레이 방식이나 멈추는 방식이 다르니 미리 만들어봤자 의미가 없음.\t//중요한건데 후에 상속을 만들 때 빠질까봐 강제하는 것임.\tPlayer(){  //추상클래스라도 생성자가 있어야함.\t\tpause = false;  \t\tcurrentPos = 0;\t}\t//지정된 위치(pos)에서 재생을 시작하는 기능이 수행하도록 작성되어야 한다.\tabstract void play(int pos); //추상메소드\t//재생을 즉시 멈추는 기능을 수행하도록 작성되어야한다.\tabstract void stop(); //추상메소드\t\tvoid play() { //인스턴스메소드\t\tplay(currentPos); //추상메소드를 사용할 수 있다.. 메소드는 선언부만 알면 호출가능하므로 추상메소드도 호출가능함.\t//상속을 통해 자손이 완성될 예정이라 사용할 수 있다. (지금 호출은 안됨. 상속을 통해 완성된 다음 호출 가능)\t}}public class ex {\tpublic static void main(String[] args) {\t\t}\t}  꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우      여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.      abstract class Unit{  \tint x,y;  \tabstract void move(int x, int y);  \tvoid stop() {  \t\t//현재 위치에 정지  \t\t};  \t}  class Marine extends Unit { //보병  \tvoid move(int x, int y) {  \t\t//지정된 위치로 이동  \t\tSystem.out.println(\"marine [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid stimPack() {  \t\t//스팀팩 사용  \t}  }  class Tank extends Unit{  \tvoid move(int x, int y) {  \tSystem.out.println(\"Tank [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid changeMode() {}; //공격모드로 변경  }  class Dropship extends Unit {  \tvoid move(int x, int y) {  \tSystem.out.println(\"Dropship [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid load() {}// 선택된 대상 태우기  \tvoid unload() {}//선택대상 내리기  }  public class ex {      \tpublic static void main(String[] args) {  //\t\tUnit[] group = new Unit[3];  //\t\tgroup[0]=new Marine();  //\t\tgroup[1]=new Tank();  //\t\tgroup[2]=new Dropship();  \t\tUnit group[] = {new Marine(), new Tank(), new Dropship()};    \t\t  \t\tfor(int i=0;i&lt;group.length;i++) {  \t\t\tgroup[i].move(100, 200);  \t\t\t//group의 타입은 Unit[], group[0], group[1], group[2]  \t\t}  \t\tObject group2[] = {new Marine(), new Tank(), new Dropship()};  \t\tfor(int i=0;i&lt;group2.length;i++) {  //\t\t\tgroup2[i].move(100, 200);  \t\t\t//Object는 최상위 객체라서 구현은 가능하나 move를 멤버로 가지고있지 않아서 에러남  \t\t}  \t}  }            추상화(불명확)←→구체화(명확)          추상화된 코드는 구체화된 코드보다 유연함. 변경에 유리  구체적인 코드 - GregorianCalendar cal = new GregorianCalendar();  추상적인 코드 = Calendar cal = Calendar.getInstance : Calendar 자손 객체를 반환해 cal에 대입. ⇒ Calendar객체가 무엇을 반환할 지 불명확함.          import java.util.Calendar;      private static Calendar createCalendar(TimeZone. Locale aLocale) {  \tif(caltype != null) {  \t\tswitch(caltype) {  \t\tcase \"buddhist\": //불교력  \t\t\tcal = new BuddhistCalendar(zone, aLocale);  \t\t\tbreak;  \t\tcase \"japanese\" : //일본력  \t\t\tcal = new JapanesImperialCalendar(zone, aLocale);  \t\t\tbreak;  \t\tcase \"gregory\" : //서양력  \t\t\tcal = new GregorianCalendar(zone, aLocale);  \t\t\tbreak;  \t\t}  \t}  }  public class ex {      \tpublic static void main(String[] args) {  //\t\tGregorianCalendar cal = new GregorianCalender(); 구체적  \t\tCalendar cal = Calendar.getInstance();//추상적  \t}  }      인터페이스(interface)추상메소드의 집합(프로그래밍관점)      구현된 것이 하나도 없는 설계도. 껍데기(모든 멤버가 public)    interface 인터페이스이름{    public static final 타입 상수이름 = 값;    public abstract 메소드이름(매개변수목록); }      interface PlayingCard{  \t//상수  \tpublic static final int SPADE =4;  \tfinal int DIAMOND = 3; //public static 생략됨  \tstatic int HAEART = 2; //public final 생략됨  \tint CLOVER = 1; //public static final      \t//추상메소드  \tpublic abstract String getCardNumber();  \tString getCaedKind(); //public abstract생략됨.  \t//public static final은 예외없이 모두 적용이기때문에 적지않아도 자동으로 붙여줌  \t}  public class ex {      \tpublic static void main(String[] args) {  \t}  }        [!important]추상클래스와 인터페이스의 차이점인터페이스는 인스턴스변수를 가질 수 없음!  인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상이 아님)  다중 상속 가능. (추상메소드는 구현부{}가 없어서 충돌해도 문제 없음) - 조상이 여러개여도 가능.  인터페이스는 지역변수를 가지지 못함(추상클래스는 가능)      인터페이스의 구현 : 인터페이스에 정의된 추상메소드를 완성하는 것.  class 클래스 이름 implements 인터페이스 이름{ 인터페이스에 정의된 모든 추상메소드를 구현해야 함. } - 일부만 구현하는 경우, 클래스앞에 abstract를 붙여야함.  = 추상클래스 완성과 동일      interface Fightable{ //인터페이스  \tvoid move(int x, int y);  \tvoid attack(Unit u);  }  class Fighter implements Fightable{ //인터페이스 구현  \tpublic void move(int x, int y) {  \t\tSystem.out.println(\"x = \"+x+\", y = \"+y);  \t}  \tpublic void\tattack(Unit u) {  \t\tSystem.out.println(\"Unit = \"+u);  \t}  }  abstract class Player{ //추상클래스  \tabstract void play(int pos);  \tabstract void stop();  }  class AudioPlayer extends Player{ //추상클래스 구현  \tvoid play(int pos) {  \t\tSystem.out.println(pos);  \t}  \tvoid stop() {  \t\t//내용  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {    \t\t  \t}  }            인터페이스를 이용한 다형성          인터페이스도 구현 클래스의 부모임      인터페이스 타입 매개변수는 인터페이스 구현한 클래스의 객체만 가능      인터페이스를 메소드의 리턴타입으로 지정가능.          import java.io.ObjectInputStream.GetField;      abstract class Unit{  \tint x,y;  \tabstract void move(int x, int y);  \tvoid stop() {  \t\tSystem.out.println(\"멈춤\");  \t};  }  interface Fightable{ //인터페이스  \tvoid move(int x, int y); //public abstract가 생략됨  \tvoid attack(Fightable f); //public abstract가 생략됨  }  class Fighter extends Unit implements Fightable {   \tpublic void move(int x, int y) { //오버라이딩 규칙: 조상(public)보다 접근제어자가 좁으면 안됨.  \t\tSystem.out.println(\"[\"+x+\", \"+y+\"]로 이동\");  \t}  \tpublic void attack(Fightable f) //매개변수 타입이 인터페이스.= 이 인스턴스를 구현한 class의 객체만 가능  \t//attack메소드는 매개변수로 Fightable인터페이스를 구현한 class의 객체만 받음  \t{   \t\tSystem.out.println(f+\"를 공격\");  \t}   \t//싸울 수 있는 상대 소환  \tFightable getFightable(){  \t\tFighter f = new Fighter();   \t\treturn f;  //Fighter가 Fightable을 상속받고있어서 형변환이 가능하기때문에 f는 Fighter지만 사용 가능  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFighter f = new Fighter();  \t\tFightable ff = f.getFightable();    \t\t  \t\tf.move(100, 200);  \t\tf.attack(new Fighter()); //toString이 나옴  \t\tf.stop();    \t\t  \t\tSystem.out.println(\"-----------------\");  \t\tUnit u = new Fighter();  \t\tu.move(100, 200);  \t\tu.stop();  //\t\tu.attack(new Fighter()); //에러, Unit에 attack이 없음    \t\t  \t\tSystem.out.println(\"-----------------\");  \t\tFightable f2 = new Fighter();  \t\tf2.move(100, 200);  \t\tf2.attack(new Fighter()); //toString이 나옴  //\t\tf2.stop(); //Fightable에 stop이 없음  \t}  }            장점          두 대상(객체)간의 ‘연결, 대화, 소통’을 돕는 ‘중간역할’을 한다      선언과 구현을 분리시킬수 있게됨.(변경에 유리)      개발시간 단축      변경에 유리한 설계      표준화 가능 (데이터베이스회사들이 JDBC에 맞춰 데이터베이스를 개발함. 자바개발자는 JDBC를 기준으로 개발 )      서로 관계없는 클래스들의 관계를 맺어줄 수 있다. : 내가 원하는 클래스만 모아서 인터페이스로 묶을 수 있음      인터페이스덕분에 한 클래스를 변경해도 다른 클래스는 안바꿔도 동작함(느슨한 결함)        직접적 관계      class A {  \tpublic void method(C c){  \t\tc.methodC();  \t}  }  class B {  \tpublic void methodB(){  \t\tSystem.out.println(\"methodB()\");  \t}  }  class C{  \tpublic void methodC(){  \t\tSystem.out.println(\"method() in C\");  \t}  }  public class InterfaceTest {      \tpublic static void main(String[] args) {  \t\tA a = new A();  \t\ta.method(new C()); //A가 B에 의존  \t}      }        간접적 관계      class A {  \tpublic void method(I i){  \t\ti.method();  \t}  }  interface I { void method();}       class B implements I{  \tpublic void method(){  \t\tSystem.out.println(\"methodB()\");  \t}  }  class C implements I{  \tpublic void method(){  \t\tSystem.out.println(\"method() in C\");  \t}  }  public class InterfaceTest {      \tpublic static void main(String[] args) {  \t\tA a = new A();  \t\ta.method(new B()); //A가 B에   \t}  }        디폴트 메소드                  인터페이스에 새로운 메소드(추상메소드)를 추가하기 어려움 - 한 인터페이스에 추상메소드가 추가되면 연관된 모든 클래스에 추가된 추상메소드 구현을 해주어야함 ⇒ 해결책:디폴트메소드(default method)        interface MyInterface {        void method();        default void newMethod();{ } }            디폴트메소드 = 인스턴스메소드 (인터페이스 원칙 위반 = 예외)      디폴트메소드가 기존의 메소드와 충돌할때?                              여러 인터페이스의 디폴트 메소드간의 충돌 — 인터페이스를 구현한 클래스에서 디폴트메소드를 오버라이딩한다                                디폴트메소드와 조상클래스의 메소드간의 충돌 — 조상클래스의 메소드가 우선되어 먼저 상속되고, 디폴트메소드는 무시된다.                                static 메소드      내부클래스(inner class) : 클래스 안에 클래스          객체생성없이도 상위클래스의 멤버에 접근가능      코드의 복잡성을 줄일 수 있음. (캡슐화)          class AAA{ //BBB의 외부클래스  \tint i=100;  \tBBB b = new BBB();  \tclass BBB{///AAA의 내부클래스  \t\tvoid method() {  //\t\t\tAAA a = new AAA();  //AAA의 내부클래스라 해줄필요없음  \t\t\tSystem.out.println(i); //객체생성없이 접근가능  \t\t}  \t}  }  class CCC{  }  public class ex {      \tpublic static void main(String[] args) {  \t\tAAA a = new AAA();  \t\ta.b.method();  \t}  }                      내부클래스의 종류와 유효범위(scope)는 변수와 동일                                            내부클래스              특징                                                          인스턴스 클래스  (instance class)              외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.                                      스태택 클래스  (static class)              외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메소드에서 사용될 목적으로 선언된다.                                      지역 클래스  (local class)              외부클래스의 메소드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.                                      익명 클래스  (anonymosus class)              클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)                                                내부클래스의 제어자는 public, private, (default), protected 4가지 사용가능.                  public class ex {          \tclass InterfaceInner{  \t\tint iv = 100;  //\t\tstatic int cv = 100; //에러, static변수 선언불가  \t\t//static은 객체없이 생성할 수 있어야하는데 인스턴스안에 들어가있어서 객체를 만들어야 사용할 수 있게됨. 모순이라 에러표시  \t\tfinal static int CONST = 100; //final static은 상수이므로 허용  \t}        \t  \tstatic class staticInner{  \t\tint iv = 200;  \t\tstatic int cv = 200; //static클래스만 static멤버를 정의할 수 있다.  \t}  \tvoid mymethod() {  \t\tclass LocalInner{  \t\t\tint iv = 300;  //\t\t\tstatic int cv = 300; //에러, static변수를 선언할 수 없다  \t\t\tfinal static int CONST = 300; //final static은 상수이므로 허용  \t\t\t//final뒤에 static이 오는 경우는 어떤 조건에서도 같은 값일 경우.   \t\t\t//객체마다 값이 다를수도 있으면 final만 쓰면됨(ex.카드의 숫자와 무늬)  \t\t}  \t\tint i = LocalInner.CONST; //지역내부클래스의 static상수는 메소드 내에서만 사용가능  \t}  \tpublic static void main(String[] args) {  \t\tSystem.out.println(InterfaceInner.CONST);  \t\tSystem.out.println(staticInner.cv);  //\t\tSystem.out.println(LocalInner.CONST); //지역내부클래스의 static상수는 메소드 외에서는 사용 불가능  \t}  }                  public class ex {          \tclass InstanceInner{}  \tstatic class StaticInner{}        \t  \tInstanceInner iv = new InstanceInner(); //인스턴스 멤버끼리는 직접 접근가능  \tstatic StaticInner cv = new StaticInner(); //static멤버끼리는 직접 접근가능  //\tstatic StaticInner cv2 = new InstanceInner(); //static멤버가 instance멤버 접근 불가능. 반대는 가능          \tstatic void staticmethod() { //static멤버는 인스턴스에 직접접근불가  //\tInstanceInner obj1 = new InstanceInner();  \t\tStaticInner obj2 = new StaticInner();        \t\t  \t\t//이렇게까지 쓰지는 않는데 일단 예시로  \t\tex outer = new ex(); //인스턴스 클래스는 외부클래스를 먼저 생성해야 생성가능  \t\tInstanceInner obj1 = outer.new InstanceInner();  \t}  \tvoid instanceMethod() {//인스턴스메소드에서는 인스턴스멤버와 static멤버 모두 접근가능  \t\tInstanceInner obj1 = new InstanceInner();  \t\tStaticInner obj2 = new StaticInner();  //\t\tLocalInner lv = new LocalInner(); //지역 내부클래스는 외부에서 접근 불가  \t}  \tvoid myMethod() {  \t\tclass LocalInner{}  \t\tLocalInner lv = new LocalInner();  \t}  \tpublic static void main(String[] args) {  \t}  }                  class Outer{  \tprivate int outerIv= 0;  \tprivate static \tint outerCv=0;        \t  \tclass InstanceInner{  \t\tint iiv = outerIv;//외부클래스의 private멤버도 접근가능  \t\tint iiv2 = outerCv;   \t}  \tstatic class StaticInner{  //\t\tint siv = outerIv; //static클래스는 외부클래스의 인스턴스멤버에 접근 불가  \t\tstatic int scv = outerCv;  \t}  \tvoid mymethod() {  \t\tint lv = 0;  \t\tfinal int LV = 0;  //final생략 가능        \t\t  //\t\tlv=3;//밑에 int liv3 = lv;에러내려고 적음. 값이 바뀌었으니 변수로 처리해서 에러남  \t\tclass LocalInner{ //지역내부클래스를 감싸고있는 메소드의 상수만 사용가능  \t\t\tint liv = outerIv;  \t\t\tint liv2 = outerCv;  \t\t\t//내부클래스의 객체가 지역변수보다 더 오래 존재가능   \t\t\t//외부클래스의 지역변수는 final이 붙은 변수(상수)만 접근 가능  \t\t\t//JDK1.8부터는 변수인데 값이 안바뀌는 것도 상수로 간주. (에러x)  \t\t\tint liv3 = lv;  \t\t\tint liv4 = LV;         \t\t\t  \t\t\tvoid method() {  \t\t\t\tSystem.out.println(lv);  \t\t\t}        \t\t\t  \t\t}  \t}  }  public class ex {  \tpublic static void main(String[] args) {  \t}  }                          인스턴스 내부클래스를 사용하려면 외부클래스의 객체를 먼저 만들고 인스턴스내부클래스의 객체를 만들어야 함      class Outer {  \tclass instanceInner {  \t\tint iv =100;  \t}  \tstatic class StaticInner {  \t\tint iv = 200;  \t\tstatic int cv = 300;  \t}  \tvoid myMethod() {  \t\tclass LocalInner{  \t\t\tint iv = 400;  \t\t}  \t}  }  public class ex {  \tpublic static void main(String[] args) {  \t\tOuter oc  = new Outer(); //외부클래스의 인스턴스를 먼저 생성해야 인스턴스클래스의  \t\tOuter.instanceInner ii = oc.new instanceInner(); //인스턴스를 생성가능    \t\t  \t\tSystem.out.println(\"ii.iv : \"+ii.iv);  \t\tSystem.out.println(\"Outer.StaticInner.cv : \"+Outer.StaticInner.cv);    \t\t  \t\t//스태틱 내부클래스의 인스턴스는 외부클래스를 먼저 생성하지않아도 된다  \t\tOuter.StaticInner si = new Outer.StaticInner();  \t\tSystem.out.println(\"ii.iv : \"+si.iv);    \t\t  \t}  }          class Outer {  \tint value = 10; //Outer.this.value 외부클래스의 iv    \t  \tclass Inner{  \t\tint value = 20; //this.value 내부클래스의 iv    \t\t  \t\tvoid method() {  \t\t\tint value = 30;  \t\t\tSystem.out.println(\"           value : \"+value);  \t\t\tSystem.out.println(\"      this.value : \"+this.value);  \t\t\tSystem.out.println(\"Outer.this.value : \"+Outer.this.value);    \t\t\t  \t\t}  \t}    \t  }  public class ex {  \tpublic static void main(String[] args) {  \t\tOuter outer = new Outer();  \t\tOuter.Inner inner = outer.new Inner();  \t\tinner.method();    \t\t  \t}  }            익명클래스(anonymous class)    : 이름이 없는 일회용 클래스. 정의와 생성을 동시에 함(조상이름을 대신 씀)  new 조상클래스 이름(){ 멤버선언 } / new 구현인터페이스이름() { 멤버선언 }      public class ex {  \tObject iv = new Object() {void method2(){}}; //익명클래스  \tstatic Object cv = new Object() {void method2(){}}; //익명클래스    \t  \tvoid Mymethod() {  \t\tObject lv = new Object() { void method2() {}}; //익명클래스  \t}      \tpublic static void main(String[] args) {  \t}  }          import java.awt.*;  import java.awt.event.*;  //awt : 자바의 윈도우 프로그래밍 도구.       public class ex {  \tpublic static void main(String[] args) {  \t\tButton b = new Button(\"start\");  //\t\tb.addActionListener(new EventHandler()); //객체생성  \t\tb.addActionListener(new AcionListener/*조상 OR 인스턴스 이름*/() { //클래스의 정의와 객체생성을 동시에  \t\t\tpublic void actionPerformed(ActionEvent e) {  \t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");  \t\t\t}  \t\t}); //객체생성    \t\t  \t\t//위랑 같아보이지만 다른 클래스임. 일회용클래스이기때문.  \t\tb.addActionListener(new AcionListener/*조상 OR 인스턴스 이름*/() { //클래스의 정의와 객체생성을 동시에  \t\t\tpublic void actionPerformed(ActionEvent e) {  \t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");  \t\t\t}  \t\t}); //객체생성    \t\t  \t\t}  \t}  //class EventHandler implements AcionListener{ //클래스 정의.   //\tpublic void actionPerformed(ActionEvent e) {  //\t\tSystem.out.println(\"ActionEvent occurred!!!\");  //\t}  //}      "
  },
  
  {
    "title": "자바의 정석 강의 - 객체지향(OOP)",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5(OOP)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 객체",
    "date": "2022-08-01 00:00:00 +0900",
    





    
    "snippet": "객체지향 언어 = 프로그래밍 언어 + 객체지향개점(규칙)  캡슐화  상속  추상화      다형성    class : 객체를 정의해 놓은 것, 객체를 생성하는데 사용함. (설계도)  = 데이터 + 함수(method) (서로 관련있는 것 끼리 묶음. 데이터만 묶으면  구조체)  기본적으로 하나의 소스파일에 하나의 class를 작성하는것이 바람직하나, 여...",
    "content": "객체지향 언어 = 프로그래밍 언어 + 객체지향개점(규칙)  캡슐화  상속  추상화      다형성    class : 객체를 정의해 놓은 것, 객체를 생성하는데 사용함. (설계도)  = 데이터 + 함수(method) (서로 관련있는 것 끼리 묶음. 데이터만 묶으면  구조체)  기본적으로 하나의 소스파일에 하나의 class를 작성하는것이 바람직하나, 여러 class를 작성할수도 있음.          public class가 있는 경우, 소스파일의 이름은 반드시 public class(한소스파일에서 한번만 사용 가능)의 이름과 일치해야함      public class가 없는 경우, 소스파일의 이름은 class 중 어느 것을 사용해도 무방함. (main method가 있는부분은 동일해야함. 아니면 수동으로 지정가능)            객체(인스턴스와 거의 같은 말임) : 실제로 존재하는 사물 또는 개념. 객체가 가진 기능과 속성에따라 용도가 다름. 모든 인스턴스를 대표하는 일반적 용어. 클래스를 인스턴스화하면 객체(인스턴스)가 됨.  (제품) - 속성(변수) + 기능(메소드)                  class 생성        class Tv { String color ………. (6개의 멤버 = 구성 6개) }                    객체 생성 : 변수명 = new 클래스명();        Tv t = new Tv();                    사용        t.channel1 = 7; t.channelDown(); sout(”현재 “+t.channel1+번입니다”)         class Tv { \t//tv의 속성 \tString color; \tboolean power; \tint channer1;        \t \t//tv의 기능 \tvoid power(){ \t\tpower !=power; //티비 온오프 \t} \tvoid channer1Up() { \t\t++channer1; \t} \tvoid channer1Down() { \t\t--channer1; \t} } public class Ex6_1 {         \tpublic static void main(String[] args) { \t\tTv t = new Tv(); \t\tt.channer1=7; \t\tt.channer1Down(); \t\tSystem.out.println(\"현재 \"+t.channer1+\"번 입니다.\");        \t\t //\t\tTv t2 = new Tv(); //\t\tSystem.out.println(\"현재 \"+t2.channer1+\"번 입니다.\"); //0번        \t\t \t\tTv t2 = t; \t\tSystem.out.println(\"현재 \"+t2.channer1+\"번 입니다.\"); //6번 \t}         }                                    객체 배열 == 참조변수 배열  tv tvarr[] = new tv[3]; == tv tvarr[] = {new tv(), new tv(), new tv()};        tvatrr[0] = new tv(); tvatrr[1] = new tv(); tvatrr[2] = new tv();              인스턴스(객체와 거의 같은 말임) : 특정 class로부터 생성된 객체      선언위치에 따른 변수의 종류      class variable {  \tint iv;  \tstatic int cv;      \tvoid method() {  \tint lv = 0;  \t}  } //이 전체가 class 영역                      변수                  클래스 영역(선언문만 가능, 순서 상관x)                          iv (intance variable), cv(static 있어서 class)                                메소드 영역 - lv(Local variable)                                                    변수의 종류              선언 위치              생성 시기                                                          class 변수              class 영역              클래스가 메모리에 올라갈 때(import할때)                                      instance 변수              class 영역              인스턴스가 생성되었을 때                                      지역변수              class영역 이외의 영역  (메소드, 생성자, 초기화 블럭 내부)              변수 선언문이 수행되었을 때                                      객체 - instance 변수를 묶어놓은 것.                  [!important]CPU ←RAM ←SSD or HDD - ssd, hdd에서 바로 cpu못가니까 ram을 둠. 파일을 읽는다고 하면(loading) 메모리(ram)에 얹는다고 표현함. = 작업을 하려면 class가 메모리에 올라간다고 표현함.ram은 컴퓨터를 끄면 데이터가 날아가니까 저장(save)하려면 다시 디스크로 옮겨야함즉, class변수는 아무때나 사용이 가능하고 instance는 객체생성을 해야 사용 가능함. 그래서!! class는 객체생성이 필요없고 instance는 객체생성이 필요함.                          class 변수 : 공통 속성(객체 모두 같은 값) ??변경하면 까다로워지니까          instance 변수 : 개별 속성(객체마다 다른 값도 가능) ??복사개념이라 수정쉬워서                  class Card{  \tString kind; //무늬  \tint number; //숫자          \tstatic int width = 100; //폭  \tstatic int height = 250;  }          public static main void(String[] args){  \tCard c = new Card();  \tc.kind = \"heart\";  \tc.number = 5;          \t// c.width = 200;  오류는 안나는데 이렇게하면 안됨!! 객체별로 값이 달라짐  \t// c.height = 300; 오류는 안나는데 이렇게하면 안됨!! 객체별로 값이 달라짐  \tCard.width = 200;  \tCard.height = 300; //class값이 전부 변경돼서 객체별로 값이 같아짐  }                  class Card{  \tString kind; //무늬  \tint number; //숫자          \tstatic int width = 100; //폭  \tstatic int height = 250;  }  public class Ex6_3 {          \tpublic static void main(String[] args) {  \t\tSystem.out.println(\"Card.width = \"+Card.width);  \t\tSystem.out.println(\"Card.height = \"+Card.height); //객체 생성없이 사용 가능        \t\t  \t\tCard c1 = new Card();  \t\tc1.kind = \"Heart\";  \t\tc1.number = 7;        \t\t  \t\tCard c2 = new Card();  \t\tc2.kind = \"Spade\";  \t\tc2.number = 4;        \t\t  \t\tSystem.out.println(\"c1은 \"+c1.kind+\", \"+c1.number+\"이며, 이 카드의 크기는 (\"+c1.width+\", \"+c1.height+\")\");  \t\tSystem.out.println(\"c2은 \"+c2.kind+\", \"+c2.number+\"이며, 이 카드의 크기는 (\"+c2.width+\", \"+c2.height+\")\");  \t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경합니다\");        \t\t  //\t\tc1.width=50;  //\t\tc1.height=80; //c1이 인스턴스지만 width와 height가 class기 때문에 모두 바뀜  \t\t//오해하기 쉬운 코드니까 권장하지 않는 코드임.        \t\t  \t\tCard.width=50;  \t\tCard.height=80;  \t\tSystem.out.println(\"c1은 \"+c1.kind+\", \"+c1.number+\"이며, 이 카드의 크기는 (\"+c1.width+\", \"+c1.height+\")\");  \t\tSystem.out.println(\"c2은 \"+c2.kind+\", \"+c2.number+\"이며, 이 카드의 크기는 (\"+c2.width+\", \"+c2.height+\")\");  \t}          }                                      메소드(=블랙박스) : 문장들을 묶어놓은 것. (class안에 있어야함)  선언부 { 구현부 }                                          값(입력)을 받아서 처리하고, 결과를 반환(출력) - 함수랑 똑같다고 보면됨(함수는 독립적이라 class안에 없어도됨.  int add(int x, int y){  int result = x+y;  return result; }                                                      반드시 return으로 마무리 지어야하는데 값이 void일경우 return 생략 가능                                                        메소드 = 블랙박스??                    별 이유없고 걍..별로 알고싶지않아서 println이 어떻게 동작하는지 궁금함? ㄴㄴㅋㅋ                                                              실행흐름                                  인스턴스 생성                  main메소드안에서 메소드 호출                  메소드 {}안의 문장 수행                  호출 메소드로 돌아와서 main메소드안의 메소드로 돌아와서 이후 문장 수행                                            하나의 메소드에 하나의 기능만 수행하도록 작성할 것.              장점                                  코드 중복 줄이기                  코드 관리 용이                  코드 재사용 용이                  코드가 간결해서 이해하기 쉬워진다                                            지역 변수 : 메소드 안에 선언된 변수 (매소드가 끝나면 없어지기때문에 다른 메소드에 이름을 같게해도 상관없음.)              메소드 호출 : 메소드 이름(값1,값2,…[값 안써도 됨]);  int result = add(3,5); ⇒ int add값을 저장할 공간이 필요해서 int result를 씀 (class영역에만 정의 가능)                          int add(int x, int y){  \tint result = x+y;  \treturn result;  }              public static void main(String [] args) {  \tint result = add(3,5);  }                        매개변수 : 메소드를 호출한쪽에서 준 값을 메소드에게 전달하는 역할              class MyMath {  \tlong add(long a, long b) {  \t\treturn a+b;  \t}  \tlong subtract(long a, long b) {  \t\treturn a-b;  \t}  \tlong multiply(long a, long b) {  \t\treturn a*b;  \t}  \tlong divide(long a, long b) {  \t\treturn a/b;  \t}            \t  \t// 두 값을 받아서 더 큰 값을 반환하는 메소드  \tlong max (long a, long b) {  //\t\treturn a&gt;b? a:b;  \t\tif(a&gt;b) return a;  \t\telse return b; //참, 거짓 둘다 return해줘야함  \t}  \tlong min (long l, long m) {  \t\treturn l&lt;m?l:m;  \t}            \t  \tvoid printgugudan(int dan) {  \t\tif(!(dan&gt;=2 &amp;&amp; dan&lt;=9)) {  \t\t\treturn;  \t\t}            \t\t  \t\tfor (int i=1;i&lt;=9;i++) {  \t\t\tSystem.out.printf(\"%d * %d = %d%n\",dan,i,dan*i);  \t\t}  \t}  }  public class Ex6_4 {              \tpublic static void main(String[] args) {  \t\tMyMath mm = new MyMath();            \t\t  \t\tlong result1 = mm.add(5L,3L);  \t\tlong result2 = mm.subtract(5L,3L);  \t\tlong result3 = mm.multiply(5L,3L);  \t\tlong result4 = mm.divide(5L,3L);            \t\t  \t\tSystem.out.println(\"add = \"+result1);  \t\tSystem.out.println(\"subtract = \"+result2);  \t\tSystem.out.println(\"multiply = \"+result3);  \t\tSystem.out.println(\"divide = \"+result4);            \t  \t\tSystem.out.println(mm.max(mm.add(5, 3),mm.add(4, 3)));  \t\tSystem.out.println(mm.max(5, 4));  \t\tSystem.out.println(mm.min(mm.add(5, 3),mm.add(4, 3)));  \t\tSystem.out.println(mm.min(5, 4));            \t\t  \t\tmm.printgugudan(5);  \t}              }                                      반환값 - return : 실행중인 메소드를 종료하고 호출한 곳으로 되돌아간다. (타입이 일치해야하나 자동형변환된는 것은 가능 ex. char → int                                            호출스택 (call srack) : 메소드 수행에 필요한 메모리가 제공되는 공간. 메소드가 호출되면 호출스택에 메모리 할당, 종료되면 해제          stack : 밑이 꽉막힌 상자. 위에 차곡차곡 쌓인다. - 후입선출      main 메소드가 println 메소드를 호출했으면 println 메소드가 실행되는동안 main 메소드는 대기상대임.println메소드가 종료되면 스택에서 사라지고 남은 main메소드가 작업을 계속함  = 맨 위에 있는 메소드 하나만 실행중, 나머지는 대기            기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.      class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tchange(d.x);     \t\t  \t\tSystem.out.println(\"After change(d.x)\");  \t\tSystem.out.println(\"main() : x = \"+d.x); //change의 int x와는 다른 주소를 가지고있기때문에 main안에서는 여전히 10의 값을 가짐  \t}  \tstatic void change(int x) { //int x로 새로운 저장공간은 만들었기때문에 class date의 int x와는 가른 주소를 가짐  \t\tx=1000;  \t\tSystem.out.println(\"chanhe() : x = \"+x);  \t}//change문이 끝났으니 change문 시작할때 새로 지정해준 int x의 값도 종료됨!  }            참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.      class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tchange(d);     \t\t  \t\tSystem.out.println(\"After change(d)\");  \t\tSystem.out.println(\"main() : x = \"+d.x); //1000  \t}  \tstatic void change(Date d) { //main에서도 공유중인 date의 d값을 복사해옴. = main의 x와 같은 동일한 공간을 가짐  \t\td.x=1000;  \t\tSystem.out.println(\"chanhe() : x = \"+d.x);  \t}  }          class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tDate d2 = copy(d);  \t\tSystem.out.println(\"d.x = \"+d.x);  \t\tSystem.out.println(\"dx.x = \"+d2.x);  \t}  \tstatic Date copy(Date d) {  \t\tDate tmp = new Date();    \t\t  \t\ttmp.x=d.x;    \t\t  \t\treturn tmp; //객체의 주소를 반환함    \t\t  \t}  }            일단 이렇게 이해함.            좀 더 확실히 이해하려고 다시 그려봄    static method(class method) - ex)Math.random();          객체생성 없이 ‘클래스이름.메소드이름()’으로 호출      인스턴스 멤버(iv, im)과 관련없는 작업을 하는 메소드      메소드 내에서 인스턴스 변수(iv), 인스턴스 메소드(im) 사용불가 (객체가 있다는 보장이 없음)            instance method          인스턴스 생성 후 ‘참조변수.메소드이름()’으로 호출      인스턴스 멤버와 관련된 작업(iv, im)을 하는 메소드      메소드 내에서 인스턴스 변수(iv) 사용가능      class 메소드 사용 가능함. (class는 언제나 사용가능함)          class MyMath3{  \tlong a,b;  //인스턴스 변수(iv)    \t  \tlong add() { //instance method  \t\treturn a+b; //인스턴스 변수  \t}  \tstatic long add(long a, long b )  { //class method. long a,b는 지역변수이자 매개변수(iv필요없음)  \t\treturn a+b; //지역변수  \t}  }  public class array {  \tpublic static void main(String[] args) {  \t\t\tSystem.out.println(MyMath3.add(200L,100L)); //class method 호출  \t\t\tMyMath3 mm = new MyMath3(); //객체 만들기  \t\t\tmm.a = 200L;  \t\t\tmm.b = 300L;  \t\t\tSystem.out.println(mm.add()); //instance method 호출  \t}  }        static은 iv를 사용하지않을때 붙일 것.    이걸 구분할줄알아야 코더가 아니고 프로그래머가된다…………………………………    그래도 한번더 정리하자면          static - 공통속성에 붙이는 것. (변하지 않는 값 - ex.카드 크기 등)        오버로딩(overloaing : 과적하다) : 한 class안에 같은 이름의 메소드 여러개를 정의하는 것. (대표적으로 println이 있다)                  성립조건                  메소드 이름이 같음          매개변수의 개수 또는 타입이 달라야함.                      반환 타입은 영향이 없음            ex )                        int add(int a, int b) {return a+b}            int add(int x, int y) {return a+b}            ⇒ 오버로딩 아님. 1번만 충족. 그냥 중복처리돼서 에러                        int add(int a, int b) {return a+b}            long add(int a, int b) {return (long)(a+b)}            ⇒ 1번 충족, 2번 불충족, 3번은 상관없음. 결론, 중복정의로 에러                        long add(int a, long b) {return a+b}            long add(long a, int b) {return a+b}            ⇒ 1번 2번 모두 충족, 오버로딩            💡 add(3,3);은 두 add 전부 해당돼서 명확하지않다고 에러남                            class MyMath3{  \tint add(int a, int b) {  \t\tSystem.out.println(\"int add (int a, int b) - \");  \t\treturn a+b;  \t}  \tlong add(long a, int b) {  \t\tSystem.out.println(\"long add (long a, int b) - \");  \t\treturn a+b;  \t}  \tlong add(int a, long b) {  \t\tSystem.out.println(\"long add (int a, long b) - \");  \t\treturn a+b;  \t}  \tlong add(long a, long b) {  \t\tSystem.out.println(\"long add (long a, long b) - \");  \t\treturn a+b;  \t}  \tint add(int[] a) { //배열의 모든 요소의 합을 결과로  \t\tSystem.out.print(\"int add(int[] a) - \");  \t\tint result = 0;  \t\tfor(int i=0; i &lt; a.length;i++)   \t\t\tresult += a[i];  \t\t\treturn result;  \t\t}  }          public class array {  \tpublic static void main(String[] args) {  \t\tMyMath3 mm = new MyMath3();  \t\tSystem.out.println(\"mm.add(3,3) 결과 : \"+mm.add(3,3));  \t\tSystem.out.println(\"mm.add(3L,3) 결과 : \"+mm.add(3L,3));  \t\tSystem.out.println(\"mm.add(3,3L) 결과 : \"+mm.add(3,3L));  \t\tSystem.out.println(\"mm.add(3L,3L) 결과 : \"+mm.add(3L,3L));        \t\t  \t\tint a[] = {100, 200,300};  \t\tSystem.out.println(\"mm.add(a) 결과 : \"+mm.add(a));        \t\t  \t}  }                      생성자(constructor) :                  인스턴스가 생성될 때마다 호출되는 ‘인스턴스 초기화 메소드’        Time t = new Time(); //객체생성  //인스턴스 초기화  t.hour = 12;  t.minute = 34;  t.second = 56;  == Time t = new  Time(12,34,56); //생성자            인스턴스 생성시 수행할 작업(iv 초기화)에 사용              class와 이름이 같아야 함. (구성다른 생성자를 여러개 쓰면 오버로딩임)        class Card {        Card() { //매개변수 없는 생성자        //인스턴스 초기화 작업        }        Card (String kind, int number) { //매개변수 있는 생성자        //인스턴스 초기화 작업        }        Card 클래스가 두개인건 생성자 오버로딩            리턴값이 없음 (void도 안붙임)      모든 class는 한개이상의 생성자가 있어야한다.            기본생성자 (default constructor) : 직접 작성해줘야하나 자동으로 생기는 생성자          매개변수가 없는 생성자              생성자가 하나도 없을 때만, 컴파일러가 자동 추가        Point() {} //Point 클래스의 기본 생성자                class Data_1 {  \tint value;  \t//Date_1(){} 가 자동으로 생김  }  class Data_2{  \tint value;  \t//Data_2() {} //기본생성자 (에러내려고 주석처리함)  \tData_2(int x){ //매개변수가있는 생산자  \t\tvalue = x;  \t}      }  public class array {  \tpublic static void main(String[] args) {  \t\tData_1 d1 = new Data_1(); //Date_1 클래스안에 생성자가 없어서(1개) 기본 생성자가 자동으로 생김  \t\tData_2 d2 = new Data_2(); //compile error 생성자를 호출했는데 Date_2안에 생성자가 없음  \t}  }        어지간하면 그냥 넣어줄것. 나중에가면 헷갈림          매개변수가 있는 생성자 : 생성자 호출할때 바로 값을 받음.          class Car {  \tString color; //색상  \tString gearType; //변속기 종류 - auto(자동), manual(수종)  \tint door; //문 개수    \t  \tCar(){}  \tCar(String c, String g, int d){  \t\tcolor = c;  \t\tgearType = g;  \t\tdoor = d;  \t}  }  public class array {   \tpublic static void main(String[] args) {  \t\tCar c = new Car(\"white\",\"auto\",4);   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t\tSystem.out.println();  \t\tCar c2 = new Car(\"red\",\"manual\",3);   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t}  }            생성자 this()          같은 클래스에서 다른 생성자를 호출할 때 사용      다른 생성자 호출시 첫 줄에서만 가능          class Car {  \tString color; //색상  \tString gearType; //변속기 종류 - auto(자동), manual(수종)  \tint door; //문 개수    \t  \tCar(){  \t\tthis(\"white\",\"auto\",4); // == Car{String color, String gearType, int door)  \t\t//color = \"white\";  \t\t//gearType = \"auto\"  \t\t//door = 4;   이거랑 같은거임. 코드 중복 줄이려고 한 문장으로 만든 것.  \t}  \tCar(String color) {  \t\tthis(color, \"manual\",3);  \t}  \tCar(String color, String gearType, int door){  \t\tthis.color = color;  \t\tthis.door = door;  \t\tthis.gearType= gearType;  \t}  }  public class array {   \tpublic static void main(String[] args) {  \t\tCar c = new Car();   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t\tSystem.out.println();  \t\tCar c2 = new Car(\"red\");   \t\tSystem.out.println(\"색 : \"+c2.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c2.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c2.door);  \t\tSystem.out.println();  \t\tCar c3 = new Car(\"blue\",\"auto\",5);   \t\tSystem.out.println(\"색 : \"+c3.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c3.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c3.door);  \t}  }        코드 중복을 제거하기 위해 생성자끼리 서로 호출하는 것  class Car {\tString color;\tString gearType; \tint door; }Car(){ //값이 주어지지않는다면 밑의 값으로 초기화\tcolor = \"white\";\tgearType = \"auto\";\tdoor = 4;} Car(String c, String g, int d){color = c;gearType = g;door = d;}↓class Car {\tString color;\tString gearType; \tint door; }Car(){\tthis(\"white\",\"auto\",4)}Car(String c, String g, int d){color = c;gearType = g;door = d;}  참조변수 this -괄호 없음 : 생성자 this랑 아예 관련없음. 연관짓지말것.          인스턴스 자신을 가리키는 참조변수 - 인스턴스 주소가 저장되어있다      인스턴스 메소드에서만 사용가능      모든 인스턴스 메소드에 지역변수로 숨겨진 채로 존재      지역변수와 인스턴스 변수를 구분할 때 사용      Car(String c, String g, int d){\t//color는 iv, c는 lv\tcolor = c;\tgearType = g;\tdoor = d;} //같은 클래스안에서는 생략이 가능하나 이름이 같으면 생략이 안됨//this가 자동으로 생략됨Car(String color, String gearType, int door){\t\tthis.color = color;\t\tthis.door = door;\t\tthis.gearType= gearType;} //this가 붙은건 iv, =뒤에있는건 lv//this가 없다면 iv처리가 됨//이름이 같아서 this 생략이 불가능왼쪽으로 많이 쓰는데, 정석은 오른쪽. 지역변수와 인스턴스 구분할때 정석으로 써주면됨class MyMath3{\tlong a,b;  //this a, this b iv의 진짜 이름\tMyMath(int a, int b){\t\tthis.a = a;\t\tthis.b = b;  //this 생락 불가능. 에러는 안나는데 지역변수가 됨\t}\tlong add(){ //인스턴스 메소드\t\treturn a+b; //return this.a + this.b    this는 생략 가능\t} \tstatic long add(long a, long b){ \t\treturn a+b;  //인스턴스 변수 사용 불가능. static이 있어서. 그래서 this. 사용불가\t}}this는 클래스 메소드나 인스턴스 매소드에서만 사용가능  변수의 초기화                  지역변수는 수동 초기화 해주어야함          class a{  \tint x;  \tint y = x;  //인스턴스 변수          \tvoid Method1(){ //메소드 안이니까 지역변수  \t\tint i;   \t\tint j = i; //에러남. i의 값이 없기때문. 지역변수는 자동으로 0으로 초기화해주지 않음.   \t}  \tvoid Method2(){  \t\tint i=0; //지역변수.   \t\tint j = i;  }                            멤버 변수는 자동 초기화된다                  멤버변수(iv, cv) 초기화          명시적 초기화 - 간단 초기화                  기본형 변수의 초기화 - int a= 0;          참조형 변수의 초기화 - Print p = new Print();)                    초기화 블럭 - 복잡한 초기화                  인스턴스 초기화 : {} (잘안씀)          클래스 초기화 블럭 : static{}                    생성자 - 인스턴스 변수 초기화. 복잡한 초기화에 사용        cv초기화가 먼저되고 iv초기화가 이루어짐. 자동→간단→복잡 초기화      class a {  \tstatic int[] arr = new int[10]  //명시적 초기화    \t  \tstatic { //클래스 초기화 블럭 - 배열 arr을 난수로 채운다  \t\tfor (...............  .....        — 클래스 변수 초기화 시점          클래스 변수 초기화 시점 - 클래스가 처음 로딩될 때 단 한번      인스턴스 변수 초기화 시점 - 객체가 만들어질때      "
  },
  
  {
    "title": "자바의 정석 강의 - 배열",
    "url": "/posts/%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 배열",
    "date": "2022-07-31 00:00:00 +0900",
    





    
    "snippet": "배열 : 같은 타입의 변수를 하나의 묶음으로 다루는 것.      선언 : 배열을 다루기 위한 참조변수의 선언    int[] score; / String[] name; - 자바스타일    int score[]; / String name[]; - c언어 스타일    둘다 가능은 함. 편한걸로 쓸것.    int[] score; score = new i...",
    "content": "배열 : 같은 타입의 변수를 하나의 묶음으로 다루는 것.      선언 : 배열을 다루기 위한 참조변수의 선언    int[] score; / String[] name; - 자바스타일    int score[]; / String name[]; - c언어 스타일    둘다 가능은 함. 편한걸로 쓸것.    int[] score; score = new int [5];    배열은 한번 생성하면 실행하는 동안 그 길이를 바꿀 수 없다. 배열의 길이 - int형 상수      char배열인 경우에만    char charr[] = {’a’,’b’,’c’,’d’}    system.out.println(charr)    으로 출력이 가능함. 다른 경우는 for문 또는 Arrays.toString(배열)을 써야 전체출력할 수 있음.  import java.util.*;public class array {\tpublic static void main(String[] args) {\t\t\t\tint iarr1[] = new int[10];\t\tint iarr2[] = new int[10];\t\tint iarr3[] = {100,95,80,70,60};\t\tchar charr[] = {'a','b','c','d'};\t\t\t\tfor(int i=0;i&lt;iarr1.length;i++) {\t\t\tiarr1[i] = i+1;\t\t}\t\t\t\tfor(int i=0;i&lt;iarr2.length;i++) {\t\t\tiarr2[i] = (int)(Math.random()*10)+1;\t\t}\t\tSystem.out.println(Arrays.toString(iarr1));\t\tSystem.out.println(Arrays.toString(iarr2));\t\tSystem.out.println(Arrays.toString(iarr3));\t\tSystem.out.println(charr);\t}}public class array {\tpublic static void main(String[] args) {\t\tint sum = 0;\t\tfloat avg = 0f;\t\t\t\tint score[] = {100,88,100,100,90};\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tsum += score[i];\t\t}\t\t\t\tavg = (float)sum / score.length;\t\t//\t\tSystem.out.printf(\"총점 : %d%n\", sum);//\t\tSystem.out.printf(\"평균 : %.1f%n\", avg);\t\t\t\tSystem.out.println(\"총점 : \"+sum);\t\tSystem.out.println(\"평균 : \"+avg);\t}}public class array {\tpublic static void main(String[] args) {\t\tint score[] = {79,88,91,33,100,55,95};\t\t\t\tint max = score[0];\t\tint min = score[0];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tif(score[i]&gt;max)\t\t\t\tmax=score[i];\t\t\telse if(score[i]&lt;min)\t\t\t\tmin=score[i];\t\t}\t\t\tSystem.out.println(\"최대값 : \"+max);\t\t\tSystem.out.println(\"최소값 : \"+min);\t\t\t\t}}배열 섞기import java.util.Arrays;public class array {\tpublic static void main(String[] args) {\t\t//배열 섞기\t\tint numarr[]= {0,1,2,3,4,5,6,7,8,9};\t\tSystem.out.println(Arrays.toString(numarr));\t\t\t\tfor(int i=0;i&lt;numarr.length;i++) {\t\t\tint n = (int)(Math.random()*10); //이건 [i]값을 랜덤으로 받는거고 실질적으로 배열값만 섞으니까 중복이 안나옴\t\t\tint tmp = numarr[i];\t\t\tnumarr[i] = numarr[n];\t\t\tnumarr[n]=tmp;\t\t}\t\tSystem.out.println(Arrays.toString(numarr));\t}}import java.util.Arrays;public class array {\tpublic static void main(String[] args) {\t\t\tint numarr[] = new int[45];\t\t\t\tfor(int i=0;i&lt;numarr.length;i++) {\t\t\tnumarr[i] = i+1;\t\t}\t\t\t\tint tmp = 0, n = 0;\t\tfor(int j=0;j&lt;numarr.length;j++) {\t\t\tn = (int)(Math.random()*45); //그냥 랜덤으로 numarr[n]을 구하면 중복값이 나옴\t\t\ttmp = numarr[0];\t\t\tnumarr[0]=numarr[n];\t\t\tnumarr[n]=tmp;\t\t}\t\tfor(int k = 0;k&lt;6;k++) {\t\tSystem.out.println(numarr[k]);\t\t}\t}}      String 배열                  선언  String[] name = new String[3];        String name[] = {”aa”,”bb”,”cc”}                import java.util.Arrays;      public class array {      \tpublic static void main(String[] args) {    \t  \t\tString strarr[]= {\"가위\",\"바위\",\"보\"};  \t\tSystem.out.println(Arrays.toString(strarr));    \t\t    \t\t  \t\tfor(int i = 0; i&lt;10;i++) {  \t\tint tmp = (int)(Math.random()*3);  \t\tSystem.out.println(strarr[tmp]);  \t\t}  \t}  }            커맨드라인을 통해 입력받기    args[]를 통해 입력받기임. cmd통해 입력받기 가능        n차원 배열 : n-1차원 배열이 여러개 모인것 보통 3차원부터는 잘 안쓰임, 표현하기 위해서 n중for문 필요함.                  2차원배열        int score [] [] = new int [4] [3]; = 4행 3열                                                           score[0][0]              score[0][1]              score[0][2]                                                          score[0]              score[0][0]              score[0][1]              score[0][2]                                      score[1]              score[1][0]              score[1][1]              score[1][2]                                      score[2]              score[2][0]              score[2][1]              score[2][2]                                      score[3]              score[3][0]              score[3][1]              score[3][2]                                      int arr[] [] ={ {1,2,3}, {4,5,6}}                    public class array {                \tpublic static void main(String[] args) {        \t        \t\tint score[][] = {        \t\t\t\t{100,100,100},        \t\t\t\t{20,20,20,20,20},        \t\t\t\t{30,30,30},        \t\t\t\t{40,40}        \t\t};        \t\tint sum = 0;        \t\t        \t\tfor(int i = 0; i&lt;score.length;i++) {        \t\t\tfor(int j=0;j&lt;score[i].length;j++) {        \t\t\t\tSystem.out.printf(\"score[%d][%d] = %d%n\",i,j,score[i][j]);        \t\t\t\t        \t\t\t\tsum +=score[i][j];        \t\t\t}        \t\t}        \t\tSystem.out.println(\"sum = \"+sum);        \t}        }        public class array {                \tpublic static void main(String[] args) {        \t        \t\tint score[][] = {        \t\t\t\t{100,100,100},        \t\t\t\t{20,20,20},        \t\t\t\t{30,30,30},        \t\t\t\t{40,40,40},        \t\t\t\t{50,50,50}        \t\t};        \t\tint kortotal = 0, engtotal = 0, mathtotal = 0;        \t\t        \t\tSystem.out.println(\"번호  국어   영어   수학   총점  평균\");        \t\tSystem.out.println(\"=============================\");        \t\t        \t\tfor(int i = 0; i&lt;score.length;i++) {        \t\t\tint sum = 0;        \t\t\tfloat avg = 0.0f;        \t\t\t        \t\t\tkortotal += score[i][0];        \t\t\tengtotal += score[i][1];        \t\t\tmathtotal += score[i][2];        \t\t\tSystem.out.printf(\"%3d\", i+1);        \t\t\tfor(int j=0;j&lt;score[i].length;j++) {        \t\t\t\tsum += score[i][j];        \t\t\t\tSystem.out.printf(\"%5d\",score[i][j]);        \t\t\t}        \t\t\tavg = sum/ (float)score[i].length;        \t\t\tSystem.out.printf(\"   %d %2.1f%n\",sum,avg);        \t\t\t}        \t\t}        \t}        import java.util.*;                public class array {                \tpublic static void main(String[] args) {        \t        \t\tString[][] words = {        \t\t\t{\"chair\", \"의자\"},        \t\t\t{\"computer\",\"컴퓨터\"},        \t\t\t{\"integer\",\"정수\"}        \t\t};        \t\t        \t\tScanner scanner = new Scanner(System.in);        \t\t        \t\tfor(int i =0; i&lt;words.length;i++) {        \t\t\tSystem.out.printf(\"Q%d. %s의 뜻은??\",i+1,words[i][0]);        \t\t\t        \t\t\tString tmp = scanner.nextLine();        \t\t\t        \t\t\tif(tmp.equals(words[i][0])) {        \t\t\t\tSystem.out.printf(\"정답입니다!!%n%n\");        \t\t\t}        \t\t\telse {        \t\t\t\tSystem.out.println(\"틀렸습니다! 정답은 \"+words[i][1]+\"입니다.\");        \t\t\t}        \t\t}        \t}        }  String class = char[] + method : 내용을 변경할 수 없다.(read only)  String a =”a”; String b = “b”; a=a+b; 하면 String a와 a값이 따로 저장됨. 덮어쓰기안됨. 연결은 a랑만 돼서 String a는 못씀    charAt - 원하는 위치의 문자를 가져옴.  substring - 원하는 부분의 문자열을 가져옴(마지막글자 안들고오니까 조심)public class array {\tpublic static void main(String[] args) {\t\t\tString str = \"abcdefg\";\t\tchar ch = str.charAt(2);\t\tSystem.out.println(ch); //c\t\tString str2 = str.substring(1,4);\t\tSystem.out.println(str2); //bcd\t\tString str3 = str.substring(1);\t\tSystem.out.println(str3); //bcdefg\t\t\t}}      arrays(class)로 배열 다루기          equals() : 같은 값 비교      toString()      deepToString : 2차원 이상의 다차원 배열의 출력              deepEquals : 2차원 이상의 배열들끼리 값이 같은지 비교  Arrays.deepEquals(배열1,배열2)                    copyOf() : 배열 복사  Arrays.copyOf(배열,복사할 개수) - 전체복사            copyRange : 배열 원하는부분(from~to)까지 복사. 마지막값(to)복사안됨      sort(배열) : 배열 정렬. 숫자 오름차순 정렬.          import java.util.Arrays;        public class array {        \tpublic static void main(String[] args) {    \t    \t\tint arr[] = {0,1,2,3,4};    \t\tint arr2d[][] = { {11,22}, {21,22} };    \t\t    \t\tSystem.out.println(Arrays.toString(arr));    \t\tSystem.out.println(Arrays.deepToString(arr2d));    \t\t    \t\tString str2d[][] = { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\"} };    \t\tString str2d2[][] = { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\"} };    \t\t    \t\tSystem.out.println(Arrays.deepEquals(str2d, str2d2));    \t\t    \t\tint arr2[] = Arrays.copyOf(arr, arr.length);    \t\tSystem.out.println(Arrays.toString(arr2));    \t\tint arr3[] = Arrays.copyOfRange(arr, 2,4);    \t\tSystem.out.println(Arrays.toString(arr3));    \t\t    \t\tint arr4[] = {0,4,2,1,3};    \t\tSystem.out.println(Arrays.toString(arr4));    \t\tArrays.sort(arr4);    \t\tSystem.out.println(Arrays.toString(arr4));    \t}    }"
  },
  
  {
    "title": "자바의 정석 강의 - 제어문 (flow control statemt)",
    "url": "/posts/%EC%A0%9C%EC%96%B4%EB%AC%B8-(flow-control-statemt)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 제어문",
    "date": "2022-07-30 00:00:00 +0900",
    





    
    "snippet": "  조건문          if문                  switch : 처리해야하는 경우의 수가 많을 때 씀(if-else if문보다 효율적)          switch (조건식) {  \tcase 값1 :   \t\t\t//...  \t\t\tbreak;  \tcase 값2 :   \t\t\t//...  \t\t\tbreak;  \t//...  \tdefault : ...",
    "content": "  조건문          if문                  switch : 처리해야하는 경우의 수가 많을 때 씀(if-else if문보다 효율적)          switch (조건식) {  \tcase 값1 :   \t\t\t//...  \t\t\tbreak;  \tcase 값2 :   \t\t\t//...  \t\t\tbreak;  \t//...  \tdefault :  \t\t//....조건식의 결과와 일치하는 case문이 없을떄  \t\t//....  }                      제약조건\t      - 조건식 결과가 정수 또는 문자열이여야함.      - case문의 값은 정수 상수(문자포함), 문자열만 가능, 중복 금지        import java.util.*;        public class ScanfEx1 {                \tpublic static void main(String[] args) {        \t        \tSystem.out.println(\"현재 월을 입력하세요\");        \t        \tScanner scanner = new Scanner(System.in);        \tint month = scanner.nextInt();        \t        \tswitch (month) {        \t\tcase 3: case 4: case 5:        \t\t\tSystem.out.println(\"현재 계절은 봄입니다.\");        \t\t\tbreak;         \t\tcase 6: case 7:case 8:        \t\t\tSystem.out.println(\"현재 계절은 여름입니다.\");        \t\t\tbreak;        \t\tcase 9: case 10:        \t\t\tSystem.out.println(\"현재 계절은 가을입니다.\");        \t\t\tbreak;        \t\tcase 11: case 12: case 1: case 2:        \t\t\tSystem.out.println(\"현재 계절은 겨울입니다.\");        \t\t\tbreak;        \t\tdefault :        \t\t\tSystem.out.println(\"잘못 입력했습니다.\");        \t\t}        \t}        }— Math.random() : 0.0과 1.0사이의 임의의 double값을 반환0.0 * 3 ≤ Math.random() &lt; 1.0*3  ex)원하는 값 1~3      각변에 3을 곱한다    0.0 * 3 ≤ Math.random() * 3 &lt; 1.0 * 3        각 변을 int형으로 변환한다    (int)0.0 * 3 ≤ (int)(Math.random() * 3) &lt; (int)1.0 * 3    0 ≤ Math.random() * 3 &lt; 3        각 변에 1을 더한다    0 + 1 ≤ (Math.random() * 3) +1 &lt; 3 + 1    1 ≤ (Math.random() * 3) +1 &lt; 4      public class ex4_7 {    \tpublic static void main(String[] args) {    \t\tint num=0;    \t\t//1~10사이의 난수를 20개 출력할 것.    \t\tfor(int i=0;i&lt;=20;i++) {    \t\t\tSystem.out.println((int)(Math.random()*10)+1);    \t\t}    \t\tSystem.out.println(\"===============\");        \t\t\t//-5~5사이의 난수를 20개 출력할 것.    \t\tfor(int j=0;j&lt;=20;j++) {    \t\t\tSystem.out.println((int)(Math.random()*11)-5); //0도 포함이라 값이 11개임    \t\t}    \t}    }  반복문          for          public class ex4_8 {        \tpublic static void main(String[] args) {    \t\tfor(int i=1, j=10;i&lt;=10;i++,j--) {    \t\t\tSystem.out.println(\"i=\"+i+\", j=\"+j);    \t}    \t    \t//구구단    \tfor(int j = 2;j&lt;=9;j++){    \t\tSystem.out.println(j+\"단 시작!!!\");    \t\tfor(int k=1;k&lt;=9;k++) {    \t\t\tSystem.out.println(j+\" * \" +k+\" = \"+j*k);    \t\t\tif(k==9)    \t\t\tSystem.out.println(\"====\"+j+\"단 종료====\\n\");    \t\t}    \t}    \t//별 찍기    \t\tfor(int n=1;n&lt;10;n++) {    \t\t\tfor(int x=1;x&lt;n;x++) {    \t\t\t\tSystem.out.print(\"★\");    \t\t\t}    \t\t\tSystem.out.println();    \t\t}     \t}    }  while - 조건식을 만족시키는 동안 블럭을 반복. do while문을 사용.    public class ex4_13 {        \tpublic static void main(String[] args) {    \t\tint sum=0;    \t\tint i=0;    \t\t    \t\twhile (sum&lt;=100) {    \t\t\tSystem.out.printf(\"%d : %d%n\",i,sum);    \t\t\tsum += ++i;    \t\t}    \t}        }    import java.util.*;        public class Ex4_14 {        \tpublic static void main(String[] args) {    \t\tint num=0, sum = 0;    \t\tSystem.out.println(\"숫자를 입력하세요.\");    \t\t    \t\tScanner scanner = new Scanner(System.in);    \t\tString tmp = scanner.nextLine();    \t\tnum = Integer.parseInt(tmp);    \t\t    \t\twhile (num != 0) {    \t\t\tsum += num%10;    \t\t\tSystem.out.printf(\"sum = %d num = %d%n\",sum,num);    \t\t\t    \t\t\tnum /= 10;    \t\t}    \t\tSystem.out.println(\"각 자리수의 합 : \"+sum);    \t\t    \t\tint sum2 = 0;    \t\tfor(num = Integer.parseInt(tmp);num&gt;0;num = num / 10)    \t\t{    \t\t\tsum2 += num%10;    \t\t\tSystem.out.printf(\"sum = %d num = %d%n\",sum2,num);    \t\t}    \t\tSystem.out.println(\"각 자리수의 합 : \"+sum2);    \t}        }  do while : 반복횟수를 알거나 코드가 중복이면 do while문을 사용  do{조건식이 참일 때 수행 될 문장. 처음 한번든 무조건 실행}  while(조건식);    import java.util.*;        public class ex4_15 {        \tpublic static void main(String[] args) {    \t\tint input = 0 , answer = 0;    \t\t    \t\tanswer = (int)(Math.random()*100)+1;    \t\tScanner scanner = new Scanner(System.in);    \t\t    \t\tdo {    \t\t\tSystem.out.println(\"1과 100사이의 정수를 입력하세요.&gt;&gt;\");    \t\t\tinput = scanner.nextInt();    \t\t\t    \t\t\tif (input &gt; answer) {    \t\t\t\tSystem.out.println(\"더 작은 수로 다시 시도하세요.\");    \t\t\t}    \t\t\telse if (input &lt; answer) {    \t\t\t\tSystem.out.println(\"더 큰 수로 다시 시도하세요.\");    \t\t\t}    \t\t} while (input != answer);    \t\t\tSystem.out.println(\"정답입니다!\");    \t\t}    \t}    public class ex4_16 {        \tpublic static void main(String[] args) {    \t\tint i = 0, sum = 0;    \t\t    \t\tdo {    \t\t\t++i;    \t\t\tsum += i;    \t\t} while(sum&lt;100);    \t\tSystem.out.println(\"i=\"+i);    \t\tSystem.out.println(\"sum=\"+sum);    \t}        }    public class ex4_16 {        \tpublic static void main(String[] args) {    \t\tint i = 0, sum = 0;    \t\t    \t\twhile (true) {    \t\t\tif(sum&gt;100)    \t\t\t\tbreak;    \t\t\t++i;    \t\t\tsum += i;    \t\t}    \t\tSystem.out.println(\"i=\"+i);    \t\tSystem.out.println(\"sum=\"+sum);    \t}        }  continue : 조건이 충족된다면 블록의 끝으로 이동, 다시 반복문 수행.public class ex4_17 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;=10;i++) {\t\t\tif(i%2==0)\t\t\t\tcontinue;\t\t\tSystem.out.println(i);\t\t}\t}}  이름붙은 반복문 : 반복문에 이름을 붙여서 break앞에 적어주면 하나이상의 반복문을 벗어날 수 있다Loop1 : for( ......\tfor( ...........\t\t\t\tbreak Loop1;import java.util.*;public class ex4_18 {\tpublic static void main(String[] args) {\t\tint menu = 0;\t\tint num = 0;\t\t\t\tScanner scanner = new Scanner(System.in);\t\t\t\touter : while (true) {\t\t\tSystem.out.println(\"(1) square\");\t\t\tSystem.out.println(\"(2) square root\");\t\t\tSystem.out.println(\"(3) log\");\t\t\tSystem.out.println(\"원하는 메뉴를 입력하세요. (종료 : 0)\");\t\t\t\t\t\tString tmp = scanner.nextLine();\t\t\tmenu = Integer.parseInt(tmp);\t\t\t\t\t\tif(menu == 0) {\t\t\t\tSystem.out.println(\"프로그램을 종료합니다.\");\t\t\t\tbreak;\t\t\t}\t\t\telse if (!(menu&gt;=1 &amp;&amp; menu&lt;=3)) {\t\t\t\tSystem.out.println(\"메뉴를 잘못 선택하셨습니다. (종료는 0)\");\t\t\t\tcontinue;\t\t\t}\t\t\tSystem.out.println(\"선택하신 메뉴는 \"+menu+\"번입니다.\");\t\t\t\t\t\tfor(;;) {\t\t\t\tSystem.out.println(\"계산할 값을 입력하세요.(계산종료 : 0, 전체종료 : 99)&gt;&gt;\");\t\t\t\ttmp = scanner.nextLine();\t\t\t\tnum = Integer.parseInt(tmp);\t\t\t\t\t\t\t\tif(num==0)\t\t\t\t\tbreak;\t\t\t\tif(num==99)\t\t\t\t\tbreak outer;\t\t\t\t\t\t\t\tswitch(menu) {\t\t\t\t\tcase 1:\t\t\t\t\t\tSystem.out.println(\"result=\"+num*num);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 2:\t\t\t\t\t\tSystem.out.println(\"result=\"+Math.sqrt(num)); //제곱근\t\t\t\t\t\tbreak;\t\t\t\t\tcase 3:\t\t\t\t\t\tSystem.out.println(\"result=\"+Math.log(num)); //로그\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - 연산자(Operator)",
    "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90(Operator)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연산자",
    "date": "2022-07-30 00:00:00 +0900",
    





    
    "snippet": "연산자 : 연산을 수행하는 기호 (+,-,*,/)피연산자 : 연산자의 수행 대상(x+3에서 x와 3)                                             종류      연산자      설명              산술 연산자      + - * / % ==« »==      사칙연산과 나머지 연산              비교...",
    "content": "연산자 : 연산을 수행하는 기호 (+,-,*,/)피연산자 : 연산자의 수행 대상(x+3에서 x와 3)                                             종류      연산자      설명              산술 연산자      + - * / % ==« »==      사칙연산과 나머지 연산              비교 연산자      &lt; &gt; ≥ ≤ == !=      크고 작음과 같고 다름을 비교              논리 연산자      &amp;&amp; | !(not)      and와 or으로 조건을 연결              대입 연산자      =      우변의 값을 좌변에 저장              기타      (type) ?: instanceof      형변환 연산자, 삼항 연산자, instanceof 연산자        증감 연산자          j = ++i : 값이 참조 되기 전에 증가시 = 일단 i+1하고 i값으로 할거 함      j = i++ : 값이 참조 된 후에 증가시킴 = i값으로 할거 다하고 +1      i++, ++i처럼 독립적으로 쓰였을때는 차이가 없음            형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것.    double d= 85.5; int score = (int)d; //85    ❗반올림 안됨! 그냥 버림!!실수→정수는 모두 그럼          자동 형변환 : 서로 다른 두 타입을 일치시킬깨 형변환을 생략하면 대부분 컴파일러가 알아서 형변환을 자동적으로 한다.                  생략 가능                          float f = 1234; == float f = (float)1234; //컴파일러가 자동으로 형변환. 두개가 같은거임.              byte - int는 int값이 byte타입의 범위 -128~127사이의 값이라면 값 손실이 없기 때문에 예외적으로 가능.  int i = 100; byte b = i ; 는 에러남. 변수값이라 값손실이 없음을 확신할 수 없기 때문.                                생략 불가능                                          int i = 3.14f; //에러남. float가 int보다 크기때문에 값손실이 발생됨.  int i = (int)3.14f로 써줘야함.                                            short - char끼리 자동 형변환 불가능. short가 부호있는 연산자라서. chat - int변환은 가능                                                              산술 변환 : 연산 전에 피연산자의 자동으로 타입을 일치시키는 것.          두 피연산자의 타입을 큰 타입으로 일치시킴              int보다 작은 타입이면 int로 변환된다.  byte + short = int / char + short = int        ‘2’ - ‘0’ = 2 (문자 2의 코드가 50이고 문자 0의 코드가 48이라서. 문자코드가 순서대로 1씩 증가해서 문자끼리 식은 일반 식과 결과값이 같음 )                public class ScanfEx1 {  \tpublic static void main(String[] args) {  \t\tint a = 1_000_000;  \t\tint b = 2_000_000;    \t\t  \t\tlong c = (long)a*b;  \t\tSystem.out.println(c);  \t}  }            반올림 - Math.round - 실수를 소수 첫째 자리에서 반올림  Math.round(4.52) = 5  —n의 자리까지 반올림을 해주려면?    Math.round(Math.PI*1000.0)/1000.0); → 3.142 이렇게 10의 n제곱을 곱하고 나눠줌    equals();String str1 = \"abc\";String str2 = \"abc\";system.out.println(str1==str삼2); //값의 위치가 같음String str3 = new String(\"abc\");String str4 = new String(\"abc\");system.out.println(str3.equals(str4); //인스턴스라서 값을 복제해와서 값의 위치가 다름!!      조건 연산자 ? : 조건식의 결과에 따라 연산결과를 달리한다.    조건식 ? 식1 : 식2 //조건식이 참이면 식1 거짓이면 식2    result = (x&gt;y) ? x : y ; //괄호 생략가능    if문을 간단하게 쓸 수 있는 장점이 있음!!        대입 연산자          lvalue : 왼쪽 피연산자, 저장공간 3, i+3같은 값이 오거나 final을 붙여 상수가 되면 에러남      rvalue : 오른쪽 피연산자      !(not)은 가독성에 안좋으니 가급적 쓰지말것 쓸거면 처음부터 쓰기. 중간부터 쓰면 알아보기 힘들어짐"
  },
  
  {
    "title": "자바의 정석 강의 - 변수(Variable)",
    "url": "/posts/%EB%B3%80%EC%88%98(Variable)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 변수",
    "date": "2022-07-29 06:27:00 +0900",
    





    
    "snippet": "  system.out.println(); 에서 print==ln==이 \\n이거라서 따로 \\n안해줘도 지금까지 줄바꿈이 됐던거임..! 충격! pintf도 있다..!      public class Ex2_1 {      \tpublic static void main(String[] args) {  \t\tSystem.out.printf(\"hello\");  ...",
    "content": "  system.out.println(); 에서 print==ln==이 \\n이거라서 따로 \\n안해줘도 지금까지 줄바꿈이 됐던거임..! 충격! pintf도 있다..!      public class Ex2_1 {      \tpublic static void main(String[] args) {  \t\tSystem.out.printf(\"hello\");  \t\tSystem.out.printf(\"hello\");  \t\tSystem.out.printf(\"hello\");  \t}      }        이거는 줄바꿈 안되고 hellohellohello로 실행됨. print로 바꿔도 마찬가지    변수(variable) : 하나의 값을 저장할 수 있는 메모리 공간(RAM). 변경가능  — 변수 선언 이유 : 값(data)를 저장할 수 있는 공간을 마련하기 위해.      변수타입 변수이름; ex)int age;                  =는 등호가 아니라 대입. 그래서 if문에서는 == 를 썼구나  int x=0; 변수 x를 선언 후 0으로 초기화  int y=5; 변수 y를 선언 후 5로 초기화        ❗지역변수는 읽기전에 꼭 초기화를 해주어야 함            변수 타입                  기본형(Primitive type) - 8개                          정수 :                                  int                  byte : 0~127, 이진데이터를 다루는데 사용                  short : c언어와의 호환을 위해 사용. 잘안쓰임                  long : int에 못넣는 20억이 넘는 값을 넣음                                            문자 : char (한글자) - 빈문자(’’;)불가능              문자열 : String (여러글자) -                                                      빈문자(””;) 가능  ⇒ “”+7 = “7” : 숫자 7이 문자열로 변환됨.  ex) “”+7+7 = “7”+7→”7”+”7”⇒ “77”  7+7+”” = 14+””→”14”+””⇒”14”                                                        class이나 너무 자주 쓰여서 String s1 = “ab”; 로 사용가능                                                              실수 (소수점) : double, float              논리(boolean) : true, false. 조선식과 논리적 계산에 사용                                                                        종류/크기                  1byte                  2byte                  4byte                  8byte                                                                              논리형                  boolean                                                                                                           문자형                                     char                                                                                        정수형                  byte                  short                  int                  long                                                  실수형                                                        float                  double                                                      n비트로 표현할 수 있는 값의 개수 : 2의 n제곱            n비트로 표현할 수 있는 부호없는 정수의 범위 : 0~2의n제곱-1            n비트로 표현할 수 있는 부호있는 정수의 범위 : -2의 n-1제곱 ~2의 n-1제곱-1                          부호비트 (sign bit)                                                      byte = -2의 7제곱~ 2의 7제곱 -1 =                                                                                            0                          7bit                                                                                      부호비트가 0이니까 양수                                                                                            1                          7bit                                                                                      부호비트가 1이니까 음수                                                        short = -2의 15제곱~ 2의 15제곱 -1 =                                                                                            s                          15bit                                                                                                                          char = 0~2의 16제곱 -1 (2진수로 변환)                                                                                            16bit                          160000000001000001                                                                                                                          int = -2의 31제곱~ 2의 31제곱 -1 = -20억~20억                                                                                            s                          31bit                                                                                                                          int = -2의 63제곱~ 2의 63제곱 -1 = -800경 ~ 800경                                                                                            s                          63bit                                                                                      혹시 부족하면 Big integer사용                                                        float = 1+8+23 = 32bit = 4byte = -1.410의 -45제곱~1.410의 -45제곱                                                                                            S                          E(8)                          M(23)                                                                                      정밀도 : 7자리                                                        double = 1+11+52 = 64bit = 8byte = -3.410의 38제곱~3.410의 38제곱                                                                                            S                          E(11)                          M(50)                                                                                      정밀도 : 15자리 (float보다 정확함)                                                                                            참조형(Reference type) : 기본형을 제외한 나머지. 무한개                          메모리주소를 저장. (4byte[40억] or 8 byte[160억])                        ex) today = new Date(); - 참조형 변수 today에 객체의 주소를 저장                              리터럴 (literal) : 그 자체로 값을 의미. 기존의 상수.                              리터럴 타입과 접미사                                                            종류                  리터럴                  접미사                                                                              논리형                  false, true                  없음                                                  정수형                  int - 123, Ob0101, 077, 0xFF,  Long - 100L                  L                                                  실수형                  3.14, 3.0e8, 1.4f, 0x1.0p-1                  f(float),  d(double, 생략가능)                                                  문자형                  ‘A’, ‘1’, ’\\n’                  없음                                                  문자열                  “ABC”, “123”, “A”, “true”                  없음                                                      정수형, 실수형은 접미사로 구분함.                                          int oct = 010;            \t\tint hex = 0x10;            \t\t            \t\tSystem.out.println(oct);            \t\tSystem.out.println(hex);            // println을 쓰면 8진수와 16진수를 표현못해서 8과 16이 나옴.            // printf를 쓰면 가능  10진수 : int i = 100;  8진수 : int i = 0100;  16진수 : int i = 0x100;  long i = 10_000_000_000L ⇒ 100억. int가 20억까지 가능함. 꼭 L붙일것.  1e3 = 여기서 e가 10의 n제곱임. = 1000.0 (접미사 없으니 double형)  int i = ‘A’; ⇒ A의 문자열코드인 65가 출력됨  상수(constant) : 한 번만 값을 저장 가능한 변수. 변경 불가능. 앞에 final을 붙이면 됨.ex) final int MAX = 100;MAX = 200;(에러남)&lt;/mark&gt;\tint score = 100;\tscore = 200;\tfinal int MAX = 100;\tchar ch = 'a';\tString str = \"abc\";— 변수와 리터럴 타입 불일치  범위가 변수&gt;리터럴 인 경우 가능함          int &gt; char / long &gt; int / double &gt; float        범위가 변수 &lt; 리터럴 인 경우 에러남          long i = 3.14f - long&lt;float이라 에러      float f = 3.14 (접미사 생략됐으니 double형) 에러. float &lt; double  double d = 3.14f ⇒ 가능      byte, short변수에 int 리터럴 사용 가능        두 변수 값 교환하는 법      int x = 10, y = 20;  int tmp;//빈공간  x=tmp;  x=y;  y=tmp;      pritnln 단점  출력형식 지정 불가 (ex.소수점 자리지정 불가)  10진수로만 출력됨⇒ printf를 사용하면 가능해짐            지시자      설명                  %b      boolean 형식으로 출력              %d      10진 정수의 형식으로 출력              %o      8진 정수의 형식으로 출력  #을 붙여야 접두사도 출력됨              %x, %X      16진 정수의 형식으로 출력  #을 붙여야 접두사도 출력됨              %f      부동 소수점의 형식으로 출력  %g를 사용하면 간략하게 출력              %e, %E (1.234e+02)      지수 표현식의 형식으로 출력              %c      문자로 출력              %s      문자열로 출력      ❗\\n, %n 둘다 줄바꿈이나 %n을 자주 사용할 것.      지시자    system.out.printf(”[%5d]%n”, 10); // [ 10] - 5자리 출력    system.out.printf(”[%-5d]%n”, 10); // [10 ] - 5자리 출력, 왼쪽정렬    system.out.printf(”[%05d]%n”, 10); // [00010] - 5자리 출력(숫자, 문자열 다 됨)    system.out.printf(”[%5d]%n”, 1234567); // [1234567] - 7자리 출력    system.out.printf(“[%14.10f]%n”, 1.23456789); // [ 1.2345678900]   (전체자리 14자리에서 소수점 10자리 출력)  화면으로 입력받기부터 - Scanner : 화면으로부터 데이터를 입력받는 class  import문 필수 - import java.util.*;  Scanner 객체의 생성 Scanner scanner = new Scanner system.in;  Scanner 객체의 사용          int num = scanner.nextInt(); //화면에서 입력받은 정수를 num에 저장      String input = scanner.nextLine(); //화면에서 입력받은 내용을 input에 저장  int num = Integer.parseInt(input); //문자열(input)을 숫자(num)으로 전환                  숫자 → 문자열 = 숫자 + “”          문자열 → 숫자 = Integer.parseInt(”문자열”)  — 한 문장에 여러 값을 받을경우 필요함                    \timport java.util.*;\t\tpublic class ScanfEx1 {\t\t\tpublic static void main(String[] args) {\t\t\t\t//정수\t\t\tScanner scanner = new Scanner(System.in);\t\t\tint num = scanner.nextInt();\t\t\tSystem.out.println(num);\t\t\t\t\t\t//문자열\t\t\tScanner scanner2 = new Scanner(System.in);\t\t\tString input = scanner2.nextLine();\t\t\tSystem.out.println(input);\t\t\t\t\t\t//문자열 -&gt; 숫자\t\t\tScanner scanner3 = new Scanner(System.in);\t\t\tString input2 = scanner3.nextLine();\t\t\tint num2 = Integer.parseInt(input2);\t\t\tSystem.out.println(input2);\t\t}\t}❗Scanner밑에 밑줄은 입출력 관련 객체들은 원칙적으로 반드시 닫아주어야함. 하지만 화면입력같은경우에는 자바 버추얼머신에서 기본적으로 관리가 되기때문에 닫아주지 않아도 됨. 오류는 무시할 것.오버플로우 : 표현할 수 있는 범위를 넘어섰다.최대값 + 1 = 최소값최소값 - 1 = 최대값10진수 :9999→0000 (칸이 4칸이라서)부호없는 정수 : ex) 4bit (표현범위0~15)15(최대값) + 1 → 0(최소값)2진수 : 1111→0000부호있는 정수 : ex) 4bit (표현범위-8~7)7(최대값)+1 → -8(최소값)부호 없는 정수 : 부호 +나-가 존재하지 않는 숫자 세계를 나타냄.(0이하의 음수를 표현x)부호 있는 정수 : 양수타입간의 변환 방법 - 외우지는 못해도 필요할때 찾아볼 수 있는 정도는 돼야함  문자 → 숫자 = 3 - ’0’  숫자 → 문자 = 3 + ’0’  문자→ 문자열 = ‘3’ + “”  문자열 → 문자 = “3”.charAt(0)  숫자 → 문자열 = 3 + ””  문자열 → 숫자  = Integer.parseInt(”3”)  = Double.parseDouble(”3.4”)\timport java.util.*;\t\tpublic class ScanfEx1 {\t\t\tpublic static void main(String[] args) {\t\t\tString str = \"3\";\t\t\tSystem.out.println(str.charAt(0)); //문자열 -&gt; 문자\t\t\tSystem.out.println('3' - '0' + 1); //문자-&gt;숫자\t\t\tSystem.out.println(Integer.parseInt(\"3\")+1); //문자열 -&gt; 숫자\t\t\tSystem.out.println(\"3\"+1); //문자열+숫자 =&gt; 31\t\t\tSystem.out.println(3+'0'); //문자 0은 숫자로 48 =&gt; 51\t\t\tSystem.out.println((char)(3+'0')); // 문자 '3' 출력\t\t}\t}printf사용시 %#x는 접두사 0x가 붙음"
  },
  
  {
    "title": "자바의 정석 강의 - 자바 시작하기 전",
    "url": "/posts/%EC%9E%90%EB%B0%94-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-07-28 21:27:00 +0900",
    





    
    "snippet": "  자바 : 프로그래밍 언어. 컴퓨터 프로그램(애플리케이션)을 만드는데 사용  실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)                  라이브러리 : 프로그램을 만드는데 필요한 기능들을 미리 만들어놓은 것.        ⇒ 쉽고 빠른 개발 가능            pc애플리케이션, 웹 애플리케이션, 모바일 애플리케이...",
    "content": "  자바 : 프로그래밍 언어. 컴퓨터 프로그램(애플리케이션)을 만드는데 사용  실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)                  라이브러리 : 프로그램을 만드는데 필요한 기능들을 미리 만들어놓은 것.        ⇒ 쉽고 빠른 개발 가능            pc애플리케이션, 웹 애플리케이션, 모바일 애플리케이션(안드로이드), 빅 데이터, 게임(ex.마크), 과학, 소형기기 등 에 활용 가능      모던 프로그래밍 언어(객체지향 + 함수형)      특징                  배우기쉬운 객체지향언어(프로그래밍언어+객체지향개념[c++,java,python])          자동 메모리 관리          멀티 쓰레드 지원 - 하나의 프로그램에서 동시에 여러작업 가능.          풍부한 라이브러리로 쉽게 개발가능.          운영체제에 독립적 - 수정없이 여러 운영체제에서 사용가능                          자바 가상 머신(JVM) : 자바 프로그램이 실행되는 가상 컴퓨터(VM). 한번 작성하면, 어디서든(어떤 운영체제에서도) 실행 가능.                                            java API문서 : java API가 제공하는 기능에 대한 상세한 정보를 제공(html)  https://docs.oracle.com/javase/7/docs/api/index.html      단축키          ctrl + shift + L : 단축키 전체 목록      alt + shift + A : 멀티컬럼 편집 - 커서가 +모양으로 바뀌는데 바꾸고 싶은 부분을 드래그해서 한번에 바꿈      ctrl + i : 자동들여쓰기      ctrl + shift + o : import java.util.~; 자동추가      "
  }
  
]

