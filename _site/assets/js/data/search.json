[
  
  {
    "title": "[김영한 스프링 MVC 1] 상품 도메인 개발",
    "url": "/posts/%EC%83%81%ED%92%88%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B0%9C%EB%B0%9C/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1, 타임리프",
    "date": "2023-08-05 00:00:00 +0900",
    





    
    "snippet": "  entity```javapackage hello.itemservice.domain.item;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;@Getter@Setter@AllArgsConstructor@NoA...",
    "content": "  entity```javapackage hello.itemservice.domain.item;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Item {\tprivate Long id;\tprivate String itemName;\tprivate Integer price;\tprivate Integer quantity;}- repository```javapackage hello.itemservice.domain.item;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.springframework.stereotype.Repository;@Repositorypublic class ItemRepository {\tprivate static final Map&lt;Long, Item&gt; store = new HashMap&lt;&gt;();\tprivate static Long seq = 0L;\tpublic Item save(Item item) {\t\titem.setId(++seq);\t\tstore.put(item.getId(), item);\t\treturn item;\t}\tpublic Item findById(Long id) {\t\treturn store.get(id);\t}\tpublic List&lt;Item&gt; findAll() {\t\treturn new ArrayList&lt;&gt;(store.values());\t\t//반환타입을 Collection으로 해서 store.values(); 해도되는데 원본 훼손방지를 위해 감쌈\t}\tpublic void update(Long itemId, Item updateParam) {\t\tItem findItem = findById(itemId);\t\tfindItem.setItemName(updateParam.getItemName());\t\tfindItem.setPrice(updateParam.getPrice());\t\tfindItem.setQuantity(updateParam.getQuantity());\t}\tpublic void clearStore() {\t\tstore.clear();\t}}실무에선 HashMap말고 ConcurrnetHashMap써야한다고함. 멀티쓰레드 환경에서 사용가능함  [!important]정적 리소스가 공개되는 /resource/static 폴더에 HTML을 넣어두면 실제 서비스에도 공개됨. 서비스를 운영할때는 공개할 필요없는 HTML을 두는것을 주의타임리프  상품 목록package hello.itemservice.web.basic;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import hello.itemservice.domain.item.Item;import hello.itemservice.domain.item.ItemRepository;import jakarta.annotation.PostConstruct;import lombok.RequiredArgsConstructor;@Controller@RequestMapping(\"/basic/items\")@RequiredArgsConstructorpublic class BasicItemController {\tprivate final ItemRepository itemRepository;\t@GetMapping\tpublic String item(Model model) {\t\tList&lt;Item&gt; all = itemRepository.findAll();\t\tmodel.addAttribute(\"items\", all);\t\treturn \"/basic/items\";\t}\t\t@PostConstruct\tpublic void init() {\t\titemRepository.save(new Item(null, \"ItemA\", 1000, 10));\t\titemRepository.save(new Item(null, \"ItemB\", 2000, 30));\t}}&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;link th:href=\"@{/css/bootstrap.min.css}\"            href=\"../css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\" style=\"max-width: 600px\"&gt;    &lt;div class=\"py-5 text-center\"&gt;        &lt;h2&gt;상품 목록&lt;/h2&gt; &lt;/div&gt;    &lt;div class=\"row\"&gt;        &lt;div class=\"col\"&gt;            &lt;button class=\"btn btn-primary float-end\"                    onclick=\"location.href='addForm.html'\"                    type=\"button\"&gt;상품                등록&lt;/button&gt; &lt;/div&gt;    &lt;/div&gt;    &lt;hr class=\"my-4\"&gt;    &lt;div&gt;        &lt;table class=\"table\"&gt;            &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;ID&lt;/th&gt;                 &lt;th&gt;상품명&lt;/th&gt; &lt;th&gt;가격&lt;/th&gt; &lt;th&gt;수량&lt;/th&gt;            &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;            &lt;tr th:each=\"item : ${items}\"&gt;                &lt;td&gt;&lt;a th:href=\"@{/basic/items/{itemId}(itemId=${item.id})}\" th:text=\"${item.id}\"&gt;회원ID&lt;/a&gt;&lt;/td&gt;                &lt;td&gt;&lt;a th:href=\"@{/basic/items/{itemId}(itemId=${item.id})}\" th:text=\"${item.itemName}\"&gt;상품명&lt;/a&gt;&lt;/td&gt;                &lt;td&gt;&lt;a th:href=\"@{/basic/items/{itemId}(itemId=${item.id})}\" th:text=\"${item.price}\"&gt;가격&lt;/a&gt;&lt;/td&gt;                &lt;td&gt;&lt;a th:href=\"@{/basic/items/{itemId}(itemId=${item.id})}\" th:text=\"${item.quantity}\"&gt;수량&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/div&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt;동적 페이지 생성  [!important]리터럴 대체 - |…||…| :\t이렇게 사용한다.타임리프에서 문자와 표현식 등은 분리되어 있기 때문에 더해서 사용해야 한다.&lt; span th:text=\"'Welcome to our application, ' + ${user.name} + '!'\" &gt;다음과 같이 리터럴 대체 문법을 사용하면, 더하기 없이 편리하게 사용할 수 있다.&lt; span th:text=\"|Welcome to our application, ${user.name}!|\" &gt;  상품 상세@GetMapping(\"/{itemId}\")\tpublic String item(@PathVariable Long itemId, Model model) {\t\tItem item = itemRepository.findById(itemId);\t\tmodel.addAttribute(\"item\", item);\t\treturn \"/basic/item\";\t}&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;link th:href=\"@{/css/bootstrap.min.css}\"          href=\"../css/bootstrap.min.css\" rel=\"stylesheet\"&gt;    &lt;style&gt;        .container {            max-width: 560px;        } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt;    &lt;div class=\"py-5 text-center\"&gt;        &lt;h2&gt;상품 상세&lt;/h2&gt; &lt;/div&gt;    &lt;div&gt;        &lt;label for=\"itemId\"&gt;상품 ID&lt;/label&gt;        &lt;input type=\"text\" id=\"itemId\" name=\"itemId\" class=\"form-control\"               th:value=\"${item.id}\" readonly&gt;    &lt;/div&gt; &lt;div&gt;    &lt;label for=\"itemName\"&gt;상품명&lt;/label&gt;    &lt;input type=\"text\" id=\"itemName\" name=\"itemName\" class=\"form-control\"           th:value=\"${item.itemName}\" readonly&gt; &lt;/div&gt;    &lt;div&gt;        &lt;label for=\"price\"&gt;가격&lt;/label&gt;        &lt;input type=\"text\" id=\"price\" name=\"price\" class=\"form-control\"               th:value=\"${item.price}\" readonly&gt;    &lt;/div&gt; &lt;div&gt;    &lt;label for=\"quantity\"&gt;수량&lt;/label&gt;    &lt;input type=\"text\" id=\"quantity\" name=\"quantity\" class=\"form-control\"           th:value=\"${item.quantity}\" readonly&gt;&lt;/div&gt;    &lt;hr class=\"my-4\"&gt;    &lt;div class=\"col\"&gt;        &lt;button class=\"w-100 btn btn-primary btn-lg\"                onclick=\"location.href='editForm.html'\"                th:onclick=\"|location.href='@{/basic/items/{itemId}/ edit(itemId=${item.id})}'|\" type=\"button\"&gt;상품 수정&lt;/button&gt;    &lt;/div&gt;    &lt;div class=\"col\"&gt;        &lt;button class=\"w-100 btn btn-secondary btn-lg\"                onclick=\"location.href='items.html'\"                th:onclick=\"|location.href='@{/basic/items}'|\" type=\"button\"&gt;목록으로&lt;/button&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt;  상품등록// @PostMapping(\"/add\")\t// public String save(@RequestParam String itemName, @RequestParam Integer price, @RequestParam Integer quantity, Model model) {\t// \tItem save = itemRepository.save(new Item(null, itemName, price, quantity));\t// \tmodel.addAttribute(\"item\", save);\t// \treturn \"/basic/item\";\t// }\t@PostMapping(\"/add\")\tpublic String save(@ModelAttribute(\"item\")/*Model에 item으로 값 들어감*/ Item item) {\t\titemRepository.save(item);\t\treturn \"/basic/item\";\t}&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;link th:href=\"@{/css/bootstrap.min.css}\"          href=\"../css/bootstrap.min.css\" rel=\"stylesheet\"&gt;    &lt;style&gt;        .container {            max-width: 560px;        } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt;    &lt;div class=\"py-5 text-center\"&gt; &lt;h2&gt;상품 등록 폼&lt;/h2&gt;    &lt;/div&gt;    &lt;h4 class=\"mb-3\"&gt;상품 입력&lt;/h4&gt;    &lt;form action=\"item.html\" th:action method=\"post\"&gt;        &lt;div&gt;            &lt;label for=\"itemName\"&gt;상품명&lt;/label&gt;            &lt;input type=\"text\" id=\"itemName\" name=\"itemName\" class=\"form-control\" placeholder=\"이름을 입력하세요\"&gt; &lt;/div&gt;        &lt;div&gt;            &lt;label for=\"price\"&gt;가격&lt;/label&gt;            &lt;input type=\"text\" id=\"price\" name=\"price\" class=\"form-control\" placeholder=\"가격을 입력하세요\"&gt;        &lt;/div&gt; &lt;div&gt;        &lt;label for=\"quantity\"&gt;수량&lt;/label&gt;        &lt;input type=\"text\" id=\"quantity\" name=\"quantity\" class=\"form-control\" placeholder=\"수량을 입력하세요\"&gt; &lt;/div&gt;        &lt;hr class=\"my-4\"&gt;        &lt;div class=\"row\"&gt;            &lt;div class=\"col\"&gt;                &lt;button class=\"w-100 btn btn-primary btn-lg\" type=\"submit\"&gt;상품                    등록&lt;/button&gt; &lt;/div&gt;            &lt;div class=\"col\"&gt;                &lt;button class=\"w-100 btn btn-secondary btn-lg\"                        onclick=\"location.href='items.html'\"        th:onclick=\"|location.href='@{/basic/items}'|\" type=\"button\"&gt;취소&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt;그런데 이 구조는 상품 등록 후 새로고침 시 중복등록된다는 큰 문제가있음!!새로고침은 마지막에 서버에 전송한 데이터를 다시 전송해서 마지막 작업이었던 등록 작업을 재실행한거임!그래서 저장 후 새로 저장한 객체의 id로 redirect를 해줘야함! → 마지막 작업이 GET요청으로 변경됨@PostMapping(\"/add\")\tpublic String save(@ModelAttribute(\"item\")/*Model에 item으로 값 들어감*/ Item item) {\t\titemRepository.save(item);\t\treturn \"redirect:/basic/items/\"+item.getId();\t}이렇게 바껴야함그런데 이렇게되면 id에 url로 들어올수 없는 값이(ex:띄어쓰기 등)들어오면 에러가 날거임RedirectAttributes을 사용하면 해결 가능!!@PostMapping(\"/add\")\tpublic String save(@ModelAttribute(\"item\") Item item, RedirectAttributes redirectAttributes) {\t\tredirectAttributes.addAttribute(\"itemId\", item.getId());\t\tredirectAttributes.addAttribute(\"status\", true); //저장 결과 -&gt; 성공\t\titemRepository.save(item);\t\treturn \"redirect:/basic/items/{itemId}\";\t\t// 남는 애들은 쿼리파라미터 형태로 전달됨 (url에 ?status=true)\t}  상품 수정@GetMapping(\"/{itemId}/edit\")\tpublic String editForm(@PathVariable Long itemId, Model model) {\t\tItem item = itemRepository.findById(itemId);\t\tmodel.addAttribute(\"item\", item);\t\treturn \"basic/editForm\";\t}\t@PostMapping(\"/{itemId}/edit\")\tpublic String edit(@PathVariable Long itemId, @ModelAttribute Item item) {\t\titemRepository.update(itemId, item);\t\treturn \"redirect:/basic/items/{itemId}\";\t}&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;link href=\"../css/bootstrap.min.css\"          th:href=\"@{/css/bootstrap.min.css}\" rel=\"stylesheet\"&gt;    &lt;style&gt;        .container {            max-width: 560px;        } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt;    &lt;div class=\"py-5 text-center\"&gt; &lt;h2&gt;상품 수정 폼&lt;/h2&gt;    &lt;/div&gt;    &lt;form action=\"item.html\" th:action method=\"post\"&gt;        &lt;div&gt;            &lt;label for=\"id\"&gt;상품 ID&lt;/label&gt;            &lt;input type=\"text\" id=\"id\" name=\"id\" class=\"form-control\" value=\"1\"                   th:value=\"${item.id}\" readonly&gt;        &lt;/div&gt; &lt;div&gt;        &lt;label for=\"itemName\"&gt;상품명&lt;/label&gt;        &lt;input type=\"text\" id=\"itemName\" name=\"itemName\" class=\"form-control\" value=\"상품A\" th:value=\"${item.itemName}\"&gt; &lt;/div&gt;        &lt;div&gt;            &lt;label for=\"price\"&gt;가격&lt;/label&gt;            &lt;input type=\"text\" id=\"price\" name=\"price\" class=\"form-control\"                   th:value=\"${item.price}\"&gt;        &lt;/div&gt; &lt;div&gt;        &lt;label for=\"quantity\"&gt;수량&lt;/label&gt;        &lt;input type=\"text\" id=\"quantity\" name=\"quantity\" class=\"form-control\" th:value=\"${item.quantity}\"&gt;    &lt;/div&gt;        &lt;hr class=\"my-4\"&gt;        &lt;div class=\"row\"&gt;            &lt;div class=\"col\"&gt;                &lt;button class=\"w-100 btn btn-primary btn-lg\" type=\"submit\"&gt;저장                &lt;/button&gt;            &lt;/div&gt;            &lt;div class=\"col\"&gt;                &lt;button class=\"w-100 btn btn-secondary btn-lg\"                        onclick=\"location.href='item.html'\"                        th:onclick=\"|location.href='@{/basic/items/{itemId}(itemId=${item.id})}'|\"                type=\"button\"&gt;취소&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 스프링 MVC 구조",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81_MVC_%EA%B5%AC%EC%A1%B0/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-06-25 00:00:00 +0900",
    





    
    "snippet": "DispatcherServletDIspatcherServlet도 부모클래스가 HttpServlet을 상속받고있음. → 모든경로에대해 매핑을 해놓음(자세한 경로가 우선순위가 높아서 기존에 등록한 서블릿도 동작함)protected void doDispatch(HttpServletRequest request, HttpServletResponse respon...",
    "content": "DispatcherServletDIspatcherServlet도 부모클래스가 HttpServlet을 상속받고있음. → 모든경로에대해 매핑을 해놓음(자세한 경로가 우선순위가 높아서 기존에 등록한 서블릿도 동작함)protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {    HttpServletRequest processedRequest = request;    HandlerExecutionChain mappedHandler = null;    ModelAndView mv = null;\t\t// 1. 핸들러 조회\t\tmappedHandler = getHandler(processedRequest); \t\tif (mappedHandler == null) {      noHandlerFound(processedRequest, response);\t\t\treturn; \t\t}\t\t//2.핸들러 어댑터 조회-핸들러를 처리할 수 있는 어댑터\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\t\t// 3. 핸들러 어댑터 실행 -&gt; 4. 핸들러 어댑터를 통해 핸들러 실행 -&gt; 5. ModelAndView 반환 \t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\t}  private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView  mv, Exception exception) throws Exception {\t\t\t // 뷰 렌더링 호출\t\t\trender(mv, request, response);  }  protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {    View view;\t\tString viewName = mv.getViewName(); //6. 뷰 리졸버를 통해서 뷰 찾기,7.View 반환    view = resolveViewName(viewName, mv.getModelInternal(), locale, request);\t\t// 8. 뷰 렌더링    view.render(mv.getModelInternal(), request, response);  }중요로직만 설명한거같음동작 순서  핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.  핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.  핸들러 어댑터 실행: 핸들러 어댑터를 실행한다.  핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다.  ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다.  viewResolver 호출: 뷰 리졸버를 찾고 실행한다.          JSP의 경우: InternalResourceViewResolver 가 자동 등록되고, 사용된다.        View반환:뷰리졸버는뷰의논리이름을물리이름으로바꾸고,렌더링역할을담당하는뷰객체를 반환한다.          JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다.        뷰렌더링:뷰를 통해서 뷰를 렌더링한다.핸들러 매핑/핸들러 어댑터  예시 1)```javapackage com.mvc1.servlet.web.springmvc.old;import org.springframework.stereotype.Component;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Component(“/springmvc/old-controller”)public class OldController implements Controller {\t@Override\tpublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\t\tSystem.out.println(“OldController.handleRequest”);\t\treturn null;\t}}![images](/assets/images/mvc1/IMG-20240909120922-2.png)- Handler Mapping    - 0순위 - @RequestMapping    - 1순위 - 스프링 빈의 이름으로 핸들러를 찾음 ← 위 코드 예시. url이름이랑 똑같은 이름의 bean을 찾음- Handler Adapter    - 0순위 - @RequestMapping    - 1순위 - HttpRequestHandler 처리    - 2순위 - Controller 인터페이스(어노테이션x, 과거에 사용) ← 위 코드 예시— 결론핸들러 매핑, 핸들러 어댑터도 모두 순서대로 찾고 없으면 다음순서로1. 핸들러 매핑으로 핸들러 조회    1. HandlerMapping을 순서대로 실행 → 핸들러 찾음    2. 빈이름으로 핸들러를 찾아야해서 BeanNameUrlHandlerMapping이 실행성공하고 핸들러인 OldContorller를 반환2. 핸들러 어댑터 조회    1. HandlerAdapter의 supports()를 순서대로 호출    2. SimpleControllerHandlerAdapter가 Controller 인터페이스를 지원하므로 대상이됨3. 핸들러 어댑터 실행    1. 디스패처서블릿이 조회한 simpleControllerHandlerAdapter를 실행하면서 핸들러 정보도 함께 넘김    2. SimpleControllerHandlerAdapter는 핸들러인 OldController를 내부에서 실행→ 결과 반환- 예시 2)```javapackage com.mvc1.servlet.web.springmvc.old;import java.io.IOException;import org.springframework.stereotype.Component;import org.springframework.web.HttpRequestHandler;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Component(\"/springmvc/request-handler\")public class MyHttpRequestHandler implements HttpRequestHandler {\t@Override\tpublic void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tSystem.out.println(\"MyHttpRequestHandler\");\t}}스프링 빈의 이름으로 핸들러를 찾음 → HttpRequestHandler 처리뷰 리졸버단순히package com.mvc1.servlet.web.springmvc.old;import org.springframework.stereotype.Component;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Component(\"/springmvc/old-controller\")public class OldController implements Controller {\t@Override\tpublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\t\tSystem.out.println(\"OldController.handleRequest\");\t\treturn new ModelAndView(\"new-form\");\t}}이렇게만 해주면 OldController.handleRequest는 콘솔창에 찍히나 view를 못찾기때문에 404에러가 뜸→ 뷰 리졸버 필요application.properties에spring.mvc.view.prefix=/WEB-INF/views/spring.mvc.view.suffix=.jsp을 해주면 페이지 로딩은 됨(저장 로직은 구현안해서 저장하면 오류남)@BeanViewResolver internalResourceViewResolver() {\treturn new InternalResourceViewResolver(\"/WEB-INF/views/\", \".jsp\");}이 작업을 스프링 부트에서 해주는 듯  스프링 부트가 자동 등록하는 뷰 리졸버          1순위 - 빈 이름으로 뷰 찾아서 반환(ex.엑셀파일 생성기능사용)      2순위 - JSP를 처리할 수 있는 뷰를 반환      — 순서  핸들러 어댑터 호출          핸들러 어댑터를 통해 new-form 이라는 논리 뷰 이름을 획득한다.        ViewResolver 호출          new-form 이라는 뷰 이름으로 viewResolver를 순서대로 호출한다.      BeanNameViewResolver 는 new-form 이라는 이름의 스프링 빈으로 등록된 뷰를 찾아야 하는데 없다.      InternalResourceViewResolver 가 호출된다.        InternalResourceViewResolver          이 뷰 리졸버는 InternalResourceView 를 반환한다.        뷰 - InternalResourceView          InternalResourceView 는 JSP처럼 포워드 forward() 를 호출해서 처리할 수 있는 경우에 사용한다.        view.render()          view.render() 가 호출되고 InternalResourceView 는 forward() 를 사용해서 JSP를 실행한다.        [!important]InternalResourceViewResolver는 JSTL라이브러리가 있으면 InternalResourceView를 상속받은 JstlView를 반환함(JSTL 태그 사용시 약간의 부가기능 추가됨)  [!important]보통 실제뷰를 랜더링하지만 JSP는 forward()를 통해서 해당 JSP로 이동해야 랜더링이 됨.  [!important]Thymeleaf 뷰 템플릿을 사용하면 ThymeleafViewResolver를 등록해야함. 최근엔 라이브러리만 추가하면 스프링부트가 자동으로 해줌spring mvcpackage com.mvc1.servlet.web.springmvc.v1;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controller //자동으로 빈 등록, 어노테이션기반 컨트롤러로 인식됨//@RequestMapping() //이건 클래스레벨이 붙어서 RequestMappingHandlerMapping으로 인식됨public class SpringMemberFormControllerV1 {\t@RequestMapping(\"/springmvc/v1/members/new-form\") //요청정보 매핑, 매소드의 이름은 임의로 지으면 됨\tpublic ModelAndView process() {\t\treturn new ModelAndView(\"new-form\"); //Model과 View의 정보를 담아서 반환\t}}이런식으로 됨다른 코드에도적 용해보면package com.mvc1.servlet.web.springmvc.v1;import java.util.List;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v3.ModelView;@Controllerpublic class SpringMemberListController {\tprivate final MemberRepository memberRepository = MemberRepository.getInstance();\t@RequestMapping(\"/springmvc/v1/members\")\tpublic ModelAndView process(Map&lt;String, String&gt; paramMap) {\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\tModelAndView mv = new ModelAndView(\"members\");\t\tmv.addObject(\"members\", members);\t\treturn mv;\t}}package com.mvc1.servlet.web.springmvc.v1;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Controllerpublic class SpringMemberSaveControllerV1 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@RequestMapping(\"/springmvc/v1/members/save\")\tpublic ModelAndView process(HttpServletRequest request, HttpServletResponse response) {\t\tString username = request.getParameter(\"username\");\t\tint age = Integer.parseInt(request.getParameter(\"age\"));\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tModelAndView mv = new ModelAndView(\"save-result\");\t\tmv.addObject(\"member\", member);\t\treturn mv;\t}}더 발전해서 각각의 컨트롤러를 하나로 통합 가능package com.mvc1.servlet.web.springmvc.v2;import java.util.List;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Controller@RequestMapping(\"springmvc/v2/members\")public class SpringMemberControllerV2 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@RequestMapping(\"/new-form\") //요청정보 매핑, 매소드의 이름은 임의로 지으면 됨\tpublic ModelAndView process() {\t\treturn new ModelAndView(\"new-form\"); //Model과 View의 정보를 담아서 반환\t}\t@RequestMapping\tpublic ModelAndView process(Map&lt;String, String&gt; paramMap) {\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\tModelAndView mv = new ModelAndView(\"members\");\t\tmv.addObject(\"members\", members);\t\treturn mv;\t}\t@RequestMapping(\"/save\")\tpublic ModelAndView process(HttpServletRequest request, HttpServletResponse response) {\t\tString username = request.getParameter(\"username\");\t\tint age = Integer.parseInt(request.getParameter(\"age\"));\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tModelAndView mv = new ModelAndView(\"save-result\");\t\tmv.addObject(\"member\", member);\t\treturn mv;\t}}여기서 더 발전해서 ModelAndView를 하나하나 만들기 귀찮으니까 개선할거임(v4에서 잠깐 본 거)package com.mvc1.servlet.web.springmvc.v3;import java.util.List;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@Controller@RequestMapping(\"springmvc/v3/members\")public class SpringMemberControllerV3 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@RequestMapping(\"/new-form\") //요청정보 매핑, 매소드의 이름은 임의로 지으면 됨\tpublic String process() {\t\treturn \"new-form\"; //Model과 View의 정보를 담아서 반환\t}\t@RequestMapping\tpublic String process(Model model) {\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\tmodel.addAttribute(\"members\", members);\t\treturn \"members\";\t}\t@RequestMapping(\"/save\")\tpublic String process(\t\t\t\t@RequestParam(\"username\") String username,\t\t\t\t@RequestParam(\"age\") int age,\t\t\t\tModel model\t) {\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tmodel.addAttribute(\"member\", member);\t\treturn \"save-result\";\t}}RequestMapping으로 해주면 getMapping이든 postMapping이든 모두 호출됨. getMapping같이 제약을 거는게 더 좋음~@RequestMapping(value = \"/new-form\", method = RequestMethod._GET_) 이것도 되긴함"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 스프링 MVC 기본기능",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81MVC%EA%B8%B0%EB%B3%B8%EA%B8%B0%EB%8A%A5/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-06-25 00:00:00 +0900",
    





    
    "snippet": "기본적인 내용이 많아서 좀 생략함  war : 톰캣 별도 설치(내장도되긴함), servlet, jsp에도 배포가능함  jar : 내장톰캣 사용. 내장서버사용에 최적화됨— 로깅운영시스템에서는 sout안씀. SLF4J와 Logback 두 라이브러리가있는데 대부분 Logback사용함(스프링부트 기본제공)package com.hello.springmvc1.b...",
    "content": "기본적인 내용이 많아서 좀 생략함  war : 톰캣 별도 설치(내장도되긴함), servlet, jsp에도 배포가능함  jar : 내장톰캣 사용. 내장서버사용에 최적화됨— 로깅운영시스템에서는 sout안씀. SLF4J와 Logback 두 라이브러리가있는데 대부분 Logback사용함(스프링부트 기본제공)package com.hello.springmvc1.basic;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class LogTestController {\tprivate final Logger log = LoggerFactory.getLogger(getClass());\t@GetMapping(\"/log-test\")\tpublic String logTest() {\t\tlog.trace(\"trace log={}, {}\",\"test1\",\"test2\");\t\tlog.debug(\"debug\",\"debugTest\");\t\tlog.info(\"log-test\");\t\tlog.warn(\"warn\",\"warnTest\");\t\tlog.error(\"error\",\"errorTest\");\t\treturn \"ok\";\t}}trace, debug는 안뜨는거확인,application.properties에서 로그레벨 설정 가능함강의에서는 logging.level.hello.springmvc=trace로 했는데 나는 안돼서..구글링해보니 logging.level.root=trace 으로 설정하니 다 뜨는 것을 확인함..→ 아 root는 전체세팅이라고함 위 강의에서 사용한 레벨은 패키지단 설정이라 둘다해놓으면 패키지에는 해당 레벨이 적용되고 전체에는 기본레벨이 적용됨. root를 trace로 하면 메세지가 너무 많이찍힘암튼 순서대로 trace(다보임)→debug→info→warn→error순임.개발서버는 debug, 운영서버는 info로 설정하면될듯참고로 restController = 반환값으로 뷰를 찾는게아니고 Http메세지 바디에 바로 입력함package com.hello.springmvc1.basic;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import lombok.extern.slf4j.Slf4j;@RestController@Slf4jpublic class LogTestController {\t// private final Logger log = LoggerFactory.getLogger(getClass());\t@GetMapping(\"/log-test\")\tpublic String logTest() {\t\tlog.trace(\"trace log={}, {}\",\"test1\",\"test2\");\t\tlog.debug(\"debug\",\"debugTest\");\t\tlog.info(\"log-test\");\t\tlog.warn(\"warn\",\"warnTest\");\t\tlog.error(\"error\",\"errorTest\");\t\treturn \"ok\";\t}}lombok쓰면 @Slf4j만 해줘도됨참고로log.debug(“debug”+”debugTest”); 이렇게되면 ()안의 연산부터 이루어져서 로그레벨을 info로해도 연산이됨=메모리잡아먹음그리고 log는 파일로 남길수도있음. 파일 용량이 커지면 분할하도록 할수있음. sout보다 성능도 좋음요청 매핑@Contorller는 반환값이 String이면 뷰 이름으로 인식해서 뷰를 찾고 뷰가 랜더링하나 @RestController는 반환값으로 뷰를 찾는게 아니라 HTTP바디에 바로 입력됨 → 실행결과로 ok메세지를 받을 수 있음@RequestMapping은 요청메소드타입에 상관없이 모두 실행됨. method로 타입 지정가능, 이거의 축약버전이 @GetMapping같은거@GetMapping에 params =”mode=debug”나 headers=”mode=debug”같이 추가로 설정해주면 특정 값이 있어야 호출이됨, 요즘은 잘 사용하지않으니 있다는거만 알고 넘어가면될듯미디어타입조건도 매핑가능함(consumes = “application/json” 등) - http 헤더의 accept헤더에 특정 데이터 타입만 허용하겠다고 지정하는것너무 기본적인 내용이라서 코드는 생략함헤더 조회@RequestMapping(\"/headers\")    public String headers(          HttpServletRequest request,          HttpServletResponse response,          HttpMethod httpMethod,          Locale locale,          @RequestHeader MultiValueMap&lt;String, String&gt;                  headerMap,          @RequestHeader(\"host\") String host,          @CookieValue(value = \"myCookie\", required = false)          String cookie    ) {        log.info(\"request={}\", request);        log.info(\"response={}\", response);        log.info(\"httpMethod={}\", httpMethod);        log.info(\"locale={}\", locale);        log.info(\"headerMap={}\", headerMap);        log.info(\"header host={}\", host);        log.info(\"myCookie={}\", cookie);        return \"ok\";    }  locale(사용자 인터페이스에서 사용되는 언어, 지역 설정, 출력 형식 등을 정의하는 문자열) 가장 우선순위가 높은 locale을 받아옴. localeresolver도 있다고하는데 잘 사용하지는 않는듯? 글로벌서비스에서는 쓰일수도? 링크들어가보면 언어, 장소같은 느낌인듯  MultiValueMap : Map과 비슷하나 하나의 키에 여러 값을 받을 수 있음. 하나의 하나의 헤더에 여러 값이 들어올수있을때 사용하는듯. 키로 호출시 배열형태로 나옴https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html자세한건 여기데이터 전달 방법  get 쿼리파라미터          메세지 바디 없이 URL의 쿼리파라미터에 데이터 포함해서 전달      검색, 필터, 페이징등에 많이 사용         @RequestMapping(\"/request-param-v1\") public void requestParamV1(HttpServletRequest request, HttpServletResponse  \tresponse) throws IOException  { \t String username = request.getParameter(\"username\"); \t int age = Integer.parseInt(request.getParameter(\"age\")); \t log.info(\"username={}, age={}\", username, age); \t response.getWriter().write(\"ok\"); }        POST - HTML Form          content-type: application/x-www-form-urlencoded      메에시 바디에 쿼리파라미터 형식으로 전달(위랑 형식 같아서 똑같이꺼낼수있음)      회원가입, 상품주문, HTML Form 사용         &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;form action=\"/request-param-v1\" method=\"post\"&gt;  username: &lt;input type=\"text\" name=\"username\" /&gt;  age: &lt;input type=\"text\" name=\"age\" /&gt;  &lt;button type=\"submit\"&gt;전송&lt;/button&gt;  &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;        HTTP message body 에 데이터를 담아서 요청          HTTP API에서 주로 사용(JSON, XML, TEXT)      데이터형식은 주로 JSON      @RequestParam참고로 @Controller 어노테이션을 붙여도 API위에 @ResponseBody를 쓰면 특정 요청만 RestController가됨HTTP 파라미터 이름이 변수 이름이랑 같거나 String, int, Integer 등 단순 타입이면 아예 생략가능함그런데 너무 생략하면 명확하지않다는 단점이 있을수도있음required가 true면 필수, false면 null 가능defaultValue로 값이 안들어오면 기본 값 설정 가능(이때는 required 불필요), 참고로 “”도 기본값으로 대체해줌 - “ “이거도 걸러주는지 확인필요@GetMapping\tpublic String test(@RequestParam(defaultValue = \"ss\") String test) {\t\tSystem.out.println(test);\t\treturn \"ok\";\t}localhost:8250?test → defaultValue로 변환됨localhost:8250?test=s → 변환안됨localhost:8250?test= → 변환됨localhost:8250?test= (띄어쓰기있음) → 변환안됨null, “” 체크는 해주나 “ “는 체크안해주는거같음!요청 파라미터가 많으면 Map&lt;String, Object&gt; 식으로 받아서 파라미터명으로 값을 꺼내오는 것도 가능HTTP 요청파라미터 - @ModelAttribute@RequestParam으로 객체의 요소를 받는다면 굳이 RequestParam을 쓰지않고 @ModelAttribute Dto 이런식으로 바로 매핑가능단, setter가 필요하며 param과 객체의 멤버변수 이름이 동일해야함(다르면 네임 설정 가능함)물론 타입에러는 bindException이 발생함.또한 @RequestParam처럼 @ModelAttribute 자체도 생략가능함.생략 시 String, int, Integer처럼 단순 타입은 @RequestParam으로,argument resolver로 지정한 타입 외에는 @ModelAttribute로 매핑됨HTTP 요청 메세지 - 단순 텍스트@PostMapping(\"/v1\")public void requestBodyString(HttpServletRequest request, HttpServletResponse response) throws IOException {\t\tServletInputStream inputStream = request.getInputStream();\t\tString messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);\t\tresponse.getWriter().write(messageBody);}@PostMapping(\"/v2\")public void requestBodyString(InputStream inputStream, Writer response) throws IOException {\t\tString messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);\t\tresponse.write(messageBody);}@PostMapping(\"/v3\")public HttpEntity&lt;String&gt; requestBodyString(HttpEntity&lt;String&gt; httpEntity) throws IOException {\t\tString messageBody = httpEntity.getBody();\t\treturn new HttpEntity&lt;&gt;(messageBody);}참고로 HttpEntity는 요청파라미터를 조회하는 기능(@RequestParam, @ModelAttribute 와는 관련x)HttpEntity대신 RequestEntity, ResponseEntity를 사용하면 더 다양한 기능을 사용할 수 있음. HttpEntity를 상속받는 애들임. 예를들어 ResponseEntity는 상태코드 설정 가능여기서 제일 최종 버전이 @RequestBody String임컨트롤러 앞에 @ResponseBody를 사용하면 return 타입을 응답코드에 넣어서 반환해줌HTTP 요청 메세지 - JSONprivate ObjectMapper objectMapper = new ObjectMapper();@PostMapping(\"/v1\")public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException {\tServletInputStream inputStream = request.getInputStream();\tString messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);\tHelloData helloData = objectMapper.readValue(messageBody, HelloData.class);\tresponse.getWriter().write(\"OK\");}@PostMapping(\"/v2\")public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException {\tHelloData helloData = objectMapper.readValue(messageBody, HelloData.class);\treturn \"OK\";}@PostMapping(\"/v3\")public String requestBodyJsonV2(@RequestBody HelloData helloData) throws IOException {\treturn \"OK\";}참고로 @RequestBody는 생략 불가능함생략하면 @ModelAttribute가 적용됨requestBody랑 ModelAttribute는 primitive type 처리하는게 조금 다름정적 리소스/static, /public, /resources, /META-INF/resources 에 있는 정적 리소스 제공뷰 템플릿뷰템플릿을 거쳐서 HTML 생성, 뷰가 응답을 만들어서 전달타임리프에 데이터 바인딩하는 그거 말하는거임return타입 String에 html경로 적어서 반환해주고 model에 데이터 값 넣어서 보내주던 그거ㅇ만약 컨트롤러에 ResponseBody어노테이션 붙이면 그냥 경로가 String으로 화면에 출력됨권장하지는 않으나 void로 매핑주소자체를 뷰의 논리적 경로로 만들어주면 매핑이되긴함. 불명확해서 권장안함!HTTP 응답 - HTTP API, 메세지 바디에 직접 입력@ResponseStatus사용하면 ResponseEntity를 반환타입으로 안해줘도 상태코드 지정 가능함대신 ResponseStatus는 동적으로 상태코드를 변경하지는 못함HTTP 메세지 컨버터@ResponseBody를 사용하면 viewReslover대신에 HttpMessageConverter가 동작함  기본 문자 처리 : String HttpMessageConverter  기본 객체 처리 : MappingJacson2HttpMessageConverter(ObjactMapper같은거?)  byte처리 등 기타 여러 HttpMessageConverter가 기본등록클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 선택됨⇒ 스프링 MVC에서는 요청에는 @RequestBody, HttpEntity(RequestEntity), 응답에는 @ResponseBody, HttpEntity(ResponseEntity)인 경우 HttpMessageConverter를 적용함HttpMessageConverter는 HTTP 요청, HTTP 응답 둘다 사용함  canRead(), canWrite() : 메세지 컨버터가 해당 클래스, 미디어타입을 지원하는지 체크.          canRead() : 메세지 컨버터가 해당 메세지를 읽을 수 있는지 확인하기 위해 호출                  대상 클래스 타입을 지원?  예) @RequestBody 의 대상 클래스 ( byte[] , String , HelloData )          HTTP 요청의 Content-Type 미디어 타입을 지원하는가                    canWrite() : 메세지 컨버터가 해당 메세지를 쓸 수 있는지 확인하기 위해 호출                  대상 클래스 타입을 지원하는가.  예) return의 대상 클래스 ( byte[] , String , HelloData )          HTTP 요청의 Accept 미디어 타입을 지원하는가.(더 정확히는 @RequestMapping 의 produces )  예) text/plain , application/json , /                      read(), write() : 메세지 컨버터를 통해서 메세지를 읽고 쓰는 기능          read() : canRead()조건을 만족하면 호출해서 객체를 생성, 반환      write() : canWrite()조건을 만족하면 호출해서 HTTP 응답 메세지 바디에 데이터를 생성      대상 클래스 타입과 미디어타입 체크 → 사용여부 결정(만족안하면 다음 메세지 컨버터로 우선순위 밀림)  ByteArrayHttpMessageConverter : byte[] 데이터를 처리          클래스 타입: byte[] , 미디어타입: _/_      요청 예) @RequestBody byte[] data      응답 예) @ResponseBody return byte[] 쓰기 미디어타입 application/octet-stream        StringHttpMessageConverter : String 문자로 데이터를 처리          클래스 타입: String , 미디어타입: _/_      요청 예) @RequestBody String data      응답 예) @ResponseBody return “ok” 쓰기 미디어타입 text/plain        MappingJackson2HttpMessageConverter : application/json          클래스 타입: 객체 또는 HashMap , 미디어타입 application/json 관련      요청 예) @RequestBody HelloData data      응답 예) @ResponseBody return helloData 쓰기 미디어타입 application/json 관련      요청 매핑 헨들러 어뎁터 구조핸들러 = 컨트롤러 라고 생각하면됨  v3용 어댑터가 필요한지 v4용 어댑터가 필요한지 찾는과정3~4. 프론트 컨트롤러에서 핸들러(컨트롤러)를 바로 호출할 수 없기때문에 찾아온 어댑터를 사이에 두고 핸들러를 호출함  핸들러가 만들어준 modelview를 반환받음HTTP 메세지 컨버터는 핸들러 어뎁터와 관련있음. @RequestMapping을 처리하는 핸들러 어뎁터인 RequestMappingHandlerAdapter는 아래와 같이 동작함  Argument Resolver  컨트롤러가 매우 다양한 파라미터(HttpServletRequest, Model, @RequestParam, @RequestBody, HttpEntity, @ModelAttribute 등)를 처리할 수 있도록 해줌  RequestMappingHandlerAdapter에서 필요한 파라미터 값(객체)를 ArgumentResolver가 생성하서 넘겨줌. 필요한 파라미터를 생성하기위해 RequestMappingHandlerAdapter가 ArgumentResolver를 호출함. 호출 후 필요한 파라미터값이 모두 준비되면 컨트롤러를 호출해서 값을 넘겨줌  만약 @RequestBody나 HttpEntity라면 HTTP메세지 컨버터까지 사용  ArgumentResolver의 supportsParameter()를 호출해서 해당 파라미터를 지원하는지 체크, 지원하면 resolveArgument()를 호출해서 실제 객체 생성 → 컨트롤러로 전달  원한다면 인터페이스 확장해서 원하는 ArgumentResolver를 만들 수 있음  ReturnValueHandler  HandlerMethodReturnValueHandler를 줄여서 ReturnValueHandler라고 부름  ArgumentResolver와 비슷하나 응답값을 변환하고 처리하는 차이점.  컨트롤러에서 뷰이름 반환을 String으로 해도 동작하는 이유  만약 @ResponeBody나 HttpEntity라면 HTTP메세지 컨버터까지 사용  [!important]HandlerMethodArgumentResolverHandlerMethodReturnValueHandlerHttpMessageConverter는 모두 인터페이스로 제공. 필요하면 확장 가능(거의 쓸일 없음)  @Bean  public WebMvcConfigurer webMvcConfigurer() {  \treturn new WebMvcConfigurer() {  \t\t@Override  \t\tpublic void addArgumentResolvers(List&lt; HandlerMethodArgumentResolver&gt;  \t\tresolvers) {  \t\t//...  \t\t} \t\t@Override  \t\tpublic void extendMessageConverters(List&lt;HttpMessageConverter&lt; ?&gt;&gt;  \t\tconverters) {  \t\t//...  \t\t}  \t};  }\t  "
  },
  
  {
    "title": "[김영한 스프링 MVC 1] MVC 프레임워크",
    "url": "/posts/MVC_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-06-11 00:00:00 +0900",
    





    
    "snippet": "프론트 컨트롤러 도입프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받아 요청에맞는 컨트롤러를 호출(컨트롤러는 서블릿필요없음)package com.mvc1.servlet.web.frontController.v1.controller;import java.io.IOException;import com.mvc1.servlet.web.frontControl...",
    "content": "프론트 컨트롤러 도입프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받아 요청에맞는 컨트롤러를 호출(컨트롤러는 서블릿필요없음)package com.mvc1.servlet.web.frontController.v1.controller;import java.io.IOException;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberFormControllerV1 implements ControllerV1 {\t@Override\tpublic void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tString viewPath = \"/WEB-INF/views/new-form.jsp\"; //jsp생성\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); //컨트롤러-&gt;뷰 이동시 사용\t\tdispatcher.forward(request, response); //서블릿에서 jsp호출\t}}package com.mvc1.servlet.web.frontController.v1.controller;import java.io.IOException;import java.util.List;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberListControllerV1 implements ControllerV1 {\tMemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tSystem.out.println(\"MvcMemberListServlet.service\");\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\trequest.setAttribute(\"members\", members);\t\tSystem.out.println(members.get(0));\t\tString viewPath = \"/WEB-INF/views/members.jsp\";\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);\t\tdispatcher.forward(request, response);\t}}package com.mvc1.servlet.web.frontController.v1.controller;import java.io.IOException;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberSaveControllerV1 implements ControllerV1 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tString username = request.getParameter(\"username\");\t\tint age = Integer.parseInt(request.getParameter(\"age\"));\t\tMember member = new Member(username, age);\t\tSystem.out.println(\"member = \" + member);\t\tmemberRepository.save(member);\t\t//Model에 데이터를 보관한다.\t\trequest.setAttribute(\"member\", member);\t\tString viewPath = \"/WEB-INF/views/save-result.jsp\";\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);\t\tdispatcher.forward(request, response);\t}}package com.mvc1.servlet.web.frontController.v1;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.v1.controller.MemberFormControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberListControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberSaveControllerV1;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV1\", urlPatterns = \"/front-controller/v1/*\")public class FrontControllerServletV1 extends HttpServlet {\tprivate Map&lt;String, ControllerV1&gt; controllerMap = new HashMap&lt;&gt;();\tpublic FrontControllerServletV1() {\t\tcontrollerMap.put(\"/front-controller/v1/members/new-form\", new MemberFormControllerV1());\t\tcontrollerMap.put(\"/front-controller/v1/members/save\", new MemberSaveControllerV1());\t\tcontrollerMap.put(\"/front-controller/v1/members\", new MemberListControllerV1());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV1.service\");\t\tString requestURI = req.getRequestURI();\t\tControllerV1 controller = controllerMap.get(requestURI);\t\tif(controller == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\tcontroller.process(req, resp);\t}}컨트롤러→뷰 부분의 중복이있음⇒ 뷰를 처리하는 객체 생성View 분리package com.mvc1.servlet.web.frontController;import java.io.IOException;import javax.swing.text.View;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MyView {\tprivate String viewPath;\tpublic MyView(String viewPath) {\t\tthis.viewPath = viewPath;\t}\tpublic void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tRequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);\t\tdispatcher.forward(request, response);\t}}package com.mvc1.servlet.web.frontController.v2.controller;import java.io.IOException;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberFormControllerV2 implements ControllerV2 {\t@Override\tpublic MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\treturn new MyView(\"/WEB-INF/views/new-form.jsp\");\t}}package com.mvc1.servlet.web.frontController.v2.controller;import java.io.IOException;import java.util.List;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberListControllerV2 implements ControllerV2 {\tMemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tSystem.out.println(\"MvcMemberListServlet.service\");\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\trequest.setAttribute(\"members\", members);\t\tSystem.out.println(members.get(0));\t\treturn new MyView(\"/WEB-INF/views/members.jsp\");\t}}package com.mvc1.servlet.web.frontController.v2.controller;import java.io.IOException;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberSaveControllerV2 implements ControllerV2 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\t\tString username = request.getParameter(\"username\");\t\tint age = Integer.parseInt(request.getParameter(\"age\"));\t\tMember member = new Member(username, age);\t\tSystem.out.println(\"member = \" + member);\t\tmemberRepository.save(member);\t\t//Model에 데이터를 보관한다.\t\trequest.setAttribute(\"member\", member);\t\treturn new MyView(\"/WEB-INF/views/save-result.jsp\");\t}}package com.mvc1.servlet.web.frontController.v2;import java.io.IOException;import java.util.HashMap;import java.util.Map;import javax.swing.text.View;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v1.ControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberFormControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberListControllerV1;import com.mvc1.servlet.web.frontController.v1.controller.MemberSaveControllerV1;import com.mvc1.servlet.web.frontController.v2.controller.MemberFormControllerV2;import com.mvc1.servlet.web.frontController.v2.controller.MemberListControllerV2;import com.mvc1.servlet.web.frontController.v2.controller.MemberSaveControllerV2;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV2\", urlPatterns = \"/front-controller/v2/*\")public class FrontControllerServletV2 extends HttpServlet {\tprivate Map&lt;String, ControllerV2&gt; controllerMap = new HashMap&lt;&gt;();\tpublic FrontControllerServletV2() {\t\tcontrollerMap.put(\"/front-controller/v2/members/new-form\", new MemberFormControllerV2());\t\tcontrollerMap.put(\"/front-controller/v2/members/save\", new MemberSaveControllerV2());\t\tcontrollerMap.put(\"/front-controller/v2/members\", new MemberListControllerV2());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV2.service\");\t\tString requestURI = req.getRequestURI();\t\tControllerV2 controller = controllerMap.get(requestURI);\t\tif(controller == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\tMyView process = controller.process(req, resp);\t\tprocess.render(req, resp);\t}}MyView의 render를 공통 로직으로 처리해서 깔끔해짐. 컨트롤러에서 MyView객체를 생성해서 반환하기만하면됨그런데 컨트롤러에서 HttpServletRequest req, HttpServletResponse resp를 안쓰는 경우도 있음 → request를 Model로 사용하는 대신 별도의 Model객체 생성 후 반환하면 됨Model 추가컨트롤러가 서블릿을 사용하지 않고 뷰 이름 중복 제거할거임package com.mvc1.servlet.web.frontController.v3;import java.util.HashMap;import java.util.Map;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class ModelView {\tprivate String viewPath;\tprivate Map&lt;String, Object&gt; model = new HashMap&lt;&gt;();\tpublic ModelView(String viewPath) {\t\tthis.viewPath = viewPath;\t}}package com.mvc1.servlet.web.frontController.v3;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberFormControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberListControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberSaveControllerV3;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV3\", urlPatterns = \"/front-controller/v3/*\")public class FrontControllerServletV3 extends HttpServlet {\tprivate Map&lt;String, ControllerV3&gt; controllerMap = new HashMap&lt;&gt;();\tpublic FrontControllerServletV3() {\t\tcontrollerMap.put(\"/front-controller/v3/members/new-form\", new MemberFormControllerV3());\t\tcontrollerMap.put(\"/front-controller/v3/members/save\", new MemberSaveControllerV3());\t\tcontrollerMap.put(\"/front-controller/v3/members\", new MemberListControllerV3());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV3.service\");\t\tString requestURI = req.getRequestURI();\t\tControllerV3 controller = controllerMap.get(requestURI);\t\tif(controller == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\tMap&lt;String, String&gt; paramMap = createParamMap(req); //받은 파라미터를 map으로 전환\t\tModelView mv = controller.process(paramMap); //해당 controller에서 viewPath세팅, model 세팅\t\t//논리이름 -&gt; 물리이름\t\tString viewPath = mv.getViewPath();\t\tMyView myView = viewResolver(viewPath);\t\tmyView.render(mv.getModel(), req, resp); //반환할 데이터 세팅\t}\tprivate static MyView viewResolver(String viewPath) {\t\treturn new MyView(\"/WEB-INF/views/\" + viewPath + \".jsp\");\t}\tprivate static Map&lt;String, String&gt; createParamMap(HttpServletRequest req) {\t\tMap&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();\t\treq.getParameterNames().asIterator()\t\t\t.forEachRemaining(paramName -&gt; paramMap.put(paramName, req.getParameter(paramName)));\t\treturn paramMap;\t}}package com.mvc1.servlet.web.frontController.v3.controller;import java.io.IOException;import java.util.Map;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberFormControllerV3 implements ControllerV3 {\t@Override\tpublic ModelView process(Map&lt;String, String&gt; paramMap) {\t\treturn new ModelView(\"new-form\");\t}}package com.mvc1.servlet.web.frontController.v3.controller;import java.io.IOException;import java.util.List;import java.util.Map;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberListControllerV3 implements ControllerV3 {\tMemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic ModelView process(Map&lt;String, String&gt; paramMap) {\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\tModelView modelView = new ModelView(\"members\");\t\tmodelView.getModel().put(\"members\", members);\t\treturn modelView;\t}}package com.mvc1.servlet.web.frontController.v3.controller;import java.io.IOException;import java.util.Map;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v2.ControllerV2;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class MemberSaveControllerV3 implements ControllerV3 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic ModelView process(Map&lt;String, String&gt; paramMap) {\t\tString username = paramMap.get(\"username\");\t\tint age = Integer.parseInt(paramMap.get(\"age\"));\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tModelView modelView = new ModelView(\"save-result\");\t\tmodelView.getModel().put(\"member\", member);\t\treturn modelView;\t}}package com.mvc1.servlet.web.frontController.v3;import java.util.Map;public interface ControllerV3 {\tModelView process(Map&lt;String, String&gt; paramMap);}ModelView객체 생성, 반환 부분이 번거로움(실용성x)⇒ 컨트롤러가 ViewName만 반환하도록 변경실용적인 컨트롤러package com.mvc1.servlet.web.frontController.v4;import java.util.Map;public interface ControllerV4 {\t/**\t *\t * @param paramMap\t * @param model\t * @return\t */\tString process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model);}package com.mvc1.servlet.web.frontController.v4.controller;import java.util.Map;import com.mvc1.servlet.web.frontController.v4.ControllerV4;public class MemberFormControllerV4 implements ControllerV4 {\t@Override\tpublic String process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model) {\t\treturn \"new-form\";\t}}package com.mvc1.servlet.web.frontController.v4.controller;import java.util.List;import java.util.Map;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v3.ModelView;import com.mvc1.servlet.web.frontController.v4.ControllerV4;public class MemberListControllerV4 implements ControllerV4 {\tMemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic String process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model) {\t\t\tList&lt;Member&gt; members = memberRepository.findAll();\t\t\tModelView modelView = new ModelView(\"members\");\t\t\tmodelView.getModel().put(\"members\", members);\t\t\treturn \"members\";\t}}package com.mvc1.servlet.web.frontController.v4.controller;import java.util.Map;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import com.mvc1.servlet.web.frontController.v4.ControllerV4;public class MemberSaveControllerV4 implements ControllerV4 {\tprivate MemberRepository memberRepository = MemberRepository.getInstance();\t@Override\tpublic String process(Map&lt;String, String&gt; paramMap, Map&lt;String, Object&gt; model) {\t\tString username = paramMap.get(\"username\");\t\tint age = Integer.parseInt(paramMap.get(\"age\"));\t\tMember member = new Member(username, age);\t\tmemberRepository.save(member);\t\tmodel.put(\"member\", member);\t\treturn \"save-result\";\t}}package com.mvc1.servlet.web.frontController.v4;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v4.controller.MemberFormControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberListControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberSaveControllerV4;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV4\", urlPatterns = \"/front-controller/v4/*\")public class FrontControllerServletV4 extends HttpServlet {\tprivate Map&lt;String, ControllerV4&gt; controllerMap = new HashMap&lt;&gt;();\tpublic FrontControllerServletV4() {\t\tcontrollerMap.put(\"/front-controller/v4/members/new-form\", new MemberFormControllerV4());\t\tcontrollerMap.put(\"/front-controller/v4/members/save\", new MemberSaveControllerV4());\t\tcontrollerMap.put(\"/front-controller/v4/members\", new MemberListControllerV4());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV4.service\");\t\tString requestURI = req.getRequestURI();\t\tControllerV4 controller = controllerMap.get(requestURI);\t\tif(controller == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\tMap&lt;String, String&gt; paramMap = createParamMap(req); //받은 파라미터를 map으로 전환\t\tMap&lt;String, Object&gt; model = new HashMap&lt;&gt;(); //추가된부분\t\tString viewName = controller.process(paramMap, model);//해당 controller에서 viewPath세팅, model 세팅\t\tMyView myView = viewResolver(viewName);\t\tSystem.out.println(myView.getViewPath());\t\tmyView.render(model, req, resp); //반환할 데이터 세팅\t}\tprivate static MyView viewResolver(String viewPath) {\t\treturn new MyView(\"/WEB-INF/views/\" + viewPath + \".jsp\");\t}\tprivate static Map&lt;String, String&gt; createParamMap(HttpServletRequest req) {\t\tMap&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();\t\treq.getParameterNames().asIterator()\t\t\t.forEachRemaining(paramName -&gt; paramMap.put(paramName, req.getParameter(paramName)));\t\treturn paramMap;\t}}v3와 거의 동일하나 model을 frontcontroller에서 생성한 후 controller의 반환타입을 String으로 변경한게 다임그러나 모양이 정해져있다는것이 단점임. 예를들면 private Map&lt;String, ControllerV4&gt; controllerMap = new HashMap&lt;&gt;(); 이부분 controller의 버전을 4로 고정시킨게 단점이라는거같음. 유연하지 못하다? 뭐 그런..;;⇒ 어댑터 사용으로 해결유연한 컨트롤러어댑터 패턴으로 다양한 인터페이스를 사용가능하도록 구현핸들러 = 컨트롤러 라고 생각하면됨  v3용 어댑터가 필요한지 v4용 어댑터가 필요한지 찾는과정3~4. 프론트 컨트롤러에서 핸들러(컨트롤러)를 바로 호출할 수 없기때문에 찾아온 어댑터를 사이에 두고 핸들러를 호출함  핸들러가 만들어준 modelview를 반환받음== 중간에 핸들러 어댑터가 추가되었기때문에 v1~v4컨트롤러까지 모두 호출가능함package com.mvc1.servlet.web.frontController.v5;import java.io.IOException;import com.mvc1.servlet.web.frontController.v3.ModelView;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public interface MyHandlerAdepter {\tboolean supports(Object handler);\tModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException;}package com.mvc1.servlet.web.frontController.v5.adepter;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import com.mvc1.servlet.web.frontController.v5.MyHandlerAdepter;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class ControllerV3HandlerAdapter implements MyHandlerAdepter {\t@Override\tpublic boolean supports(Object handler) {\t\treturn (handler instanceof ControllerV3); //controllerV3를 구현한 무언가가 들어오면 true반환\t}\t@Override\tpublic ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {\t\tControllerV3 controller = (ControllerV3) handler; //supports를 먼저 호출해서 검사한 후 실행할거임. 캐스팅해도됨\t\tMap&lt;String, String&gt; paramMap = createParamMap(request);\t\tModelView mv = controller.process(paramMap);\t\treturn mv;\t}\tprivate Map&lt;String, String&gt; createParamMap(HttpServletRequest req) {\t\tMap&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();\t\treq.getParameterNames().asIterator()\t\t\t.forEachRemaining(paramName -&gt; paramMap.put(paramName, req.getParameter(paramName)));\t\treturn paramMap;\t}}package com.mvc1.servlet.web.frontController.v5.adepter;import java.io.IOException;import java.util.HashMap;import java.util.Map;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import com.mvc1.servlet.web.frontController.v4.ControllerV4;import com.mvc1.servlet.web.frontController.v5.MyHandlerAdepter;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;public class ControllerV4HandlerAdapter implements MyHandlerAdepter {\t@Override\tpublic boolean supports(Object handler) {\t\treturn (handler instanceof ControllerV4);\t}\t@Override\tpublic ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {\t\tControllerV4 controller = (ControllerV4) handler; //supports를 먼저 호출해서 검사한 후 실행할거임. 캐스팅해도됨\t\tMap&lt;String, String&gt; paramMap = createParamMap(request);\t\tMap&lt;String, Object&gt; model = new HashMap&lt;&gt;();\t\t//반환타입 안맞아서 ModelView로 반환하기위한 작업임\t\tString viewName = controller.process(paramMap, model);\t\tModelView mv = new ModelView(viewName);\t\tmv.setModel(model);\t\treturn mv;\t}\tprivate Map&lt;String, String&gt; createParamMap(HttpServletRequest req) {\t\tMap&lt;String, String&gt; paramMap = new HashMap&lt;&gt;();\t\treq.getParameterNames().asIterator()\t\t\t.forEachRemaining(paramName -&gt; paramMap.put(paramName, req.getParameter(paramName)));\t\treturn paramMap;\t}}package com.mvc1.servlet.web.frontController.v5;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import com.mvc1.servlet.web.frontController.MyView;import com.mvc1.servlet.web.frontController.v3.ControllerV3;import com.mvc1.servlet.web.frontController.v3.ModelView;import com.mvc1.servlet.web.frontController.v3.controller.MemberFormControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberListControllerV3;import com.mvc1.servlet.web.frontController.v3.controller.MemberSaveControllerV3;import com.mvc1.servlet.web.frontController.v4.ControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberFormControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberListControllerV4;import com.mvc1.servlet.web.frontController.v4.controller.MemberSaveControllerV4;import com.mvc1.servlet.web.frontController.v5.adepter.ControllerV3HandlerAdapter;import com.mvc1.servlet.web.frontController.v5.adepter.ControllerV4HandlerAdapter;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;@WebServlet(name=\"frontControllerServletV5\", urlPatterns = \"/front-controller/v5/*\")public class FrontControllerServletV5 extends HttpServlet {\tprivate final Map&lt;String, Object&gt; handlerMappingMap = new HashMap&lt;&gt;();\tprivate final List&lt;MyHandlerAdepter&gt; handlerAdapters = new ArrayList&lt;&gt;();\tpublic FrontControllerServletV5() {\t\tinitHandlerMappingMap();\t\tinitHandlerAdapters();\t}\tprivate void initHandlerAdapters() {\t\thandlerAdapters.add(new ControllerV3HandlerAdapter());\t\thandlerAdapters.add(new ControllerV4HandlerAdapter());\t}\tprivate void initHandlerMappingMap() {\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members/new-form\", new MemberFormControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members/save\", new MemberSaveControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members\", new MemberListControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members/new-form\", new MemberFormControllerV4());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members/save\", new MemberSaveControllerV4());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members\", new MemberListControllerV4());\t}\t@Override\tprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\t\tSystem.out.println(\"FrontControllerServletV3.service\");\t\t//1. handler 조회\t\t//Controller 버전에 맞는 구현체를 가져옴 (ex.MemberFormControllerV3)\t\tObject handler = getHandler(req);\t\tif(handler == null) {\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_FOUND);\t\t\treturn;\t\t}\t\t//2. handler 목록에서 핸들러를 처리할 수 있는 handler adapter 조회\t\t//해당하는 버전의 handler adapter가 반환됨 (ex.ControllerV3HandlerAdapter)\t\tMyHandlerAdepter adapter = getHandlerAdapter(handler);\t\t//3. handler를 통해 controller 호출\t\tModelView mv = adapter.handle(req, resp, handler);\t\t/*\t\thandler를 해당 버전의 controller로 캐스팅 -&gt; ModelView반환\t\t여기서 실질적인 로직을 호출 한 후 데이터가 세팅됨\t\t */\t\tString viewPath = mv.getViewPath();\t\tMyView myView = viewResolver(viewPath);\t\tSystem.out.println(myView.getViewPath());\t\tmyView.render(mv.getModel(), req, resp); //반환할 데이터 세팅\t}\tprivate MyHandlerAdepter getHandlerAdapter(Object handler) {\t\tfor (MyHandlerAdepter adapter : handlerAdapters) {\t\t\tif(adapter.supports(handler)) {\t\t\t\treturn adapter;\t\t\t}\t\t}\t\tthrow new IllegalArgumentException(\"handler adapter를 찾을 수 없음. handler = \"+handler);\t}\tprivate Object getHandler(HttpServletRequest req) {\t\tString requestURI = req.getRequestURI();\t\treturn handlerMappingMap.get(requestURI);\t}\tprivate static MyView viewResolver(String viewPath) {\t\treturn new MyView(\"/WEB-INF/views/\" + viewPath + \".jsp\");\t}}frontController하나로 여러 interface의 구현체를 받아서 처리가능함.만약 controller interface가 추가된다하더라도 frontController는\tprivate void initHandlerAdapters() {\t\thandlerAdapters.add(new ControllerV3HandlerAdapter());\t\thandlerAdapters.add(new ControllerV4HandlerAdapter());\t}\tprivate void initHandlerMappingMap() {\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members/new-form\", new MemberFormControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members/save\", new MemberSaveControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v3/members\", new MemberListControllerV3());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members/new-form\", new MemberFormControllerV4());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members/save\", new MemberSaveControllerV4());\t\thandlerMappingMap.put(\"/front-controller/v5/v4/members\", new MemberListControllerV4());\t}이 부분만 추가해주면 되는거임!!여기에 어노테이션을 사용하면 더 편리하게 발전시킬수도있음(어노테이션[RequestMappingHandlerAdapter]을 지원하는 어댑터를 추가하면됨)이 구조가 spring MVC구조 와 동일함frontController → DispatcherServlethandlerMappingMap → HandlerMappingMyHandlerAdapter → HandlerAdapterModelView → ModelAndViewviewResolver → ViewResolverMyView → View(interface)"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 서블릿, MVC, JSP",
    "url": "/posts/%EC%84%9C%EB%B8%94%EB%A6%BF_mvc_jsp/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-05-29 00:00:00 +0900",
    





    
    "snippet": "동시성 문제 고려안하고 진행(고려시 ConcurrentHashMap, AtomicLong사용을 고려해야함)package com.mvc1.servlet.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstruct...",
    "content": "동시성 문제 고려안하고 진행(고려시 ConcurrentHashMap, AtomicLong사용을 고려해야함)package com.mvc1.servlet.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Member {    private Long id;    private String username;    private int age;}package com.mvc1.servlet.domain;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class MemberRespository {    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();    private static Long seq = 0L;    private static final MemberRespository instance = new MemberRespository();    public static MemberRespository getInstance(){ //싱글톤(사실 싱글톤이라서 위에 static빼도됨)        return instance;    }    private MemberRespository(){    }    public Member save(Member member){        member.setId(seq);        store.put(member.getId(), member);        seq++;        return member;    }    public Member findById(Long id){        return store.get(id);    }    public List&lt;Member&gt; findAll(){        return new ArrayList&lt;&gt;(store.values());    }}package com.mvc1.servlet.domain;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class MemberRepository {    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();    private static Long seq = 0L;    private static final MemberRepository instance = new MemberRepository();    public static MemberRepository getInstance(){ //싱글톤(사실 싱글톤이라서 위에 static빼도됨)        return instance;    }    private MemberRepository(){    }    public Member save(Member member){        member.setId(seq);        store.put(member.getId(), member);        seq++;        return member;    }    public Member findById(Long id){        return store.get(id);    }    public List&lt;Member&gt; findAll(){        return new ArrayList&lt;&gt;(store.values());    }    public void clearStore(){        store.clear();    }}package com.mvc1.servlet.domain;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.*;@SpringBootTestclass MemberRepositoryTest {    MemberRepository mRepo = MemberRepository.getInstance();    @AfterEach()    void afterEach(){        mRepo.clearStore();    }    @Test    void save(){        Member member = new Member(\"hello\", 20);        Member saveMember = mRepo.save(member);        Member findMember = mRepo.findById(saveMember.getId());        assertThat(findMember).isEqualTo(saveMember);    }    @Test    void findAll(){        Member member = new Member(\"hello\", 20);        Member member2 = new Member(\"hello\", 20);        mRepo.save(member);        mRepo.save(member2);        List&lt;Member&gt; result = mRepo.findAll();        assertThat(result.size()).isEqualTo(2);    }}서블릿package com.mvc1.servlet.web;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name=\"memberFormServlet\", urlPatterns = \"/servlet/members/new-form\")public class MemberFormServlet extends HttpServlet {    MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        response.setContentType(\"text/html\");        response.setCharacterEncoding(\"utf-8\");        PrintWriter w = response.getWriter();        w.write(\"&lt;!DOCTYPE html&gt;\\n\" +                \"&lt;html&gt;\\n\" +                \"&lt;head&gt;\\n\" +                \" &lt;meta charset=\\\"UTF-8\\\"&gt;\\n\" +                \" &lt;title&gt;Title&lt;/title&gt;\\n\" +                \"&lt;/head&gt;\\n\" +                \"&lt;body&gt;\\n\" +                \"&lt;form action=\\\"/servlet/members/save\\\" method=\\\"post\\\"&gt;\\n\" +                \" username: &lt;input type=\\\"text\\\" name=\\\"username\\\" /&gt;\\n\" +                \" age: &lt;input type=\\\"text\\\" name=\\\"age\\\" /&gt;\\n\" +                \" &lt;button type=\\\"submit\\\"&gt;전송&lt;/button&gt;\\n\" +                \"&lt;/form&gt;\\n\" +                \"&lt;/body&gt;\\n\" +                \"&lt;/html&gt;\\n\");    }}package com.mvc1.servlet.web;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name=\"memberSaveServlet\", urlPatterns = \"/servlet/members/save\")public class MemberSaveServlet extends HttpServlet {    MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println(\"MemberSaveServlet.service\");        String username = request.getParameter(\"username\");        int age = Integer.parseInt(request.getParameter(\"age\"));        Member member = new Member(username, age);        System.out.println(\"member = \" + member);        memberRepository.save(member);        response.setContentType(\"text/html\");        response.setCharacterEncoding(\"utf-8\");        PrintWriter w = response.getWriter();        w.write(\"&lt;html&gt;\\n\" +                \"&lt;head&gt;\\n\" +                \" &lt;meta charset=\\\"UTF-8\\\"&gt;\\n\" +                \"&lt;/head&gt;\\n\" +                \"&lt;body&gt;\\n\" +                \"성공\\n\" +                \"&lt;ul&gt;\\n\" +                \" &lt;li&gt;id=\"+member.getId()+\"&lt;/li&gt;\\n\" +                \" &lt;li&gt;username=\"+member.getUsername()+\"&lt;/li&gt;\\n\" +                \" &lt;li&gt;age=\"+member.getAge()+\"&lt;/li&gt;\\n\" +                \"&lt;/ul&gt;\\n\" +                \"&lt;a href=\\\"/index.html\\\"&gt;메인&lt;/a&gt;\\n\" +                \"&lt;/body&gt;\\n\" +                \"&lt;/html&gt;\");    }}package com.mvc1.servlet.web;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.List;@WebServlet(name=\"memberListServlet\", urlPatterns = \"/servlet/members/list\")public class MemberListServlet extends HttpServlet {    MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        List&lt;Member&gt; members = memberRepository.findAll();        PrintWriter w = response.getWriter();        w.write(\"&lt;html&gt;\");        w.write(\"&lt;head&gt;\");        w.write(\" &lt;meta charset=\\\"UTF-8\\\"&gt;\");        w.write(\" &lt;title&gt;Title&lt;/title&gt;\");        w.write(\"&lt;/head&gt;\");        w.write(\"&lt;body&gt;\");        w.write(\"&lt;a href=\\\"/index.html\\\"&gt;메인&lt;/a&gt;\");        w.write(\"&lt;table&gt;\");        w.write(\" &lt;thead&gt;\");        w.write(\" &lt;th&gt;id&lt;/th&gt;\");        w.write(\" &lt;th&gt;username&lt;/th&gt;\");        w.write(\" &lt;th&gt;age&lt;/th&gt;\");        w.write(\" &lt;/thead&gt;\");        w.write(\" &lt;tbody&gt;\");        for (Member member : members) {            w.write(\" &lt;tr&gt;\");            w.write(\" &lt;td&gt;\" + member.getId() + \"&lt;/td&gt;\");            w.write(\" &lt;td&gt;\" + member.getUsername() + \"&lt;/td&gt;\");            w.write(\" &lt;td&gt;\" + member.getAge() + \"&lt;/td&gt;\");            w.write(\" &lt;/tr&gt;\");        }        w.write(\" &lt;/tbody&gt;\");        w.write(\"&lt;/table&gt;\");        w.write(\"&lt;/body&gt;\");        w.write(\"&lt;/html&gt;\");    }}…별거없음 근데 저 HTML을 어떻게 저렇게 다 해?? + 동적 불가능→ 템플릿 엔진사용(JSP, Thymeleaf, Freemaker, Velocity 등)JSPimplementation 'org.apache.tomcat.embed:tomcat-embed-jasper'implementation 'jakarta.servlet:jakarta.servlet-api' //스프링부트 3.0 이상implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api' //스프링부트 3.0 이상implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl' //스프링부트 3.0 이상gradle추가&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-29  Time: 오후 9:26  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=\"/jsp/members/save.jsp\" method=\"post\"&gt;        username: &lt;input type=\"text\" name=\"username\" /&gt;        age: &lt;input type=\"text\" name=\"age\" /&gt;        &lt;button type=\"submit\"&gt;전송&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;이게 인텔리제이에서 만들어준 jsp형식임. form만 붙인거&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;이게 있어야 jsp라는뜻&lt;%@ page import=\"com.mvc1.servlet.domain.Member\" %&gt;&lt;%@ page import=\"com.mvc1.servlet.domain.MemberRepository\" %&gt;&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-29  Time: 오후 9:34  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%  MemberRepository memberRepository = MemberRepository.getInstance();  String username = request.getParameter(\"username\");  int age = Integer.parseInt(request.getParameter(\"age\"));  Member member = new Member(username, age);  memberRepository.save(member);%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;  &lt;li&gt;id=&lt;%=member.getId()%&gt;&lt;/li&gt;  &lt;li&gt;username=&lt;%=member.getUsername()%&gt;&lt;/li&gt;  &lt;li&gt;age=&lt;%=member.getAge()%&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;% %&gt;부분이 자바 코드임reuquest, response는 import(맨위에 &lt;%@ page import ~~~%&gt; 부분)안해줘도 그냥 쓸수있음자바코드 출력은 &lt;%= ~~~ %&gt;로 해야함&lt;%@ page import=\"java.util.List\" %&gt;&lt;%@ page import=\"com.mvc1.servlet.domain.MemberRepository\" %&gt;&lt;%@ page import=\"com.mvc1.servlet.domain.Member\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%  MemberRepository memberRepository = MemberRepository.getInstance();  List&lt;Member&gt; members = memberRepository.findAll();%&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"/index.html\"&gt;메인&lt;/a&gt;&lt;table&gt;  &lt;thead&gt;  &lt;th&gt;id&lt;/th&gt;  &lt;th&gt;username&lt;/th&gt;  &lt;th&gt;age&lt;/th&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;%    for (Member member : members) {      out.write(\" &lt;tr&gt;\");      out.write(\" &lt;td&gt;\" + member.getId() + \"&lt;/td&gt;\");      out.write(\" &lt;td&gt;\" + member.getUsername() + \"&lt;/td&gt;\");      out.write(\" &lt;td&gt;\" + member.getAge() + \"&lt;/td&gt;\");      out.write(\" &lt;/tr&gt;\");    }  %&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;for문도 가능  [!important]변경주기가 다르다는 것이 중요함변경의 라이프사이클리 다른부분을 함께 관리하는 것은 좋지않음! - ui일부수정과 비지니스로직을 동시수정하는 일은 거의 없음MVC꼭 view에서 HTML파일을 생성하는것은 아니라고함. 엑셀이든 다른 것으로 생성하는것도 가능하다고package com.mvc1.servlet.web.servletmvc;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name=\"mvcMemberFormServlet\", urlPatterns = \"/servlet-mvc/members/new-form\")public class MvcMemberFormServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        String viewPath = \"/WEB-INF/views/new-form.jsp\"; //jsp생성        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath); //컨트롤러-&gt;뷰 이동시 사용        dispatcher.forward(request, response); //서블릿에서 jsp호출    }}&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-30  Time: 오후 8:36  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 상대경로 사용, [현재 URL이 속한 계층 경로 + /save] --&gt;    &lt;!-- http://localhost:8080/servlet-mvc/members/save --&gt;    &lt;form action=\"save\" method=\"post\"&gt;        username: &lt;input type=\"text\" name=\"username\" /&gt;        age: &lt;input type=\"text\" name=\"age\" /&gt;        &lt;button type=\"submit\"&gt;전송&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;아 위 서블릿 주소로 들어갔을때 저 저 위치의 jsp파을을 실행한다는거구나!dispatcher.forward()가 다른 서블릿이나 JSP로 이동할 수 있는 기능임. 서버내부에서 다시 호출 발생위에서는 service호출 후 서버 내에서 재호출이 일어나는거임(클라이언트에 다시다녀오는게아님. redirect랑은 다름)참고로 컨트롤러를 거쳐서만 부르고싶다면(외부호출x)면아래처럼 WEB-INF폴더 안에 넣으면됨— 이까지 현재경로 servlet-mvc/members/savepackage com.mvc1.servlet.web.servletmvc;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"mvcMemberSaveServlet\", urlPatterns = \"/servlet-mvc/members/save\")public class MvcMemberSaveServlet extends HttpServlet {    private MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         String username = request.getParameter(\"username\");         int age = Integer.parseInt(request.getParameter(\"age\"));         Member member = new Member(username, age);         System.out.println(\"member = \" + member);         memberRepository.save(member);         //Model에 데이터를 보관한다.         request.setAttribute(\"member\", member);         String viewPath = \"/WEB-INF/views/save-result.jsp\";         RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);         dispatcher.forward(request, response);     } }&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-30  Time: 오후 9:01  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;성공&lt;ul&gt;  &lt;li&gt;id=${member.id}&lt;/li&gt;  &lt;li&gt;username=${member.username}&lt;/li&gt;  &lt;li&gt;age=${member.age}&lt;/li&gt;&lt;/ul&gt;&lt;a href=\"/index.html\"&gt;메인&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;%= request.getAttribute(“member”)%&gt; 로 모델에 저장한 member 를 꺼낼수는 있는데 너무 복잡해서 JSP의 ${} 으로 request의 arrtibute에 담긴 데이터를 조회함package com.mvc1.servlet.web.servletmvc;import com.mvc1.servlet.domain.Member;import com.mvc1.servlet.domain.MemberRepository;import jakarta.servlet.RequestDispatcher;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(name = \"mvcMemberListServlet\", urlPatterns = \"/servlet-mvc/members\")public class MvcMemberListServlet extends HttpServlet {    private MemberRepository memberRepository = MemberRepository.getInstance();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         System.out.println(\"MvcMemberListServlet.service\");         List&lt;Member&gt; members = memberRepository.findAll();        request.setAttribute(\"members\", members);        String viewPath = \"/WEB-INF/views/members.jsp\";        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);        dispatcher.forward(request, response);    }}&lt;%--  Created by IntelliJ IDEA.  User: nod15  Date: 2023-05-30  Time: 오후 9:08  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"/index.html\"&gt;메인&lt;/a&gt;&lt;table&gt;  &lt;thead&gt;  &lt;th&gt;id&lt;/th&gt;  &lt;th&gt;username&lt;/th&gt;  &lt;th&gt;age&lt;/th&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;c:forEach var=\"item\" items=\"${members}\"&gt;    &lt;tr&gt;      &lt;td&gt;${item.id}&lt;/td&gt;      &lt;td&gt;${item.username}&lt;/td&gt;      &lt;td&gt;${item.age}&lt;/td&gt;    &lt;/tr&gt;  &lt;/c:forEach&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;forEach를 사용해서 테이블 출력— 단점  컨트롤러의 중복(request에서 값 뽑기, viewPath 등)  response를 사용하지않아도 매개변수로 response를 적어줌  공통 처리 어려움→ 프론트 컨트롤러 패턴 도입 시 해결가능"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 서블릿",
    "url": "/posts/%EC%84%9C%EB%B8%94%EB%A6%BF/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링MVC1, 서블릿",
    "date": "2023-04-17 00:00:00 +0900",
    





    
    "snippet": "package com.mvc1.servlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletCom...",
    "content": "package com.mvc1.servlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;@ServletComponentScan //서블릿 자동등록@SpringBootApplicationpublic class ServletApplication {\tpublic static void main(String[] args) {\t\tSpringApplication.run(ServletApplication.class, args);\t}}package com.mvc1.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.ServletRequest;import jakarta.servlet.ServletResponse;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import java.io.IOException;@WebServlet(name=\"helloServlet\", urlPatterns = \"/hello\")public class HelloServlet extends HttpServlet {    @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        super.service(req, res);    }}서블릿이 호출되면 위에 작성한 서비스에서 호출됨별다른 추가설정없이localhost:8080/hello?userName=kim로 들어가면 아래와같이 콘솔에 찍힘!!추가로 response까지 설정해주고package com.mvc1.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.ServletRequest;import jakarta.servlet.ServletResponse;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import java.io.IOException;@WebServlet(name=\"helloServlet\", urlPatterns = \"/hello\")public class HelloServlet extends HttpServlet {    @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        System.out.println(\"test\");        System.out.println(\"req = \" + req);        System.out.println(\"res = \" + res);//        super.service(req, res);        String userName = req.getParameter(\"userName\");        System.out.println(userName);        res.setContentType(\"text/plain\");        res.setCharacterEncoding(\"utf-8\");        res.getWriter().write(\"hello\"+userName);    }}localhost:8080으로 들어가면이렇게뜸참고로req = org.apache.catalina.connector.RequestFacade@258ac8b6res = org.apache.catalina.connector.ResponseFacade@425275f1이거application.properties에 logging.level.org.apache.coyote.http11=debug 이거 해주면            ![[IMG-20240909114444-2.png      IMG-20240909114444-2.png]]      요청정보, 헤더정보 조회가능함근데 운영서버에서 이러면 성능저하될수도있음. 개발단계에서만 사용해야함추가로 HttpServletRequest객체는 여러가지 부가기능(임시저장소기능) 등을 지원함  [!important]HttpServletRequest, HttpServletResponse는 HTTP 요청메세지, 응답메세지를 편리하게 사용하도록 도와주는 객체임. HTTP 스펙에 대한 깊은이해없이는 제대로 이해할수없음HttpServletRequestpackage com.mvc1.servlet.request;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.Cookie;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(name=\"requestHeaderServlet\", urlPatterns = \"/request-header\")public class RequestHeaderServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        extracted(request);        printHeaders(request);        printHeaderUtils(request);        printEtc(request);    }    private static void extracted(HttpServletRequest request) {        System.out.println(\"--- REQUEST-LINE - start ---\");        System.out.println(\"request.getMethod() = \" + request.getMethod()); //GET        System.out.println(\"request.getProtocol() = \" + request.getProtocol()); //HTTP/1.1        System.out.println(\"request.getScheme() = \" + request.getScheme()); //http        // http://localhost:8080/request-header        System.out.println(\"request.getRequestURL() = \" + request.getRequestURL());        // /request-header        System.out.println(\"request.getRequestURI() = \" + request.getRequestURI());        //username=hi        System.out.println(\"request.getQueryString() = \" +                request.getQueryString());        System.out.println(\"request.isSecure() = \" + request.isSecure()); //https 사용유무        System.out.println(\"--- REQUEST-LINE - end ---\");        System.out.println();    }    private void printHeaders(HttpServletRequest request){        System.out.println(\"-------------------header start-----------------------\");        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();        //들어온 헤더 전체 조회하는 법//        while (headerNames.hasMoreElements()){//            String headerName = headerNames.nextElement();//            System.out.println(headerName+\": \"+ headerName);//        } 옛날방식        //요즘방식        request.getHeaderNames().asIterator().forEachRemaining(headerName-&gt; System.out.println(headerName+\": \"+ headerName));        System.out.println(\"-------------------header end-----------------------\");    }    private void printHeaderUtils(HttpServletRequest request){        System.out.println(\"--- Header 편의 조회 start ---\");        System.out.println(\"[Host 편의 조회]\");        System.out.println(\"request.getServerName() = \" +                request.getServerName()); //Host 헤더        System.out.println(\"request.getServerPort() = \" +                request.getServerPort()); //Host 헤더        System.out.println();        System.out.println(\"[Accept-Language 편의 조회]\");        request.getLocales().asIterator()                .forEachRemaining(locale -&gt; System.out.println(\"locale = \" +                        locale));        System.out.println(\"request.getLocale() = \" + request.getLocale());        System.out.println();        System.out.println(\"[cookie 편의 조회]\");        if (request.getCookies() != null) {            for (Cookie cookie : request.getCookies()) {                System.out.println(cookie.getName() + \": \" + cookie.getValue());            }        }        System.out.println();        System.out.println(\"[Content 편의 조회]\");        System.out.println(\"request.getContentType() = \" +                request.getContentType());        System.out.println(\"request.getContentLength() = \" +                request.getContentLength());        System.out.println(\"request.getCharacterEncoding() = \" +                request.getCharacterEncoding());        System.out.println(\"--- Header 편의 조회 end ---\");        System.out.println();    }    //기타 정보    private void printEtc(HttpServletRequest request) {        System.out.println(\"--- 기타 조회 start ---\");        System.out.println(\"[Remote 정보]\");        System.out.println(\"request.getRemoteHost() = \" +                request.getRemoteHost()); //        System.out.println(\"request.getRemoteAddr() = \" +                request.getRemoteAddr()); //        System.out.println(\"request.getRemotePort() = \" +                request.getRemotePort()); //        System.out.println();        System.out.println(\"[Local 정보]\");        System.out.println(\"request.getLocalName() = \" +                request.getLocalName()); //        System.out.println(\"request.getLocalAddr() = \" +                request.getLocalAddr()); //        System.out.println(\"request.getLocalPort() = \" +                request.getLocalPort()); //        System.out.println(\"--- 기타 조회 end ---\");        System.out.println();    }}어차피 위의 내용들은 log설정으로 쉽게볼수있는 정보라서 가볍게 보고 넘어가면 될듯?추가로포스트맨으로 이렇게 보내면이렇게나옴. post도되는구만;;GET 쿼리 파라미터package com.mvc1.servlet.request;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"requestParamServlet\", urlPatterns = \"/request-param\")public class RequestParamServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse            resp) throws ServletException, IOException {        System.out.println(\"[전체 파라미터 조회] - start\");        request.getParameterNames().asIterator()                .forEachRemaining(paramName -&gt; System.out.println(paramName +                        \"=\" + request.getParameter(paramName)));        System.out.println(\"[전체 파라미터 조회] - end\");        System.out.println();        System.out.println(\"[단일 파라미터 조회]\");        String username = request.getParameter(\"username\");        System.out.println(\"request.getParameter(username) = \" + username);        String age = request.getParameter(\"age\");        System.out.println(\"request.getParameter(age) = \" + age);        System.out.println();        System.out.println(\"[이름이 같은 복수 파라미터 조회]\");        System.out.println(\"request.getParameterValues(username)\");        String[] usernames = request.getParameterValues(\"username\");        for (String name : usernames) {            System.out.println(\"username=\" + name);        }        resp.getWriter().write(\"ok\");    }}이렇게 나옴❗만약!! username=kim&amp;username=hello(이렇게 중복으로 오는 경우는 거의 없긴함)이딴식으로 들어온다면? request.getParameter()는 1파람 1값일때만 사용해야해서 위의 예시에서는 request.getParameterValues()을 사용해야함. 참고로 request.getParameter()를 쓰면 request.getParameterValues()의 첫번째값을 가져옴아래 결과 참조. localhost:8080/request-param?username=hi&amp;username=aaa 로 넣음HTML Form 방식위의 get요청은 쿼리파라미터 형식으로 데이터가 전달되었으나 form으로 전달 시 메세지 바디에 직접 데이터를 담아서 전달됨.참고로 POST요청만 가능함(되는데도있는데 되는것처럼 보이는?거라서 그냥 POST로 하면됨)쿼리파라미터나 메세지바디나 형식은 같아서 같은방법으로 꺼낼 수 있음요부분만 다른듯?get일때는 저부분이 null이었음⇒ post html form으로 보내면 데이터가 어떤 형식인지 꼭!!!지정해줘야함!! 폼으로 전송하는 방식은 application/x-www-form-urlencoded 임(그 포스트맨에서 form데이터로 보내달라고 요청할때 x-www-form-urlencoded에서 예시를 보내줬는데 그래서 그렇구나싶은?)  x-www-form-urlencoded랑 form-data 차이          form-data - 일반적으로 바이너리 데이터(파일 같은)와 텍스트 데이터가 포함된 양식을 제출할 때 사용. 바이너리 데이터는 “Content-Disposition” 헤더로 식별되는 각각의 부분으로써 요청 바디에 별도로 전송. 파일 업로드와 같은 복잡한 작업에 적합      x-www-form-urlencoded - 가장 널리 사용되며 일반적으로 간단한 텍스트 데이터를 제출할 때 사용. 데이터는 &amp; 기호로 구분되는 키-값 쌍으로 인코딩, 각 키와 값은 “=” 기호로 구분폼 데이터를 전송하는 간단한 경우에 적합      raw - 요청 바디에서 데이터를 원시 형식으로 전송. 서버는 이 데이터를 그대로 사용할 수 있으며, 주로 JSON 또는 XML 형식의 데이터를 전송할 때 사용서버가 데이터를 그대로 사용할 수 있게 하며, 주로 JSON 또는 XML 형식의 데이터를 전송하는 경우에 적합        API 메세지 바디            단순텍스트package com.mvc1.servlet.request;import jakarta.servlet.Servlet;import jakarta.servlet.ServletException;import jakarta.servlet.ServletInputStream;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.util.StreamUtils;import java.io.IOException;import java.nio.charset.StandardCharsets;@WebServlet(name=\"requestBodyStringServlet\", urlPatterns = \"/request-body-string\")public class RequestBodyStringServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        ServletInputStream inputStream = request.getInputStream();        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);        System.out.println(\"messageBody = \" + messageBody);        response.getWriter().write(\"ok\");    }}이거찍힘끝임jsonpackage com.mvc1.servlet.request;import jakarta.servlet.ServletException;import jakarta.servlet.ServletInputStream;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.util.StreamUtils;import java.io.IOException;import java.nio.charset.StandardCharsets;@WebServlet(name = \"requestBodyJsonServlet\", urlPatterns = \"/request-body-json\")public class RequestBodyJsonServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        ServletInputStream inputStream = request.getInputStream();        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);        System.out.println(\"messageBody = \" + messageBody);    }}덤으로package com.mvc1.servlet.request;import com.fasterxml.jackson.databind.ObjectMapper;import com.mvc1.servlet.HelloData;import jakarta.servlet.ServletException;import jakarta.servlet.ServletInputStream;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.util.StreamUtils;import java.io.IOException;import java.nio.charset.StandardCharsets;@WebServlet(name = \"requestBodyJsonServlet\", urlPatterns = \"/request-body-json\")public class RequestBodyJsonServlet extends HttpServlet {    private ObjectMapper objectMapper = new ObjectMapper();    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        ServletInputStream inputStream = request.getInputStream();        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);        System.out.println(\"messageBody = \" + messageBody);        HelloData data = objectMapper.readValue(messageBody, HelloData.class);        System.out.println(\"helloData.username = \" + data.getUsername());        System.out.println(\"helloData.age = \" + data.getAge());    }}이렇게하면 객체와 매핑가능근데 객체 내 변수와 이름이 다르니까 에러뜸당연하겠지만 타입안맞아도 에러남암튼 고쳤더니 잘뜸참고로 html form데이터도 같은방식으로 직접 읽을수는 있다고함. getParameter()한거랑 같은 결과나온다고근데 굳이?느낌?HTTPServletResponse편의 기능 제공 - content-Type, 쿠키, Redirectpackage com.mvc1.servlet.response;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name=\"responseHeaderServlet\", urlPatterns = \"/response-header\")public class ResponseHeaderServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {        //status-line//        response.setStatus(200);        response.setStatus(HttpServletResponse.SC_OK); //위랑 같으나 이렇게쓰는걸 권장함        //response-header        response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\");        response.setHeader(\"Cache-Control\", \"no-cache, must-revalidate\"); //캐쉬 완전 무효화        response.setHeader(\"Pragma\", \"no-cache\");        response.setHeader(\"my-header\", \"hello\");        PrintWriter writer = response.getWriter();        writer.println(\"ok\");    }}아래처럼 메소드로 빼는것도 가능package com.mvc1.servlet.response;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.Cookie;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name=\"responseHeaderServlet\", urlPatterns = \"/response-header\")public class ResponseHeaderServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {        //status-line//        response.setStatus(200);        response.setStatus(HttpServletResponse.SC_OK); //위랑 같으나 이렇게쓰는걸 권장함        //response-header//        response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\");        response.setHeader(\"Cache-Control\", \"no-cache, must-revalidate\"); //캐쉬 완전 무효화        response.setHeader(\"Pragma\", \"no-cache\");        response.setHeader(\"my-header\", \"hello\");        content(response);        cookie(response);        redirect(response);        PrintWriter writer = response.getWriter();        writer.println(\"ok\");    }    private void content(HttpServletResponse response) {        //Content-Type: text/plain;charset=utf-8        //Content-Length: 2        //response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\");        response.setContentType(\"text/plain\");        response.setCharacterEncoding(\"utf-8\");        //response.setContentLength(2); //(생략시 자동 생성)    }    private void cookie(HttpServletResponse response) {        //Set-Cookie: myCookie=good; Max-Age=600;        //response.setHeader(\"Set-Cookie\", \"myCookie=good; Max-Age=600\");        Cookie cookie = new Cookie(\"myCookie\", \"good\");        cookie.setMaxAge(600); //600초        response.addCookie(cookie);    }    private void redirect(HttpServletResponse response) throws IOException {        //Status Code 302        //Location: /basic/hello-form.html        //response.setStatus(HttpServletResponse.SC_FOUND); //302        //response.setHeader(\"Location\", \"/basic/hello-form.html\");        response.sendRedirect(\"/basic/hello-form.html\");    }}참고로 redirect는 다른url로 이동하는 그 redirect맞음응답데이터 - HTMLpackage com.mvc1.servlet.response;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = \"responseHtmlServlet\", urlPatterns = \"/response-html\")public class ResponseHtmlServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest request, HttpServletResponse            response)            throws ServletException, IOException {        //Content-Type: text/html;charset=utf-8        response.setContentType(\"text/html\");        response.setCharacterEncoding(\"utf-8\");        PrintWriter writer = response.getWriter();        writer.println(\"&lt;html&gt;\");        writer.println(\"&lt;body&gt;\");        writer.println(\" &lt;div&gt;안녕?&lt;/div&gt;\");        writer.println(\"&lt;/body&gt;\");        writer.println(\"&lt;/html&gt;\");    }}걍… 타입 html로 해서 하나하나 만들어준다는..;;HTTP 응답데이터 - API JSONpackage com.mvc1.servlet.response;import com.fasterxml.jackson.databind.ObjectMapper;import com.mvc1.servlet.HelloData;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = \"responseJsonServlet\", urlPatterns = \"/response-json\")public class ResponseJsonServlet extends HttpServlet {    private ObjectMapper objectMapper = new ObjectMapper();    @Override    protected void service(HttpServletRequest request, HttpServletResponse            response)            throws ServletException, IOException {        //Content-Type: application/json        response.setHeader(\"content-type\", \"application/json\");        response.setCharacterEncoding(\"utf-8\");        HelloData data = new HelloData();        data.setUsername(\"kim\");        data.setAge(20);        //{\"username\":\"kim\",\"age\":20}        String result = objectMapper.writeValueAsString(data);        response.getWriter().write(result);    }}이것도 걍 JSON으로 내보낸다는 거임"
  },
  
  {
    "title": "[김영한 Querydsl] QueryDsl 기능",
    "url": "/posts/Querydsl_%EA%B8%B0%EB%8A%A5/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-04-17 00:00:00 +0900",
    





    
    "snippet": "  [!important]제약사항이 많아서 실무에서는 사용하기 부족한 기능들을 모아놓음인터페이스 지원 QuerydslPredicateExecutorpackage com.kyh.querydsl2.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaReposi...",
    "content": "  [!important]제약사항이 많아서 실무에서는 사용하기 부족한 기능들을 모아놓음인터페이스 지원 QuerydslPredicateExecutorpackage com.kyh.querydsl2.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.querydsl.QuerydslPredicateExecutor;import com.kyh.querydsl2.entity.Member;public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepositoryCustom, QuerydslPredicateExecutor&lt;Member&gt;{    List&lt;Member&gt; findByUsername(String name);    }QuerydslPredicateExecutor를 상속받아서 querydsl을 조건으로 넣을 수 있음@Test    public void querydslPredicateExecutor(){        Team teamA = new Team(\"teamA\");        Team teamB = new Team(\"teamB\");        em.persist(teamA);        em.persist(teamB);        Member member1 = new Member(\"member1\", 10, teamA);        Member member2 = new Member(\"member2\", 20, teamA);        Member member3 = new Member(\"member3\", 30, teamB);        Member member4 = new Member(\"member4\", 40, teamB);        em.persist(member1);        em.persist(member2);        em.persist(member3);        em.persist(member4);                Iterable&lt;Member&gt; list = memberRepo.findAll(QMember.member.age.between(20, 40).and(QMember.member.username.eq(\"member1\")));        for(Member m : list){            System.out.println(m.getAge());            System.out.println(m.getUsername());            System.out.println(\"-----\");        }    }이런식으로 파라미터로 쿼리문을 넣을 수 있음. 해당 쿼리문은 where문에 조건으로 들어감.그러나 left join이 불가능. 실무에서는 거의 못쓴다고 보면됨. 또한 클라이언트가 querydsl에 의존함. 구현기술을 바꾼다면 대참사가 발생함.하긴 이럴바엔 mybatis를 쓰는게..querydsl Web파라미터 바인딩을 @QuerydslPredicate어노테이션을 사용해 predicate조건으로 달아줘서 파라미터로 넘기는 기능. 한번 만들어놓고 계속쓸수있다는 장점이 있음.그러나 역시 join불가능. 실무에서 사용하기에는.. 또한 사실상 eq만 사용가능하고 사전작업이 복잡함, 컨트롤러가 querydsl에 의존함.. 별로임QuerydslRepositorySupport추상클래스.public class MemberRepositoryImpl extends QuerydslRepositorySupport implements MemberRepositoryCustom,  {    // private final JPAQueryFactory queryfactory;    // public MemberRepositoryImpl(EntityManager em) {    //     this.queryfactory = new JPAQueryFactory(em);    // }    public MemberRepositoryImpl(){        super(Member.class);    }    @Override    public List &lt; MemberTeamDto &gt; search(MemberSearchCondition condition) {        return from(member)            .leftJoin(QMember.member.team, QTeam.team)            .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))            .select(new QMemberTeamDto(                QMember.member.id,                QMember.member.username,                QMember.member.age,                QTeam.team.id,                QTeam.team.name))                .fetch();        // return queryfactory        //     .select(new QMemberTeamDto(        //         QMember.member.id,        //         QMember.member.username,        //         QMember.member.age,        //         QTeam.team.id,        //         QTeam.team.name))        //     .from(QMember.member)        //     .leftJoin(QMember.member.team, QTeam.team)        //     .where(usernameEq(condition.getUsername()),        //         teamNameEq(condition.getTeamName()),        //         ageGoe(condition.getAgeGoe()),        //         ageLoe(condition.getAgeLoe()))        //     .fetch();    }\t\t@Override    public Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable){        // QueryResults&lt;MemberTeamDto&gt; results = queryfactory        // .select(new QMemberTeamDto(        //     QMember.member.id,        //     QMember.member.username,        //     QMember.member.age,        //     QTeam.team.id,        //     QTeam.team.name))        // .from(QMember.member)        // .leftJoin(QMember.member.team, QTeam.team)        // .where(usernameEq(condition.getUsername()),        //     teamNameEq(condition.getTeamName()),        //     ageGoe(condition.getAgeGoe()),        //     ageLoe(condition.getAgeLoe()))        //     .offset(pageable.getOffset())        //     .limit(pageable.getPageSize())        // .fetchResults();        JPQLQuery&lt;MemberTeamDto&gt; results =             from(QMember.member)            .leftJoin(QMember.member.team, QTeam.team)            .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))            .select(new QMemberTeamDto(                QMember.member.id.as(\"memberId\"),                QMember.member.username,                QMember.member.age,                QTeam.team.id.as(\"teamId\"),                QTeam.team.name).as(\"teamName\"));        // System.out.println(results);        // List&lt;MemberTeamDto&gt; content = results.getResults();        // Long total = results.getTotal();        // return new PageImpl&lt;&gt;(content, pageable, total);        JPQLQuery&lt;MemberTeamDto&gt; query = getQuerydsl().applyPagination(pageable, results);        query.fetch();    }주석한 내용을 위처럼 바꿈. 페이징에 편리한 기능을 제공(코드 몇줄 줄어듬)그러나, sort에서 오류가남(버그, 우회해서사용은 가능하다고함), querydsl 3.xx을 대상으로 만들어서 querydsl 4.x에 나온 JPAQueryFactory와 QueryFactory를 사용할 수 없으며 select로 시작할 수 없음.이 페이지에서는 제일 쓸만한 기능인듯함.Querydsl 지원 클래스 직접만들기위의 QuerydslRepositorySupport를 보완하기 위한 방법  spring 데이터가 제공하는 페이징을 편리하게 변환가능  페이징과 카운트 쿼리 분리 가능  스프링데이터 sort지원  select, selectFrom으로 시작가능  EntityManager, QueryFactory 제공package com.kyh.querydsl2.repository.support;import java.util.List;import java.util.function.Function;import com.querydsl.core.types.Expression;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.repository.support.JpaEntityInformation;import org.springframework.data.jpa.repository.support.JpaEntityInformationSupport;import org.springframework.data.jpa.repository.support.Querydsl;import org.springframework.data.querydsl.SimpleEntityPathResolver;import org.springframework.data.support.PageableExecutionUtils;import org.springframework.stereotype.Repository;import org.springframework.util.Assert;import com.querydsl.core.types.EntityPath;import com.querydsl.core.types.dsl.PathBuilder;import com.querydsl.jpa.impl.JPAQuery;import com.querydsl.jpa.impl.JPAQueryFactory;import jakarta.annotation.PostConstruct;import jakarta.persistence.EntityManager;/** * Querydsl 4.x 버전에 맞춘 Querydsl 지원 라이브러리 * * @author Younghan Kim * @see org.springframework.data.jpa.repository.support.QuerydslRepositorySupport */@Repositorypublic abstract class Querydsl4RepositorySupport {    private final Class domainClass;    private Querydsl querydsl;    private EntityManager entityManager;    private JPAQueryFactory queryFactory;    public Querydsl4RepositorySupport(Class &lt; ? &gt; domainClass) {        Assert.notNull(domainClass, \"Domain class must not be null!\");        this.domainClass = domainClass;    }    @Autowired    public void setEntityManager(EntityManager entityManager) {        Assert.notNull(entityManager, \"EntityManager must not be null!\");        JpaEntityInformation entityInformation =            JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);        SimpleEntityPathResolver resolver = SimpleEntityPathResolver.INSTANCE;        EntityPath path = resolver.createPath(entityInformation.getJavaType());        this.entityManager = entityManager;        this.querydsl = new Querydsl(entityManager, new PathBuilder &lt; &gt; (path.getType(), path.getMetadata()));        this.queryFactory = new JPAQueryFactory(entityManager);    }    @PostConstruct    public void validate() {        Assert.notNull(entityManager, \"EntityManager must not be null!\");        Assert.notNull(querydsl, \"Querydsl must not be null!\");        Assert.notNull(queryFactory, \"QueryFactory must not be null!\");    }    protected JPAQueryFactory getQueryFactory() {        return queryFactory;    }    protected Querydsl getQuerydsl() {        return querydsl;    }    protected EntityManager getEntityManager() {        return entityManager;    }    protected &lt; T &gt; JPAQuery &lt; T &gt; select(Expression &lt; T &gt; expr) {        return getQueryFactory().select(expr);    }    protected &lt; T &gt; JPAQuery &lt; T &gt; selectFrom(EntityPath &lt; T &gt; from) {        return getQueryFactory().selectFrom(from);    }    protected &lt; T &gt; Page &lt; T &gt; applyPagination(Pageable pageable,        Function &lt; JPAQueryFactory, JPAQuery &gt; contentQuery) {        JPAQuery jpaQuery = contentQuery.apply(getQueryFactory());        List &lt; T &gt; content = getQuerydsl().applyPagination(pageable,            jpaQuery).fetch();        return PageableExecutionUtils.getPage(content, pageable,            jpaQuery::fetchCount);    }    protected &lt; T &gt; Page &lt; T &gt; applyPagination(Pageable pageable,        Function &lt; JPAQueryFactory, JPAQuery &gt; contentQuery, Function &lt; JPAQueryFactory,        JPAQuery &gt; countQuery) {        JPAQuery jpaContentQuery = contentQuery.apply(getQueryFactory());        List &lt; T &gt; content = getQuerydsl().applyPagination(pageable,            jpaContentQuery).fetch();        JPAQuery countResult = countQuery.apply(getQueryFactory());        return PageableExecutionUtils.getPage(content, pageable,            countResult::fetchCount);    }}package com.kyh.querydsl2.repository;import static com.kyh.querydsl2.entity.QMember.member;import static com.kyh.querydsl2.entity.QTeam.team;import static org.springframework.util.StringUtils.hasText;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.support.PageableExecutionUtils;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.entity.Member;import com.kyh.querydsl2.repository.support.Querydsl4RepositorySupport;import com.querydsl.core.types.dsl.BooleanExpression;import com.querydsl.jpa.impl.JPAQuery;public class MemberTestRepository extends Querydsl4RepositorySupport{    public MemberTestRepository() {        super(Member.class);    }    public List&lt;Member&gt; basicSelect(){        return select(member).from(member).fetch();            }    public List&lt;Member&gt; basicSelectFrom(){        return selectFrom(member).fetch();    }        //기존 사용방법    public Page&lt;Member&gt; searchPageByApplyPage(MemberSearchCondition condition, Pageable pageable){        JPAQuery&lt;Member&gt; query = selectFrom(member)        .leftJoin(member.team, team)        .where(usernameEq(condition.getUsername()),            teamNameEq(condition.getTeamName()),            ageGoe(condition.getAgeGoe()),            ageLoe(condition.getAgeLoe()));        List&lt;Member&gt; content = getQuerydsl().applyPagination(pageable, query).fetch();        return PageableExecutionUtils.getPage(content, pageable,            query::fetchCount);    }    //위와 같은 코드임.    public Page&lt;Member&gt; applyPagination(MemberSearchCondition condition, Pageable pageable){        return applyPagination(pageable, query-&gt;            query.selectFrom(member)                .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))        );    }\t\t//count쿼리 분리    public Page&lt;Member&gt; applyPagination2(MemberSearchCondition condition, Pageable pageable){        return applyPagination(pageable, query-&gt;            query.selectFrom(member)                .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))                ,countQuery-&gt;                    countQuery.select(member.id)                    .from(member)                    .leftJoin(member.team, team)                    .where(usernameEq(condition.getUsername()),                        teamNameEq(condition.getTeamName()),                        ageGoe(condition.getAgeGoe()),                        ageLoe(condition.getAgeLoe()))                );    }    private BooleanExpression usernameEq(String username) {        return !hasText(username) ? null : member.username.eq(username);    }    private BooleanExpression teamNameEq(String teamName) {        return !hasText(teamName) ? null : team.name.eq(teamName);    }    private BooleanExpression ageGoe(Integer ageGoe) {        return ageGoe == null ? null : member.age.goe(ageGoe);    }    private BooleanExpression ageLoe(Integer ageLoe) {        return ageLoe == null ? null : member.age.loe(ageLoe);    }    }Querydsl4RepositorySupport에서 만들어놓은 메소드를 불러와서 훨신 깔끔하게 코드작성 가능함."
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 스프링 시큐리티",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/",
    "categories": "Spring",
    "tags": "spring, security",
    "date": "2023-02-24 00:00:00 +0900",
    





    
    "snippet": "로그아웃은 프론트일임!!!!마찬가지로 sns로그인은 프론트일임세션, 모델을 사용할거면 안쓰는게 맞음토큰은 임의로 만료불가로그아웃은 프론트에서 브라우저 메모리에서 삭제아니면 백에서 레디스 이용찾아보면 테이블을 분리하는경우가 많은데 회원 권한이 하나라면 하나로 통합해도됨이거임plugins {\tid 'java'\tid 'war'\tid 'org.springfr...",
    "content": "로그아웃은 프론트일임!!!!마찬가지로 sns로그인은 프론트일임세션, 모델을 사용할거면 안쓰는게 맞음토큰은 임의로 만료불가로그아웃은 프론트에서 브라우저 메모리에서 삭제아니면 백에서 레디스 이용찾아보면 테이블을 분리하는경우가 많은데 회원 권한이 하나라면 하나로 통합해도됨이거임plugins {\tid 'java'\tid 'war'\tid 'org.springframework.boot' version '3.0.2'\tid 'io.spring.dependency-management' version '1.1.0'}group = 'com.example'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-web'\timplementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.0'\tcompileOnly 'org.projectlombok:lombok'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\truntimeOnly 'com.mysql:mysql-connector-j'\tannotationProcessor 'org.projectlombok:lombok'\tprovidedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\ttestImplementation 'org.springframework.boot:spring-boot-starter-security'\timplementation 'org.springframework.boot:spring-boot-starter-security'\timplementation \"io.jsonwebtoken:jjwt-api:0.11.5\"\timplementation \"io.jsonwebtoken:jjwt-jackson:0.11.5\"\timplementation \"io.jsonwebtoken:jjwt-impl:0.11.5\"}tasks.named('test') {\tuseJUnitPlatform()}설정 후server:  port: 9988spring:  datasource:    url: jdbc:mysql://localhost:3306/security_test_bd    username: root    password: 1234jwt:  secretKey: {key}permission:  permit-all-urls:    - /api/member/login    - /api/member/joinsecretKey는 충분히 길어야함이까지해서 회원가입 되야함.. 안되면 문제있는거— 로그인package com.example.security_test.mapper;import com.example.security_test.vo.entity.MemberInfoVO;import com.example.security_test.vo.request.LoginVO;import com.example.security_test.vo.request.MemberJoinVO;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface MemberMapper {    void insertMember(MemberJoinVO data);    Boolean isDuplicatedId(String id);    MemberInfoVO getMemberInfoByMemberId(String id);    MemberInfoVO getMemberInfoByLoginInfo(LoginVO login);}&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"        \"http://mabatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.example.security_test.mapper.MemberMapper\"&gt;    &lt;insert id=\"insertMember\"&gt;        INSERT INTO member_info(mi_id, mi_pwd, mi_name, mi_nickname)        VALUES(#{id}, #{pwd}, #{name}, #{nickname})    &lt;/insert&gt;    &lt;select id=\"isDuplicatedId\" resultType=\"java.lang.Boolean\"&gt;        select count(*) = 1 from member_info where mi_id = #{id}    &lt;/select&gt;    &lt;select id=\"getMemberInfoByMemberId\" resultType=\"com.example.security_test.vo.entity.MemberInfoVO\"&gt;        select * from member_info where mi_id = #{id}    &lt;/select&gt;    &lt;select id=\"getMemberInfoByLoginInfo\" resultType=\"com.example.security_test.vo.entity.MemberInfoVO\"&gt;        select * from member_info where mi_id = #{id} and mi_pwd = #{pwd}    &lt;/select&gt;&lt;/mapper&gt;@Transactionalpublic LoginResponseVO login(LoginVO login) throws Exception{    login.setPwd(AESAlgorithm.Encrypt(login.getPwd()));    MemberInfoVO member = memberMapper.getMemberInfoByLoginInfo(login);    if(member==null){        return LoginResponseVO.builder()                .status(false).message(\"ID or PWD Error\").code(HttpStatus.UNAUTHORIZED).build();    } else if (!member.isEnabled()) {        return LoginResponseVO.builder()                .status(false).message(\"이용정지됨\").code(HttpStatus.UNAUTHORIZED).build();    }    UsernamePasswordAuthenticationToken authenticationToken =            new UsernamePasswordAuthenticationToken(member.getMi_id(), member.getMi_pwd());    Authentication authentication =            authenticationManagerBuilder.getObject().authenticate(authenticationToken);    return LoginResponseVO.builder()            .status(true)            .message(\"정상 로그인\")            .token(jwtTokenProvider.generateToken(authentication))            .code(HttpStatus.OK)            .build();}@PostMapping(\"/login\")public ResponseEntity&lt;LoginResponseVO&gt; postMemberLogin(@RequestBody LoginVO login) throws Exception{    LoginResponseVO response = memberService.login(login);    return new ResponseEntity&lt;&gt;(response, response.getCode());}위처럼 해서 토큰 나와야함매핑 정보가 틀려도 안됨 415가아니고 403뜨니까 알아둘것.나머지 기능은 토큰없이 접근 불가능함Bearer Token 선택하고 위의 access Token을 붙여넣기하면 이용가능함. 토큰이없으면 403뜸— 회원 정보 조회public MemberDetailResponseVO getUserDetailInfo(String userId){        try{            customUserDetailService.loadUserByUsername(userId);            MemberInfoVO member = memberMapper.getMemberInfoByMemberId(userId);            SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");            return MemberDetailResponseVO.builder()                   .id(member.getMi_id())                    .name(member.getMi_name())                    .nickname(member.getMi_nickname())                    .registered(formatter.format(member.getMi_reg_dt()))                    .build();        }catch (UsernameNotFoundException e){            return null;        }    }@GetMapping(\"/detail/{userId}\")    public ResponseEntity&lt;MemberDetailResponseVO&gt; getMemberDetail(@PathVariable String userId){        return new ResponseEntity&lt;&gt;(memberService.getUserDetailInfo(userId), HttpStatus.OK);    }이렇게하면 다른 회원의 정보도 볼수있다는 문제가있음. 비밀번호 한번 더 입력하면 됨jwt:  secretKey: {key}permission:  permit-all-urls:    - /api/member/login    - /api/member/join    - /api/product/**- /api/product/** 는 product/ 요청을 모두 허용한다는 의미임— entity"
  },
  
  {
    "title": "[김영한 Querydsl] Spring Data Jpa와 QueryDsl",
    "url": "/posts/springdatajpa%EC%99%80querydsl/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-02-08 00:00:00 +0900",
    





    
    "snippet": "StringUtils.hasText → null과 “” 둘다 체크하는 방법!!!!!!!! 값이있으면 true, 없으면 false 반환사용자 정의 repositorypackage com.kyh.querydsl2.repository;import java.util.List;import com.kyh.querydsl2.dto.MemberSearchCondit...",
    "content": "StringUtils.hasText → null과 “” 둘다 체크하는 방법!!!!!!!! 값이있으면 true, 없으면 false 반환사용자 정의 repositorypackage com.kyh.querydsl2.repository;import java.util.List;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.dto.MemberTeamDto;public interface MemberRepositoryCustom {    List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition);}일단 querydsl을 사용할 repository를 만들어서 ~~ repositoryImpl 라는 이름으로 구현체를 만들어줌. 이름 규칙은 바뀌면안됨package com.kyh.querydsl2.repository;import java.util.List;import org.springframework.util.StringUtils;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.dto.MemberTeamDto;import com.kyh.querydsl2.dto.QMemberTeamDto;import com.kyh.querydsl2.entity.QMember;import com.kyh.querydsl2.entity.QTeam;import com.querydsl.core.types.dsl.BooleanExpression;import com.querydsl.jpa.impl.JPAQueryFactory;import jakarta.persistence.EntityManager;public class MemberRepositoryImpl implements MemberRepositoryCustom {    private final JPAQueryFactory queryfactory;    public MemberRepositoryImpl(EntityManager em) {        this.queryfactory = new JPAQueryFactory(em);    }    @Override    public List &lt; MemberTeamDto &gt; search(MemberSearchCondition condition) {        return queryfactory            .select(new QMemberTeamDto(                QMember.member.id,                QMember.member.username,                QMember.member.age,                QTeam.team.id,                QTeam.team.name))            .from(QMember.member)            .leftJoin(QMember.member.team, QTeam.team)            .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))            .fetch();    }    private BooleanExpression usernameEq(String username) {        return StringUtils.hasText(username) ? QMember.member.username.eq(username) : null;    }    private BooleanExpression teamNameEq(String teamName) {        return StringUtils.hasText(teamName) ? QTeam.team.name.eq(teamName) : null;    }    private BooleanExpression ageGoe(Integer ageGoe) {        return ageGoe == null ? null : QMember.member.age.goe(ageGoe);    }    private BooleanExpression ageLoe(Integer ageLoe) {        return ageLoe == null ? null : QMember.member.age.loe(ageLoe);    }}package com.kyh.querydsl2.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import com.kyh.querydsl2.entity.Member;public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepositoryCustom{    List&lt;Member&gt; findByUsername(String name);    }그리고 MemberRepositoryCustom을 extends함.package com.kyh.querydsl2;import static org.assertj.core.api.Assertions.assertThat;import java.util.List;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.transaction.annotation.Transactional;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.dto.MemberTeamDto;import com.kyh.querydsl2.entity.Member;import com.kyh.querydsl2.entity.Team;import com.kyh.querydsl2.repository.MemberRepository;import jakarta.persistence.EntityManager;@SpringBootTest@Transactionalclass MemberRepositoryTest {    @Autowired    EntityManager em;    @Autowired    MemberRepository memberRepo;     @Test    public void searchTest() {        Team teamA = new Team(\"teamA\");        Team teamB = new Team(\"teamB\");        em.persist(teamA);        em.persist(teamB);        Member member1 = new Member(\"member1\", 10, teamA);        Member member2 = new Member(\"member2\", 20, teamA);        Member member3 = new Member(\"member3\", 30, teamB);        Member member4 = new Member(\"member4\", 40, teamB);        em.persist(member1);        em.persist(member2);        em.persist(member3);        em.persist(member4);        MemberSearchCondition condition = new MemberSearchCondition();        condition.setAgeGoe(35);        condition.setAgeLoe(40);        condition.setTeamName(\"teamB\");        List &lt; MemberTeamDto &gt; result = memberRepo.search(condition);        assertThat(result).extracting(\"username\").containsExactly(\"member4\");        //username에 member4가 있는지?            }}사용꼭 custom에 묶여있을 필요는 없음. 그냥 repository class를 하나 만들어서 거기다가 만들어줘도됨. (특정 API에 묶여있다면 별도의 조회용 repository를 만들어도 좋다는 의미같음)페이징package com.kyh.querydsl2.repository;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import com.kyh.querydsl2.dto.MemberSearchCondition;import com.kyh.querydsl2.dto.MemberTeamDto;public interface MemberRepositoryCustom {    List&lt;MemberTeamDto&gt; search(MemberSearchCondition condition);    Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable);    Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable);}@Overridepublic Page&lt;MemberTeamDto&gt; searchPageSimple(MemberSearchCondition condition, Pageable pageable){    QueryResults&lt;MemberTeamDto&gt; results = queryfactory    .select(new QMemberTeamDto(        QMember.member.id,        QMember.member.username,        QMember.member.age,        QTeam.team.id,        QTeam.team.name))    .from(QMember.member)    .leftJoin(QMember.member.team, QTeam.team)    .where(usernameEq(condition.getUsername()),        teamNameEq(condition.getTeamName()),        ageGoe(condition.getAgeGoe()),        ageLoe(condition.getAgeLoe()))        .offset(pageable.getOffset())        .limit(pageable.getPageSize())    .fetchResults();    List&lt;MemberTeamDto&gt; content = results.getResults();    Long total = results.getTotal();    return new PageImpl&lt;&gt;(content, pageable, total);}오버라이딩 해줌@Testpublic void searchPage() {    Team teamA = new Team(\"teamA\");    Team teamB = new Team(\"teamB\");    em.persist(teamA);    em.persist(teamB);    Member member1 = new Member(\"member1\", 10, teamA);    Member member2 = new Member(\"member2\", 20, teamA);    Member member3 = new Member(\"member3\", 30, teamB);    Member member4 = new Member(\"member4\", 40, teamB);    em.persist(member1);    em.persist(member2);    em.persist(member3);    em.persist(member4);    MemberSearchCondition condition = new MemberSearchCondition();    PageRequest pageRequest = PageRequest.of(0, 3);    Page &lt; MemberTeamDto &gt; result = memberRepo.searchPageSimple(condition, pageRequest);    assertThat(result.getSize()).isEqualTo(3);    assertThat(result.getContent()).extracting(\"username\").containsExactly(\"member1\", \"member2\", \"member3\");    }count와 limit 두개가 나감@Overridepublic Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable){    List&lt;MemberTeamDto&gt; content = queryfactory    .select(new QMemberTeamDto(        QMember.member.id,        QMember.member.username,        QMember.member.age,        QTeam.team.id,        QTeam.team.name))    .from(QMember.member)    .leftJoin(QMember.member.team, QTeam.team)    .where(usernameEq(condition.getUsername()),        teamNameEq(condition.getTeamName()),        ageGoe(condition.getAgeGoe()),        ageLoe(condition.getAgeLoe()))        .offset(pageable.getOffset())        .limit(pageable.getPageSize())    .fetch();    Long total = queryfactory            .select(QMember.member)            .from(QMember.member)            .leftJoin(QMember.member.team, QTeam.team)            .where(usernameEq(condition.getUsername()),                teamNameEq(condition.getTeamName()),                ageGoe(condition.getAgeGoe()),                ageLoe(condition.getAgeLoe()))                .offset(pageable.getOffset())                .limit(pageable.getPageSize())            .fetchCount();    return new PageImpl&lt;&gt;(content, pageable, total);}count쿼리를 분리해서 해도 됨.count 쿼리 최적화@Override    public Page&lt;MemberTeamDto&gt; searchPageComplex(MemberSearchCondition condition, Pageable pageable){        List&lt;MemberTeamDto&gt; content = queryfactory        .select(new QMemberTeamDto(            QMember.member.id,            QMember.member.username,            QMember.member.age,            QTeam.team.id,            QTeam.team.name))        .from(QMember.member)        .leftJoin(QMember.member.team, QTeam.team)        .where(usernameEq(condition.getUsername()),            teamNameEq(condition.getTeamName()),            ageGoe(condition.getAgeGoe()),            ageLoe(condition.getAgeLoe()))            .offset(pageable.getOffset())            .limit(pageable.getPageSize())        .fetch();        JPAQuery&lt;Member&gt; countQuery = queryfactory                .select(QMember.member)                .from(QMember.member)                .leftJoin(QMember.member.team, QTeam.team)                .where(usernameEq(condition.getUsername()),                    teamNameEq(condition.getTeamName()),                    ageGoe(condition.getAgeGoe()),                    ageLoe(condition.getAgeLoe()));        return PageableExecutionUtils.getPage(content, pageable, ()-&gt;countQuery.fetchCount());        //return PageableExecutionUtils.getPage(content, pageable, countQuery::fetchCount);\t\t\t\t//위와 같은 표현임    }이렇게하면 count쿼리가 필요하지 않을때(ex.마지막페이지)는 spring data jpa가 자동으로 쿼리문을 안날림."
  },
  
  {
    "title": "[김영한 Querydsl] 중급문법",
    "url": "/posts/%EC%A4%91%EA%B8%89%EB%AC%B8%EB%B2%95/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-02-06 00:00:00 +0900",
    





    
    "snippet": "프로젝션 결과 반환 - 기본프로젝션 : select 대상 지정— 프로젝션 대상이 하나일때List&lt;String&gt; result = queryFactory.select(member.username).from(member).fetch();— 프로젝션 대상이 둘 이상  튜플@Test    public void testQuerydsl4(){      ...",
    "content": "프로젝션 결과 반환 - 기본프로젝션 : select 대상 지정— 프로젝션 대상이 하나일때List&lt;String&gt; result = queryFactory.select(member.username).from(member).fetch();— 프로젝션 대상이 둘 이상  튜플@Test    public void testQuerydsl4(){        JPAQueryFactory query = new JPAQueryFactory(em);        // List&lt;String&gt; result = query        //     .select(QMember.member.username)        //     .from(QMember.member)        //     .fetch();                    // for(String member : result){        //     System.out.println(member);        // }        List&lt;Tuple&gt; result = query            .select(QMember.member.username, QMember.member.age)            .from(QMember.member)            .fetch();                    for(Tuple tuple : result){            System.out.println(tuple.get(QMember.member.username));            System.out.println(tuple.get(QMember.member.age));            System.out.println(\"-----\");        }    }위처럼 원하는 값만 가져오는 거를 프로젝션이라고 함  DTO 조회(추천)                  setter를 통한 사용방법          @Test      public void findDtoBySetter(){          JPAQueryFactory query = new JPAQueryFactory(em);          List&lt;MemberDto&gt; result = query              .select(Projections.bean(MemberDto.class, QMember.member.username, QMember.member.age))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                Setter와 기본생성자가 있어야 실행됨 아니면 QBean.newInstance 에러 발생. setter를 통해서 들어가는 거임                    필드 사용 방법          @Test      public void findDtoByField(){          JPAQueryFactory query = new JPAQueryFactory(em);          List&lt;MemberDto&gt; result = query              .select(Projections.fields(MemberDto.class, QMember.member.username, QMember.member.age))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                getter, setter가 없어도 필드에 자동으로 세팅됨.        필드이름이 안맞으면 안됨. 정 안되면          @Test      public void findDtoByField(){          JPAQueryFactory query = new JPAQueryFactory(em);          List&lt;MemberDto&gt; result = query              .select(Projections.fields(MemberDto.class,                   QMember.member.username.as(\"username\"),                   QMember.member.age.as(\"age\")              ))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                아래처럼 as를 통해 별칭을 지정해주면 됨          @Test      public void findDtoByField2(){          JPAQueryFactory query = new JPAQueryFactory(em);          QMember membersub = new QMember(\"memberSub\");          List&lt;MemberDto&gt; result = query              .select(Projections.fields(MemberDto.class,                   QMember.member.username.as(\"username\"),                   ExpressionUtils.as(JPAExpressions                  .select(membersub.age.max())                  .from(membersub)                  , \"age\") //최고령자 나이만 찍힘              ))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                이런식으로 응용도 가능함.                    생성자를 통한 사용방법          @Test      public void findDtoByField(){          JPAQueryFactory query = new JPAQueryFactory(em);          List&lt;MemberDto&gt; result = query              .select(Projections.constructor(MemberDto.class, QMember.member.username, QMember.member.age))              .from(QMember.member)              .fetch();                              for(MemberDto dto : result){              System.out.println(dto.getUsername());              System.out.println(dto.getAge());              System.out.println(\"-----\");          }      }                타입이 정확히 일치해야함. 타입으로 들어가는거라서 필드이름이 다른건 상관없음            @QueryProjectionDTO 생성자에 @QueryProjection어노테이션을 달아서 gradle로 Qentity를 재 생성해주면 QDTO도 생성됨package com.kyh.querydsl2.dto;import com.querydsl.core.annotations.QueryProjection;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructorpublic class MemberDto {    private String username;    private int age;    @QueryProjection    public MemberDto(String username, int age){        this.username=username;        this.age = age;    }}이렇게하면 DTO의 생성자로 바로 반환가능함@Testpublic void findDto(){  JPAQueryFactory query = new JPAQueryFactory(em);  List&lt;MemberDto&gt; member = query      .select(new QMemberDto(QMember.member.username, QMember.member.age))      .from(QMember.member)      .fetch();  for(MemberDto m : member){      System.out.println(m.getUsername());      System.out.println(m.getAge());      System.out.println(\"=====\");  }}위의 생성자를 통한 방법보다 나은방법. 엔티티의 생성자를 통하면 컴파일시점에서 오류를 잡아낼 수 없지만 이건 컴파일시점에서 오류를 알 수 있음. 파라미터 숫자나 개수가 안맞으면 에러뜸.그러나 DTO가 querydsl에 의존된다는 단점이 있음.동적 쿼리  BooleanBuilder@Test    public void dynamicQuery_BooleanBuilder(){        String username = \"member1\";        Integer ageParam = 10;        List&lt;Member&gt; result = searchMember1(username, ageParam);        Assertions.assertThat(result.size()).isEqualTo(1);    }    private List&lt;Member&gt; searchMember1(String usernameCond, Integer ageCond){        JPAQueryFactory query = new JPAQueryFactory(em);        //null이 아닌게 보장이 된다면 이렇게 해도됨.         // BooleanBuilder builder = new BooleanBuilder(QMember.member.username.eq(usernameCond));        BooleanBuilder builder = new BooleanBuilder();        if(usernameCond!=null){            builder.and(QMember.member.username.eq(usernameCond));        }        if(ageCond!=null){            builder.and(QMember.member.age.eq(ageCond));        }        return query.selectFrom(QMember.member)                                .where(builder)                                .fetch();    }A값이 있다면 A조건을, B값이 잇다면 B조건을 검색하는 방법으로 활용됨. or조건도 가능함  Where 다중 파라미터@Test    public void dynamicQuery_WhereParam(){        String username = \"member1\";        Integer ageParam = 10;        List&lt;Member&gt; result = searchMember2(username, ageParam);        Assertions.assertThat(result.size()).isEqualTo(1);    }    private List&lt;Member&gt; searchMember2(String usernameCond, Integer ageCond){        JPAQueryFactory query = new JPAQueryFactory(em);        return query.selectFrom(QMember.member)                                .where(usernameEq(usernameCond), ageEq(ageCond))                                .fetch();    }    private Predicate ageEq(Integer ageCond) {        if(ageCond==null){            return null;        }        return QMember.member.age.eq(ageCond);        //삼항 연산자 써도 됨. ageCond==null?null:QMember.member.age.eq(ageCond);    }    private Predicate usernameEq(String usernameCond) {        if(usernameCond==null){            return null;        }        return QMember.member.username.eq(usernameCond);    }where(null)이되면 null은 무시한채로 쿼리문이 날아감날아가는 쿼리문에 where없음가독성이 더 좋다는 장점이 있음@Test    public void dynamicQuery_WhereParam(){        String username = \"member1\";        Integer ageParam = 10;        List&lt;Member&gt; result = searchMember2(username, ageParam);        Assertions.assertThat(result.size()).isEqualTo(1);    }    private List&lt;Member&gt; searchMember2(String usernameCond, Integer ageCond){        JPAQueryFactory query = new JPAQueryFactory(em);        return query.selectFrom(QMember.member)                                .where(allEq(usernameCond, ageCond))                                .fetch();    }    private BooleanExpression ageEq(Integer ageCond) {        if(ageCond==null){            return null;        }        return QMember.member.age.eq(ageCond);        //삼항 연산자 써도 됨. ageCond==null?null:QMember.member.age.eq(ageCond);    }    private BooleanExpression usernameEq(String usernameCond) {        if(usernameCond==null){            return null;        }        return QMember.member.username.eq(usernameCond);    }        private BooleanExpression allEq(String usernameCond, Integer ageCond){        return usernameEq(usernameCond).and(ageEq(ageCond));    }이런식으로 활용이 가능함. 코드가 깔끔해지고 재활용이 가능함수정, 삭제 벌크연산@Testpublic void bulkUpdate(){    JPAQueryFactory query = new JPAQueryFactory(em);    long count = query            .update(QMember.member)            .set(QMember.member.username, \"비회원\")            .where(QMember.member.age.lt(16))            .execute();    //영향을 받은 로우 수가 나옴    Assertions.assertThat(count).isEqualTo(2L);}저 뒤에 select문을 날리면 변경 전 데이터가 나옴, 쿼리문은 나가지만 영속성 컨텍스트가 가져온 값을 버리고 기존 값을 쓰기때문이라고 함.근데 난 왜 변경된게 나오는거지..?아무튼 변경하고 em.clear, em.flush하라고함spring data jpa라서 그런거같음~long count = query    .update(QMember.member)    .set(QMember.member.age, QMember.member.age.add(1))    .where(QMember.member.age.lt(16))    .execute();더하기는 이렇게하면됨. 곱하기는 multiply, 빼기는 add(-1) 이렇게해야함 마이너스함수는 없음long count = query        .delete(QMember.member)        .where(QMember.member.age.gt(16))        .execute();삭제 쿼리SQL function@Testpublic void sql(){  JPAQueryFactory query = new JPAQueryFactory(em);  List&lt;String&gt; result = query      .select(Expressions.stringTemplate(          \"function('replace',{0},{1},{2})\",          QMember.member.username, \"member\",\"M\"))          .from(QMember.member)          .fetch();  //영향을 받은 로우 수가 나옴  // Assertions.assertThat(count).isEqualTo(2L);  em.flush();  em.clear();  for(String m : result){      System.out.println(m);      System.out.println(\"===\");  }}registerFunction에 있는 거만 쓸 수 있음없으면 mysqlDialect에서 등록해서 써야함List&lt;String&gt; result = query            .select(QMember.member.username)            .from(QMember.member)            .where(QMember.member.username.eq(                // Expressions.stringTemplate(\"function('lower',{0})\", QMember.member.username)))                QMember.member.username.lower()))            .fetch();어지간한건 다 지원중이라서 그냥 저렇게쓰면될듯"
  },
  
  {
    "title": "[김영한 스프링 MVC 1] 웹 애플리케이션 이해",
    "url": "/posts/%EC%9B%B9%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%B4%ED%95%B4/",
    "categories": "Spring",
    "tags": "spring, mvc, 김영한스프링MVC1",
    "date": "2023-02-05 00:00:00 +0900",
    





    
    "snippet": "웹서버 : HTTP기반으로 동작. 정적 리소스 제공, 기타 부가기능. ex) NGINX, APACHE웹 애플리케이션 서버(WAS) : HTTP기반으로 동작, 웹 서버 기능 포함+(정적 리소스 제공 기능), 프로그램코드를 실행해서 애플리케이션 로직을 수행(동적 HTML, HTTP API[JSON], 서블릿, JSP, 스프링 MVC), ex)톰캣 Jett...",
    "content": "웹서버 : HTTP기반으로 동작. 정적 리소스 제공, 기타 부가기능. ex) NGINX, APACHE웹 애플리케이션 서버(WAS) : HTTP기반으로 동작, 웹 서버 기능 포함+(정적 리소스 제공 기능), 프로그램코드를 실행해서 애플리케이션 로직을 수행(동적 HTML, HTTP API[JSON], 서블릿, JSP, 스프링 MVC), ex)톰캣 Jetty, Undertow— 웹 서버, 웹 애플리케이션 서버의 차이  웹서버          정적 리소스(파일[HTML, CSS, JS, 이미지, 영상])      그러나 프로그램을 실행하는 기능을 포함하기도함        웹 애플리케이션 서버(WAS)          프로그램코드를 실행해서 애플리케이션 로직을 수행                  동적 HTML, HTTP API(JSON)          서블릿, JSP, 스프링 MVC          ex) 톰캣 Jetty, Undertow                    그러나 웹 서버의 기능을 제공함              JAVA는 서블릿 컨테이너 기능을 제공하면 WAS  그러나 서블릿없이 자바코드를 실행하는 서버 프레임워크도 있음            애플리케이션코드를 실행하는데 더 특화됨      ⇒ 결론 : 용어도 경계도 애매함. 개인적으로 이해하기로는 요청이왔을때 파일로 응답하면 웹서버, 코드로 응답하면 was라는거같음— 웹 시스템 구성 - WAS, DB  WAS, DB 만으로 시스템 구성이 가능함.  WAS는 정적 리소스, 애플리케이션 로직 모두 제공가능함.  그러나 WAS가 너무 많은 역할을 담당(애플리케이션 로직, html, css, js, 이미지 등), 서버과부화 우려있음  가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수도 있음 (싼거 처리한다고 비싼거 처리못함)  WAS장애시 오류 화면(죄송합니다~~하는 에러창)도 노출 불가능함. (생각보다 잘 죽음)→ 웹 시스템 구성 - WEB, WAS, DE  정적 리소스는 웹 서버가 처리  웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임  WAS는 중요한 애플리케이션 로직 처리 전담  시스템 리소스를 효율적으로 사용 가능  정적 리소스가 많이 사용되면 Web서버 증설 → 잘 죽지않음(계산하는 로직이 없음)  애플리케이션 리소스가 많이 사용되면 WAS서버 증설  WAS, DB 장애시 WEB서버가 오류 화면을 송출 가능함(==오류화면 HTML==)서블릿위의 의미없는 로직을 자동화 하기위해 나온 것이 서블릿.서블릿을 지원하는 WAS를 사용하면 의미있는 비즈니스 로직만 실행됨. 그외업무는 자동화되는거임.  urlPatterns의 URL이 호출되면 서블릿 코드가 실행됨.      HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest        위 메소드에 파라미터로 받으면 이걸 자동으로 만들어준다는거임 request.getusername하면 kim이 나옴        HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse        위 메소드의 파라미터로 받으면 이걸 만들어준다는거임    개발자는 HTTP 스펙을 매우 편리하게 사용— HTTP 요청, 응답 흐름서블릿 컨테이너가 서블릿 객체를 자동으로 생성, 호출, 생명주기 관리(WAS종료시 함께 종료됨)  HTTP 요청시          WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체를 호출      개발자는 Request 객체에서 HTTP 요청정보를 편리하게 꺼내서 사용함.      개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력함      WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답정보를 생성함.      서블릿 컨테이너  톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함  서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리함  서블릿 객체는 싱글톤으로 관리됨          고객의 요청이 올때마다 새 객체를 생성하는 것이 비효율임  위 그림에서 request와 response는 매번 새로 생성되는것이 맞으나(고객마다, request마다 정보가 다름) helloServlet이 계속 새로 생성될 필요는 없다는 뜻임. 고객의 요청이올때마다 helloservlet을 생성하는것은 비효율적이기때문  → 들어온 request를 가지고 이미 만들어진 helloservlet에서 작업을 처리, response에 처리결과를 세팅 후 내보냄      최초 로딩 시점에 서블릿 객체를 미리 만들고 재활용함      모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근  같은 서버라면 어떤 사용자가 요청해도 같은 서블릿 인스턴스에 접근됨.      공유 변수 사용 주의  → 같은 서블릿 인스턴스를 사용하다가 다른 회원의 정보가 보인다면 대참사가 일어남!!      서블릿 컨테이너 종료 시 함께 종료됨        JSP도 서블릿으로 변환되어서 사용  동시요청을 위한 멀티 쓰레드 처리 지원동시요청 - 멀티 쓰레드⭐매우 중요!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!위 그림에서 서블릿 객체는 누가 호출하나? ⇒ 쓰레드쓰레드: 애플리케이션 코드를 하나하나 순차적으로 실행하는 것  java main 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행됨  쓰레드가 없다면 자바 애플리케이션 실행이 불가능함.  쓰레드는 한번에 하나의 코드 라인만 수행가능  동시 처리가 필요하다면 쓰레드를 추가로 생성해야함  쓰레드 하나 사용시 단일 요청          요청이 오면 연결이 쓰레드를 할당해서 servlet을 호출함 응답이 끝나면 쓰레드는 휴식        쓰레드 하나 사용시 다중 요청          요청이 와서 스레드가 요청을 처리중일때 다른 요청이 들어오면 쓰레드가 할일을 끝낼때까지 대기함. 1차 요청이 처리지연이라도 되면 둘다 터지는 사태가 발생함.  ⇒ 요청마다 쓰레드를 생성하는 방법으로 해결                  요청1이 들어오면 쓰레드1이 처리를 하고 요청2가 들어오면 쓰레드2가 처리를 하는 방식 → 처리가 지연되도 상관없음.          장점                          동시요청 처리가능, 리소스(CPU, 메모리)가 허용할 때까지 처리가능함.              하나의 쓰레드가 지연되도 나머지는 정상작동함                                단점                          쓰레드 생성 비용이 비싸고 요청이 올때마다 쓰레드를 생성하면 응답속도가 늦어짐                              쓰레드는 컨텍스트 스위칭 비용이 발생함  사실 코어 하나가 쓰레드 두개를 동시 실행할 수 없으나 속도가 빠르니까 동시에 처리하는 것처럼 보이는거임. 그래서 이 두 쓰레드를 전환할때 비용이 발생함. 이걸 콘텍스트 스위칭 비용이라고 부름(쓰레드가 많아지면 비용이 커짐)                            쓰레드 생성에 제한이 없어 요청이 너무 많이오면 CPU, 메모리 임계정을 넘어 서버가 죽을 수도 있음(CPU와 메모리 성능상 생성가능한 쓰레드 1000개라도 10000개의 요청이 들어오면 모든 쓰레드를 생성하다가 서버가 죽어버린다는 뜻임)  ⇒ 단점 보완을 위해 쓰레드 풀 도입                쓰레드 풀                                                        쓰레드를 담아놓는 풀을 생성. 요청이 들어오면 쓰레드 풀에 쓰레드를 요청함.(위처럼 200개의 쓰레드가 담긴 쓰레드 풀에 요청이 2개 들어오면 쓰레드 풀에는 198개의 쓰레드가 남음. 응답까지 끝나면 쓰레드풀에 쓰레드 반납함. 그럼 다시 200개됨)쓰레드를 다썼다고 쓰레드를 죽이지 않음!!만약!! 쓰레드 200개가 모두 사용중이라면?? 새로 들어온 요청은 쓰레드 대기상태가 되거나 거절됨.한 10개까지는 대기시키고 나머지는 거절하는 것도 가능함  쓰레드풀에 생성가능한 쓰레드의 최대치는 톰켓에서 기본 200개임(변경가능함)  쓰레드가 미리 생성되어있어서 쓰레드를 생성, 종료하는 비용(CPU)가 절약되고 응답시간이 빠름  너무 많은 요청이 들어와도 기존 요청은 안전하게 처리 가능함  [!important]WAS의 주요 튜닝 포인트는 최대 쓰레드의 수임.이 값을 너무 낮게 설정하면 서버 리소스는 여유롭지만 클라이언트는 응답지연이 금방옴.너무 높게 설정하면 CPU, 메모리 리소스 임계점 초과로 서버가 다운될 가능성이 높아짐실무에서 장애가 발생하면 일단 서버부터 늘리고 이후에 튜닝하는 것이 좋음. 클라우드가 아니면 열심히 튜닝할것.쓰레드 적정숫자는 애플리케이션 로직 복잡도, CPU, 메모리, IO리소스 상황에 따라 모두 다름. 성능테스트 후 결정하는 것이 가장 좋음.— 핵심 정리  멀티 쓰레드에대한 부분은 WAS가 처리함  개발자가 멀티쓰레드 관련 코드를 신경안써도 됨  개발자는 싱글쓰레드 프로그래밍을 하듯이 편리하게 소스코드를 개발하면됨  그러나 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용해야함. (일단 멀티쓰레드환경이니까)용어 정리  정적 리소소 : 고정된 HTML파일, CSS, JS, 이미지, 영상 등을 제공. 주로 웹브라우저      HTTP 페이지          동적으로 필요한 HTML파일을 생성해서 전달      웹 브라우저 : HTML 해석            HTTP API          HTML이 아니라 데이터를 전달(주로 JSON)      다양한 시스템에서 호출함      데이터만 주고받음. UI화면이 필요하면 클라이언트가 별도처리함      앱, 웹 클라이언트, 서버 to 서버      UI클라이언트 접점                  앱 클라이언트(아이폰, 안드로이드, PC앱)          웹 브라우저에서 자바 스크립트를 통한 HTTP API 호출          React, Vue.js 같은 웹 클라이언트                    서버 to 서버                  주문서버 → 결제서버          기업간 데이터 통신                      서버사이드 렌더링 (SSR) - 백엔드 필수서버에서 최종 HTML을 생성해서 클라에 전달. 주로 정적인 화면에 사용.(쉬움^^..)관련기술 : JSP, 타임리프 → 백엔드개발자가 사용  클라이언트 사이드 렌더링(CSR) - 프론트 분야HTML 결과를 자바스크립트를 사용해서 웹 브라우저에서 동적으로 생성해서 적용함. 주로 동적인 화면에 사용, 웹 환경을 앱처럼 필요한 부분부분 변경 가능함.ex) 구글 지도, Gmail, 구글 캘린더 등관련 기술 : React, Vue.js → 웹 프론트엔드 개발자가 사용  [!important]React, Vue.js를 CSR+SSR 동시에 지원하는 웹 프레임워크도 있음. SSR을 사용해도 자바스크립트를 사용해서 화면 일부를 동적으로 변경 가능함.❗백엔드 개발자에게 CSR은 옵션. 원래는 프론트개발자의 전문분야임.자바 웹 기술 역사  서블릿 - HTML 생성의 어려움  JSP - HTML생성은 편리하지만 비즈니스로직까지 너무 많은 역할 담당  서블릿 + JSP 조합 MVC 패턴 사용  MVC 패턴자동화, 다양한 기술지원, 스트럿츠, 웹워크, 스프링 MVC(과거버전)          was설치후 war파일을 만들어서 설치한 was에 배포        어노테이션기반의 스프링 MVC 등장      스프링부트 등장          서버 내장      빌드 결과 jar에 was서버 포함 → 빌드 배포 단순화        ⇒ MVC 프레임워크 시대 종료(모든 단점 해결)    Web servlet(Spring MVC), Web Reactive(Spring WebFlux)로 분화          Web servlet(위에 설명한걸 말함)      Web Reactive(최신기술)                  특징                          비동기 넌 블러킹 처리              최소 쓰레드로 최대 성능 - 쓰레드 컨텍스트 스위칭 비용 효율화              함수형 스타일로 개발 - 동시처리 코드 효율화              서블릿 기술 사용x                                그런데                          난이도 매우 높음              아직은 RDB 지원 부족 - nosql을 사용하면 좋은듯?              일반 MVC 쓰레드 모델도 충분히 빠름              실무에서 아직 많이 쓰이지는 않음(한 1%이하)                                          자바 뷰 템플릿의 역사HTML을 편리하게 생성하는 뷰 기능  JSP          속도 느림. 기능 부족        프리마커(FreeMarker), 벨로시티(Velocity)          속도 문제 해결, 다양한 기능        타임리프(Thymeleaf)          내추럴 템플릿 : HTML의 모양을 유지하면서 뷰 템플릿 적용가능      스프링 MVC와 강력한 기능 통합      최선의 선택, 단 성능은 프리마커, 벨로시티가 더 빠름      "
  },
  
  {
    "title": "[김영한 스프링 핵심원리 기본편] 스프링 컨테이너와 빈",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80_%EB%B9%88/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리기본편",
    "date": "2023-01-29 00:00:00 +0900",
    





    
    "snippet": "스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);ApplicationContext(인터페이스임)를 스프링 컨테이너라고 부름 - 정확히는 BeanFactory, ApplicationContext로 구분해서 부르는...",
    "content": "스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);ApplicationContext(인터페이스임)를 스프링 컨테이너라고 부름 - 정확히는 BeanFactory, ApplicationContext로 구분해서 부르는데 BeanFactory를 사용하는 경우가 거의 없음XML기반이나 어노테이션 기반의 자바 설정 클래스로 만들 수 있음. 직전 강의에서 사용한 AppConfig가 어노테이션기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것.new AnnotationConfigApplicationContext(Appconfig.class); 이게 ApplicationContext 인터페이스의 구현체임저상태로 실행하면 메소드 이름이 key값이 되서 스프링 컨테이너에 빈 객체가 저장됨. key값으로 bean객체를 꺼내올 수 있는 상태가 되는거임@Bean(name=”memberService2”) 이런식으로 이름을 따로 지정해줄수도 있음.빈 이름은 겹치면 안됨~ 덮어쓰기되거나 오류남]빈을 먼저 생성하고 의존관계를 주입하나 위처럼 자바코드로 빈을 등록하면 빈을 등록하면서 생성자를 호출해 의존관계 주입도 함께 됨.(그니까 위 사진처럼 orderService를 등록하려고보는데 discountPolicy()가 있어서 실행되는 과정에서 의존관계가 등록된다는 말인거같음)모든 빈 출력package com.hello.core.beanfind;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.hello.core.Appconfig;public class binfindTest {    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Appconfig.class);    @Test    @DisplayName(\"모든 빈 출력하기\")    void findAllBean(){        String[] beanDefinitionNames = ac.getBeanDefinitionNames();        for(String beanDefinitionName : beanDefinitionNames){            Object bean = ac.getBean(beanDefinitionName);            System.out.println(beanDefinitionName);            System.out.println(bean);            System.out.println(\"---------------\");        }    }}위에껀 스프링 자체의 빈. memberService부터가 내가 등록한 빈임만약 내가 등록한 빈만 보고싶다@Test    @DisplayName(\"애플리케이션 빈 출력하기\")    void findApplicationBean(){        String[] beanDefinitionNames = ac.getBeanDefinitionNames();        for(String beanDefinitionName : beanDefinitionNames){            BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);            if(beanDefinition.getRole()==BeanDefinition.ROLE_APPLICATION){                Object bean = ac.getBean(beanDefinitionName);                System.out.println(beanDefinitionName);                System.out.println(bean);                System.out.println(\"---------------\");            }        }    }  ROLE_APPLICATION : 직접 등록한 애플리케이션 빈  ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈  getBean() : 빈 이름으로 객체를 가져옴.스프링 빈 조회@Test@DisplayName(\"빈 이름으로 조회\")void findBeanByName(){    MemberService memberService = ac.getBean(\"memberService\", MemberService.class);    System.out.println(memberService);    System.out.println(memberService.getClass());    Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);}@Test@DisplayName(\"타입으로 조회\")void findBeanByType(){    MemberService memberService = ac.getBean(MemberService.class);    System.out.println(memberService);    System.out.println(memberService.getClass());    Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);}위와 동일한 결과@Test@DisplayName(\"구체타입으로 조회\")void findBeanByType2(){    MemberService memberService = ac.getBean(MemberServiceImpl.class);    System.out.println(memberService);    System.out.println(memberService.getClass());    Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);}이것도 동일함. 그러나 좋은방법은 아님. 이상적으로 돌아가지 않을때 사용하는 방법@Test@DisplayName(\"빈 이름 조회 실패\")void findBeanByName2(){    org.junit.jupiter.api.Assertions.assertThrows(        NoSuchBeanDefinitionException.class,         ()-&gt;ac.getBean(\"xxxx\",MemberService.class)    );}조회 실패 케이스동일타입 bean이 여러개일때@Test    @DisplayName(\"타입조회. 같은타입 둘 이상-&gt;중복오류발생\")    void sameType(){        MemberRepository member = ac.getBean(MemberRepository.class);    }    @Configuration    static class SameBeanConfig{        @Bean        public MemberRepository memberRepository1(){            return new MemoryMemberRepository();        }        @Bean        public MemberRepository memberRepository2(){            return new MemoryMemberRepository();        }    }오류남@Test    @DisplayName(\"타입조회. 같은타입 둘 이상-&gt;빈이름지정하면됨\")    void sameType2(){        MemberRepository memberRepository = ac.getBean(\"memberRepository1\", MemberRepository.class);        System.out.println(memberRepository);        Assertions.assertThat(memberRepository).isInstanceOf(MemberRepository.class);    }    @Test    @DisplayName(\"모든 타입 조회\")    void sameType3(){        Map&lt;String,MemberRepository&gt; memberRepository = ac.getBeansOfType(MemberRepository.class);        System.out.println(memberRepository);                for(String key : memberRepository.keySet()){            System.out.println(key);            System.out.println(memberRepository.get(key));            System.out.println(\"=====\");        }        Assertions.assertThat(memberRepository.size()).isEqualTo(2);    }이런식으로 해결하면됨.상속관계package com.hello.core.beanfind;import static org.junit.jupiter.api.Assertions.assertThrows;import java.util.Map;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.NoUniqueBeanDefinitionException;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.FixdiscountPolicy;import com.hello.core.discount.RateDiscountPolicy;public class ApplicationContextExtendsFIndTest {        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);    @Test    @DisplayName(\"부모타입 조회시 자식이 둘이상이면 중복오류\")    void findBeanByParentTypeDuplication(){        assertThrows(NoUniqueBeanDefinitionException.class, ()-&gt;ac.getBean(DiscountPolicy.class));    }    @Test    @DisplayName(\"부모타입 조회시 자식이 둘이상이면 빈이름 지정\")    void findBeanByParentTypeDuplication2(){        DiscountPolicy rateDiscountPolicy = ac.getBean(\"rateDiscountPolicy\", DiscountPolicy.class);        Assertions.assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class);    }    @Test    @DisplayName(\"특정 하위타입으로 조회\") //안좋은방법    void findBeanByParentTypeDuplication3(){        RateDiscountPolicy rateDiscountPolicy = ac.getBean(RateDiscountPolicy.class);        Assertions.assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class);    }    @Test    @DisplayName(\"부모타입으로 모두 조회\")     void findBeanByParentTypeDuplication4(){        Map&lt;String, DiscountPolicy&gt; beans = ac.getBeansOfType(DiscountPolicy.class);        Assertions.assertThat(beans).isEqualTo(2);        for(String key : beans.keySet()){            System.out.println(key);            System.out.println(beans.get(key));            System.out.println(\"====\");        }    }    @Test    @DisplayName(\"부모타입으로 모두 조회(Object)\")     void findBeanByParentTypeDuplication5(){        Map&lt;String, Object&gt; beans = ac.getBeansOfType(Object.class); //spring 내부적으로 등록된 bean까지 모두 출력됨        for(String key : beans.keySet()){            System.out.println(key);            System.out.println(beans.get(key));            System.out.println(\"====\");        }    }    @Configuration    static class TestConfig{        @Bean        public DiscountPolicy rateDiscountPolicy(){            return new RateDiscountPolicy();        }        @Bean        public DiscountPolicy fixDiscountPolicy(){            return new FixdiscountPolicy();        }    }}이것만 알아두면 됨"
  },
  
  {
    "title": "[김영한 Querydsl] 환경설정",
    "url": "/posts/%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-01-21 00:00:00 +0900",
    





    
    "snippet": "build.gradle의 plugins에 id \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10”설정 추가dependencies에 implementation 'com.querydsl:querydsl-jpa’ 라이브러리 추가맨 하단에(test밑에)def querydslDir = “$buildDir/generat...",
    "content": "build.gradle의 plugins에 id \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10”설정 추가dependencies에 implementation 'com.querydsl:querydsl-jpa’ 라이브러리 추가맨 하단에(test밑에)def querydslDir = “$buildDir/generated/querydsl”querydsl {jpa = truequerydslSourcesDir = querydslDir}sourceSets {main.java.srcDir querydslDir}configurations {querydsl.extendsFrom compileClasspath}compileQuerydsl {options.annotationProcessorPath = configurations.querydsl}추가plugins {\tid 'java'\tid 'org.springframework.boot' version '3.0.1'\tid 'io.spring.dependency-management' version '1.1.0'\tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\"}group = 'com.kyh'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\timplementation 'org.springframework.boot:spring-boot-starter-webflux'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\tcompileOnly 'org.projectlombok:lombok'\truntimeOnly 'com.mysql:mysql-connector-j'\tannotationProcessor 'org.projectlombok:lombok'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\ttestImplementation 'io.projectreactor:reactor-test'\timplementation 'com.querydsl:querydsl-jpa'}tasks.named('test') {\tuseJUnitPlatform()}//querydsl 추가 시작def querydslDir = \"$buildDir/generated/querydsl\"querydsl {\tjpa = true\tquerydslSourcesDir = querydslDir}sourceSets {\tmain.java.srcDir querydslDir}configurations {\tquerydsl.extendsFrom compileClasspath}compileQuerydsl {\toptions.annotationProcessorPath = configurations.querydsl}//querydsl 추가 끝저거 실행❗❗ 스프링부트 3.0이상 일때buildscript {   ext {      queryDslVersion = \"5.0.0\"   }}plugins {\tid 'java'\tid 'war'\tid 'org.springframework.boot' version '3.0.1'\tid 'io.spring.dependency-management' version '1.1.0'\tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\"}group = 'com.kyh'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-data-jdbc'\timplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\timplementation 'org.springframework.boot:spring-boot-starter-web'\tcompileOnly 'org.projectlombok:lombok'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\truntimeOnly 'com.mysql:mysql-connector-j'\tannotationProcessor 'org.projectlombok:lombok'\tprovidedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\timplementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'\tannotationProcessor \"com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta\"}tasks.named('test') {\tuseJUnitPlatform()}//querydsl 추가 시작def querydslDir = \"$buildDir/generated/querydsl\"querydsl {   jpa = true   querydslSourcesDir = querydslDir}sourceSets {   main.java.srcDir querydslDir}compileQuerydsl{   options.annotationProcessorPath = configurations.querydsl}configurations {   compileOnly {      extendsFrom annotationProcessor   }   querydsl.extendsFrom compileClasspath}//querydsl 추가 끝이렇게 추가해야함위에 설정해준 폴더에 Qentity가 생겼는지 확인. 생겨야 된거임package com.kyh.querydsl2.entity;import static com.querydsl.core.types.PathMetadataFactory.*;import com.querydsl.core.types.dsl.*;import com.querydsl.core.types.PathMetadata;import javax.annotation.processing.Generated;import com.querydsl.core.types.Path;/** * QHello is a Querydsl query type for Hello */@Generated(\"com.querydsl.codegen.DefaultEntitySerializer\")public class QHello extends EntityPathBase&lt;Hello&gt; {    private static final long serialVersionUID = -1622153575L;    public static final QHello hello = new QHello(\"hello\");    public final NumberPath&lt;Long&gt; id = createNumber(\"id\", Long.class);    public QHello(String variable) {        super(Hello.class, forVariable(variable));    }    public QHello(Path&lt;? extends Hello&gt; path) {        super(path.getType(), path.getMetadata());    }    public QHello(PathMetadata metadata) {        super(Hello.class, metadata);    }}빌드하면 자동으로 만들어준다고함깃에 Qentity는 올리면 안된다고함!!!!!!!!!!!!!!!!!!!!!!!!!보통 build폴더를 ignore하고 쓰기때문에 ignore하고 여기만들면 안올라가긴함.— 근데 위 방법으로 하면 컴파일에 문제가 생기는거같아서buildscript {   ext {      queryDslVersion = \"5.0.0\"   }}plugins {\tid 'java'\tid 'war'\tid 'org.springframework.boot' version '3.0.1'\tid 'io.spring.dependency-management' version '1.1.0'\tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\"}group = 'com.kyh'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-data-jdbc'\timplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\timplementation 'org.springframework.boot:spring-boot-starter-web'\tcompileOnly 'org.projectlombok:lombok'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\truntimeOnly 'com.mysql:mysql-connector-j'\tannotationProcessor 'org.projectlombok:lombok'\tprovidedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\timplementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'\tannotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'}tasks.named('test') {\tuseJUnitPlatform()}//querydsl 추가 시작def querydslDir = \"$buildDir/generated/querydsl\"querydsl {   jpa = true   querydslSourcesDir = querydslDir}sourceSets {   main.java.srcDir querydslDir}compileQuerydsl{   options.annotationProcessorPath = configurations.querydsl}configurations {   compileOnly {      extendsFrom annotationProcessor   }   querydsl.extendsFrom compileClasspath}//querydsl 추가 끝이 방법으로 수정함. 이렇게하니까 JPAQueryFactory도 사용가능함(학원에서는 위버전이 됨)"
  },
  
  {
    "title": "[김영한 Querydsl] 기본문법",
    "url": "/posts/%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/",
    "categories": "JPA",
    "tags": "spring, jpa, querydsl, 김영한Querydsl",
    "date": "2023-01-21 00:00:00 +0900",
    





    
    "snippet": "@Testpublic void TestJPQL(){    Member findJPQL = em.createQuery(\"select m from Member m where m.username=:username\", Member.class).setParameter(\"username\", \"member1\").getSingleResult();    Asserti...",
    "content": "@Testpublic void TestJPQL(){    Member findJPQL = em.createQuery(\"select m from Member m where m.username=:username\", Member.class).setParameter(\"username\", \"member1\").getSingleResult();    Assertions.assertThat(findJPQL.getUsername()).isEqualTo(\"member1\");}@Testpublic void testQuerydsl(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember m = new QMember(\"m\");    Member member = query.select(m).from(m).where(m.username.eq(\"member1\")).fetchOne();    System.out.println(member);    Assertions.assertThat(member.getUsername()).isEqualTo(\"member1\");}파라미터 바인딩을 안해줬는데 자동으로 해줌.기본 Q-Type@Testpublic void testQuerydsl(){  JPAQueryFactory query = new JPAQueryFactory(em);  // QMember m = new QMember(\"m\");  Member member = query.select(QMember.member).from(QMember.member).where(QMember.member.username.eq(\"member1\")).fetchOne();  System.out.println(member);  // Assertions.assertThat(member.getUsername()).isEqualTo(\"member1\");}이렇게 써도됨. import를 static으로 해주면 member만 써줘도 됨Qentity에 이렇게 정의되있어서 터미널에뜨는 sql문에는 테이블 별칭이 member1로 되있음. 미리 QMember m = new QMember(“m”);이런식으로 설정해주면 테이블별칭이 m으로 바뀜. 셀프조인할때 진짜 간혹 한번씩 쓰기도하는듯검색조건 쿼리Member member = query.select(QMember.member)            .from(QMember.member)            .where(QMember.member.username.eq(\"member1\").and(QMember.member.age.eq(10)))            .fetchOne();이런식으로 가능함. and말고 or조건도 가능함Member member = query.select(QMember.member)            .from(QMember.member)            .where(                QMember.member.username.eq(\"member1\"),                QMember.member.age.eq(10)            )            .fetchOne();위랑 같은결과가 나옴. and를 쓰지않더라도 콤마로 구분가능member.username.eq(\"member1\") // username = 'member1'member.username.ne(\"member1\") //username != 'member1'member.username.eq(\"member1\").not() // username != 'member1'member.username.isNotNull() //이름이 is not nullmember.age.in(10, 20) // age in (10,20)member.age.notIn(10, 20) // age not in (10, 20)member.age.between(10,30) //between 10, 30member.age.goe(30) // age &gt;= 30member.age.gt(30) // age &gt; 30member.age.loe(30) // age &lt;= 30member.age.lt(30) // age &lt; 30member.username.like(\"member%\") //like 검색member.username.contains(\"member\") // like ‘%member%’ 검색member.username.startsWith(\"member\") //like ‘member%’ 검색이거 외에도 많음. sql에 있는건 거의 다 있다고 보면됨결과조회위에서는 fetchOne()을 썼는데 fetch()를 쓰면 결과가 List로 나옴.  fetchOne() - 단건조회  fetch() - 리스트 조회, 데이터가 없다면 빈 리스트 반환  fetchFirst() - limit(1).fetchOne()과 같은 결과  fetchResults() - 페이징 정보 포함, total count 쿼리 추가 실행 - 성능이 중요할땐 가급적 사용 하지말것  fetchCount() - count쿼리로 변경해서 count 수 조회JPAQueryFactory query = new JPAQueryFactory(em);//ListList&lt;Member&gt; fetch = query.selectFrom(QMember.member).fetch();//단 건Member findMember1 = query.selectFrom(QMember.member).fetchOne();//처음 한 건 조회Member findMember2 = query.selectFrom(QMember.member).fetchFirst();//페이징에서 사용QueryResults&lt;Member&gt; results = query.selectFrom(QMember.member).fetchResults(); //페이징 정보 포함되있음List&lt;Member&gt; content = results.getResults();//컨텐츠만 꺼내옴. results.getTotal(); //페이징을 위한 총 컨텐츠의 수 //쿼리 2번 날아감//count 쿼리로 변경(위 getTotal이랑 같은결과임)long count = query.selectFrom(QMember.member).fetchCount();정렬em.persist(new Member(null, 100));em.persist(new Member(\"member5\", 100));em.persist(new Member(\"member6\", 100));List&lt;Member&gt; result = queryFactory\t.selectFrom(member)\t.where(member.age.eq(100))\t.orderBy(member.age.desc(), member.username.asc().nullsLast())\t.fetch();Member member5 = result.get(0);Member member6 = result.get(1);Member memberNull = result.get(2);assertThat(member5.getUsername()).isEqualTo(\"member5\");assertThat(member6.getUsername()).isEqualTo(\"member6\");assertThat(memberNull.getUsername()).isNull();페이징@Testpublic void paging1() { List&lt;Member&gt; result = queryFactory\t .selectFrom(member)\t .orderBy(member.username.desc())\t .offset(1) //0부터 시작(zero index)\t .limit(2) //최대 2건 조회\t .fetch(); assertThat(result.size()).isEqualTo(2);}전체가 필요하다면@Testpublic void paging2() { QueryResults&lt;Member&gt; queryResults = queryFactory\t .selectFrom(member)\t .orderBy(member.username.desc())\t .offset(1)\t .limit(2)\t .fetchResults(); assertThat(queryResults.getTotal()).isEqualTo(4); assertThat(queryResults.getLimit()).isEqualTo(2); assertThat(queryResults.getOffset()).isEqualTo(1); assertThat(queryResults.getResults().size()).isEqualTo(2);}단, count쿼리도 같이 실행되니 성능 상 주의해야함집합@Testpublic void aggregation() throws Exception { List&lt;Tuple&gt; result = queryFactory\t .select(member.count(),\t\t member.age.sum(),\t\t member.age.avg(),\t\t member.age.max(),\t\t member.age.min())\t .from(member)\t .fetch(); Tuple tuple = result.get(0); assertThat(tuple.get(member.count())).isEqualTo(4); assertThat(tuple.get(member.age.sum())).isEqualTo(100); assertThat(tuple.get(member.age.avg())).isEqualTo(25); assertThat(tuple.get(member.age.max())).isEqualTo(40); assertThat(tuple.get(member.age.min())).isEqualTo(10);}tuple은 프로젝션과 결과반환에서 설명함. Querydsl이 제공함. 타입이 여러개일때 꺼내올 수 있는 기능을 하는거같음. 실무에선 DTO로 반환하는걸 더 많이쓴다고함  groupBy@Testpublic void group() throws Exception { List&lt;Tuple&gt; result = queryFactory\t .select(team.name, member.age.avg())\t .from(member)\t .join(member.team, team)\t .groupBy(team.name)\t .fetch(); Tuple teamA = result.get(0); Tuple teamB = result.get(1); assertThat(teamA.get(team.name)).isEqualTo(\"teamA\"); assertThat(teamA.get(member.age.avg())).isEqualTo(15); assertThat(teamB.get(team.name)).isEqualTo(\"teamB\"); assertThat(teamB.get(member.age.avg())).isEqualTo(35);  [!important]having가능함. .groupBy(item.price).having(item.price.gt(1000))이런식으로 쓰면됨조인@Testpublic void testQuerydsl2(){    JPAQueryFactory query = new JPAQueryFactory(em);    List&lt;Member&gt; result =query.selectFrom(QMember.member)        .join(QMember.member.team, QTeam.team)        .where(QTeam.team.name.eq(\"teamA\"))        .fetch();}left join, right join 가능함. join뒤에 on도 가능theta join(크로스 조인)도 가능@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    //회원이름과 팀이름이 같은 경우    List&lt;Member&gt; result =query.select(QMember.member)        .from(QMember.member, QTeam.team) //연관관계 없는 team과 member를 조인 가능함        .where(QMember.member.username.eq(QTeam.team.name))        .fetch();}외부조인은 on을 사용해야 가능함  on절                  조인 대상 필터링          List&lt;Tuple&gt; result = query.select(QMember.member, QTeam.team)              .from(QMember.member)              .leftJoin(QMember.member.team, QTeam.team).on(QTeam.team.name.eq(\"teamA\"))              .fetch();                ]]        내부조인을 하면 where절에서 필터링하는 것과 동일함(where t.team.name.eq(”teamA”)). 내부조인이면 where로 해결하고 외부조인이 필요할때만 사용하는 것을 권장함                    연관관계 없는 엔티티 외부조인          em.persist(new Member(\"teamA\"));  em.persist(new Member(\"teamB\"));  em.persist(new Member(\"teamC\"));          List&lt;Tuple&gt; result = query.select(QMember.member, QTeam.team)      .from(QMember.member)      .leftJoin(QTeam.team).on(QMember.member.username.eq(QTeam.team.name))       //leftjoin에 team만 적어줬기때문에 FK로 join하는 것이 아니라 on절을 기준으로 join함      .fetch();                                  페치 조인                  적용 전          @PersistenceUnit  EntityManagerFactory emf;  @Test  public void fetchJoinNo() throws Exception {  \t em.flush();  \t em.clear();          \t Member findMember = queryFactory  \t\t .selectFrom(member)  \t\t .where(member.username.eq(\"member1\"))  \t\t .fetchOne();             boolean loaded =\temf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());  \t\t//team이 로드되었는지를 확인함          \t assertThat(loaded).as(\"페치 조인 미적용\").isFalse();  }                        @Test  public void fetchJoinUse() throws Exception {  \t em.flush();  \t em.clear();      \t Member findMember = queryFactory  \t\t .selectFrom(member)  \t\t .join(member.team, team).fetchJoin()  \t\t .where(member.username.eq(\"member1\"))  \t\t .fetchOne();      \t boolean loaded =\temf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());  \t\t//team이 로드되었는지를 확인함      \t assertThat(loaded).as(\"페치 조인 적용\").isTrue();  }      서브쿼리com.querydsl.jpa.JPAExpressions 사용— 나이가 가장 많은 회원@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember memberSub = new QMember(\"memberSub\");    List&lt;Member&gt; result = query        .selectFrom(QMember.member)        .where(QMember.member.age.eq(            JPAExpressions                .select(memberSub.age.max())                .from(memberSub)        ))        .fetch();    assertThat(result).extracting(\"age\").containsExactly(20);}— 나이가 평균 이상인 회원@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember memberSub = new QMember(\"memberSub\");    List&lt;Member&gt; result = query        .selectFrom(QMember.member)        .where(QMember.member.age.goe(            JPAExpressions                .select(memberSub.age.avg())                .from(memberSub)        ))        .fetch();    assertThat(result).extracting(\"age\").containsExactly(18,15,17);}— 나이가 10살 초과인 회원@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember memberSub = new QMember(\"memberSub\");    List&lt;Member&gt; result = query        .selectFrom(QMember.member)        .where(QMember.member.age.in(            JPAExpressions                .select(memberSub.age)                .from(memberSub)                .where(memberSub.age.gt(10))        ))        .fetch();    for(Member member : result){        System.out.println(member);    }}— select 절에 서브쿼리@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    QMember memberSub = new QMember(\"memberSub\");    List&lt;Tuple&gt; result = query        .select(QMember.member.username,                JPAExpressions                    .select(memberSub.age.avg())                    .from(memberSub))        .from(QMember.member)        .fetch();    for(Tuple member : result){        System.out.println(member);    }}JPAExpressions도 static으로 import해주면 더 깔끔하게 쓸 수 있음⚠️from절의 서브쿼리는 지원하지 않음. jpq, jpql과 마찬가지로 하이버네이트 구현체를 사용하면 querydsl도 select절의 서브쿼리를 사용가능함.→ from절의 서브쿼리 해결방안  서브쿼리를 join으로 변경  애플리케이션에서 쿼리를 2분 분리해서 실행  native SQL문을 사용쿼리문으로 모든 것을 해결하려는 것은 나쁜습관이라고 함. 쿼리문은 데이터만 가져오도록 할 것.SQL AntiPatterns이 책 참고case문select, where에서 사용 가능@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    List&lt;String&gt; result = query        .select(QMember.member.age            .when(10).then(\"열살\")            .when(18).then(\"열여덟살\")            .otherwise(\"기타\"))        .from(QMember.member)        .fetch();    for(String member : result){        System.out.println(member);    }}같은값이 두번나오면 저렇게 2로 표시가 되는건가..?그런가보네List&lt;String&gt; result = queryFactory\t .select(new CaseBuilder()\t .when(member.age.between(0, 20)).then(\"0~20살\")\t .when(member.age.between(21, 30)).then(\"21~30살\")\t .otherwise(\"기타\")).from(member).fetch()좀더 복잡한 case문은 이렇게 짜면됨그러나 쿼리문은 DB에서 최소한의 데이터를 가져오는 작업만하고 애플리케이션에서 바꾸는 것이 더 효율적임— 다음과 같은 임의의 순서로 회원을 출력하고 싶다면?  0 ~ 30살이 아닌 회원을 가장 먼저 출력  0 ~ 20살 회원 출력  21 ~ 30살 회원 출력NumberExpression&lt;Integer&gt; rankPath = new CaseBuilder() .when(member.age.between(0, 20)).then(2) .when(member.age.between(21, 30)).then(1) .otherwise(3);List&lt;Tuple&gt; result = queryFactory .select(member.username, member.age, rankPath) .from(member) .orderBy(rankPath.desc()) .fetch();for (Tuple tuple : result) { String username = tuple.get(member.username); Integer age = tuple.get(member.age); Integer rank = tuple.get(rankPath); System.out.println(\"username = \" + username + \" age = \" + age + \" rank = \"+ rank);}복잡한 조건을 변수로 지정해서 사용 가능함상수@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    List&lt;Tuple&gt; result = query        .select(QMember.member.username, Expressions.constant(\"A\"))        .from(QMember.member)        .fetch();    for(Tuple member : result){        System.out.println(member);    }}sql문에는 따로 추가되서 날아가는것은 아니나 A가 찍혀나옴concat@Testpublic void testQuerydsl3(){    JPAQueryFactory query = new JPAQueryFactory(em);    List&lt;String&gt; result = query        .select(QMember.member.username.concat(\"_\").concat(QMember.member.age.stringValue()))        .from(QMember.member)        .fetch();            for(String member : result){        System.out.println(member);    }}Enum처리할때 자주 사용함"
  },
  
  {
    "title": "[김영한 실전! 스프링 데이터 JPA] 그 외 기능",
    "url": "/posts/%EA%B7%B8%EC%99%B8%EA%B8%B0%EB%8A%A5/",
    "categories": "JPA",
    "tags": "jpa, 실전스프링데이터JPA, ORM",
    "date": "2023-01-19 00:00:00 +0900",
    





    
    "snippet": "복잡도에 비해서 실무에서 쓰기에는 약간 애매한 기능들Specifications(명세) - 안씀DDD(도메인 주도 설계)는 SPECIFICATION(명세)라는 개념을 소개. spring data jpa는 JPA Criteria(가독성구리다고하심)를 활용해 이 개념을 사용할 수 있도록 지원함  술어(predicate)          참 또는 거짓으로 평...",
    "content": "복잡도에 비해서 실무에서 쓰기에는 약간 애매한 기능들Specifications(명세) - 안씀DDD(도메인 주도 설계)는 SPECIFICATION(명세)라는 개념을 소개. spring data jpa는 JPA Criteria(가독성구리다고하심)를 활용해 이 개념을 사용할 수 있도록 지원함  술어(predicate)          참 또는 거짓으로 평가      AND/OR 같은 연산자로 조합해서 다양한 검색조건을 쉽게 생성함(컴포지트 패턴) - ex.검색 조건 하나하나      org.springframework.data.jpa.domain.Specification 클래스로 정의          package com.spring.datajpa.repository;      import java.util.Collection;  import java.util.List;      import org.springframework.data.domain.Page;  import org.springframework.data.domain.Pageable;  import org.springframework.data.domain.Slice;  import org.springframework.data.jpa.repository.EntityGraph;  import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.data.jpa.repository.JpaSpecificationExecutor;  import org.springframework.data.jpa.repository.Lock;  import org.springframework.data.jpa.repository.Modifying;  import org.springframework.data.jpa.repository.Query;  import org.springframework.data.jpa.repository.QueryHints;  import org.springframework.data.repository.query.Param;      import com.spring.datajpa.entity.Member;      import jakarta.persistence.LockModeType;  import jakarta.persistence.QueryHint;      public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;,   MemberRepositoryCustom, JpaSpecificationExecutor&lt;Member&gt;{      ...  }          @Test  public void specBasic() throws Exception {  \t //given  \t Team teamA = new Team(\"teamA\");  \t em.persist(teamA);  \t Member m1 = new Member(\"m1\", 0, teamA);  \t Member m2 = new Member(\"m2\", 0, teamA);  \t em.persist(m1);  \t em.persist(m2);  \t em.flush();  \t em.clear();  \t //when  \t Specification&lt;Member&gt; spec =\tMemberSpec.username(\"m1\").and(MemberSpec.teamName(\"teamA\"));  \t List&lt;Member&gt; result = memberRepository.findAll(spec);  \t //then  \t Assertions.assertThat(result.size()).isEqualTo(1);  }          public class MemberSpec {  \t public static Specification&lt;Member&gt; teamName(final String teamName) {  \t\t return (Specification&lt;Member&gt;) (root, query, builder) -&gt; {  \t\t\t if (StringUtils.isEmpty(teamName)) {  \t\t\t return null;  \t\t }  \t\t Join&lt;Member, Team&gt; t = root.join(\"team\", JoinType.INNER); //회원과 조인  \t\t return builder.equal(t.get(\"name\"), teamName);  \t\t };  \t }  \t public static Specification&lt;Member&gt; username(final String username) {  \t\t return (Specification&lt;Member&gt;) (root, query, builder) -&gt;  \t\t builder.equal(root.get(\"username\"), username);  \t }  }        ..안씀. 그냥 querydsl쓰는게 나음  Query By Example - 애매함동적쿼리를 편리하게 처리 가능함@SpringBootTest@Transactionalpublic class QueryByExampleTest {\t @Autowired MemberRepository memberRepository;\t @Autowired EntityManager em;\t @Test\t public void basic() throws Exception {\t\t //given\t\t Team teamA = new Team(\"teamA\");\t\t em.persist(teamA);\t\t em.persist(new Member(\"m1\", 0, teamA));\t\t em.persist(new Member(\"m2\", 0, teamA));\t\t em.flush();\t\t //when\t\t //Probe 생성\t\t Member member = new Member(\"m1\");\t\t Team team = new Team(\"teamA\"); //내부조인으로 teamA 가능\t\t member.setTeam(team);\t\t //ExampleMatcher 생성, age 프로퍼티는 무시\t\t ExampleMatcher matcher = ExampleMatcher.matching().withIgnorePaths(\"age\"); //age라는 속성이 있다면 무시\t\t Example&lt;Member&gt; example = Example.of(member, matcher);\t\t List&lt;Member&gt; result = memberRepository.findAll(example);\t\t //then\t\t assertThat(result.size()).isEqualTo(1);\t }}  Probe: 필드에 데이터가 있는 실제 도메인 객체  ExampleMatcher: 특정 필드를 일치시키는 상세한 정보 제공, 재사용 가능  Example: Probe와 ExampleMatcher로 구성, 쿼리를 생성하는데 사용outer join이 안됨!! 중첩 제약조건도 안됨!!매칭조건이 너무 단순함(거의 =조건만)그냥 querydsl쓰자Projections - 꽤 도움됨엔티티대신 DTO를 편리하게 조회인터페이스만 정의해두면 실제 구현체는 spring data jpa가 만들어서 데이터를 담아서 반환함  open projections      public interface UsernameOnly {  \t @Value(\"#{target.username + ' ' + target.age + ' ' + target.team.name}\")  \t String getUsername();  }        이름 20 1팀 이런식으로 나옴. 모든 데이터가 조회된다는 단점이 있음.    클래스 기반 Projections      public class UsernameOnlyDto {  \t private final String username;      \t public UsernameOnlyDto(String username) {  \t\t this.username = username;  \t }      \t public String getUsername() {  \t\t return username;  \t }  }        생성자의 파라미터 이름으로 매핑됨    동적 Projections      &lt;T&gt; List&lt;T&gt; findProjectionsByUsername(String username, Class&lt;T&gt; type);          List&lt;UsernameOnly&gt; result = memberRepository.findProjectionsByUsername(\"m1\",UsernameOnly.class);        중접구조      &lt;T&gt; List&lt;T&gt; findProjectionsByUsername(String username, Class&lt;T&gt; type);          public interface NestedClosedProjection {  \t String getUsername();  \t TeamInfo getTeam();      \t interface TeamInfo {  \t\t String getName();  \t }  }          List&lt;NestedClosedProjections&gt; result = memberRepository.findProjectionsByUsername(\"m1\",NestedClosedProjections.class);        중첩구조일때는 약간 애매해짐.  — 결론  프로젝션 대상이 root 엔티티면 유용함  프로젝션 대상이 root 엔티티를 넘어가면 JPQL SELECT 최적화가 안됨  실무의 복잡한 쿼리를 해결하기에는 한계가있음  단순할 때만 사용하고 복잡해지면 QueryDSL쓸것네이티브 쿼리sql문을 직접 짜는 거. 사용하지않는것이 좋으나 최수의 수단으로 어쩔수없을때 사용하면됨.@Query(value = \"select * from member where username = ?\", nativeQuery = true)Member findByNativeQuery(String username)보통 DTO로 조회하고싶을때 사용함반환타입이 몇개 지원이 되지않음(Object[], Tuple, DTO). 동적쿼리도 불가능.— projections를 활용해서 효율적으로 쓸 수 있음@Query(value = \"SELECT m.member_id as id, m.username, t.name as teamName \" + \"FROM member m left join team t ON m.team_id = t.team_id\", countQuery = \"SELECT count(*) from member\", //페이징때문에 만든거임 nativeQuery = true)Page&lt;MemberProjection&gt; findByNativeProjection(Pageable pageable)interface DTO로 반환+page기능동적쿼리는 잘 안되니까 알아둘것. 동적쿼리는 하이버네이트를 직접 활용하거나 스프링 jdbcTemplate, myBatis, jooq같은 외부 라이브러리 사용하면됨"
  },
  
  {
    "title": "[김영한 실전! 스프링 데이터 JPA] Spring Data Jpa 분석",
    "url": "/posts/spring_data_jpa_%EB%B6%84%EC%84%9D/",
    "categories": "JPA",
    "tags": "jpa, 실전스프링데이터JPA, ORM",
    "date": "2023-01-19 00:00:00 +0900",
    





    
    "snippet": "구현체 분석  @Repository 적용: JPA 예외를 스프링이 추상화한 예외로 변환  @Transactional 트랜잭션 적용 - jpa에서는 붙여야했으나 spring data jpa에서는 안붙여도됨          JPA의 모든 변경은 트랜잭션 안에서 동작      스프링 데이터 JPA는 변경(등록, 수정, 삭제) 메서드를 트랜잭션 처리     ...",
    "content": "구현체 분석  @Repository 적용: JPA 예외를 스프링이 추상화한 예외로 변환  @Transactional 트랜잭션 적용 - jpa에서는 붙여야했으나 spring data jpa에서는 안붙여도됨          JPA의 모든 변경은 트랜잭션 안에서 동작      스프링 데이터 JPA는 변경(등록, 수정, 삭제) 메서드를 트랜잭션 처리      서비스 계층에서 트랜잭션을 시작하지 않으면 리파지토리에서 트랜잭션 시작      서비스 계층에서 트랜잭션을 시작하면 리파지토리는 해당 트랜잭션을 전파 받아서 사용      그래서 스프링 데이터 JPA를 사용할 때 트랜잭션이 없어도 데이터 등록, 변경이 가능했음(사실은 트랜잭션이 리포지토리 계층에 걸려있는 것임)        @Transactional(readOnly = true)          데이터를 단순히 조회만 하고 변경하지 않는 트랜잭션에서 readOnly = true 옵션을 사용하면 플러시를 생략해서 약간의 성능 향상을 얻을 수 있음        save() 메서드          새로운 엔티티면 저장(persist) - isNew(entity)가 true면      새로운 엔티티가 아니면 병합(merge) - isNew(entity)가 false면  — 새로운 엔티티 구분 방법      식별자가 객체일 때 null 로 판단      식별자가 자바 기본 타입일 때 0 으로 판단 - int처럼 null이 올 수 없는 경우      Persistable 인터페이스를 구현해서 판단 로직 변경 가능        기본키가 없으면 엔티티고 있으면 기존에있던 엔티티로 판단하는 듯.        근데 만약 임의로 기본키를 지정했는데 DB에 해당하는 기본키가 존재하지 않으면? insert구문으로 바꿔서 날림. = 비효율적    데이터 변경을 변경감지 기능을 하용하고 저장은 persist를 사용하는게 나음. merge를 쓰지않겠다고 가정하고 코드를 짜면 됨.    근데 만약! 기본키를 임의로 지정해줘야하는 순간이 온다면?      package com.spring.datajpa.entity;      import java.time.LocalDateTime;      import org.springframework.data.annotation.CreatedDate;  import org.springframework.data.domain.Persistable;  import org.springframework.data.jpa.domain.support.AuditingEntityListener;      import jakarta.persistence.Entity;  import jakarta.persistence.EntityListeners;  import jakarta.persistence.Id;  import lombok.AccessLevel;  import lombok.NoArgsConstructor;      @Entity  @NoArgsConstructor(access = AccessLevel.PROTECTED)  @EntityListeners(AuditingEntityListener.class)  public class Item implements Persistable&lt;String&gt;{      @Id      private String id;          @CreatedDate       private LocalDateTime createdDate;          public Item(String id){          this.id=id;      }          @Override      public String getId(){          return id;      }          @Override      public boolean isNew(){          return createdDate==null;      }  }          package com.spring.datajpa.repository;      import org.junit.jupiter.api.Test;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.boot.test.context.SpringBootTest;      import com.spring.datajpa.entity.Item;      @SpringBootTest  public class ItemRepositoryTest {      @Autowired ItemRepository itemRepository;          @Test      public void save(){          Item item = new Item(\"a\");          itemRepository.save(item);      }  }        저장 값의 등록일을 기준으로 판단하도록 오버라이딩함.  "
  },
  
  {
    "title": "[김영한 실전! 스프링 데이터 JPA] 확장 기능",
    "url": "/posts/%ED%99%95%EC%9E%A5%EA%B8%B0%EB%8A%A5/",
    "categories": "JPA",
    "tags": "jpa, 실전스프링데이터JPA, ORM",
    "date": "2023-01-17 00:00:00 +0900",
    





    
    "snippet": "사용자 리포지토리 구현리포지토리는 인터페이스만 정의하고 구현체는 자동으로 생성하는 spring data jpa에서 인터페이스의 메소드를 직접 구현하고싶다면?  JPA 직접 사용  스프링 JDBC Template사용  Mybatis사용  데이터베이스 커넥션 직접 사용  Querydsl 사용package com.spring.datajpa.repositor...",
    "content": "사용자 리포지토리 구현리포지토리는 인터페이스만 정의하고 구현체는 자동으로 생성하는 spring data jpa에서 인터페이스의 메소드를 직접 구현하고싶다면?  JPA 직접 사용  스프링 JDBC Template사용  Mybatis사용  데이터베이스 커넥션 직접 사용  Querydsl 사용package com.spring.datajpa.repository;import java.util.List;import com.spring.datajpa.entity.Member;public interface MemberRepositoryCustom {    List&lt;Member&gt; findMemberCustom();}package com.spring.datajpa.repository;import java.util.List;import com.spring.datajpa.entity.Member;import jakarta.persistence.EntityManager;import lombok.RequiredArgsConstructor;@RequiredArgsConstructorpublic class MemberRepositoryImpl implements MemberRepositoryCustom{    private final EntityManager em; //순수 JPA 사용    @Override    public List&lt;Member&gt; findMemberCustom() {        return em.createQuery(\"select m from Member m\").getResultList();    }}package com.spring.datajpa.repository;import java.util.Collection;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Slice;import org.springframework.data.jpa.repository.EntityGraph;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Lock;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.jpa.repository.QueryHints;import org.springframework.data.repository.query.Param;import com.spring.datajpa.entity.Member;import jakarta.persistence.LockModeType;import jakarta.persistence.QueryHint;public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepositoryCustom{    ...}잘 실행됨됨QueryDSL이나 SpringJdbcTemplate을 함께 사용할 때 사용자 정의 리포지토리 기능 자주 사용함단, 인터페이스 이름은 상관 없으나 구현 클래스는 꼭 ~~~impl로 맞춰줘야함. 그래야 스프링이 자동으로 맞춰줌. 다른이름으로 하려면 설정할수있으나 어지간하면 그냥 쓰자그냥 임의의 리포지토리를 만들어도 됨. MemberQueryRepository를 인터페이스가 아닌 클래스로 만들고 스프링 빈으로 등록해서 그냥 직접 사용해도 된다는 뜻. 그럼 스프링 데이터 JPA와는 아무런 관계 없이 별도로 동작함Auditing엔티티 생성, 변경 시 변경인과 시간을 추적하고싶을때 사용  등록일(기본)  수정일(기본)  등록자(추가)  수정자(추가)등록자, 수정자가 없을수도 있으나 거의 4개는 기본으로 사용하는 분위기인듯?— 순수 jpapackage com.spring.datajpa.entity;import java.time.LocalDateTime;import jakarta.persistence.Column;import jakarta.persistence.PrePersist;import jakarta.persistence.PreUpdate;@MappedSuperclass //진짜 상속하는건 아니고 속성만 상속받는거임. 데이터만 공유하는 느낌public class JapBaseEntity {    @Column(updatable=false)    private LocalDateTime createdDate;    private LocalDateTime updatedDate;    @PrePersist //persist하기전에 수행    public void perPersist(){        LocalDateTime now = LocalDateTime.now();        createdDate = now;        updatedDate = now;      }    @PreUpdate //업데이트 전에 실행    public void preUpdate(){        updatedDate = LocalDateTime.now();    }}public class Member extends JapBaseEntity {...}@MappedSuperclass를 붙이면 spring.jpa.hibernate.ddl-auto=create를 했을때 멤버테이블에 수정일도 추가됨.@Testpublic void jpabaseTest() throws InterruptedException{    Member member = new Member(\"member1\");    memberRepo.save(member); //@PrePersist 발생    Thread.sleep(100); //테스트에서 sleep쓰는거 좋은코드는 아니라고하심    member.setUsername(\"member2\");    em.flush();    em.clear();    Member findMember = memberRepo.findById(member.getId()).get();    System.out.println(findMember.getCreatedDate());    System.out.println(findMember.getUpdatedDate());}DB에 이렇게 저장됨. 다른 엔티티에도 jpabaseEntity를 상속해주면됨. 다시 만들필요없음— spring data jpapackage com.spring.datajpa;import java.util.Optional;import java.util.UUID;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.AuditorAware;import org.springframework.data.jpa.repository.config.EnableJpaAuditing;@EnableJpaAuditing@SpringBootApplicationpublic class DataJpaApplication {\tpublic static void main(String[] args) {\t\tSpringApplication.run(DataJpaApplication.class, args);\t}\t@Bean //등록자, 수정자 쓸때만 추가해주면\tpublic AuditorAware&lt;String&gt; auditorProvider(){\t\t// return new AuditorAware&lt;String&gt;() {\t\t// \t@Override\t\t// \tpublic Optional&lt;String&gt; getCurrentAuditor(){\t\t// \t\treturn Optional.of(UUID.randomUUID().toString());\t\t// \t}\t\t// };\t\treturn () -&gt; Optional.of(UUID.randomUUID().toString()); //위에랑 같은거임\t}}메인에 꼭 @EnableJpaAuditing붙여야함. 안붙이면 안됨. 밑에 @Bean은 등록자랑 수정자를 받을때만 만들어주면됨package com.spring.datajpa.entity;import java.time.LocalDateTime;import org.springframework.data.annotation.CreatedBy;import org.springframework.data.annotation.CreatedDate;import org.springframework.data.annotation.LastModifiedBy;import org.springframework.data.annotation.LastModifiedDate;import org.springframework.data.jpa.domain.support.AuditingEntityListener;import jakarta.persistence.Column;import jakarta.persistence.EntityListeners;import jakarta.persistence.MappedSuperclass;import lombok.Getter;@EntityListeners(AuditingEntityListener.class)@MappedSuperclass@Getterpublic class BaseEntity {    @CreatedDate    @Column(updatable = false)      private LocalDateTime createdDate;        @LastModifiedDate    private LocalDateTime lastModifiedDate;     @CreatedBy    @Column(updatable = false)    private String createdBy;      @LastModifiedBy    private String lastModifiedBy;}public class Member extends BaseEntity {...}@Testpublic void baseTest() throws InterruptedException{    Member member = new Member(\"member1\");    memberRepo.save(member); //@PrePersist 발생    Thread.sleep(100); //테스트에서 sleep쓰는거 좋은코드는 아니라고하심    member.setUsername(\"member2\");    em.flush();    em.clear();    Member findMember = memberRepo.findById(member.getId()).get();    System.out.println(findMember.getCreatedDate());    System.out.println(findMember.getLastModifiedDate());    System.out.println(findMember.getCreatedBy());    System.out.println(findMember.getLastModifiedBy());}⚠️보통 BaseTimeEntity를 만들어서 생성시간, 수정시간을 넣고, BaseEntity에 등록자와 수정자를 넣은다음, BaseEntity가 BaseTimeEntity를 상속받도록해서 엔티티마다 필요한 것을 상속받게함. 4개 다 필요하면 BaseEntity를 상속받고, 등록일과 수정일만 필요하면 BaseTimeEntity만 상속받으면되는거임!!web확장도메인 클래스 컨버터http파라미터로 넘어온 엔티티의 아이디로 엔티티 객체를 찾아서 바인딩@GetMapping(\"/members/{id}\")public String findMember(@PathVariable(\"id\") Long id){  Member member = memberRepo.findById(id).get();  return member.getUsername();}@GetMapping(\"/members2/{id}\")public String findMember2(@PathVariable(\"id\") Member member){  return member.getUsername();}둘다 같은 결과가 나옴…;;몰랐다..근데 권장하지않으신다고..간단할때만 쓸수있다고하심. 쓸거면 조회할때만 쓰기. 수정삭제도되긴하는데 복잡해진다고하심아 트랜잭션이 없는 범위에서 엔티티를 조회해서 그렇다고하심!!페이징과 정렬application.properties에spring.data.web.pageable.default-page-size=20 /# 기본 페이지 사이즈/spring.data.web.pageable.max-page-size=2000 /# 최대 페이지 사이즈설정하면 기본값 설정 가능함  접두사페이징 정보가 둘 이상일때 사용public String list( @Qualifier(\"member\") Pageable memberPageable, @Qualifier(\"order\") Pageable orderPageable,...)❗엔티티는 DTO를 의존하지않는게 좋음. 같은패키지가 아니면 괜찮으나 주의하는게좋음. 엔티티생성자에 DTO를 받지말라는 소리인듯..ㅜㅜ@GetMapping(\"/members\")public Page&lt;MemberDto&gt; list(Pageable pageable) { return memberRepository.findAll(pageable).map(MemberDto::new);}이렇게까지 줄일 수 있음— Page를 1부터 시작하려면?      pageable, page를 파라미터 응답값으로 받지말고 직접 클래스를 만들어서 처리.  PageRequest(Pageable 구현체)를 직접 만들어서 제공      PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC, \"username\"));      Page&lt;Member&gt; page = memberRepo.findByAge(10, pageRequest);  List&lt;Member&gt; content = page.getContent();      Long totalElement = page.getTotalElements();      Assertions.assertThat(content.size()).isEqualTo(3);  Assertions.assertThat(page.getTotalElements()).isEqualTo(4);  Assertions.assertThat(page.getNumber()).isEqualTo(0);  Assertions.assertThat(page.getTotalPages()).isEqualTo(2);  Assertions.assertThat(page.isFirst()).isTrue();  Assertions.assertThat(page.hasNext()).isTrue();  Assertions.assertThat(page.isLast()).isFalse();            spring.data.web.pageable.one-indexed-parameters 를 true 로 설정.  web에서 page 파라미터를 -1 처리 해서 받아옴. 따라서 응답값인 Page 에 모두 0 페이지 인덱스를 사용하게됨.  json으로 나간 page 정보들이 0으로 시작한다는 문제인거같음~  "
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용2] OSIV와 성능 최적화",
    "url": "/posts/OSIV%EC%99%80_%EC%84%B1%EB%8A%A5_%EC%B5%9C%EC%A0%81%ED%99%94/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용2, ORM",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "  Open Session In View : 하이버네이트  Open EntityManage In View : JPA  spring.jpa.open-in-view : true 기본값 - OSIV ON 상태트랜젝션 범위를 벗어나도 영속성 컨텍스트가 살아있음. 모든 작업이 끝날때까지 살아있다고 이해하면될거같음.실시간 트래픽이 중요한 애플리케이션에서는 커넥션...",
    "content": "  Open Session In View : 하이버네이트  Open EntityManage In View : JPA  spring.jpa.open-in-view : true 기본값 - OSIV ON 상태트랜젝션 범위를 벗어나도 영속성 컨텍스트가 살아있음. 모든 작업이 끝날때까지 살아있다고 이해하면될거같음.실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 말라버림.컨트롤러에서 외부 API를 호출하면 외부 API 대기시간만큼 커넥션 리소스를 반환하지 못하고 유지해야함.엔티티를 controller나 view에서 활용가능한 장점이 있음.  spring.jpa.open-in-view : false - OSIV OFF (종료 상태)트렌젝션 범위를 벗어나면 영속성 컨텍스트를 반환함. 대신 모든 지연로딩을 트랜잭션 안에서 처리해야함. 그리고 view template에서 지연로딩이 동작하지 않음. 트랜젝션이 끝나기 전에 지연로딩을 강제호출해야함. 프록시 에러 뜸아..그래서 지금까지 서비스랑 컨트롤러를 나눠서 햇구나…. 서비스에서 모든 작업을 하고 컨트롤러에서 반환 값을 가져와서 출력해주는 방식으로 해야한다는 것 같음.Command와 Query를 분리하면 복잡성을 관리하기 좋음. 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요하나 복잡성에 비해 핵심 비즈니스에 큰 영향을 주는 것은 아님단순하게  OrderService          OrderService : 핵심 비즈니스 로직      OrderQueryService : 화면이나 API에 맞춘 서비스 (주로 읽기 전용 트렌잭션 사용)으로 나누는 것을 추천.      고객서비스의 실시간 API는 OSIV를 끄고 Admin처럼 커넥션을 많이 사용하지 않는 곳에서는 키는걸 추천함."
  },
  
  {
    "title": "[김영한 실전! 스프링 데이터 JPA] 공통 인터페이스 - 쿼리 메소드",
    "url": "/posts/%EA%B3%B5%ED%86%B5%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%BF%BC%EB%A6%AC_%EB%A9%94%EC%86%8C%EB%93%9C/",
    "categories": "JPA",
    "tags": "jpa, 실전스프링데이터JPA, ORM",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "@Autowired MemberJpaRepository memberJpaRepository;세상에 이거 프록시였다………………………………………….! sysout으로 getclass찍었는데,,,,, 프록시 니가 왜 거기서나와..?상태됨JpaRepository는 JPA에 특화된 기능만 모아놓은 인터페이스임.  주요 메서드          save(S) : ...",
    "content": "@Autowired MemberJpaRepository memberJpaRepository;세상에 이거 프록시였다………………………………………….! sysout으로 getclass찍었는데,,,,, 프록시 니가 왜 거기서나와..?상태됨JpaRepository는 JPA에 특화된 기능만 모아놓은 인터페이스임.  주요 메서드          save(S) : 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합한다.      delete(T) : 엔티티 하나를 삭제한다. 내부에서 EntityManager.remove() 호출      findById(ID) : 엔티티 하나를 조회한다. 내부에서 EntityManager.find() 호출      getOne(ID) : 엔티티를 프록시로 조회한다. 내부에서 EntityManager.getReference() 호출      findAll(…) : 모든 엔티티를 조회한다. 정렬( Sort )이나 페이징( Pageable ) 조건을 파라미터로 제공할수 있다자세한 것은https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation여기서 확인 가능함        스프링 데이터 JPA가 제공하는 쿼리 메소드 기능          조회: find…By ,read…By ,query…By get…By,                  https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation          예:) findHelloBy 처럼 …에 식별하기 위한 내용(설명)이 들어가도 된다.                    COUNT: count…By 반환타입 long      EXISTS: exists…By 반환타입 boolean      삭제: delete…By, remove…By 반환타입 long      DISTINCT: findDistinct, findMemberDistinctBy      LIMIT: findFirst3, findFirst, findTop, findTop3                  https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.limit-query-result  실무에서는 메소드 이름이 너무 길어진다면 그냥 쿼리문을 작성해서 메소드 이름을 간략하게 만드는 것을 추천함                    JPA named Query거의 안씀~  jpa에서 사용      package com.spring.datajpa.entity;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.FetchType;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.JoinColumn;  import jakarta.persistence.ManyToOne;  import lombok.AccessLevel;  import lombok.Getter;  import lombok.NoArgsConstructor;  import lombok.Setter;  import lombok.ToString;      @Entity  @Getter @Setter  @NoArgsConstructor(access = AccessLevel.PROTECTED)  @ToString(of = {\"id\", \"username\", \"age\"}) //연관관계 필드는 가급적 toString 하지말것  @NamedQuery(      name=\"Member.findByUsername\",      query=\"select m from member m where m.username=:username\"  )  public class Member {              @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"member_id\")      private Long id;      private String username;      private int age;      @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"team_id\")      private Team team;          public Member(String userName){          this.username = userName;      }          public void changeTeam(Team team){          this.team = team;          team.getMembers().add(this);      }          public Member(String name, int age, Team team) {          this.username=name;          this.age = age;          if(team!=null){              changeTeam(team);          }      }  }          public class MemberRepository {  \t public List&lt;Member&gt; findByUsername(String username) {  \t\t List&lt;Member&gt; resultList =  \t\t em.createNamedQuery(\"Member.findByUsername\", Member.class)  \t\t .setParameter(\"username\", username)  \t\t .getResultList();  \t }  }        이렇게 사용함. 귀찮은게 문제임    spring data jpa에서 사용  엔티티에 @namedQuery 어노테이션 사용하고      package com.spring.datajpa.repository;      import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.data.jpa.repository.Query;  import org.springframework.data.repository.query.Param;      import com.spring.datajpa.entity.Member;      public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;{          @Query(name=\"Member.findByUsername\")      List&lt;Member&gt; findByUsername(@Param(\"username\") String username);  }        jpql이 entity에 작성된 쿼리문을 찾아서 날려줌  참고로      package com.spring.datajpa.repository;      import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.data.jpa.repository.Query;  import org.springframework.data.repository.query.Param;      import com.spring.datajpa.entity.Member;      public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;{      List&lt;Member&gt; findByUsername(@Param(\"username\") String username);  }        이렇게 해도 동작함. 네임드 쿼리를 찾아서 실행함. 만약 없으면 그냥 메소드 만들어서 실행됨  잘 안쓰니까 알아만두면될듯.    컬렉션 파라미터 바인딩  package com.spring.datajpa.repository;import java.util.Collection;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import com.spring.datajpa.entity.Member;public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;{    @Query(name=\"Member.findByUsername\")    List&lt;Member&gt; findByUsername(@Param(\"username\") String username);    @Query(\"select m from Member m where m.username in :names\")    List&lt;Member&gt; findByNames(@Param(\"names\") Collection&lt;String&gt; names); //Collection말고 List로 해도됨    }List&lt;Member&gt; list = memberRepo.findByNames(Arrays.asList(\"member4\", \"member1\"));이렇게 사용 사능함!! asList를 처음 알았다!!!in 쿼리로 나가는 것이 확인됨if≠null 쓰는거보다 optional을 쓰는게 더 낫다는데 아직 감이 잘 안잡힘ㅜㅜ 설명도 자세하게 해주신건 아니라서 일단 넘어감페이징Page - 추가 count 쿼리 결과를 포함하는 페이징 : Pageable 사용PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC, \"username\"));Page&lt;Member&gt; page = memberRepo.findByAge(10, pageRequest);List&lt;Member&gt; content = page.getContent();Long totalElement = page.getTotalElements();Assertions.assertThat(content.size()).isEqualTo(3);Assertions.assertThat(page.getTotalElements()).isEqualTo(4);Assertions.assertThat(page.getNumber()).isEqualTo(0);Assertions.assertThat(page.getTotalPages()).isEqualTo(2);Assertions.assertThat(page.isFirst()).isTrue();Assertions.assertThat(page.hasNext()).isTrue();Assertions.assertThat(page.isLast()).isFalse();Slice - 추가 count 쿼리 없이 다음 페이지만 확인가능(모바일의 더보기) : 내부적으로 limit+1조회PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC, \"username\"));Slice&lt;Member&gt; page = memberRepo.findByAge(10, pageRequest);List&lt;Member&gt; content = page.getContent();// Long totalElement = page.getTotalElements();Assertions.assertThat(content.size()).isEqualTo(3);// Assertions.assertThat(page.getTotalElements()).isEqualTo(4);Assertions.assertThat(page.getNumber()).isEqualTo(0);// Assertions.assertThat(page.getTotalPages()).isEqualTo(2);Assertions.assertThat(page.isFirst()).isTrue();Assertions.assertThat(page.hasNext()).isTrue();Assertions.assertThat(page.isLast()).isFalse();Slice는 totalPage 없음. repository에서 반환타입도 바꿔줘야함❗page쿼리는 DB의 모든 데이터를 카운트해야만 가져올수있기때문에 성능이 좋지않음. 그래서 조인이 많이 일어나면 한 테이블만 조회해서 카운트 값을 가져옴@Query(value=\"select m from Member m left join m.teat t\", countQuery = \"select count(m.username) from Member m\")    Page&lt;Member&gt; findByAge2(int age, Pageable page);이렇게 분리하는것이 가능함. 이렇게되면 카운트 쿼리는 간단하게 날아감.Page&lt; Entity &gt;를 DTO로 변환하려면page.map(member-&gt;new MemberDto(member.getId(), member.getUsername(), null));벌크성 수정 쿼리한번에 값을 바꾸는 거. (연봉 10퍼센트 인상)  jpa 방법      public int bulkAgePlus(int age) {   int resultCount = em.createQuery(   \"update Member m set m.age = m.age + 1\" +   \"where m.age &gt;= :age\")   .setParameter(\"age\", age)   .executeUpdate();   return resultCount;  }          @Test  public void bulkUpdate() throws Exception {   //given   memberJpaRepository.save(new Member(\"member1\", 10));   memberJpaRepository.save(new Member(\"member2\", 19));   memberJpaRepository.save(new Member(\"member3\", 20));   memberJpaRepository.save(new Member(\"member4\", 21));   memberJpaRepository.save(new Member(\"member5\", 40));   //when   int resultCount = memberJpaRepository.bulkAgePlus(20); //20살 이상이면   //then   assertThat(resultCount).isEqualTo(3);  }            spring data jpa  @Modifying어노테이션을 넣어야 update쿼리로 작동함      @Modifying  @Query(\"update Member m set m.age = m.age+1 where m.age&gt;=:age\")  int bulkAgePlus(@Param(\"age\") int age);          memberRepo.save(new Member(\"member1\", 10, teamA));  memberRepo.save(new Member(\"member5\", 10, teamA));  memberRepo.save(new Member(\"member6\", 10, teamA));  memberRepo.save(new Member(\"member7\", 10, teamA));  memberRepo.save(new Member(\"member2\", 15, teamB));  memberRepo.save(new Member(\"member3\", 18, teamA));  memberRepo.save(new Member(\"member4\", 12, teamB));      int resultCount = memberRepo.bulkAgePlus(15);      Assertions.assertThat(resultCount).isEqualTo(2);        근데 이렇게하면 바로 member3을 조회하면 18으로 나옴. ==반영이 안된거임. 벌크연산에서 주의해야할점.==    원래는 EntityManager을 가져왔었음.        그러나 요즘엔      @Modifying(clearAutomatically = true)  @Query(\"update Member m set m.age = m.age+1 where m.age&gt;=:age\")  int bulkAgePlus(@Param(\"age\") int age);        이렇게하면        자동으로 됨. 단순 값 바꾸기만 한다면 괜찮겠지만 연산을 한다던지 조회를 한다던지하면 꼭 영속성 컨텍스트에 반영하는 작업을 해주어야함  @EntityGraph: 연관된 엔티티들을 sql 한번에 조회하는 방법그냥 단순하게 findAll같은 메소드들을 페치조인으로 오버라이딩한다고 생각하면 될거같음@Override@EntityGraph(attributePaths = {\"team\"})List&lt;Member&gt; findAll();조회해보면 join문으로 나가는 것을 확인할 수 있음.@EntityGraph(attributePaths = {\"team\"})@Query(\"select m from Member m\")List&lt;Member&gt; findMember();이렇게해도됨. 위랑 같은 쿼리문이 나감@EntityGraph(attributePaths = {\"team\"})List&lt;Member&gt; findByUsername(@Param(\"username\") String username);이렇게도 가능함.페치조인을 편리하게 가능. jpa에서 제공하는 건데 @NamedQuery같이 @NamedEntityGraph 사용가능함. 이것도 잘 안씀쿼리가 복잡해지면 그냥 페치조인쓰신다고함. 진짜 간단한거만 이렇게 쓰기도한다 정도로만 정리하면될듯JPA Hint &amp; Lock  JPA Hint변경감지 기능을 사용하려면 결론적으로 객체가 2개 필요함(변경된 객체, 변경하기 전 원본 객체). 이게 메모리를 차지함. 그런데 그냥 조회만하고 변경을 하지않는다면? 굳이 원본 객체를 저장해놓을 필요가 없음. 그렇다면 순수 조회용 데이터 값을 들고오는 방법은?@QueryHints(value = @QueryHint(name=\"org.hibernate.readOnly\", value=\"true\"))Member findReadOnlyByUsername(String username);jpa는 지원하지않고 하이버네이트가 제공하는 기능임. 스냅샷 없이 조회가 돼서 변경이되도 감지가되지않음!!!사실 대부분의 성능문제는 쿼리를 잘못 작성해서 생기는 문제라 이걸로 크게 성능이 향상되지는..않음^^.. 진짜 중요하고 진짜 트래픽이 큰곳 몇군데만 넣게되지 많이 쓰지는 않음  JPA Lock          select for update를 jpa에서 지원함.        @Lock(LockModeType.PESSIMISTIC_WRITE)  List&lt;Member&gt; findLockByUsername(String username);                    자세한건 JPA책 마지막 챕터 참고. 좀 딥함.아마 쓸일없을거같음. 실시간 트래픽이 많은 서비스에서는 가급적 사용하지 말것. 다른방법으로 해결하는 것이 좋음.실시간트래픽이 많지않고 정확성이 중요한경우는 사용해도될듯?"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용2] 고급 - 컬렉션 조회 최적화",
    "url": "/posts/%EA%B3%A0%EA%B8%89_%EC%BB%AC%EB%A0%89%EC%85%98_%EC%A1%B0%ED%9A%8C_%EC%B5%9C%EC%A0%81%ED%99%94/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용2, ORM",
    "date": "2023-01-09 00:00:00 +0900",
    





    
    "snippet": "@GetMapping(\"/api/v2/orders\")    public List&lt;OrderDto&gt; orderV2(){        List&lt;Order&gt; orders = orderRepository.findAllByString(new OrderSearch());        List&lt;OrderDto&gt; collect = o...",
    "content": "@GetMapping(\"/api/v2/orders\")    public List&lt;OrderDto&gt; orderV2(){        List&lt;Order&gt; orders = orderRepository.findAllByString(new OrderSearch());        List&lt;OrderDto&gt; collect = orders.stream().map(o-&gt;new OrderDto(o)).collect(Collectors.toList());        return collect;    }    @Data     static class OrderDto{        private Long orderId;        private String name;        private LocalDateTime orderDate;        private OrderStatus orderStatus;        private Address address;        private List&lt;OrderItemDto&gt; orderItems;        public OrderDto(Order order){            this.orderId=order.getId();            this.name=order.getMember().getName();            this.orderDate = order.getOrderDate();            this.orderStatus=order.getStatus();            this.address = order.getDelivery().getAddress();            // this.orderItems = order.getOrderItems(); //이건 엔티티라서 이렇게 해봤자 안나옴            //그렇다고 여기서 for문을 돌려서 넣어준다고 해결된건아님. 엔티티가 json으로 나가고 있는 상태인것            //DTO로 변환 필요함            orderItems = order.getOrderItems().stream().map(OrderItem-&gt;new OrderItemDto(OrderItem)).collect(Collectors.toList());        }양방향 매핑에서 oneToMany인 경우의 예시. 쿼리문이 엄청나게 많이 나감이것을 해결하기위해 페치조인 최적화를 해야함@GetMapping(\"/api/v3/orders\")    public List&lt;OrderDto&gt; ordersV3(){        List&lt;Order&gt; orders = orderRepository.findAllWithItem();        List&lt;OrderDto&gt; collect = orders.stream().map(o-&gt;new OrderDto(o)).collect(Collectors.toList());        return collect;    }public List&lt;Order&gt; findAllWithItem() {        return em.createQuery(\"select o from Order o join fetch o.member m join fetch o.delivery d join fetch o.orderItems oi join fetch oi.item i\", Order.class).getResultList();    }위 예시를 실행하면 4번 order가 두번나오는걸 확인할 수 있음. 데이터 뻥튀기      상세 JSON      [      {          \"orderId\": 4,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:22.559742\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 4,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:22.559742\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 11,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:22.591641\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      },      {          \"orderId\": 11,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:22.591641\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      },      {          \"orderId\": 18,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:31.940847\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 18,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:31.940847\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 25,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:31.969452\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      },      {          \"orderId\": 25,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:31.969452\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      }  ]      데이터 뻥튀기 해결방법 ! → distinct사용public List&lt;Order&gt; findAllWithItem() {        return em.createQuery(\"select distinct o from Order o join fetch o.member m join fetch o.delivery d join fetch o.orderItems oi join fetch oi.item i\", Order.class).getResultList();    }쿼리문이 한번만 나감. 그러나 페이징 불가능. 데이터 뻥튀기가 일어난 후 중복을 제거하기떄문에 페이징을 하면 기준자체가 틀어져서 이상한 결과가 나옴(1을 기준으로 페이징을 해야하는데 다를 기준으로 페이징이 되는것이 문제임)      상세 JSON      [      {          \"orderId\": 4,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:22.559742\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 11,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:22.591641\",          \"orderStatus\": \"ORDER\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      },      {          \"orderId\": 18,          \"name\": \"userA\",          \"orderDate\": \"2023-01-08T13:10:31.940847\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"서울\",              \"street\": \"1\",              \"zipcode\": \"1111\"          },          \"orderItems\": [              {                  \"itemName\": \"JPA1 BOOK\",                  \"price\": 10000,                  \"count\": 1              },              {                  \"itemName\": \"JPA2 BOOK\",                  \"price\": 20000,                  \"count\": 2              }          ]      },      {          \"orderId\": 25,          \"name\": \"userB\",          \"orderDate\": \"2023-01-08T13:10:31.969452\",          \"orderStatus\": \"CANCEL\",          \"address\": {              \"city\": \"진주\",              \"street\": \"2\",              \"zipcode\": \"2222\"          },          \"orderItems\": [              {                  \"itemName\": \"SPRING1 BOOK\",                  \"price\": 20000,                  \"count\": 3              },              {                  \"itemName\": \"SPRING2 BOOK\",                  \"price\": 40000,                  \"count\": 4              }          ]      }  ]      컬렉션 페치조인은 하나만 사용가능함. 컬렉션 둘 이상의 페치조인을 사용하면 데이터가 부정합하게 조회될수도있음한계 돌파페이징 + 컬렉션 엔티티 조회문제 해결  ToOne 관계를 모두 페치조인함. ToOne관계는 row수를 증가시키지 않아서 페이징 쿼리에 영향을 미치지 않음  컬렉션은 지연로딩으로 조회한다  지연로딩 최적화를 위해 hibernate.default_batch_fetch_size, @BetchSize를 적용시킨다 → 컬렉션, 프록시 객체를 한꺼번에 설정한 size만큼 IN쿼리로 조회한다application.properties에서 spring.jpa.properties.hibernate.default_batch_fetch_size=100설정public List&lt;Order&gt; findAllWithItem(int offset, int limit) {    return em.createQuery(\"select o from Order o join fetch o.member m join fetch o.delivery\", Order.class)        .setFirstResult(offset).setMaxResults(limit)    .getResultList();}@GetMapping(\"/api/v3.1/orders\")    public List&lt;OrderDto&gt; ordersV3_page(        @RequestParam(value=\"offset\", defaultValue = \"0\") int offset,        @RequestParam(value=\"limit\", defaultValue = \"100\") int limit    ){        List&lt;Order&gt; orders = orderRepository.findAllWithItem(offset, limit);        List&lt;OrderDto&gt; collect = orders.stream().map(o-&gt;new OrderDto(o)).collect(Collectors.toList());        return collect;    }이렇게 해두면 조회한 order의 값을 in쿼리로 찾아서옴. where orderId in(4,10) 이런식위에서 설정한 batch-fatch의 수가 in쿼리에 몇개의 개수로 할지 정한거임. (총 데이터가 100개인데 10으로 설정하면 쿼리가 10번나가는거임)⇒ 1+n+n문제를 1+1+1으로 해결한것. 위의 경우보다 쿼리문은 늘어났지만 데이터양이 많을 때는 중복제거를 하는것보다는 이것이 더 효율적일수도있음(DB데이터 전송량이 줄어듬). 상황과 데이터 양에 따라 달라짐public List&lt;Order&gt; findAllWithItem(int offset, int limit) {        return em.createQuery(\"select o from Order o\", Order.class)            .setFirstResult(offset).setMaxResults(limit)        .getResultList();    }이렇게 해도 되지만 페치조인 쓰는게 나음디테일하게 설정하고싶다면@BatchSize(size=1000)    @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL)    private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();이렇게 해주면됨@BatchSize(size=1000)@Entity@Getter @Setter@NoArgsConstructor(access = AccessLevel.PROTECTED) //기본생성자 쓰지말라는 의미.public class OrderItem {    @Id @GeneratedValue    @Column(name = \"order_item_id\")    private Long id;    @ManyToOne(fetch = FetchType.LAZY)    @JoinColumn(name=\"item_id\")    private Item item;컬렉션이 아닌경우는 이렇게페치조인은 페이징이 불가능하지만 이방법은 페이징이 가능함. 사이즈는 100~1000사이로 설정할것. 1000으로 잡으면 DB에 순간부하가 증가할수있음 애플리케이션은 100이든 1000이든 전체데이터를 로딩해야해서 메모리 사용량이 같으니까 1000으로 설정하는 것이 성능상 가장 좋으나 DB가 어디까지 순간부하를 견딜 수 있는지로 결정. 100으로해놓고 점점 늘리는것도 괜찮음JPA에서 DTO로 직접 조회package com.jpabook.jpashop.repository.order.query;import java.util.List;import javax.persistence.EntityManager;import org.springframework.stereotype.Repository;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class OrderQueryRepository {        private final EntityManager em;    public List&lt;OrderQueryDto&gt; findOrderQueryDtos(){        List&lt;OrderQueryDto&gt; result = findOrders();        result.forEach(o-&gt;{List&lt;OrderItemQueryDto&gt; orderItems = findOrderItems(o.getOrderId());            o.setOrderItems(orderItems);        });        return result;    }    private List&lt;OrderItemQueryDto&gt; findOrderItems(Long orderId) {        return em.createQuery(\"select new com.jpabook.jpashop.repository.order.query.OrderItemQueryDto(oi.order.id, i.name, oi.orderPrice, oi.count) from OrderItem oi join oi.item i where oi.order.id=:orderId\"        , OrderItemQueryDto.class).setParameter(\"orderId\", orderId).getResultList();    }    public List&lt;OrderQueryDto&gt; findOrders() {        return em.createQuery(\"select new com.jpabook.jpashop.repository.order.query.OrderQueryDto(o.id, m.name, o.orderDate, o.status, d.address) from Order o join o.member m join o.delivery d\"            , OrderQueryDto.class).getResultList();    }    }package com.jpabook.jpashop.repository.order.query;import java.time.LocalDateTime;import java.util.List;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.OrderStatus;import lombok.Data;@Datapublic class OrderQueryDto {    private Long orderId;    private String name;    private LocalDateTime orderDate;    private OrderStatus status;    private Address address;    private List&lt;OrderItemQueryDto&gt; orderItems;    public OrderQueryDto(Long orderId, String name, LocalDateTime order, OrderStatus status, Address address){        this.orderId = orderId;        this.name = name;        this.orderDate = order;        this.status=status;        this.address = address;    }    }package com.jpabook.jpashop.repository.order.query;import com.fasterxml.jackson.annotation.JsonIgnore;import lombok.Data;@Datapublic class OrderItemQueryDto {    @JsonIgnore    private Long orderId;    private String itemName;    private int orderPrice;    private int count;    public OrderItemQueryDto(Long orderId, String itemName, int orderPrice, int count){        this.orderId=orderId;        this.itemName=itemName;        this.orderPrice=orderPrice;        this.count=count;    }}@GetMapping(\"/api/v4/orders\")    public List&lt;OrderQueryDto&gt; ordersV4(){        return orderQueryRepository.findOrderQueryDtos();    }총 3번의 쿼리가 나감. 쿼리는 하나인데 여러개의 쿼리가 나갔으니 n+1임. 코드가 단순하고 유지보수가 쉬움.  컬렉션 조회 최적화public List&lt;OrderQueryDto&gt; findAllByDto_optimization() {        List&lt;OrderQueryDto&gt; result = findOrders();        List&lt;Long&gt; orderIds = result.stream().map(o-&gt;o.getOrderId()).collect(Collectors.toList());        List&lt;OrderItemQueryDto&gt; orderItems = em.createQuery(\"select new com.jpabook.jpashop.repository.order.query.OrderItemQueryDto(oi.order.id, i.name, oi.orderPrice, oi.count) from OrderItem oi join oi.item i where oi.order.id in :orderIds\"        , OrderItemQueryDto.class).setParameter(\"orderIds\", orderIds).getResultList();        Map&lt;Long, List&lt;OrderItemQueryDto&gt;&gt; orderItemMap = orderItems.stream().collect(Collectors.groupingBy(orderItemQueryDto-&gt;orderItemQueryDto.getOrderId())); //orderId를 기준으로 map으로 변경됨        result.forEach(o-&gt;o.setOrderItems(orderItemMap.get(o.getOrderId())));        return result;    }in으로 변경. 조회 시 쿼리가 2번 나감. 성능이 최적화되지만 코드가 복잡해짐.  플랫 데이터 최적화package com.jpabook.jpashop.repository.order.query;import java.time.LocalDateTime;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.OrderStatus;import lombok.Data;@Datapublic class OrderFlatDto {    private Long orderId;    private String name;    private LocalDateTime orderDate; //주문시간    private Address address;    private OrderStatus orderStatus;    private String itemName;//상품 명    private int orderPrice; //주문 가격    private int count;      //주문 수량    public OrderFlatDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address, String itemName, int orderPrice, int count) {        this.orderId = orderId;        this.name = name;        this.orderDate = orderDate;        this.orderStatus = orderStatus;        this.address = address;        this.itemName = itemName;        this.orderPrice = orderPrice;        this.count = count;    }}public List&lt;OrderFlatDto&gt; findAllByDto_flat() {        return em.createQuery(            \"select new com.jpabook.jpashop.repository.order.query.OrderFlatDto(o.id, m.name, o.orderDate, o.status, d.address, i.name, oi.orderPrice, oi.count)\" +                    \" from Order o\" +                    \" join o.member m\" +                    \" join o.delivery d\" +                    \" join o.orderItems oi\" +                    \" join oi.item i\", OrderFlatDto.class)            .getResultList();    }한번의 쿼리가 나가지만위와같이 데이터 중복이 일어남. order 4번이 두번나옴. 페이징도 불가능.package com.jpabook.jpashop.repository.order.query;import java.time.LocalDateTime;import java.util.List;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.OrderStatus;import lombok.Data;import lombok.EqualsAndHashCode;@Data@EqualsAndHashCode(of=\"orderId\") //얘를 기준으로 그룹화public class OrderQueryDto {    private Long orderId;    private String name;    private LocalDateTime orderDate;    private OrderStatus status;    private Address address;    private List&lt;OrderItemQueryDto&gt; orderItems;    public OrderQueryDto(Long orderId, String name, LocalDateTime order, OrderStatus status, Address address){        this.orderId = orderId;        this.name = name;        this.orderDate = order;        this.status=status;        this.address = address;    }    public OrderQueryDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address, List&lt;OrderItemQueryDto&gt; orderItems) {        this.orderId = orderId;        this.name = name;        this.orderDate = orderDate;        this.status = orderStatus;        this.address = address;        this.orderItems = orderItems;    }}@GetMapping(\"/api/v7/orders\")    public List&lt;OrderQueryDto&gt; ordersV7(){        List&lt;OrderFlatDto&gt; flats = orderQueryRepository.findAllByDto_flat();        return flats.stream()                .collect(groupingBy(o -&gt; new OrderQueryDto(o.getOrderId(), o.getName(), o.getOrderDate(), o.getOrderStatus(), o.getAddress()),                        mapping(o -&gt; new OrderItemQueryDto(o.getOrderId(), o.getItemName(), o.getOrderPrice(), o.getCount()), toList())                )).entrySet().stream()                .map(e -&gt; new OrderQueryDto(e.getKey().getOrderId(), e.getKey().getName(), e.getKey().getOrderDate(), e.getKey().getOrderStatus(), e.getKey().getAddress(), e.getValue()))                .collect(toList());    }이런식으로 DTO로 변환해서 내보내도 됨. 그럼 중복값없이 나옴. (근데 toList 메소드가 없다고 뜸.. 일아봐야함)일단 order로 그룹화해서 일치하는 부분을 orderitem list에 넣어서 출력하는 것만 알아두면될듯성능이 좋으나 order를 기준으로 페이징이 불가능. 페이징을 자주쓰기때문에 사용하기 애매하고 중복데이턱 많으면 컬렉션 조회 최적화가 성능이 더 잘나오기도 한다.권장순서  엔티티 조회 방식으로 우선 접근          페치조인으로 쿼리수 최적화      컬렉션 최적화                  페이징 필요 - hibernate.default_batch_fetch_size, @BatchSize로 최적화          페이징 필요x - 페치 조인 사용                      엔티티 조회 방식으로 해결이 안되면 DTO조회 방식 사용  DTO조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate 사용"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용2] 기본",
    "url": "/posts/%EA%B8%B0%EB%B3%B8/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용2, ORM",
    "date": "2023-01-07 00:00:00 +0900",
    





    
    "snippet": "패키지는 API(JSON)와 템플릿 엔진(HTML)을 사용하는 컨트롤러를 분리할것. 공통으로 예외처리를 할때 패키지나 구성단위로 많이함.회원가입package com.jpabook.jpashop.api;import javax.validation.Valid;import org.springframework.web.bind.annotation.PostMapp...",
    "content": "패키지는 API(JSON)와 템플릿 엔진(HTML)을 사용하는 컨트롤러를 분리할것. 공통으로 예외처리를 할때 패키지나 구성단위로 많이함.회원가입package com.jpabook.jpashop.api;import javax.validation.Valid;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.service.MemberService;import lombok.Data;import lombok.RequiredArgsConstructor;@RestController@RequiredArgsConstructorpublic class MemberApiController {    private final MemberService memberService;    @PostMapping(\"/api/v1/members\")    public CreateMemberResponse saveMemberV1(@RequestBody @Valid Member member){        Long id =  memberService.join(member);        return new CreateMemberResponse(id);    }    @Data    static class CreateMemberResponse{        private Long id;                public CreateMemberResponse(Long id) {            this.id = id;        }    }}json파일로 내보내면 id만 뜸.package com.jpabook.jpashop.domain;import java.util.ArrayList;import java.util.List;import javax.persistence.Embedded;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.OneToMany;import javax.validation.constraints.NotEmpty;import lombok.Getter;import lombok.Setter;@Entity@Getter@Setterpublic class Member {    @Id @GeneratedValue    private Long id;    @NotEmpty    private String name;    @Embedded    private Address address;    @OneToMany(mappedBy = \"member\")    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();}@NotEmpty때문에 이름이 비면이렇게 뜸중복값은 이렇게 뜸그런데 이렇게 검증로직이 엔티티에 들어가있으면 api마다 다른 조건에 대응하기가 힘듦.그리고 엔티티가 변경되면 api스펙자체가 변경됨. 엔티티와 api가 1대1로 매핑된 상태 → DTO를 만들어야함.요즘은 간편가입, 소셜로그인 가입 등 여러 케이스가 있어서 DTO가 많이 생김package com.jpabook.jpashop.api;import javax.validation.Valid;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.service.MemberService;import lombok.Data;import lombok.RequiredArgsConstructor;@RestController@RequiredArgsConstructorpublic class MemberApiController {    private final MemberService memberService;    @PostMapping(\"/api/v1/members\")    public CreateMemberResponse saveMemberV1(@RequestBody @Valid CreateMemberRequest request){        Member member = new Member();        member.setName(request.getName());        Long id =  memberService.join(member);        return new CreateMemberResponse(id);    }    @Data    static class CreateMemberRequest{        private String name;    }    @Data    static class CreateMemberResponse{        private Long id;                public CreateMemberResponse(Long id) {            this.id = id;        }    }}이렇게 만들라는 소리임회원 정보 수정@PutMapping(\"/api/v2/members/{id}\")    public UpdateMemberResponse updateMemberV2(@PathVariable(\"id\") Long id, @RequestBody @Valid UpdateMemberRequest request){        memberService.update(id, request.getName()); //바로 return Member를 해줘도 되긴하지만 일단 이렇게함        Member findMember = memberService.findOne(id);         return new UpdateMemberResponse(id, findMember.getName());    }    @Data    static class UpdateMemberRequest{        private String name;    }    @Data    @AllArgsConstructor    static class UpdateMemberResponse{        private Long id;        private String name;    }회원 조회// @GetMapping(\"/api/v1/members\")    // public List&lt;Member&gt; membersV1() {    //     return memberService.findMembers();    // } //안좋은 예시. 실제로 실행해보니 무한로딩이 남. 양방향 매핑때문에..일단 @JsonIgnore를 썼는데 좋은 방법이 아님    @GetMapping(\"/api/v2/members\")    public Result memberV2(){        List&lt;Member&gt; findMembers = memberService.findMembers();        List&lt;MemberDto&gt; collect = findMembers.stream().map(m-&gt;new MemberDto(m.getName())).collect(Collectors.toList());        return new Result(collect);    }    @Data    @AllArgsConstructor    static class Result&lt;T&gt;{        private T data;    }    @Data    @AllArgsConstructor    static class MemberDto{        private String name;    }내가 노출할거만 DTO에 필드로 만들면됨"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용2] 고급 - 지연로딩, 조회성능 최적화",
    "url": "/posts/%EA%B3%A0%EA%B8%89_%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9,-%EC%A1%B0%ED%9A%8C%EC%84%B1%EB%8A%A5_%EC%B5%9C%EC%A0%81%ED%99%94/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용2, ORM",
    "date": "2023-01-07 00:00:00 +0900",
    





    
    "snippet": "  @Component : 개발자가 직접 만든 객체를 bean으로 만드는 것.  @PostConstruct : 스프링이 bean을 초기화 한 후에 딱 한번만 실행함  선생님께서 저번에 뭘 만들어도 마스터 계정 하나는 만들고 시작해야한다고 하셨는데 그럴때 사용하는 것 같다.package com.jpabook.jpashop;import javax.anno...",
    "content": "  @Component : 개발자가 직접 만든 객체를 bean으로 만드는 것.  @PostConstruct : 스프링이 bean을 초기화 한 후에 딱 한번만 실행함  선생님께서 저번에 뭘 만들어도 마스터 계정 하나는 만들고 시작해야한다고 하셨는데 그럴때 사용하는 것 같다.package com.jpabook.jpashop;import javax.annotation.PostConstruct;import javax.persistence.EntityManager;import javax.transaction.Transactional;import org.springframework.stereotype.Component;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.Delivery;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.domain.Order;import com.jpabook.jpashop.domain.OrderItem;import com.jpabook.jpashop.domain.item.Book;import lombok.RequiredArgsConstructor;@Component @RequiredArgsConstructorpublic class InitDb {    private final InitService initService;    @PostConstruct    public void init(){        initService.dbInit1();        initService.dbInit2();    }        @Component    @Transactional    @RequiredArgsConstructor    static class InitService {        private final EntityManager em;        public void dbInit1() {            System.out.println(\"Init1\" + this.getClass());            Member member = createMember(\"userA\", \"서울\", \"1\", \"1111\");            em.persist(member);            Book book1 = createBook(\"JPA1 BOOK\", 10000, 100);            em.persist(book1);            Book book2 = createBook(\"JPA2 BOOK\", 20000, 100);            em.persist(book2);            OrderItem orderItem1 = OrderItem.createOrderItem(book1, 10000, 1);            OrderItem orderItem2 = OrderItem.createOrderItem(book2, 20000, 2);            Delivery delivery = createDelivery(member);            Order order = Order.createOrder(member, delivery, orderItem1, orderItem2);            em.persist(order);        }        public void dbInit2() {            Member member = createMember(\"userB\", \"진주\", \"2\", \"2222\");            em.persist(member);            Book book1 = createBook(\"SPRING1 BOOK\", 20000, 200);            em.persist(book1);            Book book2 = createBook(\"SPRING2 BOOK\", 40000, 300);            em.persist(book2);            OrderItem orderItem1 = OrderItem.createOrderItem(book1, 20000, 3);            OrderItem orderItem2 = OrderItem.createOrderItem(book2, 40000, 4);            Delivery delivery = createDelivery(member);            Order order = Order.createOrder(member, delivery, orderItem1, orderItem2);            em.persist(order);        }        private Member createMember(String name, String city, String street, String zipcode) {            Member member = new Member();            member.setName(name);            member.setAddress(new Address(city, street, zipcode));            return member;        }        private Book createBook(String name, int price, int stockQuantity) {            Book book1 = new Book();            book1.setName(name);            book1.setPrice(price);            book1.setStockQuantity(stockQuantity);            return book1;        }        private Delivery createDelivery(Member member) {            Delivery delivery = new Delivery();            delivery.setAddress(member.getAddress());            return delivery;        }    }}시작할때 데이터 넣고 시작양방향 연관관계 문제이문제.. 양방향 매핑이 걸린곳에 @JsonIgnore를 걸어줘도 이런 문제가 생김.LAZY를 걸어두면 null을 들고올 수는 없으니 그 자리에 proxy를 넣어둠@ManyToOne(fetch = FetchType.LAZY)@JoinColumn(name = \"member_id\")private Member member=new ByteBuddyInterceptor();이런 형태로 걸린다는 소리임. 저기서 ByteBuddyInterceptor가 proxy인듯그리고 member를 꺼내 쓸때 DB에 쿼리문을 날려서 member안에 진짜 객체를 넣어주는 듯근데 JSON이 ByteBuddyInterceptor를 사용할 수 없음!!그래서 에러가 나는 것임!!  [!info]  https://mvnrepository.com/artifact/com.fasterxml.jackson.datatype/jackson-datatype-hibernate5이거 gradle에 넣어줄것package com.jpabook.jpashop;import org.hibernate.Hibernate;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import com.fasterxml.jackson.datatype.hibernate5.Hibernate5Module;@SpringBootApplicationpublic class JpashopApplication {\tpublic static void main(String[] args) {\t\tSpringApplication.run(JpashopApplication.class, args);\t}\t@Bean\tHibernate5Module hibernate5Module(){\t\treturn new Hibernate5Module();\t}}근데 사실 엔티티를 내보내는 경우가 거의 없어서 이렇게까진 안해도된다고 하심..^^일단 null로 나옴@Bean\tHibernate5Module hibernate5Module() {\t\tHibernate5Module hibernate5Module = new Hibernate5Module();\t\t//강제 지연 로딩 설정\t\thibernate5Module.configure(Hibernate5Module.Feature.FORCE_LAZY_LOADING, true);\t\treturn hibernate5Module;이렇게 해주면 json내보낼때 지연로딩해놓은걸 조회하긴 함@GetMapping(\"/api/v1/simple-orders\")    public List&lt;Order&gt; ordersV1() {        List&lt;Order&gt; all = orderRepository.findAllByString(new OrderSearch());        for (Order order : all) {            order.getMember().getName(); //Lazy 강제 초기화            order.getDelivery().getAddress(); //Lazy 강제 초기화        }        return all;    }아니면 뭐 이렇게..어쨌든 이렇게 하면 안됨 DTO로 변환해서 반환할 것.@GetMapping(\"/api/v2/simple-orders\")    public List&lt;SimpleOrderDto&gt; orderV2(){        List&lt;Order&gt; orders = orderRepository.findAllByString(new OrderSearch());        List&lt;SimpleOrderDto&gt; result = orders.stream().map(o-&gt; new SimpleOrderDto(o)).collect(Collectors.toList());        return result;    }    @Data    static class SimpleOrderDto{        private Long orderId;        private String name;        private LocalDateTime orderDate;        private OrderStatus orderStatus;        private Address address;                public SimpleOrderDto(Order order){            orderId=order.getId();            name = order.getMember().getName(); //LAZY초기화            orderDate = order.getOrderDate();            orderStatus = order.getStatus(); //LAZY초기화            address = order.getDelivery().getAddress();        }    }  [!important]List&lt; SimpleOrderDto &gt; result = orders.stream().map(o-&gt; new SimpleOrderDto(o)).collect(Collectors.toList());orders를 가져와서 stream으로 돌린다음(컬렉션 안의 요소들을 순차접근) map(A를 B로 바꿈)최종적으로 쿼리가 5번나갔음. order한번 member2번 delivery 2번. n+1문제 발생⇒ 페치조인 사용 필요페치조인정말 자주 쓰임!!!  OneToOne, ManyToOne joinpublic List&lt;Order&gt; findAllWithMemberDelivery() {  return em.createQuery(\"select o from Order o join fetch o.member m join fetch o.delivery\", Order.class).getResultList();}repository에 만들어줬음@GetMapping(\"/api/v3/simple-orders\")public List&lt;SimpleOrderDto&gt; orderV3(){  List&lt;Order&gt; orders = orderRepository.findAllWithMemberDelivery();    List&lt;SimpleOrderDto&gt; result = orders.stream().map(o-&gt; new SimpleOrderDto(o)).collect(Collectors.toList());  return result;}한번의 쿼리로 완성가능쿼리문으로 바로 DTO 리스트를 가져오는 법도 있음package com.jpabook.jpashop.repository;import java.time.LocalDateTime;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.OrderStatus;import lombok.Data;@Datapublic class OrderSimpleQueryDto {    private Long orderId;    private String name;    private LocalDateTime orderDate; //주문시간    private OrderStatus orderStatus;    private Address address;    public OrderSimpleQueryDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address) {        this.orderId = orderId;        this.name = name;        this.orderDate = orderDate;        this.orderStatus = orderStatus;        this.address = address;    }}package com.jpabook.jpashop.repository.order.simpleQuery;import java.util.List;import javax.persistence.EntityManager;import org.springframework.stereotype.Repository;import com.jpabook.jpashop.repository.OrderSimpleQueryDto;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class OrderSimpleQueryRepository {    private final EntityManager em;        public List&lt;OrderSimpleQueryDto&gt; findOrderDto() {        return em.createQuery(\"select new com.jpabook.jpashop.repository.OrderSimpleQueryDto(o.id, m.name, o.orderDate, o.status, d.address) from Order o \"            +\"join o.member m join o.delivery d\", OrderSimpleQueryDto.class).getResultList();        //DTO가 매핑이 될 수가 없음!!자동으로 생성자에 넣어주는 기능은 없음        //DTO의 생성자는 엔티티 자체를 파라미터로 받으면 안되고 위 쿼리문에서 나올 컬럼을 하나하나 넣어줘야함    }}대신 다른식으로 활용하기 어렵지만 성능상 더 좋긴함. 그러나 애플리케이션 네트웍 용량 최적화는 생각보다 미비함. API스펙에 맞춘 코드가 repository에 들어가는 단점이 있음그럼 뭘 써야하냐..는 나중에 설명함query repository를 저장하는 패키지를 만들어두는 것을 추천함이렇게 해도 안되면 네이티브 SQL이나 스프링 JDBC template을 사용해서 SQL을 직접 사용함  OneToMany join엔티티를 DTO로 변환할때 엔티티를 DTO에 감싸서 보내게되면 아무런 의미가 없어짐. 엔티티안에 연관 엔티티도 DTO로 변환해서 내보내야함"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] JSP",
    "url": "/posts/jsp/",
    "categories": "Spring",
    "tags": "spring, jsp, 국비교육",
    "date": "2023-01-04 00:00:00 +0900",
    





    
    "snippet": "jar : java application runtimewar : web archive runtime프로젝트 생성시 빼먹은 패키지가있다면 메이븐에서 추가해도됨  [!info]  https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper/10.1.4이거 추가. 버전에 숫자말...",
    "content": "jar : java application runtimewar : web archive runtime프로젝트 생성시 빼먹은 패키지가있다면 메이븐에서 추가해도됨  [!info]  https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper/10.1.4이거 추가. 버전에 숫자말고 다른게있으면 테스트버전임 jasper가 jsp view resolver임server.port=80으로하면 localhost로 들어가도 접속됨. 포트기본번호라서. 원격배포할때 80으로 내보냄dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-web'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\tprovidedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'\t// https://mvnrepository.com/artifact/org.projectlombok/lombok\tcompileOnly group: 'org.projectlombok', name: 'lombok', version: '1.18.24'\t// https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper\timplementation group: 'org.apache.tomcat.embed', name: 'tomcat-embed-jasper', version: '10.1.4'\timplementation 'jstl:jstl:1.2'}server.port=8989# jsp 사용spring.mvc.view.prefix=/WEB-INF/viewsspring.mvc.view.suffix=.jsp폴더 구성메인에 하위폴더를 만들어야함index.jsp&lt;%@page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;     &lt;h1&gt;index page&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 웹 계층 개발",
    "url": "/posts/%EC%9B%B9_%EA%B3%84%EC%B8%B5_%EA%B0%9C%EB%B0%9C/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-04 00:00:00 +0900",
    





    
    "snippet": "https://getbootstrap.com/docs/5.1/getting-started/download/다운받아서 resources의 static폴더 안에 넣으면됨버전문제로 잘 안되는듯 쌤이랑 같은버전까니까 됨회원 가입@NotEmpty - 필수값 표시스프링 부트 버전이 2.3 이상이라면 build.gredle에 implementation ‘org.s...",
    "content": "https://getbootstrap.com/docs/5.1/getting-started/download/다운받아서 resources의 static폴더 안에 넣으면됨버전문제로 잘 안되는듯 쌤이랑 같은버전까니까 됨회원 가입@NotEmpty - 필수값 표시스프링 부트 버전이 2.3 이상이라면 build.gredle에 implementation ‘org.springframework.boot:spring-boot-starter-validation’ 추가해줘야함html에서 &lt;form role=\"form\" action=\"/members/new\" th:object=\"${memberForm}\" method=\"post\"&gt;중 th:object=”${memberForm}” 은 이 form안에서는 memberForm을 사용하겠다는 의미임&lt;div class=\"form-group\"&gt;               &lt;label th:for=\"city\"&gt;도시&lt;/label&gt;               &lt;input type=\"text\" th:field=\"*{city}\" class=\"form-control\" placeholder=\"도시를 입력하세요\"&gt;&lt;/div&gt;이렇게쓰면&lt;div class=\"form-group\"&gt;     &lt;label for=\"city\"&gt;도시&lt;/label&gt;     &lt;input type=\"text\" class=\"form-control\" placeholder=\"도시를 입력하세요\" id=\"city\" name=\"city\" value=\"\"&gt;&lt;/div&gt;이렇게 나옴id랑 name이 중복이면 저렇게 표시하기도함 그냥써도됨package com.jpabook.jpashop.controller;import javax.validation.constraints.NotEmpty;import lombok.Getter;import lombok.Setter;@Getter @Setterpublic class MemberForm {     @NotEmpty(message=\"회원이름은 필수입니다.\")     private String name;     private String city;     private String street;     private String zipcode;}package com.jpabook.jpashop.controller;import javax.validation.Valid;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import com.jpabook.jpashop.domain.Address;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.service.MemberService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructorpublic class MemberController {          private final MemberService memberService;     @GetMapping(\"/members/new\")     public String createForm(Model model){          model.addAttribute(\"memberForm\", new MemberForm());          return \"/members/createMemberForm\";     }     @PostMapping(\"/members/new\")     public String create(@Valid MemberForm form, BindingResult result){          System.out.println(result.hasErrors());          if(result.hasErrors()){               return \"members/createMemberForm\";          }          Address address = new Address(form.getCity(), form.getStreet(), form.getZipcode());          Member member = new Member();          member.setName(form.getName());          member.setAddress(address);          memberService.join(member);          return \"redirect:/\";     }}그래도 @NotEmpty가 제대로 동작을 안함.. 재시도해봐야함..정보 수정@GetMapping(\"items/{itemId}/edit\")    public String updateItemForm(@PathVariable(\"itemId\") Long itemId, Model model){        Book item = (Book) itemService.findOne(itemId); //추천하지않는 방법이나 예시를 위해 사용        BookForm form = new BookForm();        form.setId(item.getId());        form.setName(item.getName());        form.setPrice(item.getPrice());        form.setStockQuantity(item.getStockQuantity());        form.setAuthor(item.getAuthor());        form.setIsbn(item.getIsbn());        model.addAttribute(\"form\", form);        return \"items/updateItemForm\";    }    @PostMapping(\"items/{itemId}/edit\")    public String updateItem(@PathVariable String itemId, @ModelAttribute(\"form\") BookForm form){        Book book = new Book();        book.setId(form.getId());        book.setName(form.getName());        book.setPrice(form.getPrice());        book.setStockQuantity(form.getStockQuantity());        book.setAuthor(form.getAuthor());        book.setIsbn(form.getIsbn());        itemService.saveItem(book);        return \"redirect:/items\";    }@ModelAttribute - 파라미터로 넘어온 값을 객체로 만들어주는 어노테이션인듯?변경감지와 병합(merge)준영속 - 새로운 객체를 만들었으나 setter를 통해 기본키를 설정해 준 경우 - DB를 한번 거친 상태 = 준영속 상태의 객체⇒ 영속성 컨텍스트가 더는 관리하지 않는 엔티티!!!@PostMapping(\"items/{itemId}/edit\")public String updateItem(@PathVariable String itemId, @ModelAttribute(\"form\") BookForm form){    Book book = new Book();    book.setId(form.getId());    book.setName(form.getName());    book.setPrice(form.getPrice());    book.setStockQuantity(form.getStockQuantity());    book.setAuthor(form.getAuthor());    book.setIsbn(form.getIsbn());    itemService.saveItem(book);    return \"redirect:/items\";}위 예시에서는 itemService.saveItem(book)에서 수정을 시도하는 Book객체를 의미함. Book객체는 이미 DB에 한번 저장되어 식별자가 존재하는 상태임. 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있음!!아무리 값을 수정해도 save를 해주지 않으면 DB가 바뀌지 않는 상태이런 상태의 준영속 엔티티의 값을 수정하는 방법?      변경감지(dirty checking) 기능 사용    변경을 감지해서 자동으로 update구문을 날려주는 것     @Transactional public void updateItem(Long id, Book param){   Item findItem = itemRepository.findOne(id);   findItem.setPrice(param.getPrice());   findItem.setName(param.getName());   findItem.setStockQuantity(param.getStockQuantity()); }        준영속 상태의 엔티티를 이용해 영속상태의 엔티티를 가져옴    사실 set을 사용하는 것이 아니라 값이 변경되는 메소드를 만드는 것이 좋음        병합(merge) 사용(사용하지않는편이 좋음)     public void save(Item item){   if(item.getId()==null){ //DB에 저장된적없는 순수한 객체이면       em.persist(item); //DB저장   }else{       em.merge(item); //업데이트같은 느낌   }    }            준영속 상태이던 member가 영속상태로 바뀌는것이 아니라 영속상태인 mergeMember를 반환해주는 것임.    ❗병합 사용시 모든 속성이 변경됨!! 병합 시 값이 없으면 null로 업데이트될 수도 있음!!!!!! 모든 필드를 교체한다는 점 기억해둘것!!    [!important]컨트롤러에서 엔티티를 남발하지 말 것@PostMapping(\"items/{itemId}/edit\")    public String updateItem(@PathVariable Long itemId, @ModelAttribute(\"form\") BookForm form){        itemService.updateItem(itemId, form.getName(), form.getPrice(), form.getStockQuantity());        return \"redirect:/items\";    }@Transactional    public void updateItem(Long id, String name, int price, int stock){        Item findItem = itemRepository.findOne(id);        findItem.setPrice(price);        findItem.setName(name);        findItem.setStockQuantity(stock);    }위 코드가 더 좋은 코드라는 소리임트랜젝션이 있는 서비스계층에 식별자(id)와 변경할 데이터를 명확하게 전달.(파라미터 or DTO)트랜젝션이 있는 서비스 계층에서 영속상태의 엔티티를 조회, 엔티티 데이터 직접 변경트랜젝션 커밋시점에 변경 감지가 실행됨주문 내역, 취소@GetMapping(\"/orders\")    public String orderList(@ModelAttribute(\"orderSearch\") OrderSearch orderSearch, Model model){        List&lt;Order&gt; orders = orderService.findOrders(orderSearch);        model.addAttribute(\"orders\", orders);        return \"order/orderList\";    }    @PostMapping(\"/orders/{orderId}/cancel\")    public String cancelOrder(@PathVariable(\"orderId\") Long orderId) {        orderService.cancelOrder(orderId);        return \"redirect:/orders\";    }"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 주문 도메인 개발",
    "url": "/posts/%EC%A3%BC%EB%AC%B8_%EB%8F%84%EB%A9%94%EC%9D%B8/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-03 00:00:00 +0900",
    





    
    "snippet": "구현기능  상품주문  주문내역 조회  주문 취소개발 순서      주문 엔티티, 주문상품 엔티티 개발     package com.jpabook.jpashop.domain;         import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List;     impor...",
    "content": "구현기능  상품주문  주문내역 조회  주문 취소개발 순서      주문 엔티티, 주문상품 엔티티 개발     package com.jpabook.jpashop.domain;         import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List;     import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.EnumType; import javax.persistence.Enumerated; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table;     import lombok.Getter; import lombok.Setter;     @Entity @Table(name=\"orders\") @Getter@Setter public class Order {     @Id @GeneratedValue     @Column(name=\"order_id\")     private Long id;             @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"member_id\")     private Member member;     @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL)     private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();     @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)     @JoinColumn(name=\"delivery_id\")     private Delivery delivery;         private LocalDateTime orderDate;     @Enumerated(EnumType.STRING)     private OrderStatus status;         //연관관계 메소드     public void setMember(Member member){         this.member = member;         member.getOrders().add(this);     }     public void addOrderItem(OrderItem orderItem){         orderItems.add(orderItem);         orderItem.setOrder(this);     }     public void setDelivery(Delivery delivery){         this.delivery = delivery;         delivery.setOrder(this);     }     //주문     public static Order createOrder(Member member, Delivery delivery, OrderItem...orderItems){         Order order = new Order();         order.setMember(member);         order.setDelivery(delivery);         for(OrderItem orderItem: orderItems){             order.addOrderItem(orderItem);         }         order.setStatus(OrderStatus.ORDER);         order.setOrderDate(LocalDateTime.now());         return order;     }     //주문 취소     public void cancel(){         if(delivery.getStatus()==DeliveryStatus.COMP){             throw new IllegalStateException(\"이미 배송 완료된 상품은 취소가 불가능합니다.\");         }         this.setStatus(OrderStatus.CANCLE);         for(OrderItem orderItem : orderItems){             orderItem.cancel();         }     }         //전체 주문 조회     public int getTotalPrice(){         int totalPrice=0;         for(OrderItem orderItem : orderItems){             totalPrice += orderItem.getTotalPrice();         }         return totalPrice;     } }         package com.jpabook.jpashop.domain;         import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne;     import com.jpabook.jpashop.domain.item.Item;     import lombok.Getter; import lombok.Setter;     @Entity @Getter @Setter public class OrderItem {     @Id @GeneratedValue     @Column(name = \"order_item_id\")     private Long id;     @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name=\"item_id\")     private Item item;         @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name=\"order_id\")     private Order order;         private int orderPrice;         private int count;         //비즈니스 로직     public void cancel() {         getItem().addStock(count);     }         public int getTotalPrice() {         return getOrderPrice() * getCount();     }        //생성 메소드     public static OrderItem createOrderItem(Item item, int orderPrice, int count){         OrderItem orderItem = new OrderItem();         orderItem.setItem(item);         orderItem.setOrderPrice(orderPrice);         orderItem.setCount(count);             item.removeStock(count);             return orderItem;     } }            주문 리포지토리 개발     package com.jpabook.jpashop.repository;     import javax.persistence.EntityManager;     import org.springframework.stereotype.Repository;     import com.jpabook.jpashop.domain.Order;     import lombok.RequiredArgsConstructor;     @Repository @RequiredArgsConstructor public class OrderRepository {     private final EntityManager em;         public void save(Order order){         em.persist(order);     }         public Order findOne(Long id){         return em.find(Order.class, id);     } }            주문 서비스 개발 @NoArgsConstructor(access = AccessLevel.PROTECTED) //기본생성자 쓰지말라는 의미.     package com.jpabook.jpashop.domain;         import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List;     import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.EnumType; import javax.persistence.Enumerated; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table;     import com.jpabook.jpashop.repository.OrderRepository; import com.jpabook.jpashop.service.OrderService;     import lombok.AccessLevel; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter;     @Entity @Table(name=\"orders\") @Getter@Setter @NoArgsConstructor(access = AccessLevel.PROTECTED) public class Order {     @Id @GeneratedValue     @Column(name=\"order_id\")     private Long id;             @ManyToOne(fetch = FetchType.LAZY)     @JoinColumn(name = \"member_id\")     private Member member;     @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL)     private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();     @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)     @JoinColumn(name=\"delivery_id\")     private Delivery delivery;         private LocalDateTime orderDate;     @Enumerated(EnumType.STRING)     private OrderStatus status;         //연관관계 메소드     public void setMember(Member member){         this.member = member;         member.getOrders().add(this);     }     public void addOrderItem(OrderItem orderItem){         orderItems.add(orderItem);         orderItem.setOrder(this);     }     public void setDelivery(Delivery delivery){         this.delivery = delivery;         delivery.setOrder(this);     }     //주문     public static Order createOrder(Member member, Delivery delivery, OrderItem...orderItems){         Order order = new Order();         order.setMember(member);         order.setDelivery(delivery);         for(OrderItem orderItem: orderItems){             order.addOrderItem(orderItem);         }         order.setStatus(OrderStatus.ORDER);         order.setOrderDate(LocalDateTime.now());         return order;     }     //주문 취소     public void cancel(){         if(delivery.getStatus()==DeliveryStatus.COMP){             throw new IllegalStateException(\"이미 배송 완료된 상품은 취소가 불가능합니다.\");         }         this.setStatus(OrderStatus.CANCLE);         for(OrderItem orderItem : orderItems){             orderItem.cancel();         }     }         //전체 주문 조회     public int getTotalPrice(){         int totalPrice=0;         for(OrderItem orderItem : orderItems){             totalPrice += orderItem.getTotalPrice();         }         return totalPrice;     }         //검색     // public List&lt;Order&gt; findOrders(OrderSearch orderSearch){     //     return OrderRepository.findAll(orderSearch);     // } }        주문, 주문취소 메소드를 보면 비지니스로직 대부분이 엔티티에 있음. 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 함. 이처럼 엔티티가 비지니스 로직을 가지고 객체 지향의 특성을 활용하는 것을 도메인 모델 패턴이라고 함 반대로 비지니스 로직이 거의 없고 서비스에서 대부분의 로직을 처리하는 것을 트랜잭션 스크립트 패턴이라고 함        주문 검색 기능 개발     package com.jpabook.jpashop.repository;     import java.util.List;     import javax.persistence.EntityManager; import javax.persistence.TypedQuery;     import org.springframework.stereotype.Repository; import org.springframework.util.StringUtils;     import com.jpabook.jpashop.domain.Order; import com.jpabook.jpashop.domain.OrderSearch;     import lombok.RequiredArgsConstructor;     @Repository @RequiredArgsConstructor public class OrderRepository {     private final EntityManager em;         public void save(Order order){         em.persist(order);     }         public Order findOne(Long id){         return em.find(Order.class, id);     }     public List&lt;Order&gt; findAll(OrderSearch orderSearch){         return em.createQuery(\"select o from Order o join o.member m where o.status = :status and m.name like :name\", Order.class)         .setParameter(\"status\", orderSearch.getOrderStatus()).setParameter(\"name\", orderSearch.getMemberName())         .setMaxResults(1000) //최대 1000건         .getResultList();     }         //비추방법     public List&lt;Order&gt; findAllByString(OrderSearch orderSearch) {             String jpql = \"select o from Order o join o.member m\";         boolean isFirstCondition = true;         //주문 상태 검색     if (orderSearch.getOrderStatus() != null) {         if (isFirstCondition) {             jpql += \" where\";             isFirstCondition = false;         } else {             jpql += \" and\";         }         jpql += \" o.status = :status\";     }          //회원 이름 검색(이것도 비추)     if (StringUtils.hasText(orderSearch.getMemberName())) {         if (isFirstCondition) {             jpql += \" where\";             isFirstCondition = false;         } else {             jpql += \" and\";         }         jpql += \" m.name like :name\";     }         TypedQuery&lt;Order&gt; query = em.createQuery(jpql, Order.class)             .setMaxResults(1000);         if (orderSearch.getOrderStatus() != null) {         query = query.setParameter(\"status\", orderSearch.getOrderStatus());     }     if (StringUtils.hasText(orderSearch.getMemberName())) {         query = query.setParameter(\"name\", orderSearch.getMemberName());     }         return query.getResultList(); } }            주문 기능 테스트  "
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 상품 도메인 개발",
    "url": "/posts/%EC%83%81%ED%92%88_%EB%8F%84%EB%A9%94%EC%9D%B8_%EA%B0%9C%EB%B0%9C/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-03 00:00:00 +0900",
    





    
    "snippet": "  setter를 이용하지 않고 재고 변경package com.jpabook.jpashop.exception;public class NotEnoughStockException extends RuntimeException{    public NotEnoughStockException(){        super();    }    public NotEn...",
    "content": "  setter를 이용하지 않고 재고 변경package com.jpabook.jpashop.exception;public class NotEnoughStockException extends RuntimeException{    public NotEnoughStockException(){        super();    }    public NotEnoughStockException(String message){        super(message);    }    public NotEnoughStockException(String message, Throwable cause){        super(message, cause);    }    public NotEnoughStockException(Throwable cause){        super(cause);    }}package com.jpabook.jpashop.domain.item;import java.util.ArrayList;import java.util.List;import javax.persistence.Column;import javax.persistence.DiscriminatorColumn;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Inheritance;import javax.persistence.InheritanceType;import javax.persistence.ManyToMany;import com.jpabook.jpashop.domain.Category;import com.jpabook.jpashop.exception.NotEnoughStockException;import lombok.Getter;import lombok.Setter;@Entity@Getter @Setter@Inheritance(strategy = InheritanceType.SINGLE_TABLE)@DiscriminatorColumn(name=\"dtype\")public abstract class Item {    @Id    @GeneratedValue    @Column(name = \"item_id\")    private Long id;    private String name;    private int price;    private int stockQuantity;    @ManyToMany(mappedBy = \"items\")    private List&lt;Category&gt; categories = new ArrayList&lt;&gt;();    //비지니스 로직    //재고 증가    public void addStock(int quantity){        this.stockQuantity+=quantity;    }    //재고 감소    public void removeStock(int quantity){        int restStock = this.stockQuantity-quantity;        if(restStock&lt;0){            throw new NotEnoughStockException(\"need more stock\");        }        this.stockQuantity = restStock;    }}재고를 가진 엔티티안에 재고 증감 메소드를 작성함  repositorypackage com.jpabook.jpashop.repository;import java.util.List;import javax.persistence.EntityManager;import org.springframework.stereotype.Repository;import com.jpabook.jpashop.domain.item.Item;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class ItemRepository {    private final EntityManager em;        public void save(Item item){        if(item.getId()==null){ //DB에 저장된적없는 순수한 객체이면            em.persist(item); //DB저장        }else{            em.merge(item); //업데이트같은 느낌        }       }    public Item findOne(Long id){        return em.find(Item.class, id);    }    public List&lt;Item&gt; findAll(){        return em.createQuery(\"select i from Item i\", Item.class).getResultList();    }}  servicepackage com.jpabook.jpashop.service;import java.util.List;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.jpabook.jpashop.domain.item.Item;import com.jpabook.jpashop.repository.ItemRepository;import lombok.RequiredArgsConstructor;@Service@Transactional(readOnly=true)@RequiredArgsConstructorpublic class ItemService {    private final ItemRepository itemRepository;    @Transactional //위에 readOnly설정때문에 다시 오버라이딩해줌    public void saveItem(Item item){        itemRepository.save(item);    }    public List&lt;Item&gt; findItems(){        return itemRepository.findAll();    }    public Item findOne(Long itemId){        return itemRepository.findOne(itemId);    }}"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 회원 도메인 개발",
    "url": "/posts/%ED%9A%8C%EC%9B%90_%EB%8F%84%EB%A9%94%EC%9D%B8_%EA%B0%9C%EB%B0%9C/",
    "categories": "JPA",
    "tags": "spring, jpa, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-02 00:00:00 +0900",
    





    
    "snippet": "repository@PersistenceContext스프링에서 영속성 관리를 위해 Entity Manager가 존재한다.그래서 스프링이 처음 시작할 때, entity manager를 만들어서 빈으로 등록을 해둔다.entity manager는 @Autowired가 아니고 특별하게 @PersistenceContext라는 어노테이션으로 주입을 해줄 수 있다...",
    "content": "repository@PersistenceContext스프링에서 영속성 관리를 위해 Entity Manager가 존재한다.그래서 스프링이 처음 시작할 때, entity manager를 만들어서 빈으로 등록을 해둔다.entity manager는 @Autowired가 아니고 특별하게 @PersistenceContext라는 어노테이션으로 주입을 해줄 수 있다.근데 최신 스프링부트에서는 @Autowired로도 할 수 있다고 한다.package com.jpabook.jpashop.repository;import java.util.List;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import org.springframework.stereotype.Repository;import com.jpabook.jpashop.domain.Member;@Repositorypublic class MemberRepository {    @PersistenceContext    private EntityManager em;    public void save(Member member){        em.persist(member);    }    public Member findOne(Long id){        return em.find(Member.class, id);    }    public List&lt;Member&gt; findAll(){        return em.createQuery(\"select m from Member m\", Member.class).getResultList();    }    public List&lt;Member&gt; findByName(String name){        return em.createQuery(\"select m from Member m where m.name=:name\", Member.class).setParameter(\"name\", name).getResultList();    }    }  @RequiredArgsConstructor사용방법package com.jpabook.jpashop.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.repository.MemberRepository;import lombok.RequiredArgsConstructor;@Service@RequiredArgsConstructor //final있는 필드의 생성자만 만들어줌@Transactional/* (readOnly = true) */ //spring어노테이션 사용 추천. 만약 모든 메소드가 읽기 전용이라면 여기서 붙여줘도됨public class MemberService {     private final MemberRepository memberRepository;      // @Autowired //최신버전에선 없어도됨 자동으로 넣어줌     // public MemberService(MemberRepository memberRepository){     //      this.memberRepository = memberRepository;     // } //생성자를 통해 설정하는 방법. 권장방법     //위에 @RequiredArgsConstructor를 써서 주석처리함. 같은거임     //회원가입     public Long join(Member member){          validateDuplicateMember(member);          memberRepository.save(member);             return member.getId();       }          private void validateDuplicateMember(Member member) {          List&lt;Member&gt; findMembers= memberRepository.findByName(member.getName());          if(!findMembers.isEmpty()){               throw new IllegalStateException(\"이미 존재하는 회원입니다.\");          }     }     //회원 전체 조회     @Transactional(readOnly = true) //읽기 모드. 데이터 변경안됨(성능상 좋음)     public List&lt;Member&gt; findMembers(){          return memberRepository.findAll();     }     @Transactional(readOnly = true) //읽기 모드. 데이터 변경안됨(성능상 좋음)     public Member findOne(Long memberId){          return memberRepository.findOne(memberId);     }}RequiredArgsConstructor : final이 붙은 필드만 생성자를 만들어줌package com.jpabook.jpashop.repository;import java.util.List;import javax.persistence.EntityManager;import org.springframework.stereotype.Repository;import com.jpabook.jpashop.domain.Member;import lombok.RequiredArgsConstructor;@Repository@RequiredArgsConstructorpublic class MemberRepository {    // @PersistenceContext 스프링 부트 라이브러리를 사용하면 @Autowired로 변경가능 -&gt; @RequiredArgsConstructor 사용가능    private final EntityManager em;    public void save(Member member){        em.persist(member);    }    public Member findOne(Long id){        return em.find(Member.class, id);    }    public List&lt;Member&gt; findAll(){        return em.createQuery(\"select m from Member m\", Member.class).getResultList();    }    public List&lt;Member&gt; findByName(String name){        return em.createQuery(\"select m from Member m where m.name=:name\", Member.class).setParameter(\"name\", name).getResultList();    }    }위처럼 repository에도 사용가능함  테스트 코드package com.jpabook.jpashop;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.fail;import javax.persistence.EntityManager;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.annotation.Rollback;import org.springframework.transaction.annotation.Transactional;import com.jpabook.jpashop.domain.Member;import com.jpabook.jpashop.repository.MemberRepository;import com.jpabook.jpashop.service.MemberService;@SpringBootTest@Transactionalpublic class MemberRepositoryTest {    @Test    @Rollback(false) //rollback안하고 commit해버림    @Transactional    public void test() throws Exception{        Member member = new Member();    }    @Autowired MemberService memberService;    @Autowired MemberRepository memberRepository;    @Autowired EntityManager em;    @Test    // @Rollback(false)    public void 회원가입() throws Exception{        Member member = new Member();        member.setName(\"kim\");        Long saveId =memberService.join(member);        em.flush(); //rollback설정을 유지하면서 insert 쿼리문을 보기위해 확인        assertEquals(member, memberRepository.findOne(saveId));    }    @Test    public void 중복회원예외() throws Exception{        Member member1 = new Member();        member1.setName(\"kim\");        Member member2 = new Member();        member2.setName(\"kim\");        memberService.join(member1);        try{            memberService.join(member2);        }catch(IllegalStateException e){            return;        }        fail(\"예외가 발생해야한다\"); //위에서 예외가 발생하지않으면 실패처리됨    }}"
  },
  
  {
    "title": "[김영한 실전! 스프링 부트와 JPA 활용1] 들어가기 전에",
    "url": "/posts/%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0_%EC%A0%84%EC%97%90/",
    "categories": "JPA",
    "tags": "jpa, spring, 실전스프링부트와JPA활용1, ORM",
    "date": "2023-01-01 00:00:00 +0900",
    





    
    "snippet": "다른건 다 똑같이 하면되고application.properties에 spring.jpa.hibernate.ddl-auto=create 추가해주면 실행 시 자동으로 테이블 만들어줌테스트 코드에서 @Transactional을 붙여도 rollback안하고 commit 하는 법@Test@Rollback(false) //rollback안하고 commit해버림@...",
    "content": "다른건 다 똑같이 하면되고application.properties에 spring.jpa.hibernate.ddl-auto=create 추가해주면 실행 시 자동으로 테이블 만들어줌테스트 코드에서 @Transactional을 붙여도 rollback안하고 commit 하는 법@Test@Rollback(false) //rollback안하고 commit해버림@Transactionalpublic void test() throws Exception{  Member member = new Member();  member.setUsername(\"memberA\");  Long savedId = memberRepository.sava(member);  Member find = memberRepository.find(savedId);  Assertions.assertThat(find.getId()).isEqualTo(member.getId());    Assertions.assertThat(find.getUsername()).isEqualTo(member.getUsername());\tAssertions.assertThat(find).isEqualTo(member);    }회원(Member): 이름과 임베디드 타입인 주소( Address ), 그리고 주문( orders ) 리스트를 가진다. 주문(Order): 한 번 주문시 여러 상품을 주문할 수 있으므로 주문과 주문상품( OrderItem )은 일대다 관계다. 주문은 상품을 주문한 회원과 배송 정보, 주문 날짜, 주문 상태( status )를 가지고 있다. 주문 상태는 열거형을 사용했는데 주문( ORDER ), 취소( CANCEL )을 표현할 수 있다.  주문상품(OrderItem): 주문한 상품 정보와 주문 금액( orderPrice ), 주문 수량( count ) 정보를 가지고  있다. (보통 OrderLine , LineItem 으로 많이 표현한다.)  상품(Item): 이름, 가격, 재고수량( stockQuantity )을 가지고 있다. 상품을 주문하면 재고수량이  줄어든다. 상품의 종류로는 도서, 음반, 영화가 있는데 각각은 사용하는 속성이 조금씩 다르다.  배송(Delivery): 주문시 하나의 배송 정보를 생성한다. 주문과 배송은 일대일 관계다.  카테고리(Category): 상품과 다대다 관계를 맺는다. parent , child 로 부모, 자식 카테고리를  연결한다.  주소(Address): 값 타입(임베디드 타입)이다. 회원과 배송(Delivery)에서 사용한다.  참고: 회원 엔티티 분석 그림에서 Order와 Delivery가 단방향 관계로 잘못 그려져 있다. 양방향 관계가 맞다.  참고: 회원이 주문을 하기 때문에, 회원이 주문리스트를 가지는 것은 얼핏 보면 잘 설계한 것 같지만, 객체 세상은 실제 세계와는 다르다. 실무에서는 회원이 주문을 참조하지 않고, 주문이 회원을 참조하는 것으로  충분하다. 여기서는 일대다, 다대일의 양방향 연관관계를 설명하기 위해서 추가했다  MEMBER: 회원 엔티티의 Address 임베디드 타입 정보가 회원 테이블에 그대로 들어갔다. 이것은  DELIVERY 테이블도 마찬가지다.  ITEM: 앨범, 도서, 영화 타입을 통합해서 하나의 테이블로 만들었다. DTYPE 컬럼으로 타입을 구분한다. 참고: 테이블명이 ORDER 가 아니라 ORDERS 인 것은 데이터베이스가 order by 때문에 예약어로 잡고  있는 경우가 많다. 그래서 관례상 ORDERS 를 많이 사용한다.  참고: 실제 코드에서는 DB에 소문자 + _(언더스코어) 스타일을 사용하겠다.  데이터베이스 테이블명, 컬럼명에 대한 관례는 회사마다 다르다. 보통은 대문자 + _(언더스코어)나 소문자  _(언더스코어) 방식 중에 하나를 지정해서 일관성 있게 사용한다. 강의에서 설명할 때는 객체와 차이를  나타내기 위해 데이터베이스 테이블, 컬럼명은 대문자를 사용했지만, 실제 코드에서는 소문자 +  _(언더스코어) 스타일을 사용하겠다.  연관관계 매핑 분석  회원과 주문: 일대다 , 다대일의 양방향 관계다. 따라서 연관관계의 주인을 정해야 하는데, 외래 키가 있는 주문을 연관관계의 주인으로 정하는 것이 좋다. 그러므로 Order.member 를 RDERS.MEMBER_ID 외래키와 매핑한다.  주문상품과 주문: 다대일 양방향 관계다. 외래 키가 주문상품에 있으므로 주문상품이 연관관계의 주인이다.  그러므로 OrderItem.order 를 ORDER_ITEM.ORDER_ID 외래 키와 매핑한다.  주문상품과 상품: 다대일 단방향 관계다. OrderItem.item 을 ORDER_ITEM.ITEM_ID 외래 키와  매핑한다.  주문과 배송: 일대일 양방향 관계다. Order.delivery 를 ORDERS.DELIVERY_ID 외래 키와 매핑한다.  카테고리와 상품: @ManyToMany 를 사용해서 매핑한다.(실무에서 @ManyToMany는 사용하지 말자. 여기서는 다대다 관계를 예제로 보여주기 위해 추가했을 뿐이다)  예제에서는 설명을 쉽게하기 위해 엔티티 클래스에 Getter, Setter를 모두 열고, 최대한 단순하게 설계  실무에서는 가급적 Getter는 열어두고, Setter는 꼭 필요한 경우에만 사용하는 것을 추천모든 연관관계 매핑은 LAZY로 세팅하고, 연관관계 메소드까지 작성한 상태로 시작  계층형 구조 사용          controller, web - 웹 계층      service - 비즈니스 로직, 트랜잭션 처리      repository - JPA를 직접 사용하는 계층, 엔티티 매니저 사용      domain - 엔티티가 모여있는 계층, 모든 계층에서 사용      "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 쿼리언어 - 중급 문법",
    "url": "/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EC%A4%91%EA%B8%89-%EB%AC%B8%EB%B2%95/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-31 00:00:00 +0900",
    





    
    "snippet": "경로 표현식.(점)을 찍어서 객체 그래프를 탐색함  [!important]select m.username -&gt; 상태 필드from Member mjoin m.team t -&gt; 단일 값 연관 필드(엔티티로 넘어감. ManyToOne or OneToOne)join m.orders o -&gt; 컬렉션 값 연관 필드(양방향 관계. 컬렉션으로 넘어감...",
    "content": "경로 표현식.(점)을 찍어서 객체 그래프를 탐색함  [!important]select m.username -&gt; 상태 필드from Member mjoin m.team t -&gt; 단일 값 연관 필드(엔티티로 넘어감. ManyToOne or OneToOne)join m.orders o -&gt; 컬렉션 값 연관 필드(양방향 관계. 컬렉션으로 넘어감)where t.name = ‘팀A’  상태 필드(state field): 단순히 값을 저장하기 위한 필드(ex: m.username). 경로 탐색의 끝(.찍어서 어디 못간다는 소리). 탐색x      연관 필드(association field): 연관관계를 위한 필드          단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티(ex: m.team). 묵시적 내부조인(inner join) 발생. 탐색O - m.team에서 m.team.name가능      컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션(ex: m.orders). 묵시적 내부 조인(inner join) 발생. 탐색X - t.members.get(0) 이런거 안됨!! t.members에서 더이상 탐색 불가능함(t.members.size는 가능함)                  from절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색가능  = select m.username from Team t join t.members m 이건 가능하다는 소리                    묵시적 내부 조인(조심해서 써야함. 가능하면 발생하지 않도록 해야함)  select m.team from Member m 쿼리를 날렸을때, 묵시적으로 team테이블과 join이 일어남        가급적 명시적조인으로 사용. 조인은 SQL튜닝에 중요 포인트임  걍 묵시적 조인 쓰지말것!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 걍신경안써도될듯  페치 조인(fetch join)매우중요!!SQL조인 종류x, JPQL에서 성능 최적화를 위해 제공하는 기능연관된 엔티티나 컬렉션을 SQL한번에 함께 조회하는 기능join fetch 명령어 사용페치 조인 ::= [left [OUTER] | inner ] join fetch 조인경로(SQL) select * from Member m inner join team t on m.team_id = t.id= (JPQL) select m from Member m join fetch m.team한번의 쿼리문으로 원하는 값을 모두 조회가능함그냥 m.getTeam().getName()을 쓰면 최악의 경우(회원끼리 겹치는 팀이 없을 경우) 100명의 회원을 조회하면 team을 조회하는 쿼리문도 100번이 나가서 비효율적임그러나 페치조인문을 날리면 영속성 컨텍스트에 모든값이 들어오기때문에 한번의 쿼리문으로 해결가능함      컬렉션 페치조인    일대 다 관계에서 사용    (SQL) select * from team t inner join member m on t.id = m.team_id where = ‘팀A’    = (JPQL) select t from team t join fetch t.members where t.name = ‘팀A’        위처럼 주의할 점!! 데이터 뻥튀기가 일어남        팀A에 속한 회원이 2명이라서 팀A가 2번 조회됨!!    → DISTINCT 사용 - select distinct t from Team t join fetch t.members          SQL에 DISTINCT를 추가      에플리케이션에서 엔티티 중복 제거            team의 중복이 제거됨!!  sql에서 distinct을 사용하면 데이터가 완전히 일치해야 중복이 제거된다는 한계가 있음  그래서 distinct가 애플리케이션에서 추가로 중복제거를 함. 같은 식별자를 가진 엔티티를 제거함  (위와같은 일대 다는 뻥튀기가 되지만 다대일은 뻥튀가안됨)  페치조인을 사용할때만 즉시조인이 일어남!!  페치조인은 객체 그래프를 SQL한번에 조회하는 개념임    대부분의 n+1의 문제를 해결할 수 있음                  한계                  페치 조인 대상에는 별칭을 줄 수 없음(하이버네이트는 가능하나 가급적 사용x)  select distinct t from Team t join fetch t.members m - 여기서 m이 안된다는 소리임  where문을 페치문에 가급적 사용하지 말라는 소리같음.. 차라리 여기서 where문을 사용하지말고 Member에서 값을 가져오라는..뜻인듯  페치 조인을 다중으로 사용할때는 어쩔수없이 쓸때도 있기는 하다고하심          둘 이상의 컬렉션은 페치조인할 수 없음 - 일대다대다같은 괴상한 상황이 일어남          컬렉션을 페치조인하면 페이징API를 이용할 수 없음                          다대일, 일대일 닽은 단일 값 연관 필드들은 페치조인해도 페이징이 가능함(걍 순서 바꾸란 소리)              하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험함!!!!!)                                              그러나 이방법은 성능이 안나옴(위 예시만봐도 3번 쿼리문이 날아감)        이럴때는 @BatchSize를 붙여서 (사이즈는 1000이하로 대충 정해줌)          @BatchSize(size=100)  @OneToMany(mappedBy = \"team\")  private List&lt;Member&gt; members = new ArrayList&lt;Member&gt;();                        teamA, teamb의 아이디가 둘다 들어간걸 확인할 수 있음!!        위에 BatchSize에 지정해준 숫자만큼 한번에 조회가능함! 지금은 팀이 2개라서 2개가 들어간거고 100개까지 가능한상황임                위와같이 설정해주면 기본값 설정 가능(한 1000이하로,,)                  결론          연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화      엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함      @OneToMany(fetch = FetchType.LAZY) //글로벌 로딩 전략      실무에서 글로벌 로딩 전략은 모두 지연 로딩      최적화가 필요한 곳은 페치 조인 적용(n+1이 일어나는 곳만 페치조인을 사용)      모든 것을 페치 조인으로 해결할 수 는 없음      페치 조인은 객체 그래프를 유지할 때 사용하면 효과적      여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적      다형성 쿼리]]조회 대상을 특정 자식으로 한정Ex) Item 중에 Book, Movie를 조회  (JPQL) select i from Item i where type(i) IN (Book, Movie)      (SQL) select i from i where i.DTYPE in (‘B’, ‘M’)        TREAT(JPA2.0)          자바의 타입 캐스팅과 유사      상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용      FROM, WHERE, SELECT(하이버네이트 지원) 사용      ex )부모인 Item과 자식 Book                  (JPQL) select i from Item i where treat(i as Book).auther = ‘kim’          (SQL) select i.* from Item i where i.DTYPE = ‘B’ and i.auther = ‘kim’                      item과 연관된 엔티티 중에서 book인 엔티티의 auther이 ‘kim’인것을 찾아오는 구문  엔티티 직접 사용      기본 키 값  select count(m) from Member m //엔티티를 직접 사용 - 이런경우  자동으로 JPA가 기본 키(m.id)로 변환해서 사용함  엔티티를 파라미터로 넘겨도 마찬가지임    java  String jpql = “select m from Member m where m = :member”;   List resultList = em.createQuery(jpql).setParameter(\"member\", member).getResultList(); =    최종적으로 select m.* from Member m where m.id=? 가 실행됨        외래 키 값  Team team = em.find(Team.class, 1L); String qlString = “select m from Member m where m.team = :team”; List resultList = em.createQuery(qlString).setParameter(\"team\", team).getResultList();select m.* from Member m where m.team_id=? 가 실행됨Named 쿼리  미리 정의해서 이름을 부여해두고 사용하는 JPQL  정적 쿼리  어노테이션, XML에 정의  애플리케이션 로딩 시점에 초기화 후 재사용  애플리케이션 로딩 시점에 쿼리를 검증(오타나면 정확하게 알려줌)@Entity@NamedQuery( name = \"Member.findByUsername\", query=\"select m from Member m where m.username = :username\")public class Member { ........}List&lt;Member&gt; resultList = em.createNamedQuery(\"Member.findByUsername\", Member.class).setParameter(\"username\", \"회원1\").getResultList();spring jpa에서 사용했던@Query(”select …………………….”) 그게 이거임벌크연산(update, delete문을 의미함)재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?  JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행          재고가 10개 미만인 상품을 리스트로 조회한다.      상품 엔티티의 가격을 10% 증가한다.      트랜잭션 커밋 시점에 변경감지가 동작한다.        변경된 데이터가 100건이라면 100번의 UPDATE SQL 실행int count = em.createQuery(\"update Member m set m.age = 20\").executeUpdate();System.out.println(count);걍 이게 다임update, delete, insert(jpa표준스택에는 없음. 하이버네이트가 지원) 됨. where문도 사용 가능  주의 사항  벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리(flush됨)          벌크 연산을 먼저 실행      벌크 연산 수행 후 영속성 컨텍스트 초기화            이런 대참사가 일어난다는 뜻임.    flush가 일어났을때 age는 20이 아니었기때문에 이런 대참사가 일어남      int count = em.createQuery(\"update Member m set m.age = 20\").executeUpdate();  m = em.find(Member.class, m.getId());  m2 = em.find(Member.class, m2.getId());  m3 = em.find(Member.class, m3.getId());  em.clear();  System.out.println(count);      System.out.println(m.getAge());  System.out.println(m2.getAge());  System.out.println(m3.getAge());        이렇게 해줘야함       ㅇㅇ    spring data jpa에는    @Modifying    @Query(”update……………..”) 가 있음 이거 쓰면 됨  "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 쿼리언어 기본문법",
    "url": "/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-31 00:00:00 +0900",
    





    
    "snippet": "JPAFactoryQuery query = new JPAQueryFactory(em);QMember m = QMember.member;JPA를 사용하면 엔티티 객체를 중심으로 개발을 함. 문제는 검색쿼리. 검색을 할때도 테이블이 아닌 객체를 대상으로 검색을 함. 모든 DB데이터를 객체로 변환해서 검색을 하는 것은 불가능함에플리케이션이 필요한 데이터만 ...",
    "content": "JPAFactoryQuery query = new JPAQueryFactory(em);QMember m = QMember.member;JPA를 사용하면 엔티티 객체를 중심으로 개발을 함. 문제는 검색쿼리. 검색을 할때도 테이블이 아닌 객체를 대상으로 검색을 함. 모든 DB데이터를 객체로 변환해서 검색을 하는 것은 불가능함에플리케이션이 필요한 데이터만 DB에 불러오려면 결국 검색조건이 포함된 SQL이 필요함.JPQL(Java Persistence Query Language)가장 단순한 조회 방법 - entityManager.find(), 객체 그래프 탐색(a.getB().getC())JPA는 SQL을 추상화 한 JPQL이라는 객체 지향 쿼리 언어를 제공함SQL과 문법이 유사함. select, from, where, goup by, having, join 지원JPQL은 엔티티객체를 대상으로 쿼리SQL은 DB를 대상으로 쿼리List&lt;Member&gt; list = em.createQuery(\"select m from Member m where m.username like '%kim%'\", Member.class).getResultList();for(Member m : list){    System.out.println(m);}이런식객체 지향 sql이라고 생각하면 됨. 동적쿼리를 짜기 어려움결국 SQL로 변환되어 실행됨!!엔티티와 속성은 대소문자 구분을 하지만 JPQL 키워드는 대소문자 구분을 하지 않음. 테이블 이름이 아닌 엔티티 이름을 사용함. 별칭 필수(as 생략 가능)  TypedQuery : 반환 타입이 명확할 때 사용  Query : 반환 타입이 명확하지 않을 때 사용Member m = new Member();m.setName(\"member1\");m.setAge(10);em.persist(m);//반환타입이 확실TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member m\", Member.class);TypedQuery&lt;String&gt; query2 = em.createQuery(\"select m.name from Member m\", String.class);//반환타입 불확실(String, int 두가지가 반환됨)Query query3 = em.createQuery(\"select m.name, m.age from Member m\");  반환 결과가 여러개일때 - getResultList()  반환 결과가 하나일때 - getSingleResult()          getSingleResult()를 사용했는데 만약 결과가 없을 때 -&gt; NoResultException - 별루임;; try-catch로 감싸줘야함      getSingleResult()를 사용했는데 결과가 둘 이상일때 -&gt; NonUniqueResultException      //결과가 여러개일때            TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member m\", Member.class);            List&lt;Member&gt; resultList = query.getResultList(); //받아온 값을 List로 가져옴. 결과가 여러개일경우            //결과가 없으면 빈리스트가 반환됨            //결과가 정확히 하나일때            TypedQuery&lt;Member&gt; query2 = em.createQuery(\"select m from Member m where m.id=10L\", Member.class);            Member resultMember = query2.getSingleResult();            //만약 결과가 하나일때 -&gt; NoResultException            //결과가 둘 이상일때 -&gt; NonUniqueResultException  파라미터 바인딩(이름기준)Member m = new Member();m.setName(\"member1\");m.setAge(10);em.persist(m);//TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member m where m.name = :username\", Member.class);//query.setParameter(\"username\", \"member1\"); //위 쿼리의 :username에 member1을 넣음//Member resultMember = query.getSingleResult();Member resultMember = em.createQuery(\"select m from Member m where m.name = :username\", Member.class).setParameter(\"username\", \"member1\").getSingleResult();//위 3줄이랑 같은거임System.out.println(resultMember);tx.commit();criteriaCriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class);Root&lt;Member&gt; m = query.from(Member.class);CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(\"name\"), \"kim\"));List&lt;Member&gt; resultList = em.createQuery(cq).getResultList();어렵지만 쿼리문에서 오타가났을때 잡아주고CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class);Root&lt;Member&gt; m = query.from(Member.class);CriteriaQuery&lt;Member&gt; cq = query.select(m);String userName=\"aaaa\";if(userName!=null){    cq = cq.where(cb.equal(m.get(\"name\"), \"kim\"));}List&lt;Member&gt; resultList = em.createQuery(cq).getResultList();이런식으로 활용이 가능함그러나 SQL스럽지가 않고 실용성이 없어서 잘 사용되지않음. 유지보수가 어려움..QueryDSL(실무사용권장)위의 대안으로 나옴JPAFactoryQuery query = new JPAQueryFactory(em);QMember m = QMember.member;List&lt;Member&gt; list =query.selectFrom(m)\t.where(m.age.gt(18))\t.orderBy(m.name.desc())\t.fetch()자바코드로 sql을 작성가능. SPQL빌더 역할컴파일 시점에 문법 오류를 찾을 수 있고 동적쿼리 작성이 편리함. 단순하고 쉬움JPQL을 알면 자동으로 따라옴!!네이티브 SQLJPA가 제공하는 SQL을 직접 하용. JPQL로 해결할 수 없는 특정 DB에 의존적인 기능 사용 가능(오라클의 connect By, 특정 DB에만 사용하는 SQL 힌트)String sql = “SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = ‘kim’\"; List&lt;Member&gt; resultList =  em.createNativeQuery(sql, Member.class).getResultList();잘안씀JDBC 직접 사용, SpringJdbcTemplate 등  JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등을 함께 사용 가능  단 원래는 쿼리를 날릴때 flush가 일어나 DB에 반영이되는데 이방법은 반영이되지않아서 수동으로 flush를 해줘야함프로젝션select절에 조회할 대상을 지정하는 것.대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자 등 기본데이터 타입)  select m from Member m → 엔티티 프로젝션  select m.team from Member m → 엔티티 프로젝션(Member와 연관된 엔티티를 가져옴)  select m.address from Member m → 임베디드 타입 프로젝션  select m.username, m.age from Member m → 스칼라 타입 프로젝션          여러 값 조회 하는 방법                  Query타입으로 조회 - 위에서 본 반환타입이 명확하지 않을때 방법          Object[] 타입으로 조회          new 명령어로 조회                          단순 값을 DTO로 조회  select new jpabook.jpql.UserDTO(m.username, m.age) from Member m              패키지 명을 포함한 전체 클래스명 입력              순서와 타입이 일치하는 생성자 필요                                            DISTINCT로 중복제거 가능  쿼리문을 통해 가져온 엔티티의 값을 수정해도 DB값이 수정됨! 영속성 컨텍스트에 의해 관리중이라는 소리임Member m = new Member();m.setName(\"member1\");m.setAge(10);em.persist(m);em.flush();em.clear();//join쿼리이나 join쿼리라는 것이 잘 보이지 않음. 비추천List&lt;Team&gt; result = em.createQuery((\"select m.team from Member m\"), Team.class).getResultList();//추천방법result = em.createQuery(\"select t from Member m join m.team t\", Team.class).getResultList();for(Team t : result){    System.out.println(t.getName());}//임베디드 타입 프로젝션List&lt;Address&gt; result2 = em.createQuery((\"select o.address from Order o\"), Address.class).getResultList();// List&lt;Address&gt; result2 = em.createQuery((\"select address from Address\"), Address.class).getResultList(); // -&gt; 불가능한 방법. Order안에 address가 소속되어있음//스칼라 타입 프로젝션 - 여러값 조회//Query사용방법 (비추)Query q = em.createQuery(\"select distinct m.name, m.age from Member m\");//Object[] 사용방법(비추)List result3 = em.createQuery(\"select distinct m.name, m.age from Member m\").getResultList();Object o = result3.get(0); //0이 위 쿼리문의 첫번째 칼럼인 name, 1이 두번째 칼럼인 age의 값을 받아옴Object[] result4 = (Object[]) o;System.out.println(result4[0]); //member1 출력System.out.println(result4[1]); //10 출력System.out.println(result4.length); //2 출력//위랑 같은 거임List&lt;Object[]&gt; result5 = em.createQuery(\"select distinct m.name, m.age from Member m\").getResultList();Object[] result6 = (Object[]) o;System.out.println(result6[0]); //member1 출력System.out.println(result6[1]); //10 출력System.out.println(result6.length); //2 출력//new 명령어로 조회 - DTO (가장깔끔함)List&lt;MemberDTO&gt; result7 = em.createQuery(\"select new com.kyhpractice.jpap.jpabook.jpashop.jpadomain.MemberDTO(m.name, m.age) from Member m\").getResultList();//경로 제대로 적기ㅜㅜ(나중에 QueryDSL을 사용하면 보안가능)//순서와 타입이 일치해야함MemberDTO memberDTO = result7.get(0);System.out.println(memberDTO.getName());System.out.println(memberDTO.getAge());tx.commit();페이징.setFirstResult(페이지[0부터 시작]).setMaxResults(한페이지에 표시할 갯수)조인      내부조인    select m from Member m join m.team t → inner join 실행        외부조인    select m from m left join m.team t → left outer join 실행        세타조인(연관관계가 없는 것을 조인시킴. 크로스조인에 where문을 붙이는듯?)    select count(m) from Member m, Team t where m.username = t.name        on절          join대상 필터링                  회원과 팀을 조회하면서 팀이름이 A인 팀만  jpql : select m, t from Member m left join m.team t on t.name=’A’  sql : select m., t. from Member m left join Team t on m.team_id = t.id and t.name=’A’                    연관 관계 없는 엔티티 외부조인(하이버네이트5.1부터)                  회원의 이름과 팀이름이 같은 대상 외부조인  jpql : select m, t from Member m left join team t on m.username = t.name  sql : select m. * , t. * from Member m left join team t on m.username = t.name                    서브 쿼리서브 쿼리 지원 함수      [not] exists(supquery) : 서브쿼리에 결과가 존재하면 참                                                      {all              any              some} (subquery)                                          ALL 모두 만족하면 참      any, some : 같은 의미. 조건을 하나라도 만족하면 참        ex) - 팀 a소속인 회원    select m from Member m where exists (select t from m.team t where t.name = ‘팀A’)                  전체 상품 각각의 재고보다 주문량이 많은 주문들  select o from Order o where o.orderAmount &gt; ALL (select p.stockAmount from Product p)                    어떤 팀이든 팀에 소속된 회원  select m from Member m where m.team = ANY (select t from Team t)              [not] in (subquery) : 서브쿼리 결과 중 하나라도 같은 것이 있으면 참  한계          where, having절에서만 서브쿼리 사용가능함.      select절도 가능(하이버네이트에서 지원)              **from절의 서브쿼리는 현재 jpql에서 불가능함!!        **→ 조인으로 풀수있으면 풀어서 해결(안되면 쿼리를 두번 날리기)            JPQL의 타입 표현  문자: ‘HELLO’, ‘She’’s’  숫자: 10L(Long), 10D(Double), 10F(Float)  Boolean: TRUE, FALSE      ENUM: jpabook.MemberType.Admin (패키지명 포함)    String query = “Select m.name from Member m where m.type= 패키지명.MemberType.ADMIN”    위와같이 enum의 패키지명까지 적어주어야함    엔티티 타입: TYPE(m) = Member (상속 관계에서 사용)  SQL과 문법이 같은 식  EXISTS, IN  AND, OR, NOT  =, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;  BETWEEN, LIKE, IS NULL조건식      기본 case 식    select      case           when m.age &lt;= 10 then ‘학생요금’          when m.age &gt;= 60 then ‘경로요금’          else ‘일반요금’      end  from Member m        단순 case 식  select      case t.name          when ‘팀A’ then ‘인센티브110%’          when ‘팀B’ then ‘인센티브120%’          else ‘인센티브105%’      end  from Team t        COALESCE: 하나씩 조회해서 null이 아니면 반환  ex ) 사용자 이름이 없으면 이름없는 회원 반환  select coalesce(m.username,’이름 없는 회원’) from Member m        NULLIF: 두 값이 같으면 null 반환, 다르면 첫번째 값 반환  ex ) 사용자 이름이 관리자면 null을 나머지는 본인의 이름을 반환  select NULLIF(m.username, ‘관리자’) from Member m  둘다 queryDSL에서 지원함기본함수  CONCAT  select concat(’a’,’b’) from Member m으로 써도 되지만 하이버네이트는  select ‘a’ || ‘b’ from Member m 으로 쓸수도 있음  SUBSTRING(문자열 잘라내기)  TRIM  LOWER, UPPER  LENGTH  LOCATE : 문자열 위치 찾기  ABS, SQRT, MOD  SIZE, INDEX(JPA 용도)사용자 정의 함수      하이버네이트는 사용전 방언에 추가해야함  사용하는 DB 방언을 상속받고 사용자 정의 함수를 등록  ❗그러나 MySQL57Dialect에 대부분이 등록되어있음. 등록안되어있으면 사용자 정의 함수를 등록해야함        사용자 정의 함수 등록하는 법      package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;      import org.hibernate.dialect.H2Dialect;  import org.hibernate.dialect.function.StandardSQLFunction;  import org.hibernate.type.StandardBasicTypes;      public class MyH2Dialect extends H2Dialect{      public MyH2Dialect(){          registerFunction(\"group_concat\", new StandardSQLFunction(\"group_concat\", StandardBasicTypes.STRING));      }  }        함수마다 등록하는 법은 다 다름. H2Dialect에서 확인      String query = \"select function('group_concat', m.name) from Member m\";      List&lt;String&gt; result = em.createQuery(query, String.class).getResultList();      for(String name : result){      System.out.println(name);  }        이미 등록된거라서      String query = \"select group_concat(m.name) from Member m\";      List&lt;String&gt; result = em.createQuery(query, String.class).getResultList();      for(String name : result){    System.out.println(name);  }        이렇게 써도 되긴함  "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 값 타입",
    "url": "/posts/%EA%B0%92%ED%83%80%EC%9E%85/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-31 00:00:00 +0900",
    





    
    "snippet": "JPA의 데이터 타입 분류  엔티티타입          @Entity로 정의하는 객체      데이터가 변해도 식별자로 지속해서 추적 가능(회원 엔티티의 키나 나이값을 변경해도 식별자로 인식 가능)        값 타입          int, Integer, String 처럼 단순히 값으로 사용하는 기본타입이나 객체      식별자가 없고 값만있어 ...",
    "content": "JPA의 데이터 타입 분류  엔티티타입          @Entity로 정의하는 객체      데이터가 변해도 식별자로 지속해서 추적 가능(회원 엔티티의 키나 나이값을 변경해도 식별자로 인식 가능)        값 타입          int, Integer, String 처럼 단순히 값으로 사용하는 기본타입이나 객체      식별자가 없고 값만있어 변경시 추적 불가(숫자 100을 200으로 교체하면 완전히 다른값으로 대체)      분류                  기본값 타입(항상 값을 복사함)  — 생명주기를 엔티티에 의존하는 타입(회원삭제 = 이름, 나이필드도 삭제)  — 공유 불가(회원이름변경시 다른회원 이름이 변경되면 안됨)                          자바 기본 타입(int, double) - 원래 절대 공유안됨              래퍼 클래스(Integer, Long) - 공유가능한 객체이지만 변경x              String - 공유가능한 객체이지만 변경x                                임베디드 타입(embedded type, 복합 값 타입)                          새로운 값 타입 직접 정의가능              주로 기본 값 타입(int, String 등)을 모아서 만들어서 복합 값 타입이라고 함  ex) 근무시작시간, 근무종료시간 두개로 나타내지 않고 근무시간으로 나타냄  — 사용법              @Embeddable : 값 타입을 정의하는 곳에 표시              @Embedded : 값 타입을 사용하는 곳에 표시              기본 생성자 필수                          @Entity  public class Member  {      @Id @GeneratedValue      @Column(name=\"MEMBER_ID\")      private Long id;      private String name;      // @ManyToOne @JoinColumn(name = \"TEAM_ID\", insertable = false, updatable = false)      // private Team team;      //기간      @Embedded      private Period workPeriod;      //주소      @Embedded      private Address homeAddress;  }                          package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;              import java.time.LocalDateTime;              import javax.persistence.Embeddable;  @Embeddable  public class Period {      private LocalDateTime startDate;      private LocalDateTime endDate;                  public LocalDateTime getStartDate() {          return this.startDate;      }                  public void setStartDate(LocalDateTime startDate) {          this.startDate = startDate;      }                  public LocalDateTime getEndDate() {          return this.endDate;      }                  public void setEndDate(LocalDateTime endDate) {          this.endDate = endDate;      }              }                          package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;              import javax.persistence.Embeddable;              @Embeddable  public class Address {      private String city;      private String street;      private String zipcode;                  public String getCity() {          return this.city;      }                  public void setCity(String city) {          this.city = city;      }                  public String getStreet() {          return this.street;      }                  public void setStreet(String street) {          this.street = street;      }                  public String getZipcode() {          return this.zipcode;      }                  public void setZipcode(String zipcode) {          this.zipcode = zipcode;      }      public Address(){}      public Address(String city, String street, String zipcode){          this.city=city;          this.street = street;          this.zipcode= zipcode;      }              }                                    클래스를 나눴지만 한 테이블로 저장되는것을 확인할 수 있음            — 장점                          재사용 가능              높은 응집도              Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음              임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함                                    임베디드 타입을 쓰든 안쓰든 DB에 저장되는 값은 같음!!! = 임베디드 타입은 엔티티의 값일 뿐 사용하나 안하나 매핑하는 테이블은 같다. 객체와 테이블을 아주 세밀하게(find-greined) 매핑하는 것이 가능  잘 살계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음!!            —임베디드 타입과 연관관계                          엔티티의 임베디드 타입의 값이 안에 또 엔티티를 가질수도 있음                          @Embeddable  public class Address {      private String city;      private String street;  \t\t@Column(name=\"ZIPCODE\")      private String zipcode;                  private Member member;  }                        이런 식의 구조가 가능하다는 소리                                          @AttributeOverried 속성 재정의(잘 안씀)                                  만약 한 엔터티에서 같은 값 타입을 사용하려면?(회원 엔티티에서 집주소, 회사주소 등 여러 값을 가지는 경우. 한 클래스를 여러 값으로 표현가능한지?)                                  @Embedded      private Period workPeriod;      //주소      @Embedded      private Address homeAddress;      @Embedded      @AttributeOverrides({          @AttributeOverride(name=\"city\", column = @Column(name=\"WORK_CITY\")),          @AttributeOverride(name=\"street\", column = @Column(name=\"WORK_STREET\")),          @AttributeOverride(name=\"zipcode\", column = @Column(name=\"WORK_ZIPCODE\"))      })      private Address workAddress;                                                                            임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 side effect 발생 가능성 있음(회원 테이블이 주소 임베디드 타입 값을 보유중이라면 1번 회원이 주소를 변경했을때 2번 회원도 바뀔수도 있음)                  Address a = new Address(\"대구 서구\", \"북비산로 67길\", \"12300\");              Member m = new Member();              m.setName(\"hello\");              m.setHomeAddress(a);              em.persist(m);              Member m2 = new Member();              m2.setName(\"hello2\");              m2.setHomeAddress(a);              em.persist(m2);              m.getHomeAddress().setCity(\"서울\");              tx.commit();                                                이런식으로  만약 같은 값을 써야한다면 위의 예시에서는  a2 = new Address(a.getCity, a.getStreet, a.getZipcode) 로 새 객체를 만든 다음(복사)에 m2에 넣어줘야함.  그러나 객체 타입은 참조값을 직접 대입하는 것을 막을 수 없음 = 객체의 공유참조를 피할 수 없음 → 불변 객체 사용                            불변객체(immutable object) : 생성 시점 이후 절대 값을 변경할 수 없음.                                  객체 타입을 수정할 수 없게 만들어 부작용 원천 차단                  생성자로만 값을 설정하고 수정자(setter)를 만들지 않으면 됨(아니면 private로 만들기)                  Integer, String은 자바가 제공하는 대표적인 불변객체                                            값 비교 - 동등성 비교(equals()사용)                                  값 타입의 equals()메소드를 적절하게 재정의(주로 모든 필드 사용)                                  @Override      public boolean equals(Object o){          if(this==o) return true;          if(o == null || getClass() != o.getClass()) return false;          Address address = (Address) o;          return Objects.equals(city, address.city) &amp;&amp;                   Objects.equals(street, address.getStreet()) &amp;&amp;                  Objects.equals(zipcode, address.getZipcode());       }                                                              값 타입 컬렉션(collection value type) - 잘안씀. 차라리 엔티티로 승격화함                          값 타입을 하나이상 저장할 때 사용              @ElementCollection, @CollectionTable 사용              데이터 베이스는 컬렉션을 같은 테이블에 저장할 수 없음(별도 테이블 생성)              값 타입 컬렉션은 영속성 전이(Cascade) + 고아객체 제거 기능을 필수로 가져감              컬렉션을 저장하기 위한 별도의 테이블 필요                          @Entity  public class Member  {      @Id @GeneratedValue      @Column(name=\"MEMBER_ID\")      private Long id;      private String name;      // @ManyToOne @JoinColumn(name = \"TEAM_ID\", insertable = false, updatable = false)      // private Team team;      //기간      @Embedded      private Period workPeriod;      //주소      @Embedded      private Address homeAddress;                  @ElementCollection      @CollectionTable(name=\"FAVORITE_FOOD\", joinColumns = @JoinColumn(name=\"MEMBER_ID\"))      @Column(name=\"FOOD_NAME\") //값이 하나라 사용가능      private Set&lt;String&gt; favoriteFoods = new HashSet&lt;String&gt;();                      @ElementCollection      @CollectionTable(name=\"ADDRESS\", joinColumns = @JoinColumn(name=\"MEMBER_ID\"))      //값이 여러개라 @Column사용 불가능      private List&lt;Address&gt; addressHistory = new ArrayList&lt;Address&gt;();  }                          Address a = new Address(\"대구 서구\", \"북비산로 67길\", \"12300\");                  Member m = new Member();                  m.setName(\"hello\");                  m.setHomeAddress(a);                  m.getFavoriteFoods().add(\"치킨\");                  m.getFavoriteFoods().add(\"족발\");                  m.getFavoriteFoods().add(\"피자\");                  m.getFavoriteFoods().add(\"떡볶이\");                  m.getAddressHistory().add(new Address(\"1\", \"1\", \"1111\"));                  m.getAddressHistory().add(new Address(\"2\", \"2\", \"2222\"));                                    이런식  컬렉션은 전부 지연로딩임                          조회, 수정                  //조회  List&lt;Address&gt; list = find.getAddressHistory();  for(Address address : list){  System.out.println(address.getCity());  }  Set&lt;String&gt; set = find.getFavoriteFoods();  for(String food : set){  System.out.println(food);  }  //수정  find.setHomeAddress(new Address(\"newCity\", find.getHomeAddress().getStreet(), find.getHomeAddress().getZipcode()));  //수정  find.getFavoriteFoods().remove(\"치킨\");  find.getFavoriteFoods().add(\"한식\");                                                      — 제약사항                          값 타입은 엔티티와 다르게 식별자 개념이 없음              값 변경시 추적이 어려움              값 타입 컬렉션에 변경사항이 발생하면 주인 엔티티와 연관된 모든 데이터(멤버아이디가 동일한 것)를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장              값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성함(null x, 중복 x)                        ⇒ 실무에서는 값타입 컬렉션 대신 일대다 관계를 사용하는 것이 나음. 일대다 관계를 위한 엔티티를 만들고 여기서 값 타입 사용.(영속성 전이(Cascade)+고아객체 제거를 사용해 값타입 컬렉션처럼 사용)              package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;              import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;              @Entity  public class AddressEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      private Long id;      private Address address;  }                          @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)      @JoinColumn(name=\"MEMBER_ID\")      private List&lt;AddressEntity&gt; addressHistory = new ArrayList&lt;AddressEntity&gt;();                        값 타입을 엔티티로 승격시켜줌(실무사용방법)                              "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 프록시와 연관관계 관리",
    "url": "/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80_%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84_%EA%B4%80%EB%A6%AC/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-30 00:00:00 +0900",
    





    
    "snippet": "FK가 걸린 다른 객체를 각 상황에따라 같이조회할때도있고 조회하지않을때도 있을때, 조회하지 않을때 프록시와 지연로딩을 사용.프록시  em.find() : 데이터 베이스를 통해 실제 엔티티 객체 조회      em.getReference() : 데이터 베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회        위 코드 아래에 다시 findMembe...",
    "content": "FK가 걸린 다른 객체를 각 상황에따라 같이조회할때도있고 조회하지않을때도 있을때, 조회하지 않을때 프록시와 지연로딩을 사용.프록시  em.find() : 데이터 베이스를 통해 실제 엔티티 객체 조회      em.getReference() : 데이터 베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회        위 코드 아래에 다시 findMember.getName()을 하면 쿼리문 없이 바로 hello가 출력됨    em.getReference를 해서 가져온 findMember는 가짜 객체(껍데기만 같고 속은 텅텅빈상태)임. 실제 객체의 값을 조회할 때, sql문을 날려 DB에서 조회하는 것.    이론상 이 객체가 진짜인지 프록시 객체인지 구분하지 않고 사용가능함. 실제 클래스를 상속받아서 만들어지는 객체    프록시는 실제 객체의 참조(target)을 보관. 프록시 객체를 호출하면서 프록시 객체는 실제 객체의 메소드를 호출. 그런데 처음 호출하는거면 target이 없음 → 초기화 요청 작업 필요      — 특징  처음 사용할때 한번만 초기화  프록시 객체 초기화시 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화하면 프록시 객체를 통해 실제 인티티에 접근가능한것.  원본 엔티티를 상속받음. 따라서 타입체크시 주의.( == 비교 안됨, instance of 사용할것)      영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환(이미 em.find로 찾은 객체를 em.getReference로 찾으면 이미 찾아놓은 객체를 가져옴. 그래서 == 비교해도 true임  같은 원리고 em.getReference()로 호출하고 뒤에 em.find()로 같은 객체를 가져오면 == 비교를 해도 true가 나옴. em.find도 프록시를 가져오기 때문임. 실무에서 이렇게 복잡하게쓰일 일은 거의 없음)    영속성 컨텍스트의 도움을 받을수 없는 상태(준영속상태)일때 프록시 초기화하면 문제 발생          영속성 컨텍스트의 도움을 받을수 없는 상태(준영속상태)?  em.detach(proxy)를 사용했거나 em.close(), em.clear()를 사용했을 경우      영속성이 제거된 상태이기때문에 영속성 초기화를 할 수 없음      — 프록시 확인 방법  emf.getPersistenceUnitUtill.isLoaded(Object entity) - 프록시 인스턴스 초기화 여부 확인  entity.getClass().getName() 출력 - 프록시 클래스 확인 방법  org.hibernate.initialize(entity) - 프록시 강제 초기화  → JPA표준은 강제 초기화 없음  member.getName() - 강제 호출프록시는 잘 사용되지않으나 지연로딩과 즉시로딩이 자주 사용됨지연로딩(LAZY)@ManyToOne(fetch=FetchType.LAZY) - 연관 클래스 불러오기 전에는 연관 클래스 제외 조회지연로딩으로 만들면 연관 클래스를 프록시로 가지고옴실제 연관 클래스를 사용하는 시점에 초기화 됨연관 클래스를 자주 함께 조회한다면 성능상 손해임. → 즉시로딩 사용실무에서는 가급적 지연로딩만 사용할것!!@ManyToOne, @OneToOne은 기본이 즉시 로딩임 → LAZY로 설정해주어야함@OneToMany, @ManyTOMany는 기본이 지연로딩임즉시로딩(EAGER)@ManyToOne(fetch=FetchType.EAGER) - 처음부터 연관 클래스를 같이 가지고옴예상치 못한 SQL이 발생함. JPQL에서 N+1문제를 일으킴.  N+1문제?  하나의 테이블에 쿼리문을 날렸는데 다른 테이블 쿼리문도 실행되는 상황. 엔티티에 다른 엔티티가 연관되어있어서 한 테이블에 select문을 날렸는데 연관 테이블도 select되는 상황을 의미함— 결론모두 지연로딩으로 세팅 후 fetch join 사용 - 원하는 애들만 선택해서 가져오는 기법select m from Member m join fetchm.team 같이 사용, 뒤에 자세히 설명영속성 전이(CASCADE)@OneToMany(mappedBy=”parent”, cascade=CascadeType.XXX)특정 엔티티를 영속상태로 만들때 연관 엔티티도 영속상태로 만들어줌.(=부모 엔티티 저장 시, 자식 엔티티도 저장)연관관계 매핑과는 아무 관련이 없음. 엔티티를 영속화 할때 연관관계 엔티티도 함께 영속화되는 편리함때문에 사용됨하나의 부모가 자식들을 관리할때 효과가 있음. 자식의 연관관계가 여러개일때는 사용하지말것.— 종류  ALL : 모두 적용  PERDIDT : 영속  REMOVE : 삭제  MERGE : 병합  REFRESH : REFRESH  DETACH : DETACH고아객체고아객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제orphanRemoval = true부모의 List에서 자식을 remove해버리면 자식 데이터 자체가 삭제가 됨CascadeType.REMOVE처럼 동작함  주의점          참조하는 곳이 하나일때만 사용      특정 엔티티가 개인 소유일때만 사용      @OneToOne, @OneToMany만 사용 가능      ❗영속성 전이 + 고아객체, 생명주기  CascadeType.ALL + orphanRemovel = true  스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove로 제거  두 옵션을 모두 활성화 하면 부모 엔티티를 통해 자식의 생명주기 관리 가능  도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 떄 유"
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 고급매핑",
    "url": "/posts/%EA%B3%A0%EA%B8%89%EB%A7%A4%ED%95%91/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-29 00:00:00 +0900",
    





    
    "snippet": "DB에는 상속이라는 개념이 없음. 상속을 DB에서는 각각의 테이블로 변환(조인), 통합테이블 변환(단일테이블), 서브타입 테이블(구현클래스마다 테이블)로 변환 3가지가 있음  주요 어노테이션          @Inheritance(strategy= InheritanceType.XXX)                  JOINED : 조인전략(기본) - ...",
    "content": "DB에는 상속이라는 개념이 없음. 상속을 DB에서는 각각의 테이블로 변환(조인), 통합테이블 변환(단일테이블), 서브타입 테이블(구현클래스마다 테이블)로 변환 3가지가 있음  주요 어노테이션          @Inheritance(strategy= InheritanceType.XXX)                  JOINED : 조인전략(기본) - 정규화되어있음. 외래키 참조 제약조건 사용가능, 저장공간 효율화, 조인으로 인한 성능 저하, 쿼리 복잡, 저장시 insert 쿼리 2번          SINGLE_TABLE : 단일 테이블 전략(단순, 확장가능성 낮을때) - 조인필요없음, 쿼리 단순, 자식 엔티티가 매핑한 컬럼은 모두 null 허용, 상황에 따라 테이블이 커지면 성능이 떨어질수도 있음          TABLE_PER_CLASS : 구현 클래스마다 테이블 전략(쓰지말것) -                      @DiscriminatorColumn(name=”DTYPE”)  @DiscriminatorValue(”XXX”)      @MappedSuperclass - 공통 매핑 정보가 필요할때 사용(id, name)        공통되는 부분을 새 클래스로 만들고, 각각의 클래스들이 새 클래스를 extents 하면 됨    공통 되는 부분을 뽑아 만든 클래스에는 @MappedSuperclass를 써줘야함          상속 관계 매핑x      엔티티x, 테이블과 매핑 x      부모클래스를 상속받는 자식클래스에 매핑 정보만 제공      조회, 검색 불가(em.find(BaseEntity)불가)      직접 생성해서 사용할 일이 없으므로 추상 클래스 권장(abstract)          @Entity  @Inheritance(strategy = InheritanceType.SINGLE_TABLE)  @DiscriminatorColumn //기본이 DTYPE  public abstract class Item {      @Id @GeneratedValue      @Column(name = \"ITEM_ID\")      private Long id;      private String name;      private int price;      private int stockQuantity;      @ManyToMany(mappedBy = \"items\")      private List&lt;Category&gt; child = new ArrayList&lt;Category&gt;();  }      "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 연관관계 매핑",
    "url": "/posts/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84_%EB%A7%A4%ED%95%91/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-27 00:00:00 +0900",
    





    
    "snippet": "  방향(Direction)                  단방향          package com.kyhJPA.practice;          import javax.persistence.*;  @Entity  public class Member {      @Id @GeneratedValue      @Column(name = \"MEMBER_...",
    "content": "  방향(Direction)                  단방향          package com.kyhJPA.practice;          import javax.persistence.*;  @Entity  public class Member {      @Id @GeneratedValue      @Column(name = \"MEMBER_ID\")      private Long id;      @Column(name = \"USERNAME\")      private String username;                  // @Column(name = \"TEAM_ID\")      // private Long teamId;              @ManyToOne      @JoinColumn(name=\"TEAM_ID\")      private Team team;              public Team getTeam() {          return this.team;      }              public void setTeam(Team team) {          this.team = team;      }              // public Long getTeamId() {      //     return this.teamId;      // }              // public void setTeamId(Long teamId) {      //     this.teamId = teamId;      // }              public Long getId() {          return this.id;      }              public void setId(Long id) {          this.id = id;      }              public String getUsername() {          return this.username;      }              public void setUsername(String username) {          this.username = username;      }                  public Member(){              }              }                  {              \"bookSeq\": 3,              \"booktitle\": \"NestJS로 배우는 벡엔드 프로그래밍,NestJS로 배우는 벡엔드 프로그래밍\",              \"bookPrice\": 27000,              \"bookdiscount\": 0.1,              \"bookDelivery\": \"무료배송\",              \"publisherSeq\": {                  \"publisherSeq\": 3,                  \"publisherName\": \"제이펍\"              },              \"translatorSeq\": null,              \"bookSales\": 0,              \"bookRegDt\": \"2022-12-19T15:00:00.000+00:00\"          }                            양방향        위 단방향 매핑에서 team에서 member를 찾아올수없음!!          package com.kyhJPA.practice;          import java.util.ArrayList;  import java.util.List;          import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.Id;  import javax.persistence.OneToMany;          @Entity  public class Team {      @Id @GeneratedValue      @Column(name=\"TEAM_ID\")      private Long id;      private String name;              @OneToMany(mappedBy = \"team\") //Member클래스의 멤버변수 team과 연결되어있      private List&lt;Member&gt; members = new ArrayList&lt;Member&gt;();              public List&lt;Member&gt; getMembers() {          return this.members;      }              public void setMembers(List&lt;Member&gt; members) {          this.members = members;      }                  public Long getId() {          return this.id;      }              public void setId(Long id) {          this.id = id;      }              public String getName() {          return this.name;      }              public void setName(String name) {          this.name = name;      }                  }                team에 memberList를 생성해서 mappedBy를 사용                  객체와 테이블이 관계를 맺는 차이                          객체 연관관계 2개                                  회원 → 팀 연관관계 1개(단방향)                  팀→ 회원 연관관계 1개(단방향)                                            테이블 연관관계 1개                                  회원 ←→ 팀의 연관관계 1개(양방향)                                                                    → 객체의 양방향 관계 = 서로다른 단방향 관계 2개        ❗외래키 관리는 단방향 연관관계 2개중 하나로만 관리를 해야함 - 연관관계 주인(Owner)                              자주하는 실수                          연관관계 주인에 값을 입력하지 않음 - 항상 양쪽에 값을 설정해야함(편의 메소드를 작성하는 것을 추천함 - 양쪽에 모두 존재하면 문제발생 가능성있음)                          public void changeTeam(Team team) {          this.team = team;          team.getMembers().add(this); //여기서 this는 Member 클래스를 의미함      }                                      무한루프 - toString, lombok, JSON에서 무한루프에 빠짐!!  ⇒ lombok에서 toString만드는거 쓰지말것. json은.. entity를 바로 내보내지말것..!!!ㅜㅜㅠDTO(VO)를 생성해서 순수 자바 객체를 내보내는 것을 추천함,,,!!                        ⚠️ 단방향 매핑으로도 연관관계 매핑은 완료됨!!!!!양방향 매핑은 반대방향 조회기능이 추가된것뿐임!!!! 일단 단방향으로 매핑을 완료한 후 필요할때 양방향을 추가하면 됨                                다중성(Multiplicity)          다대일(N:1) - 가장 많이 사용              일대다(1:N) - 권장하지 않음                  항상 다(N)쪽에 외래키가 있어 반대편 테이블의 외래키를 관리하는 특이한 구조. @joinColumn을 꼭 사용해야함. 아니면 중간에 조인테이블을 추가해서 사용                  @OneToMany() @JoinColumn(name=\"TEAM_ID\") //Member클래스의 멤버변수 team과 연결되어있음      private List&lt;Member&gt; members = new ArrayList&lt;Member&gt;();                  Member member = new Member();              member.setUsername(\"member0\");              em.persist(member);                      Team team = new Team();              team.setName(\"Team0\");              team.getMembers().add(member); //team테이블이 아닌 member테이블의 team_id에 값이 들어감 update구문               //권장하지 않는 이유. team을 보냈는데 member테이블이 update됨                      em.persist(team);                          연관관계 관리를 위해 추가로 UPDATE SQL이 실행되어 비효율적임.                      일대다 양방향 - 공식x                          @JoinColumn(insertable = false, updatable = false) 를 사용              그냥 다대일 양방향을 사용할것.                          @ManyToOne      @JoinColumn(name=\"TEAM_ID\", insertable = false, updatable = false) //읽기전      private Team team;                                                  일대일(1:1)                  주테이블이나 대상 테이블중에 외래키 선택 가능                          주 테이블 외래키                                  객체지향 개발자 선호                  JPA매핑 편리                  주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능하나 값이 없으면 외래키에 null 허용                                            대상 테이블 외래키                                  대상 테이블에 외래키가 존재                  전통적인 DB개발자 선호                  주테이블과 대상테이블을 일대일에서 일대다로 바꿀때 테이블 구조는 유지되나 프록시 기능의 한계로 지연로딩으로 설정해도 항상 즉시 로딩됨                                                              다대일, 단방향 매핑과 유사함                  @Entity  public class Locker {       @Id @GeneratedValue       private Long id;               private String name;               @OneToOne(mappedBy = \"locker\")       private Member member;  }                  @Entity  public class Member {      @Id @GeneratedValue      @Column(name = \"MEMBER_ID\")      private Long id;      @Column(name = \"USERNAME\")      private String username;              @ManyToOne      @JoinColumn(name=\"TEAM_ID\")      private Team team;              @OneToOne @JoinColumn(name=\"LOCKER_ID\")      private Locker locker;  }                    다대다(N:M) - 쓰지말것. 연결 테이블을 하나 생성해서 다대일, 일대다로 풀어내야함        연관관계 주인(Owner)          객체 양방향 연관관계(단방향 2개)에서 하나를 연관관계 주인으로 지정      연관관계 주인만이 외래키를 관리(등록, 수정)      주인이 아닌쪽은 읽기만 가능      주인은 mappedBy속성을 이용하지x(mappedBy가 있다면 주인이 아님)      주인은 외래키가 있는곳으로 정할것(반대편을 가짜매핑이라고 편의상 부름. 전문용어는 아닌듯) - DB 입장에서는 외래키가 있는곳이 다, 없는곳이 1.        @JoinColumn : 외래 키를 매핑할 때 사용          name : 매핑할 외래키 이름. 필드명_참조할 테이블의 기본키 컬럼명      referencedColumnName : 외래키가 참조하는 대상 테이블의 컬럼명. 참조하는 테이블의 기본키 컬럼명      foreignKey(DDL) - 외래 키 제약조건을 직접 지정가능. 테이블 생성할때만 사용가능      @Column속성과 같은것                  unique          nullable insertable          updateable          columnDefinition          table                      @ManyToOne 주요 속성          optional : false로 설정하면 연관된 엔티티가 항상 있어야 함 - 기본값 true      fetch - 글로벌 페치 전략을 설정                  @ManyToOne=FetchType.EAGER          @OneToMany=FetchType.LAZY                    cascade - 영속성 전이 기능 사용      targetEntity - 연관된 엔티티의 타입정보를 설정. 거의 사용 안함.(컬렉션을 사용해도 제네릭으로 타입정보를 알수있음)        @OneToMany 주요 속성          mappedBy - 연관관계 주인 필드 선택      fetch - 글로벌 페치 전략을 설정                  @ManyToOne=FetchType.EAGER          @OneToMany=FetchType.LAZY                    cascade - 영속성 전이 기능 사용      targetEntity - 연관된 엔티티의 타입정보를 설정. 거의 사용 안함.(컬렉션을 사용해도 제네릭으로 타입정보를 알수있음)      "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] MVC패턴 실습",
    "url": "/posts/MVC/",
    "categories": "Spring",
    "tags": "spring, mvc, 국비교육",
    "date": "2022-12-26 00:00:00 +0900",
    





    
    "snippet": "클라이언트사이드 렌더링(CSR) : 사용자의 컴퓨터 성능에따라 달라짐. (지금까지 한 방법)서버사이드 렌더링(SSR) : 서버의 성능에 따라 움직임?(새로 시도할 방법)jdk버전 17.0.4.1로 업데이트함환경변수 JAVA_HOME 경로 변경해주기. vscode에서도 자바버전 확인해보기스프링 프로젝트 생성시 자바 3.0.1, 17버전으로 선택appli...",
    "content": "클라이언트사이드 렌더링(CSR) : 사용자의 컴퓨터 성능에따라 달라짐. (지금까지 한 방법)서버사이드 렌더링(SSR) : 서버의 성능에 따라 움직임?(새로 시도할 방법)jdk버전 17.0.4.1로 업데이트함환경변수 JAVA_HOME 경로 변경해주기. vscode에서도 자바버전 확인해보기스프링 프로젝트 생성시 자바 3.0.1, 17버전으로 선택application.properties에서 공백이 들어가면 안됨. 종료를 의미하는 ;을 사용하지 않아서 제대로 써줘야함controller(사용자와의 연결을 관리)에서 날아온 medel을 viewResolver가 파일을 찾아서 view에 표시함callback(프로그램이 메소드를 실행)개념과도 맞물림 - 자바스크립트의 event, click, spring의 getMapping 등 IOC와 동일함resource의 static폴더에는 아이콘 같이 잘 변하지않는 것들을 넣음  html에서 입력받은 정보를 객체에 저장하는 방법&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;회원가입&lt;/h1&gt;    &lt;form action=\"/member/join\" method=\"post\"&gt;        &lt;table&gt;            &lt;tbody&gt;                &lt;tr&gt;                    &lt;td&gt;아이디&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"id\"&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;비밀번호&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"password\" name=\"pwd\"&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;이름(닉네임)&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"nickname\"&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan=\"2\"&gt;                        &lt;input type=\"submit\" value=\"회원가입\"&gt;                        &lt;a href=\"/\"&gt;메인으로&lt;/a&gt;                    &lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;package com.green.demo.VO;import lombok.Data;@Datapublic class UserInfoVO {    private String id;    private String pwd;    private String nickname;}package com.green.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import com.green.demo.VO.UserInfoVO;@Controller@RequestMapping(\"/member\")public class MemberController {    @GetMapping(\"/join\")    public String getMemberJoin(){        return \"/member/join\";    }    @PostMapping(\"/join\")    public String postMemberJoin(UserInfoVO data){        System.out.println(data);        return \"member/join\";    }}여기서 회원가입하면출력됨package com.green.demo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import com.green.demo.VO.UserInfoVO;import com.green.demo.entity.UserEntity;import com.green.demo.repository.UserRepository;@Controller@RequestMapping(\"/member\")public class MemberController {    @Autowired UserRepository uRepo;    @GetMapping(\"/join\")    public String getMemberJoin(){        return \"/member/join\";    }    @PostMapping(\"/join\")    public String postMemberJoin(UserInfoVO data){        System.out.println(data);        UserEntity entity = new UserEntity(null, data.getId(), data.getPwd(), data.getNickname());        System.out.println(entity);        uRepo.save(entity);        return \"member/join\";    }}받은 값은 repository에 save()해주면 DB에 저장됨물론 이런방법으로 하면 안됨  가입 후 성공메세지@PostMapping(\"/join\")    public String postMemberJoin(UserInfoVO data){        System.out.println(data);        UserEntity entity = new UserEntity(null, data.getId(), data.getPwd(), data.getNickname());        System.out.println(entity);        uRepo.save(entity);        return \"member/joined\";    }&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;성공적으로 가입되었습니다.&lt;/h1&gt;    &lt;a href=\"/\"&gt;메인으로&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;  중복가입 메세지@PostMapping(\"/join\")    public String postMemberJoin(UserInfoVO data, Model model){        System.out.println(data);        if(uRepo.countByUiId(data.getId())&gt;0){            model.addAttribute(\"dup_id\", data.getId());            return \"/member/duplicated\";        }        UserEntity entity = new UserEntity(null, data.getId(), data.getPwd(), data.getNickname());        System.out.println(entity);        uRepo.save(entity);        return \"member/joined\";    }&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&lt;u th:text=\"${dup_id}\"&gt;&lt;/u&gt;은/는 이미 가입된 아이디입니다.&lt;/h1&gt;    &lt;a href=\"/\"&gt;메인으로&lt;/a&gt;    &lt;a href=\"/member/join\"&gt;회원가입&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;책application.properties 설정server.port=8044\\#DB설정  jdbc:mysql://jdbc연결 프로토콜(http://, ftp://, smtp://)spring.datasource.url=jdbc:mysql://localhost:3306/book_info_dbspring.datasource.username=rootspring.datasource.password=1234\\#thymeleaf(출력화면) 설정spring.thymeleaf.enabled=true\\#application.properties입장에서의 소속 패키지(폴더경로)# classpath : src/main/resources 경로를 의미spring.thymeleaf.prefix=classpath:/templates/#최종적으로 src/main/resources/templates/ 경로를 의미spring.thymeleaf.suffix=.html\\#File Transfer Settingsspring.servlet.multipart.enabled=truespring.servlet.multipart.max-file-size=100MBspring.servlet.multipart.max-request-size=110MB      일부 값만 적어서 객체 생성하는 방법 - @Builder      package com.greenart.book_info.entity;              import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Builder;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"admin_account\")  @DynamicInsert //입력이 안된 null값은 default값을 입력  @Builder //입력한 값만 입력. 객체 생성 시 없는 값은 제외하고 입력  public class AdminAccountEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"ai_seq\")                            private Long aiSeq;       @Column(name=\"ai_id\")                             private String aiId;       @Column(name=\"ai_pwd\")                            private String aiPwd;       @Column(name=\"ai_name\")                           private String aiName;       @Column(name=\"ai_grade\")  @ColumnDefault(\"1\")     private Integer aiGrade;       @Column(name=\"ai_status\") @ColumnDefault(\"0\")     private Integer aiStatus;  }          package com.greenart.book_info;      import org.junit.jupiter.api.Test;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.boot.test.context.SpringBootTest;  import org.springframework.transaction.annotation.Transactional;      import com.greenart.book_info.entity.AdminAccountEntity;  import com.greenart.book_info.repository.AdminAccountRepository;      @SpringBootTest  class BookInfoApplicationTests {      \t@Autowired AdminAccountRepository aRepo;      \t@Test  \t@Transactional  \tvoid addAdmin() {  \t\tAdminAccountEntity account = AdminAccountEntity.builder().aiId(\"admin\").aiPwd(\"1234\").aiName(\"관리자\").build();  \t\taRepo.save(account);  \t\tSystem.out.println(account);  \t}      }        모든 값을 입력하지 않고도 생성가능함.(생성자와 동일한 역할이나 입력하지 않을 멤버변수에 null을 사용하지않고 생성가능)        중복아이디시 입력값 살리는 법      package com.greenart.book_info.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PostMapping;  import org.springframework.web.bind.annotation.RequestMapping;      import com.greenart.book_info.entity.AdminAccountEntity;  import com.greenart.book_info.repository.AdminAccountRepository;      @Controller  @RequestMapping(\"/member\")  public class MemberController {           @Autowired AdminAccountRepository aRepo;           @GetMapping(\"/join\") //requestMapping       public String getMemberJoin(){            return \"/member/join\"; //application.properties prefix, suffix기준       }       @PostMapping(\"/join\")       public String postMemberJoin(String id, String pwd, String name, Model model){            if(aRepo.countByAiId(id)&gt;0){                 model.addAttribute(\"id\", id);                 model.addAttribute(\"name\", name);                 model.addAttribute(\"status\", \"duplicated\");                 return \"/member/join\";             }else{                 AdminAccountEntity data = AdminAccountEntity.builder().aiId(id).aiPwd(pwd).aiName(name).build();                 aRepo.save(data);            }            return \"/login\"; //가입 성공하면 바로 로그인페이지로       }  }          &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;관리자 등록&lt;/h1&gt;        &lt;form action=\"/member/join\" method=\"post\"&gt;            &lt;!-- table&gt;tbody&gt;(tr&gt;td*2)*3 입력하면 자동으로 틀 만들어줌--&gt;            &lt;table&gt;                 &lt;tbody&gt;                      &lt;tr&gt;                           &lt;td&gt;아이디&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"text\" name=\"id\" th:value=\"${id}\"&gt;&lt;/td&gt;                           &lt;td&gt;&lt;span th:if=\"${status=='duplicated'}\" style=\"color: red;\"&gt;중복 아이디 입니다.&lt;/span&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;비밀번호&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"password\" name=\"pwd\"&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;이름&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"text\" name=\"name\" th:value=\"${name}\"&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td colspan=\"2\"&gt;                                &lt;input type=\"submit\" value=\"관리자 등록\"&gt;                           &lt;/td&gt;                      &lt;/tr&gt;                 &lt;/tbody&gt;            &lt;/table&gt;       &lt;/form&gt;  &lt;/body&gt;  &lt;/html&gt;        중복아이디 입력으로 실패처리돼도 아이디와 이름의 값이 유지가 되고 메세지가 뜸          공백검사      String replacedId = id.replaceAll(\" \", \"\"); //문자열 공백 제거            if(id.length()!=replacedId.length()){ //공백이 있었다면 문자열의 길이가 달라짐                 model.addAttribute(\"status\", \"whitespaceId\");                 return \"/member/join\";             }            String replacedPwd = pwd.replaceAll(\" \", \"\"); //문자열 공백 제거            if(pwd.length()!=replacedPwd.length()){ //공백이 있었다면 문자열의 길이가 달라짐                 model.addAttribute(\"status\", \"whitespacePwd\");                 return \"/member/join\";             }        메소드에 추가 후 html에 if문 추가        영문, 숫자만 가능하도록 추가 - 정규표현식 사용      String kor_pattern = \"^[a-zA-Z0-9]*$\"; //영어, 숫자만 가능            Pattern p = Pattern.compile(kor_pattern);            if(!p.matcher(id).matches()){                 model.addAttribute(\"status\", \"invalidId\");                 return \"/member/join\";             }        메소드에 추가 후 html에 if문 추가    이메일, 전화번호 형식 등 검색하면 정규표현식 뜸. 복붙해서 쓰면됨    정규표현식으로 공백도 걸러지니 정규표현식을 사용한다면 위의 공백검사는 안해줘도됨        로그인      @GetMapping(\"/login\")  public String getLogin(HttpServletResponse response){      response.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");      response.setHeader(\"Pragma\", \"no-cache\");      response.setHeader(\"Expires\", \"0\"); //로그인 후 뒤로가기했을때 비밀번호가 뜨지않도록 캐시를 날림      return \"/login\";  }  @PostMapping(\"/login\")  public String postLogin(String id, String pwd, Model model, HttpSession session){       //session - 값들을 저장하는 저장소(전체서비스에서 한개 = 전역적임[전체영역에서 접근 가능])      System.out.println(id);      System.out.println(pwd);      AdminAccountEntity loginUser = adminAccountRepository.findByAiIdAndAiPwd(id, pwd);      //다른 URL로 들어가면 loginUser는 사용할 수 없음      if(loginUser==null){           model.addAttribute(\"loginStatus\", \"failed\");           model.addAttribute(\"message\", \"아이디 또는 비밀번호 오류입니다.\");           return \"/login\";      }      session.setAttribute(\"loginUser\", new LoginUserVO(loginUser));      //session은 다른 URL로 들어가도 사용가능      return \"redirect:/\"; //로그인성공하면 메인화면으로(파일경로아니고 매핑경로 기준.)  }          &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;login&lt;/h1&gt;       &lt;form action=\"/login\" method=\"post\"&gt;            &lt;table&gt;                 &lt;tr&gt;                      &lt;td&gt;아이디&lt;/td&gt;                      &lt;td&gt;&lt;input type=\"text\" name=\"id\"&gt;&lt;/td&gt;                 &lt;/tr&gt;                 &lt;tr&gt;                      &lt;td&gt;비밀번호&lt;/td&gt;                      &lt;td&gt;&lt;input type=\"password\" name=\"pwd\"&gt;&lt;/td&gt;                 &lt;/tr&gt;                 &lt;tr&gt;                      &lt;td colspan=\"2\"&gt;                      &lt;button&gt;로그인&lt;/button&gt;                 &lt;/tr&gt;                 &lt;tr&gt;                      &lt;td colspan=\"2\"&gt;                           &lt;a href=\"/member/join\"&gt;관리자 등록&lt;/a&gt;                      &lt;/td&gt;                 &lt;/tr&gt;            &lt;/table&gt;       &lt;/form&gt;       &lt;div th:if=\"${loginStatus == 'failed'}\"&gt;            &lt;p th:text=\"${message}\" style=\"color: red; font-weight: bold; font-size: 14px;\"&gt;&lt;/p&gt;       &lt;/div&gt;  &lt;/body&gt;  &lt;/html&gt;            계정 조회 후 상태값 변경, 계정 삭제    영속성 조심(수정했다가 원본 테이블 수정될까봐)!! 새 객체 만들어줌      package com.greenart.book_info.VO;      import com.greenart.book_info.entity.AdminAccountEntity;      import lombok.Data;  @Data  public class AdminAccountVo {       private Long seq;       private String id;       private String name;       private Integer grade;       private Integer status;           public AdminAccountVo(AdminAccountEntity account){            this.seq = account.getAiSeq();            this.id = account.getAiId();            this.name = account.getAiName();            this.grade = account.getAiGrade();            this.status = account.getAiStatus();       }  }          @GetMapping(\"/list\")  public String getMemberList(Model model, Pageable pageable  ){      Page&lt;AdminAccountEntity&gt; page = aRepo.findAll(pageable);      List&lt;AdminAccountVo&gt; result = new ArrayList&lt;&gt;();      for(AdminAccountEntity a : page.getContent()){           result.add(new AdminAccountVo(a));      }      model.addAttribute(\"accountList\", result);      model.addAttribute(\"totalPage\", page.getTotalPages());      model.addAttribute(\"totalCount\", page.getTotalElements());      model.addAttribute(\"getMemberJoin()\", page.getNumber());      return \"member/list\";  }  @GetMapping(\"/status\")  public String getMemberStatusUpdate(@RequestParam Long seq, @RequestParam Integer status){      AdminAccountEntity entity = aRepo.findByAiSeq(seq); //select문      entity.setAiStatus(status); //값 변경      aRepo.save(entity); //ctrl + s      // -&gt; update      return \"redirect:/member/list\";  }  @GetMapping(\"/delete\")  public String getMemberDelete(@RequestParam Long seq){      AdminAccountEntity entity = aRepo.findByAiSeq(seq);      aRepo.delete(entity); //삭제      return \"redirect:/member/list\";  }        result에 new를 써서 새로운 객체를 만들어준것이 영속성 제거를 위해 사용한 것임    @{URL}(param=${value}) 형식으로    @{/member/status(seq=${admin.seq})} 이런식.    admin.seq에 해당 멤버의 seq값이 자동으로 들어감 최종적으로    /member/status?seq=7 이런식으로 주소가 생성됨    — 파라미터 추가 @{/member/status(seq=${admin.seq}, status=1)} 이런식      &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;Admin Account List&lt;/h1&gt;       &lt;!-- &lt;p th:text=\"${accountList}\"&gt;&lt;/p&gt; --&gt;       &lt;table&gt;            &lt;thead&gt;                     &lt;tr&gt;                      &lt;th&gt;번호&lt;/th&gt;                      &lt;th&gt;아이디&lt;/th&gt;                      &lt;th&gt;이름&lt;/th&gt;                      &lt;th&gt;등급&lt;/th&gt;                      &lt;th&gt;상태&lt;/th&gt;                 &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                 &lt;tr th:each=\"admin, i : ${accountList}\"&gt; &lt;!-- 반복문 --&gt;                      &lt;td th:text=\"${admin.seq}\"&gt;&lt;/td&gt;                      &lt;td th:text=\"${admin.id}\"&gt;&lt;/td&gt;                      &lt;td th:text=\"${admin.name}\"&gt;&lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:switch=\"${admin.grade}\"&gt;                                &lt;span th:case=\"1\"&gt;일반&lt;/span&gt;                                &lt;span th:case=\"99\"&gt;슈퍼유저&lt;/span&gt;                           &lt;/th&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:switch=\"${admin.status}\"&gt;                                &lt;span th:case=\"0\"&gt;등록대기&lt;/span&gt;                                &lt;span th:case=\"1\"&gt;사용가능&lt;/span&gt;                                &lt;span th:case=\"2\"&gt;사용정지&lt;/span&gt;                           &lt;/th&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:if=\"${admin.status==0}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=1)}\"&gt;사용 승인&lt;/a&gt;                           &lt;/th:block&gt;                           &lt;th:block th:if=\"${admin.status==1}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=2)}\"&gt;사용 정지&lt;/a&gt;                           &lt;/th:block&gt;                           &lt;th:block th:if=\"${admin.status==2}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=1)}\"&gt;사용 승인&lt;/a&gt;                           &lt;/th:block&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block&gt;                                &lt;a th:href=\"@{/member/delete(seq=${admin.seq})}\"&gt;삭제&lt;/a&gt;                           &lt;/th:block&gt;                      &lt;/td&gt;                 &lt;/tr&gt;            &lt;/tbody&gt;       &lt;/table&gt;       &lt;div&gt;            &lt;span th:each=\"num : ${\\#numbers.sequence(1, totalPage)}\"&gt;                 &lt;a th:href=\"@{/member/list(page=${num-1},size=10,sort=aiSeq,desc)}\" th:text=\" ${num}\"&gt;&lt;/a&gt;            &lt;/span&gt;       &lt;/div&gt;  &lt;/body&gt;  &lt;/html&gt;                              페이지 기능 추가. 페이지 누르면 이동됨        슈퍼유저만 관리자리스트페이지 접근가능      @GetMapping(\"/list\")  public String getMemberList(      Model model,       @PageableDefault(size=10, sort=\"aiSeq\", direction =Sort.Direction.DESC) Pageable pageable,      HttpSession session  ){      LoginUserVO login = (LoginUserVO)session.getAttribute(\"loginUser\");      if(login == null){           return \"redirect:/login\";      }      Page&lt;AdminAccountEntity&gt; page = aRepo.findAll(pageable);      List&lt;AdminAccountVo&gt; result = new ArrayList&lt;&gt;();      for(AdminAccountEntity a : page.getContent()){           result.add(new AdminAccountVo(a));      }      model.addAttribute(\"accountList\", result);      model.addAttribute(\"totalPage\", page.getTotalPages());      model.addAttribute(\"totalCount\", page.getTotalElements());      model.addAttribute(\"getMemberJoin()\", page.getNumber());      return \"member/list\";  }                &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;            &lt;script th:inline=\"javascript\"&gt;            /* &lt;![CDATA[ */                 const grade = /*[[${session.loginUser.grade}]]*/;                 if(grade==1){                      alert(\"마스터 관리자만 접근 가능한 메뉴입니다.\");                      location.href=\"/\";                 }            /* ]] */       &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;Admin Account List&lt;/h1&gt;       &lt;!-- &lt;p th:text=\"${accountList}\"&gt;&lt;/p&gt; --&gt;       &lt;table&gt;            &lt;thead&gt;                     &lt;tr&gt;                      &lt;th&gt;번호&lt;/th&gt;                      &lt;th&gt;아이디&lt;/th&gt;                      &lt;th&gt;이름&lt;/th&gt;                      &lt;th&gt;등급&lt;/th&gt;                      &lt;th&gt;상태&lt;/th&gt;                 &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                 &lt;tr th:each=\"admin, i : ${accountList}\"&gt; &lt;!-- 반복문 --&gt;                      &lt;td th:text=\"${admin.seq}\"&gt;&lt;/td&gt;                      &lt;td th:text=\"${admin.id}\"&gt;&lt;/td&gt;                      &lt;td th:text=\"${admin.name}\"&gt;&lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:switch=\"${admin.grade}\"&gt;                                &lt;span th:case=\"1\"&gt;일반&lt;/span&gt;                                &lt;span th:case=\"99\"&gt;슈퍼유저&lt;/span&gt;                           &lt;/th&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:switch=\"${admin.status}\"&gt;                                &lt;span th:case=\"0\"&gt;등록대기&lt;/span&gt;                                &lt;span th:case=\"1\"&gt;사용가능&lt;/span&gt;                                &lt;span th:case=\"2\"&gt;사용정지&lt;/span&gt;                           &lt;/th&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block th:if=\"${admin.status==0}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=1)}\"&gt;사용 승인&lt;/a&gt;                           &lt;/th:block&gt;                           &lt;th:block th:if=\"${admin.status==1}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=2)}\"&gt;사용 정지&lt;/a&gt;                           &lt;/th:block&gt;                           &lt;th:block th:if=\"${admin.status==2}\"&gt;                                &lt;a th:href=\"@{/member/status(seq=${admin.seq}, status=1)}\"&gt;사용 승인&lt;/a&gt;                           &lt;/th:block&gt;                      &lt;/td&gt;                      &lt;td&gt;                           &lt;th:block&gt;                                &lt;a th:href=\"@{/member/delete(seq=${admin.seq})}\"&gt;삭제&lt;/a&gt;                           &lt;/th:block&gt;                      &lt;/td&gt;                 &lt;/tr&gt;            &lt;/tbody&gt;       &lt;/table&gt;       &lt;div&gt;            &lt;span th:each=\"num : ${\\#numbers.sequence(1, totalPage)}\"&gt;                 &lt;a th:href=\"@{/member/list(page=${num-1})}\" th:text=\" ${num}\"&gt;&lt;/a&gt;            &lt;/span&gt;       &lt;/div&gt;  &lt;/body&gt;  &lt;/html&gt;                로그아웃      @GetMapping(\"/logout\")       public String getLogout(HttpSession session){            // session.invalidate(); //세션 정보 모두 삭제            session.setAttribute(\"loginUser\", null); //session에 다른정보가 있다면            return \"redirect:/\";         }            책 DB 생성      create table writer_info(  \twi_seq int not null auto_increment primary key,  \twi_name varchar(100) not null,  \twi_introduce text null,  \twi_img varchar(255) default 'writer_default.jpg'  );  create table translator_info(  \tti_seq int not null auto_increment primary key,  \tti_name varchar(100) not null,  \tti_introduce text null,  \tti_img varchar(255) default 'translator_default.jpg'  );  create table publish_company(  \tpc_seq int not null auto_increment primary key,  \tpc_name varchar(255) not null  );      create table book_info(  \tbi_seq int not null auto_increment primary key,  \tbi_title varchar(255) not null,  \tbi_sub_title varchar(255) null,  \tbi_price int not null default 0,  \tbi_discount double not null default 0.1,  \tbi_point double not null default 0.05,  \tbi_pub_dt datetime not null,  \tbi_wi_seq int null,  \tbi_ti_seq int null,  \tbi_pub_seq int null,  \tforeign key (bi_wi_seq) references writer_info(wi_seq) on delete set null on update cascade, -- 작가 삭제시 책정보 null, 작가변경시 책도 변경  \tforeign key (bi_ti_seq) references translator_info(ti_seq) on delete set null on update cascade, -- 번역가 삭제시 책정보 null, 번역가 변경시 책도 변경  \tforeign key (bi_pub_seq) references publish_company(pc_seq) on delete set null on update cascade -- 출판사 삭제시 책정보 null, 출판사 변경시 책도 변경  );        foreign key 설정함.      package com.greenart.book_info.entity;      import java.time.LocalDate;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"book_info\")  @DynamicInsert  public class BookInfoEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"bi_seq\")         private Long biSeq;       @Column(name=\"bi_title\")       private String biTitle;       @Column(name=\"bi_sub_title\")   private String biSubTitle;            @Column(name=\"bi_price\")       private Integer biPrice;            @Column(name=\"bi_discount\") @ColumnDefault(\"0.1\")   private Double biDiscount;            @Column(name=\"bi_point\")    @ColumnDefault(\"0.05\")   private Integer biPoint;            @Column(name=\"bi_pub_dt\")      private LocalDate biPubDt;            @Column(name=\"bi_wi_seq\")      private Long biWiSeq;            @Column(name=\"bi_ti_seq\")      private Long biTiSeq;            @Column(name=\"bi_pub_seq\")     private Long biPubSeq;           }          package com.greenart.book_info.entity;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"publish_company\")  public class PublishCompanyEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"pc_seq\")        private Long pcSeq;       @Column(name=\"pc_name\")       private String pcName;    }          package com.greenart.book_info.entity;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"translator_info\")  @DynamicInsert  public class TranslatorInfoEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"ti_seq\")        private Long tiSeq;       @Column(name=\"ti_name\")       private String tiName;       @Column(name=\"ti_introduce\")  private String tiIntroduce;            @Column(name=\"ti_img\") @ColumnDefault(\"translator_default.jpg\") private String tiImg;  }          package com.greenart.book_info.entity;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"writer_info\")  @DynamicInsert  public class WriterInfoEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name = \"wi_seq\")           private Long wiSeq;       @Column(name = \"wi_name\")          private String wiName;       @Column(name = \"wi_introduce\")     private String wiIntroduce;            @Column(name = \"wi_img\") @ColumnDefault(\"writer_default.jpg\") private String wiImg;  }            책 추가(연관관계매핑)      package com.greenart.book_info.entity;      import java.time.LocalDate;      import org.hibernate.annotations.ColumnDefault;  import org.hibernate.annotations.DynamicInsert;  import org.springframework.beans.factory.annotation.Autowired;      import com.greenart.book_info.VO.BookAddVO;  import com.greenart.book_info.repository.PublishCompanyRepository;  import com.greenart.book_info.repository.TranslatorInfoRepository;  import com.greenart.book_info.repository.WriterInfoRepository;      import jakarta.persistence.Column;  import jakarta.persistence.Entity;  import jakarta.persistence.GeneratedValue;  import jakarta.persistence.GenerationType;  import jakarta.persistence.Id;  import jakarta.persistence.JoinColumn;  import jakarta.persistence.ManyToOne;  import jakarta.persistence.Table;  import lombok.AllArgsConstructor;  import lombok.Builder;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity  @Table(name = \"book_info\")  @DynamicInsert  @Builder  public class BookInfoEntity {       @Id @GeneratedValue(strategy = GenerationType.IDENTITY)       @Column(name=\"bi_seq\")         private Long biSeq;       @Column(name=\"bi_title\")       private String biTitle;       @Column(name=\"bi_sub_title\")   private String biSubTitle;            @Column(name=\"bi_price\")       private Integer biPrice;            @Column(name=\"bi_discount\") @ColumnDefault(\"0.1\")   private Double biDiscount;            @Column(name=\"bi_point\")    @ColumnDefault(\"0.05\")   private Double biPoint;            @Column(name=\"bi_pub_dt\")      private LocalDate biPubDt;        @ManyToOne @JoinColumn(name=\"bi_wi_seq\") WriterInfoEntity writer;       @ManyToOne @JoinColumn(name = \"bi_ti_seq\") TranslatorInfoEntity translator;       @ManyToOne @JoinColumn(name = \"bi_pub_seq\") PublishCompanyEntity publisher;           public BookInfoEntity(BookAddVO data){            this.biTitle = data.getTitle();            this.biSubTitle   = data.getSub_title();            this.biPrice  = data.getPrice();            this.biDiscount   = data.getDiscount()/100.0;            this.biPoint  = data.getPoint()/100.0;            this.biPubDt  = data.getPub_dt();       }  }          package com.greenart.book_info.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PostMapping;  import org.springframework.web.bind.annotation.RequestMapping;      import com.greenart.book_info.VO.BookAddVO;  import com.greenart.book_info.entity.BookInfoEntity;  import com.greenart.book_info.repository.BookInfoRepository;  import com.greenart.book_info.repository.PublishCompanyRepository;  import com.greenart.book_info.repository.TranslatorInfoRepository;  import com.greenart.book_info.repository.WriterInfoRepository;      @Controller  @RequestMapping(\"/book\")  public class BookInfoController {           @Autowired TranslatorInfoRepository tRepo;       @Autowired WriterInfoRepository wRepo;       @Autowired BookInfoRepository bRepo;       @Autowired PublishCompanyRepository pRepo;           @GetMapping(\"/add\")       public String getBookAdd(Model model){            model.addAttribute(\"writerList\", wRepo.findAll());            model.addAttribute(\"translatorList\", tRepo.findAll());            model.addAttribute(\"publisherList\", pRepo.findAll());            return \"/book/add\";       }       @PostMapping(\"/add\")       public String postBookAdd(BookAddVO data){            BookInfoEntity entity = BookInfoEntity.builder()                 .biTitle(data.getTitle())                 .biSubTitle(data.getSub_title())                 .biPrice(data.getPrice())                 .biDiscount(data.getDiscount()/100.0)                 .biPoint(data.getPoint()/100.0)                 .biPubDt(data.getPub_dt())                 .writer(wRepo.findByWiSeq(data.getWriter()))                 .translator(tRepo.findByTiSeq(data.getTranslator()))                 .publisher(pRepo.findByPcSeq(data.getPublisher()))                 .build();            bRepo.save(entity);            return \"redirect:/\";       }               }          &lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;       &lt;style&gt;            body {text-align: center;}            \\#input_form_table {margin: 0 auto; border-collapse: collapse;}             \\#input_form_table input {width: 70%;}            \\#input_form_table td {padding: 10px;}       &lt;/style&gt; &lt;!-- css --&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;책 정보 추가&lt;/h1&gt;       &lt;form action=\"/book/add\" method=\"post\"&gt;            &lt;table border=\"1\" id=\"input_form_table\"&gt;                 &lt;tbody&gt;                      &lt;tr&gt;                           &lt;td&gt;책 제목&lt;/td&gt;                           &lt;td colspan=\"2\"&gt;&lt;input type=\"text\" name=\"title\"&gt;&lt;/td&gt;                           &lt;td&gt;출간일&lt;/td&gt;                           &lt;td colspan=\"2\"&gt;&lt;input type=\"text\" name=\"pub_dt\"&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;부제목&lt;/td&gt;                           &lt;td colspan=\"5\"&gt;&lt;input type=\"text\" name=\"sub_title\"&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;작가&lt;/td&gt;                           &lt;td&gt;                                &lt;select name=\"writer\"&gt;                                     &lt;option value=\"0\"&gt;선택안함&lt;/option&gt;                                     &lt;option th:each=\"writer, i : ${writerList}\" th:text=\"${writer.wiName}\" th:value=\"${writer.wiSeq}\"&gt;&lt;/option&gt;                                &lt;/select&gt;                           &lt;/td&gt;                           &lt;td&gt;번역가&lt;/td&gt;                           &lt;td&gt;                                &lt;select name=\"translator\"&gt;                                     &lt;option value=\"0\"&gt;선택안함&lt;/option&gt;                                     &lt;option th:each=\"translator, i : ${translatorList}\" th:text=\"${translator.tiName}\" th:value=\"${translator.tiSeq}\"&gt;&lt;/option&gt;                                &lt;/select&gt;                           &lt;/td&gt;                           &lt;td&gt;출판사&lt;/td&gt;                           &lt;td&gt;                                &lt;select name=\"publisher\"&gt;                                     &lt;option value=\"0\"&gt;선택안함&lt;/option&gt;                                     &lt;option th:each=\"publisher, i : ${publisherList}\" th:text=\"${publisher.pcName}\" th:value=\"${publisher.pcSeq}\"&gt;&lt;/option&gt;                                &lt;/select&gt;                           &lt;/td&gt;                           &lt;td&gt;&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td&gt;가격&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"number\" name=\"price\" min=\"0\"&gt;원&lt;/td&gt;                           &lt;td&gt;할인률&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"number\" name=\"discount\" min=\"0\" max=\"100\"&gt;%&lt;/td&gt;                           &lt;td&gt;적립율&lt;/td&gt;                           &lt;td&gt;&lt;input type=\"number\" name=\"point\" min=\"0\" max=\"100\"&gt;%&lt;/td&gt;                      &lt;/tr&gt;                      &lt;tr&gt;                           &lt;td colspan=\"6\"&gt;                                &lt;button&gt;저장&lt;/button&gt;                                &lt;a href=\"/\"&gt;돌아가기&lt;/a&gt;                           &lt;/td&gt;                      &lt;/tr&gt;                 &lt;/tbody&gt;            &lt;/table&gt;       &lt;/form&gt;  &lt;/body&gt;  &lt;/html&gt;      package com.greenart.book_info.entity;import jakarta.persistence.CascadeType;import jakarta.persistence.Column;import jakarta.persistence.Entity;import jakarta.persistence.GeneratedValue;import jakarta.persistence.GenerationType;import jakarta.persistence.Id;import jakarta.persistence.JoinColumn;import jakarta.persistence.ManyToOne;import jakarta.persistence.Table;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity@Table(name=\"student_info\")public class StudentInfoEntity {     @Id @GeneratedValue(strategy = GenerationType.IDENTITY)     @Column(name=\"stu_seq\") private Long stuSeq;     @Column(name=\"stu_name\") private String stuName;     // @Column(name=\"stu_major_seq\") private Long stuMajorSeq;     @ManyToOne(cascade = CascadeType.PERSIST) @JoinColumn(name=\"stu_major_seq\") private StudentMajorEntity major;}@Test\tvoid addStudent(){\t\tStudentInfoEntity stu = new StudentInfoEntity();\t\tstu.setStuName(\"박학생\");\t\tstu.setMajor(new StudentMajorEntity(null, \"컴퓨터 공학과\")); //Major도 함께 insert됨\t\tstuRepo.save(stu);\t}cascade = CascadeType.PERSIST때문에 가능함. 학과테이블에 중복을 허용하지않아서 이미 있는 값으로 테스트하면 에러남.연계되는 정보를 같이 지정하겠다는 의미setMajor를 할때 student_major테이블에도 자동으로 insert됨cascade = CascadeType.PERSIST를 붙이지 않고도 하려면 테스트코드를 이런식으로짜야함@Test\tvoid addStudent2(){\t\tStudentInfoEntity stu = new StudentInfoEntity();\t\tstu.setStuName(\"최학생\");\t\tstu.setMajor(majorRepo.findById(3L).get()); //Major도 함께 insert됨\t\tstuRepo.save(stu);\t}직접 찾아서 넣겠다는 의미라 cascade가 붙으면 에러남사용자 →(요청)→ 컨트롤러 →(데이터)→ 모델+뷰 → HTML ⇒(응답)⇒ 사용자      session, Model 설명    endpoint        이거말하는거임    영문이아니면 한글자에 길이가 2로 계산하는 시스템도있으니 주의할것                  세션초기화        session.invalidate(); 사용                package com.greenart.testproject.main.controller;      import org.springframework.stereotype.Controller;  import org.springframework.ui.Model;  import org.springframework.web.bind.annotation.GetMapping;      import jakarta.servlet.http.HttpSession;      @Controller  public class MainController {       @GetMapping(\"/\")       public String getMain(Model model, HttpSession session){            //Model - 데이터를 실어나르는 박스(데이터 컨텍스트)            model.addAttribute(\"hello\", \"Hello World!!\");            //웹페이지 파일이 로드되기전에 생성됨            session.setAttribute(\"sessionValue\", \"세션에 추가된 값\");            //백엔드 시스템에서, 세션무효화를 실행했을때 세션을 다시만든다.                return \"/index\";       }           @GetMapping(\"/index\")       public String getIndex(Model model){            model.addAttribute(\"hello\", \"@GetMapping(\\\"index\\\")를 통한 응답\");            return \"/index\";       }       @GetMapping(\"/invalidate\")       public String getInvalidate(HttpSession session){            session.invalidate(); //세션 초기화            return \"redirect:/index\";            //index는 endpoint에서 찾음       }  }        엔티티에 기본키값이 설정되어있다면 save를 했을때 업데이트로 적용됨          회원탈퇴          &lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;       &lt;meta charset=\"UTF-8\"&gt;       &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;       &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;       &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;       &lt;h1&gt;회원탈퇴&lt;/h1&gt;       &lt;h2 style=\"color: red;\"&gt;정말 탈퇴하시겠습니까?&lt;/h2&gt;       &lt;form action=\"member/leave\" method=\"post\" id=\"leave_form\"&gt;            &lt;input type=\"checkbox\" id=\"agree\"&gt;            &lt;label for=\"agree\"&gt;회원탈퇴시 발생하는 손해에대해서 책임지겠습니다.&lt;/label&gt;            &lt;button id=\"leave\"&gt;회원탈퇴&lt;/button&gt;            &lt;a href=\"/\"&gt;메인으로&lt;/a&gt;       &lt;/form&gt;       &lt;script&gt;            document.getElementById(\"leave\").addEventListener(\"click\", function(e){                 e.preventDefault();                 if(!document.getElementById(\"agree\").checked){                      alert(\"체크박스에 체크를 해주셔야 탈퇴 진행이 가능합니다.\")                      return;                 }                 if(confirm(\"진짜 탈퇴하시겠습니까?\")){                      alert(\"탈퇴\");                      document.getElementById(\"leave_Form\").submit();                 }            })       &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;        스크립트를 써야 탈퇴 메세지창이 뜸      package com.greenart.testproject.main.repository;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.greenart.testproject.main.entity.User;      @Repository  public interface UserRepository extends JpaRepository&lt;User, Long&gt; {       Integer countByUserId(String userId);       public User findByUserIdAndUserPwd(String userId, String userPwd);       //delete from user_info where user_id = 'user_id'       public void deleteByUserId(String UserId);  }                      서버 여는 코드(SQL)        use mysql;        create user ‘root’@’%’ identified by ‘1234’;        grant all privileges on . to ‘root’@’%’;        flush privileges;              히스토리 테이블은 서비스가 정상 작동하는것을 확인한 후에 독립적인 테이블을 만들어주면됨    (FK없이 순수데이터로만 들어가야함)  "
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 엔티티 매핑",
    "url": "/posts/%EC%97%94%ED%8B%B0%ED%8B%B0_%EB%A7%A4%ED%95%91/",
    "categories": "JPA",
    "tags": "jpa, 김영한자바ORM표준JPA, ORM",
    "date": "2022-12-26 00:00:00 +0900",
    





    
    "snippet": "객체와 테이블 매핑  객체와 테이블 매핑          @Entity                  JPA가 관리          기본 생성자 필수(파라미터가 없는 public 또는 protected생성자)          final 클래스, enum, interface, inner 클래스 사용 x          저장할 필드에 final 사용 x ...",
    "content": "객체와 테이블 매핑  객체와 테이블 매핑          @Entity                  JPA가 관리          기본 생성자 필수(파라미터가 없는 public 또는 protected생성자)          final 클래스, enum, interface, inner 클래스 사용 x          저장할 필드에 final 사용 x                    @Table        필드와 컬럼 매핑 - @Column  기본 키 매핑 - @Id  연관관계 매핑 - @ManyToOne, @JoinColumn      데이터베이스 스키마 자동 생성 (persistence.xml에서 설정)          DDL을 애플리케이션 실행시점에 자동 생성      테이블 중심 → 객체 중심      DB방언을 사용해 DB에 더 적합한 DDL 생성      이미 생성된 DDL은 개발장비에만 사용(운영에 사용 x)      생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용        (entity 클래스 생성 후 실행하면 자동으로 만들어준다는 얘기같음)                                                                              create          기존 테이블 삭제 푸 다시 생성 (drop + create)                          create-drop          create와 같으나 종료시점에서 테이블 drop                          update          변경문만 반영(운영 DB에서는 사용x, 칼럼삭제x)                          vaildate          엔티티와 테이블이 정상 매핑되었는지만 확인                          none          사용x                      이미 운영중인 장비에 create, create-drop, update를 사용하면 대참사 가능성.    개발 초기 - create or update    테스트 서버 - update or vaildate    스테이징, 운영 - vaildate or none    DDL 생성기 : 멤버 변수 위에 @Column(unique=true, length=10)처럼 지정가능, DDL 자동 생성할때만 사용, JPA실행로직에는 영향을 주지않          유니크 제약조건 - @Column(unique=true, length=10)      필수 조건 - @Column(nullable=false, length=10)      필드와 컬럼 매핑  @Column - 컬럼 매핑(그냥 @Column(name=’dd’, nullable=false, columnDefinition=’….’)이런식으로 쓰면됨)          name - 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름      insertable, updatable - 등록, 변경 가능 여부 TRUE              nullable(DDL) - null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시에  not null 제약조건이 붙는다.                    unique(DDL) - @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제  약조건을 걸 때 사용한다.(잘안씀.. 이름이 이상하게나옴 차라리 @table에서 거는게 나음)                    columnDefinition(DDL) - 데이터베이스 컬럼 정보를 직접 줄 수 있다.  ex) varchar(100) default ‘EMPTY’  필드의 자바 타입과 방언 정보를 사용해서 적절한 컬럼 타입 length(DDL) 문자 길이 제약조건, String 타입에만 사용한다. (기본값 255)            precision, scale(DDL) - BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다).  precision은 소수점을 포함한 전체 자 릿수를, scale은 소수의 자릿수다. 참고로 double, float 타입에는 적용되지 않는다. 아주 큰 숫자나 정밀한 소수를 다루어야 할 때만 사용한다.  (기본값 precision=19, scale=2)        @Temporal - 날짜 타입 매핑          TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑(예: 2013–10–11)      TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑(예: 11:11:11)      TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(예: 2013–10–11 11:11:11)        @Enumerated - enum 타입 매핑          EnumType.ORDINAL : enum의 순서를 DB에 저장 - enum에 적은 순서대로 integer값으로 저장. enum의 순서가 꼬이면 대참사 우려(쓰지말것)      EnumType.STRING : enum의 이름을 DB에 저장        @Lob - BLOB, CLOB 매핑            특정 필드를 컬럼에 매핑하지 않음(매핑 무시)      기본키 매핑@Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id ← 이거  IDENTITY - 기본키 생성을 DB에 위임. DB에 insert를 해야 값을 알 수 있있어서 예외로 JPA가 em.persist한 순간 바로 DB에 쿼리를 날려버려서 기본키를 찾아옴!!!  SEQUENCE - 오라클 기본키  TABLE 전략 : 키 전용 테이블을 하나 만들어서 DB 시퀀스를 흉내내는 전략(모든 DB에 적용가능하나 성능이 떨어짐. 잘안씀)package com.kyhpractice.jpap.jpabook.jpashop.jpadomain;import java.time.LocalDateTime;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.EnumType;import javax.persistence.Enumerated;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name=\"ORDERS\")public class Order {    @Id @GeneratedValue    @Column(name=\"ORDER_ID\")    private Long id;    @Column(name=\"MEMBER_ID\")    private Long memberId;    private LocalDateTime orderDate;    @Enumerated(EnumType.STRING)    private OrderStatus status;    public Long getId() {        return this.id;    }    public void setId(Long id) {        this.id = id;    }    public Long getMemberId() {        return this.memberId;    }    public void setMemberId(Long memberId) {        this.memberId = memberId;    }    public LocalDateTime getOrderDate() {        return this.orderDate;    }    public void setOrderDate(LocalDateTime orderDate) {        this.orderDate = orderDate;    }    public OrderStatus getStatus() {        return this.status;    }    public void setStatus(OrderStatus status) {        this.status = status;    }    }위 예제 코드에서 private Long memberId; 부분!! 객체지향스럽지 않음!! Member member로 받아오는것이 정확한것이아닌지??테이블의 외래키를 객체에 그대로 가져오는것이 문제임! 객체 그래프 탐색도 불가능하고 참조가 없으므로 UML도 잘못⇒ 연관관계 매핑"
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 영속성 관리",
    "url": "/posts/%EC%98%81%EC%86%8D%EC%84%B1_%EA%B4%80%EB%A6%AC/",
    "categories": "JPA",
    "tags": "김영한자바ORM표준JPA, jpa, ORM",
    "date": "2022-12-25 00:00:00 +0900",
    





    
    "snippet": "영속성 컨텍스트  JPA를 이해하는데 가장 중요한 용어  “엔티티를 영구 저장하는 환경”  EntityManager.persist(entity) - DB에 저장하는 것이 아니라 영속성 컨텍스트에 저장함  논리적인 개념(눈에보이지 않음)  엔티티 메니저를 통해서 영속성 컨텍스트에 접근  엔티티의 생명주기          비영속(new/transient)...",
    "content": "영속성 컨텍스트  JPA를 이해하는데 가장 중요한 용어  “엔티티를 영구 저장하는 환경”  EntityManager.persist(entity) - DB에 저장하는 것이 아니라 영속성 컨텍스트에 저장함  논리적인 개념(눈에보이지 않음)  엔티티 메니저를 통해서 영속성 컨텍스트에 접근  엔티티의 생명주기          비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 - em.persist 하기 전 entity      영속(managed) : 영속성 컨텍스트에 관리되는 상태 - em.persist 한 상태 or em.find한 상(DB저장상태아님. 1차 캐시에 저장된상태)      준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태. 영속성 컨텍스트가 제공하는 기능을 사용하지 못함.(더이상 JPA가 관리하지 않음.)                  em.detach(entity) : 특정 엔티티만 준영속 상태로 전환.          em.clear() : 영속성 컨텍스트를 완전히 초기화          em.close() : 영속성 컨텍스트를 종                    삭제(removed) : 삭제된 상태 - em.remove(entity)      → em.persist단계에서 entity가 1차캐시에 저장됨. 이후 조회할때 DB접근 필요없이 1차캐시만 조회하면 되서 효율적임. 그러나 1차캐시에서 찾지못한다면 DB를 조회해서 1차캐시를 재로딩?함이렇게 1차캐시에서 조회해오기때문에 각 두 변수에 같은 조건으로 조회를 한다면 동일성 비교를 했을때 true가 나옴em.persist(entity)를 하면 1차 캐시에 entity가 저장되고 insert SQL이 쓰기지연 저장소에 저장됨 → 이 후 transaction.commit()을 하면 DB에 쓰기지연 저장소에 저장되어있던 SQL문이 flush됨위 처럼 수정해주면 변경 값을 DB에 자동으로 수정해줌. 변경감지기능이 있어서 따로 DB를 수정해줄 필요가 없음!!! 1차 캐시에서 entity의 초기값을 스냅샷으로 저장해뒀다가 스냅샷과 entity를 비교해서 다른게 있다면 DB를 수정함. 삭제도 마찬가지로 1차캐시에서 지워지면 DB도 지워짐  플러시 : 영속성 컨텍스트의 변경내용(쓰기지연 저장소)을 데이터베이스에 반영(DB 바로 반영)          em.flush() - 직접 호출      트랜잭션 커밋 - 플러시 자동 호출      JPQL 쿼리 실행 - 플러시 자동 호출(DB반영 안된상태에서 SQL문을 날리면 오류발생가능성있음)      영속성 컨텍스트를 비우지는 않음      영속성 컨텍스트의 변경내용을 DB에 동기화      트랜잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화하면      ❗1차캐시는 고객이 10명이 접속하면 10개가 생김. 성능상 이점이 그렇게 크지는 않"
  },
  
  {
    "title": "[김영한 자바 ORM 표준 JPA] 설정",
    "url": "/posts/%EC%84%A4%EC%A0%95/",
    "categories": "JPA",
    "tags": "김영한자바ORM표준JPA, jpa, ORM",
    "date": "2022-12-23 00:00:00 +0900",
    





    
    "snippet": "maven을 이용한 강의.수업시간에 gradle을 사용하였으나 강사님의 댓글을 보니 실무에서는 maven도 활용할 줄 아는 것이 더 좋다고 해서 (gradle로 설정하기엔 너무 까다롭고, spring이 들어오면 다 해결될 문제라고 하심)일단 maven으로 따라해보려고 한다.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;...",
    "content": "maven을 이용한 강의.수업시간에 gradle을 사용하였으나 강사님의 댓글을 보니 실무에서는 maven도 활용할 줄 아는 것이 더 좋다고 해서 (gradle로 설정하기엔 너무 까다롭고, spring이 들어오면 다 해결될 문제라고 하심)일단 maven으로 따라해보려고 한다.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;groupId&gt;jpa-basic&lt;/groupId&gt;\t&lt;artifactId&gt;ex1-hello-jpa&lt;/artifactId&gt;\t&lt;version&gt;1.0.0&lt;/version&gt;\t&lt;dependencies&gt;\t\t&lt;!-- JPA 하이버네이트 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.hibernate&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;\t\t\t&lt;version&gt;5.3.10.Final&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- H2 데이터베이스 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.h2database&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;h2&lt;/artifactId&gt;\t\t\t&lt;version&gt;1.4.199&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- 실행했더니 작동하지 않아서 구글링 후 추가해줌 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;\t\t\t&lt;version&gt;2.3.0&lt;/version&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;&lt;/project&gt;resources폴더 - META-INF 속에 persistence파일 생성&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence version=\"2.2\" xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\"&gt;    &lt;persistence-unit name=\"hello\"&gt;        &lt;properties&gt;            &lt;!-- 필수 속성 --&gt;            &lt;property name=\"javax.persistence.jdbc.driver\" value=\"org.h2.Driver\" /&gt;            &lt;property name=\"javax.persistence.jdbc.user\" value=\"sa\" /&gt;            &lt;property name=\"javax.persistence.jdbc.password\" value=\"\" /&gt;            &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:h2:tcp://localhost/~/test\" /&gt;            &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.H2Dialect\" /&gt;            &lt;!-- 옵션 --&gt;            &lt;property name=\"hibernate.show_sql\" value=\"true\" /&gt;            &lt;property name=\"hibernate.format_sql\" value=\"true\" /&gt;            &lt;property name=\"hibernate.use_sql_comments\" value=\"true\" /&gt;            &lt;!--&lt;property name=\"hibernate.hbm2ddl.auto\" value=\"create\" /&gt;--&gt;        &lt;/properties&gt;    &lt;/persistence-unit&gt;&lt;/persistence&gt;데이터베이스 생성 후 entity 매핑을 해주고package com.kyhJPA.practice;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JpaMain {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");        EntityManager em = emf.createEntityManager();        Member member = new Member();        EntityTransaction tx = em.getTransaction();        tx.begin();        member.setId(1L);        member.setName(\"helloA\");        em.persist(member);        tx.commit();        em.close();        emf.close();    }}아래 코드를 실행하면 데이터 베이스에 저장됨실행 후 터미널에 뜬 sql문.package com.kyhJPA.practice;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JpaMain {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");        EntityManager em = emf.createEntityManager();                EntityTransaction tx = em.getTransaction();        tx.begin();        try{            Member member = new Member();            member.setId(2L);            member.setName(\"helloB\");            em.persist(member);            tx.commit();        }catch(Exception e){            tx.rollback();        }finally{            em.close();        }        emf.close();    }}정석적인 코드이나 스프링이 대신해주기때문에 작성할 필요없음]]조회업데이트❗ 주의 사항  엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유  엔티티 매니저는 쓰레드 간의 공유x (사용하고 버려야함)  JPA의 모든 데이터 변경은 트랜잭션 안에서 실JPQL  엔티티 객체를 대상으로 쿼리  SQL은 데이터베이스 테이블을 대상으로 쿼리 = 객체지향 쿼리"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 기본편] 객체지향 설계",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리기본편",
    "date": "2022-12-21 00:00:00 +0900",
    





    
    "snippet": "  비즈니스 요구사항과 설계          회원                              회원을 가입하고 조회할 수 있다.  회원은 일반과 VIP 두 가지 등급이 있다.                    회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)                      주문과 할인...",
    "content": "  비즈니스 요구사항과 설계          회원                              회원을 가입하고 조회할 수 있다.  회원은 일반과 VIP 두 가지 등급이 있다.                    회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)                      주문과 할인 정책  회원은 상품을 주문할 수 있다.  회원 등급에 따라 할인 정책을 적용할 수 있다.                    할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)          할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)                    순수 자바 코드 구현package com.hello.core.Member;public enum Grade {    BASIC,    VIP}package com.hello.core.Member;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Member {    private Long id;    private String name;    private Grade grade;}package com.hello.core.Member;public interface MemberRepository {    void save(Member member);    Member findById(Long memberid);}package com.hello.core.Member;import java.util.HashMap;import java.util.Map;public class MemoryMemberRepository implements MemberRepository {    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();    //Hash맵을 사용하면 동시성 이유발생 위험 있음. 콘커러테이션맵?을 쓰라고함    @Override    public void save(Member member) {        store.put(member.getId(), member);    }    @Override    public Member findById(Long memberid) {        return store.get(memberid);    }    }package com.hello.core.Member;public interface MemberService {        void join(Member member);    Member findMember(Long memberId);}package com.hello.core.Member;// impl = 구현체가 하나만있을때 관례로 많이 쓰임public class MemberServiceImpl implements MemberService{    private MemberRepository memberRepository = new MemoryMemberRepository();    @Override    public void join(Member member) {        memberRepository.save(member);//MemoryMemberRepository의 save가 호출됨    }    @Override    public Member findMember(Long memberId) {        return memberRepository.findById(memberId); //MemoryMemberRepository의 findById가 호출    }    }package com.hello.core;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;public class MemberApp {    public static void main(String[] args) {        MemberService mService = new MemberServiceImpl();        Member member = new Member(1L,\"MemberA\",Grade.VIP);        mService.join(member);        System.out.println(mService.findMember(1L));        System.out.println(member);        // 순수 자바 코드 구현방법            }}의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음. → 주문까지 만들고나서 해결방안 설명= MemberRepository는 인터페이스에 의존하지만 MemoryMemberRepository(실제 할당하는 부분)는 구현체를 의존관심사 분리해결방법package com.hello.core.order;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.FixdiscountPolicy;public class Appconfig {    public MemberService memberService(){ //생성자 주입        return new MemberServiceImpl(new MemoryMemberRepository());    }    public OrderService orderService(){        return new OrderServiceImpl(new MemoryMemberRepository(), new FixdiscountPolicy());    }}package com.hello.core.member;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.order.Appconfig;public class MemberServiceTest {    MemberService mService;        @BeforeEach //각 테스트 실행 전 무조건 실행되는 테스트    public void BeforeEach(){        Appconfig a = new Appconfig();        mService = a.memberService();    }    @Test    void join(){        Member member = new Member(1L, \"MemberA\", Grade.VIP);        mService.join(member);        Member findMember = mService.findMember(1L);        Assertions.assertThat(member).isEqualTo(findMember);    }}package com.hello.core;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;import com.hello.core.order.Appconfig;public class MemberApp {    public static void main(String[] args) {        Appconfig appconfig = new Appconfig();        // MemberService mService = new MemberServiceImpl(null);        MemberService mService = appconfig.memberService();        Member member = new Member(1L,\"MemberA\",Grade.VIP);        mService.join(member);        System.out.println(mService.findMember(1L));        System.out.println(member);        // 순수 자바 코드 구현방법            }}package com.hello.core.order;import com.hello.core.Member.Member;import com.hello.core.Member.MemberRepository;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.FixdiscountPolicy;import com.hello.core.discount.RateDiscountPolicy;public class OrderServiceImpl implements OrderService {    // private final MemberRepository memberRepository = new MemoryMemberRepository();    // private final DiscountPolicy discountPolicy = new FixdiscountPolicy();    //만약 할인 정책이 변경된다면 new FixdiscountPolicy()만 고쳐주면 전체 변경 가능    // private final DiscountPolicy discountPolicy = new RateDiscountPolicy();    //그러나 이 방식은 RateDicountPolicy에도 의존중인 상태로 DIP위반    //코드를 바꿔줘야한다는 자체가 OCP 위반임.    //인터페이스에만 의존하도록 의존관계를 변경해야함.        private DiscountPolicy discountPolicy; //인터페이스에만 의존중임. 그러나 이대로면 NullPointerException 발생    private final MemberRepository memberRepository;    //OrderServiceImlp에 구현객체를 대신 생성해주어야함    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy){        this.discountPolicy = discountPolicy;        this.memberRepository = memberRepository;    }    @Override    public Order createOrder(Long memberId, String itemName, int itemPrice) {        Member member = memberRepository.findById(memberId);        int discountPrice = discountPolicy.discount(member, itemPrice);        return new Order(memberId, itemName, itemPrice, discountPrice);    }}이런식으로 작성해주어야함선생님께서 너무 좋은 강의이나 실무에서 이런 객체 지향적인 설계를 실제로 구현하기가 꽤나 까다롭다고..하시면서 실무관련 강의를 먼저 듣는것도 좋은방법이라고 말씀해주셨다..!이쪽이 더 기초 이론쪽 로드맵인거같아서 들었는데 실무관련 로드맵 부터 완성해보기로 했다AppConfig 리팩터링중복이있고 역할에 따른 구현이 잘 안보인다는 문제가 있음이런 구조가 되어야함.package com.hello.core;import com.hello.core.Member.MemberRepository;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.FixdiscountPolicy;import com.hello.core.order.OrderService;import com.hello.core.order.OrderServiceImpl;public class Appconfig {    public MemberService memberService(){ //생성자 주입        return new MemberServiceImpl(memberRepository());    }    private MemberRepository memberRepository(){        return new MemoryMemberRepository();    }    // public MemberService memberService(){ //생성자 주입    //     return new MemberServiceImpl(new MemoryMemberRepository());    // } //아래와 중복코드가 있음. new MemoryMemberRepository부분. 위의 코드로 수정해줌    public OrderService orderService(){        return new OrderServiceImpl(memberRepository(), discountPolicy());    }    public DiscountPolicy discountPolicy(){        return new FixdiscountPolicy();    } //할인정책도 메소드를 만들어줌}수정한 Appconfig. 이렇게하면 메소드명으로 역할 구분이 가능해짐새로운 구조와 할인정책 적용현재 사용영역과 구성 영역이 분리되어있음구성영역만 고치면 됨package com.hello.core;import com.hello.core.Member.MemberRepository;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.RateDiscountPolicyimport com.hello.core.discount.RateDiscountPolicy;;import com.hello.core.order.OrderService;import com.hello.core.order.OrderServiceImpl;public class Appconfig {    public MemberService memberService(){ //생성자 주입        return new MemberServiceImpl(memberRepository());    }    private MemberRepository memberRepository(){        return new MemoryMemberRepository();    }    // public MemberService memberService(){ //생성자 주입    //     return new MemberServiceImpl(new MemoryMemberRepository());    // } //아래와 중복코드가 있음. new MemoryMemberRepository부분. 위의 코드로 수정해줌    public OrderService orderService(){        return new OrderServiceImpl(memberRepository(), discountPolicy());    }    public DiscountPolicy discountPolicy(){        // return new FixdiscountPolicy();        return new RateDiscountPolicy();    } //할인정책도 메소드를 만들어줌}discountPolicy에서 return만 달라짐IoC(Inversion of Control) : 제어의 역전내가 호출하는 것이 아니라 프레임워키가 대신 호출해주는 것.위 예시에서 Appconfig 등장 이후 구현 객체는 실행만 담당함. 프로그램 제어 흐름은 Appconfig가 가져감.프로그램의 제어 흐름을 외부에서 관리하는 것을 IoC라고 함.  프레임워크 vs 라이브러리          프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 프레임워크 맞음(JUnit)      내가 작성한 코드가 직접 제어의 흐름을 담당한다면 프레임워크가 아니라 라이브러리임      DI(Dependency Injection) : 의존관계 주입위 예시에서 OrderServiceImpl은 DiscountPolicy 인터페이스만 알고있지 DiscountPolicy의 어떤 구현체(FixDiscountPolicy, RateDiscountPolicy)가 들어올지는 알고있지 않음!!  정적인 의존관계          클래스가 사용하는 inport코드만 보고 의존관계를 쉽게 판단 가능함      애플리케이션을 실행하지 않아도 분석가능함      OrderServiceImpl을 보면 OrderService가 상위 인테페이스인것을 알 수 있고 MemberRepository와 DiscountPolicy를 참고하고있음을 알 수 있음        동적인 의존관계          애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계임      애플리케이션을 실행하지 않으면 어떤 객체가 OrderServiceImpl에 주입될지는 알 수 없음        결론          실행시점(런타임)에 외부에서 실제 구현객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라함      객체 인스턴스를 생성해서 그 참조값을 전달해서 연결함      클라이언트코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경 가능함      정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경가능함      컨테이너AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것 → IoC컨테이너 또는 DI컨테이너라고 부름의존관계 주입에 초점을 맞춰서 요즘은 주로 DI컨테이너라고 함. 아샘블러, 오브젝트 팩토리 등으로 불리기도함스프링으로 변경  AppConfig : 설정정보package com.hello.core;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.hello.core.Member.MemberRepository;import com.hello.core.Member.MemberService;import com.hello.core.Member.MemberServiceImpl;import com.hello.core.Member.MemoryMemberRepository;import com.hello.core.discount.DiscountPolicy;import com.hello.core.discount.RateDiscountPolicy;import com.hello.core.order.OrderService;import com.hello.core.order.OrderServiceImpl;@Configurationpublic class Appconfig {    @Bean    public MemberService memberService(){ //생성자 주입        return new MemberServiceImpl(memberRepository());    }    @Bean    private MemberRepository memberRepository(){        return new MemoryMemberRepository();    }    // public MemberService memberService(){ //생성자 주입    //     return new MemberServiceImpl(new MemoryMemberRepository());    // } //아래와 중복코드가 있음. new MemoryMemberRepository부분. 위의 코드로 수정해줌    @Bean    public OrderService orderService(){        return new OrderServiceImpl(memberRepository(), discountPolicy());    }    @Bean    public DiscountPolicy discountPolicy(){        // return new FixdiscountPolicy();        return new RateDiscountPolicy();    } //할인정책도 메소드를 만들어줌}이렇게하면 스프링컨테이너에 들어감@Bean이 붙을 메소드는 모두 public이여야함. 아니면 컴파일 오류남.  MemberApppackage com.hello.core;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;public class MemberApp {    public static void main(String[] args) {        // Appconfig appconfig = new Appconfig();        // MemberService mService = appconfig.memberService();        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);        MemberService mService = applicationContext.getBean(\"memberService\", MemberService.class); //일치하는 메소드 이름을 찾아내서 가져옴        Member member = new Member(1L,\"MemberA\",Grade.VIP);        mService.join(member);        System.out.println(mService.findMember(1L));        System.out.println(member);        // 순수 자바 코드 구현방법            }}  OrderApppackage com.hello.core.order;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.hello.core.Appconfig;import com.hello.core.Member.Grade;import com.hello.core.Member.Member;import com.hello.core.Member.MemberService;public class OrderApp {    public static void main(String[] args) {        // Appconfig a = new Appconfig();        // MemberService memberService = a.memberService();        // OrderService orderService = a.orderService();        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);        MemberService memberService = applicationContext.getBean(\"memberService\", MemberService.class);        OrderService orderService = applicationContext.getBean(\"orderService\", OrderService.class);        Long memberid = 1L;        Member member = new Member(memberid, \"memberA\", Grade.VIP);        memberService.join(member);        Order order = orderService.createOrder(memberid, \"itemA\", 10000);        System.out.println(order);        System.out.println(order.calculatePrice());    }}"
  },
  
  {
    "title": "[김영한 스프링 핵심원리 기본편] 객체지향 설계와 스프링",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84%EC%99%80_%EC%8A%A4%ED%94%84%EB%A7%81/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링핵심원리기본편",
    "date": "2022-12-20 00:00:00 +0900",
    





    
    "snippet": "스프링 - 여러가지 기술의 모음배치처리 : 실무에서 많은 데이터를 업데이트해야할경우 일부만 먼저처리하고 저장하고 다시 일부를 처리하고 저장하기를 반복함. 스프링배치가 이것을 효율적으로 할수있게 도와줌스프링부트- 다른기능을 편리하게 사용할수있게 도와주는 기술이라 제체적으로는 별기능이없음.스프링은 객체지향 언어가 가진 특징을 살려낼수있는 프레임워크임. 클...",
    "content": "스프링 - 여러가지 기술의 모음배치처리 : 실무에서 많은 데이터를 업데이트해야할경우 일부만 먼저처리하고 저장하고 다시 일부를 처리하고 저장하기를 반복함. 스프링배치가 이것을 효율적으로 할수있게 도와줌스프링부트- 다른기능을 편리하게 사용할수있게 도와주는 기술이라 제체적으로는 별기능이없음.스프링은 객체지향 언어가 가진 특징을 살려낼수있는 프레임워크임. 클라이언트를 변경하지않고, 서버의 구현기능을 유연하게 변경 가      SOLID : 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리          SRP : 단일 책임 원칙(single responsibility principle)                  한 클래스는 하나의 책임만 가져야한다.          하나의 책임이라는 것은 모호하다                          클수있고, 작을수있다.              문맥과 상황에 따라 다르다                                중요한 기능은 변경이다. 변경이있을때 파급효과가 적으면 단일책임 원칙을 잘 따른것          예) UI변경, 객체의 생성과 사용을 분                            OCP : 개방-폐쇄 원칙(Open/closed principle)                  소프트 웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다                → 다형성 활용.                  인터페이스를 구현한 새로운 클래스를 하나 만들어 새로운 기능을 구현          역할과 구현의 분리를 생각해볼것          문제점                                          구현 객체를 변경하려면 클라이언트 코드를 변경해야함.  MemberRepository m = new MemoryMemberRepository(); (변경전)  MemberRepository m = new JdbcMemberRepository(); (변경)                                            다형성을 사용했지만 OCP원칙을 지킬수 없음(코드를 변경해야함)                ⇒객체를 생성, 연관관계를 맺어주는 별도의 조립, 생성자가 필요(스프링 컨테이너)                                                        LSP : 리코스트 치환원칙 (Liskov substitution principle)                  프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야한다.          다영성에서 하위 클래스는 인터페이스 규약을 다 지켜야한다는 것, 다형성을 지원하기 위한 원칙. 인터페이스를 구현한 구현체를 믿고 사용하려면 필요한 원칙          단순히 컴파일을 넘어서는 이야기          예) 자동차의 엑셀을 밟았을때 뒤로가는 것은 LSP위반. 느리더라도 앞으로 가야                    ISP : 인터페이스 분리 원칙 (Interface segregation principle)                  특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다          자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리          사용자 클라리언트 → 운전자 클라이언트, 정비사 클라이언트로 분리          분리하면정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.          인터페이스가 명확해지고 대체가능성이 높아진다.                    DIP : 의존관계 역전 원칙 (Dependency inversion principle)                              프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.            = 클라이언트 코드가 구현클래스말고 인터페이스만 보라는 의미                    쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻          앞에서 얘기한 역할(Role)에 의존하게 해야한다는 것과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게되면 변경이 아주 어려워진다.          그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만 구현클래스도 동시에 의존함                      MemberService 클라이언트가 구현클래스를 직접 선택함  MemberRepository m = new  MemoryMemberRepository();            ⇒ DIP 위반(구체화에도 의존중임)                                — 다형성만으로는 OCP, DIP를 지킬 수 없음  ⇒ 스프링 컨테이너 필요(이상적으로는 모든 설계에 인터페이스를 부여해야하나 추상화라는 비용이 발생함)    기능 확장 가능성이 없다면 구체 클래스를 직접 사용하고 향후 꼭 필요할 때 리팩터링해서 인터페이스 도입하는것도 하나의 방법    토비의 스프링 강의 듣고 한번 보는것을 추천  "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] jpql",
    "url": "/posts/jpql/",
    "categories": "Spring",
    "tags": "spring, jqpl, ORM, 국비교육",
    "date": "2022-12-16 00:00:00 +0900",
    





    
    "snippet": "  sql문 지정방법 - @Query 어노테이션 사용(오타가 하나라도 있으면 리포지토리가 생성이 안됨)package com.nunnunnu.jpql.entity;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;imp...",
    "content": "  sql문 지정방법 - @Query 어노테이션 사용(오타가 하나라도 있으면 리포지토리가 생성이 안됨)package com.nunnunnu.jpql.entity;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity@Table(name=\"category_info\") //이렇게해야 @Query에서 클래스 이름으로 쿼리문 사용가능public class CategoryEntity {    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name=\"ci_seq\")  private Long ciSeq;    @Column(name=\"ci_name\") private String ciName;    }package com.nunnunnu.jpql.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;import com.nunnunnu.jpql.entity.CategoryEntity;@Repositorypublic interface CategoryRepository extends JpaRepository&lt;CategoryEntity, Long&gt; {    @Query(value = \"SELECT c.ciSeq FROM CategoryEntity c WHERE c.ciName LIKE %:key%\")    List&lt;Long&gt; selectCategoryByKeyword(@Param(\"key\") String keyword);        @Query(value = \"SELECT c from CategoryEntity c where c.ciName like %:key%\")    public List&lt;CategoryEntity&gt; selectCategoryNameLikeKeyword(@Param(\"key\") String keyword);}      화이트 리스트 설정(프론트와 작업시 필요) - 아래 코드는 프론트만 허용하는 것이아니라 모두를 허용하겠다는 것이라 실제로는 이렇게하면안됨        cors 해결      package com.green.flo.config;      import org.springframework.context.annotation.Configuration;  import org.springframework.web.servlet.config.annotation.CorsRegistry;  import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;      @Configuration  public class WebConfig implements WebMvcConfigurer {       @Override       public void addCorsMappings(CorsRegistry registry){            registry.addMapping(\"/**\") //모든 매핑 경로에 대해(특정 메핑만 허용이면 /api/* 이런식으로 적어주면됨)            .allowedOrigins(\"*\") //모든 사용자에 대해 (특정아이피만 허용이면 여기 아이피넣으면됨)            .allowedMethods(\"*\"); //GET, POST, PUT, DELETE, PATCH, OPTION 모든 메소드를 허용함.       }  }      "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] JPA2",
    "url": "/posts/green_jpa2/",
    "categories": "JPA",
    "tags": "jpa, 국비교육, spring, ORM",
    "date": "2022-12-13 00:00:00 +0900",
    





    
    "snippet": "— API명세서 작성  회원 정보 조회시 비밀번호 빼고 조회하는 법package com.green.jpa_test.member.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Generate...",
    "content": "— API명세서 작성  회원 정보 조회시 비밀번호 빼고 조회하는 법package com.green.jpa_test.member.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import com.fasterxml.jackson.annotation.JsonIgnore;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.annotation.JsonProperty;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity(name = \"member_info\")@JsonIgnoreProperties(    value = {\"pwd\"}, allowSetters = true, allowGetters = false //setter는 권한허용, getter는 권한비허용.     //불러올때는 비번안나온다는소리)public class MemberInfoVO {    //jpa가 _는 제대로 인식을 못함    //mi_seq;mi_id;mi_pwd;mi_name;mi_nickname;mi_reg_dt;mi_status    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) //MYSQL의 AUTO_INCREMENT    @Column(name=\"mi_seq\") //기본키의 이름이 mi_seq임    private Long seq;         @Column(name=\"mi_id\")    private String id;    // @JsonIgnore //json형식으로 내보낼때 빠져서 나오나 입력할때도 빼고입력해야해서 적절하지않음    @JsonProperty(\"pwd\")    @Column(name=\"mi_pwd\")    private String pwd;    @Column(name=\"mi_name\")    private String name;    @Column(name=\"mi_nickname\")    private String nickname;    @Column(name=\"mi_reg_dt\")    private Date regDt;    @Column(name=\"mi_status\")    private Integer status;}      제품등록      package com.green.jpa_test.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name=\"product_info\")  public class ProductInfoVo {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"pi_seq\")      private Integer seq;          @Column(name=\"pi_name\")      private String name;      @Column(name=\"pi_price\")      private Integer price;      @Column(name=\"pi_discount\")      private Double discount;      @Column(name=\"pi_reg_dt\")      private Date regDt;      @Column(name=\"pi_status\")      private Integer stauts;      @Column(name=\"pi_stock\")      private Integer stock;  }          package com.green.jpa_test.repository;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.green.jpa_test.entity.ProductInfoVo;      @Repository  public interface ProductRepository extends JpaRepository&lt;ProductInfoVo, Long&gt; {      // public Long countByName(String name);  }          @Test  \t@Transactional  \tpublic void productAdd(){  \t\tProductInfoVo p = new ProductInfoVo();  \t\tp.setName(\"제품명\");  \t\tp.setPrice(15000);  \t\tp.setDiscount(0.0);  \t\tp.setRegDt(new Date());  \t\tp.setStauts(1);  \t\tp.setStock(100);  \t\tprodRepo.save(p);  \t}  \t// @Test  \t// public void nameDupChkTest(){  \t// \tLong cnt = prodRepo.countByName(\"제품명\");  \t// \tassertEquals(cnt, 1);  \t// } //제품이름은 동일할수도있음          package com.green.jpa_test.api;      import java.util.LinkedHashMap;  import java.util.Map;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.http.ResponseEntity;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PutMapping;  import org.springframework.web.bind.annotation.RequestBody;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RestController;      import com.green.jpa_test.entity.ProductInfoVo;  import com.green.jpa_test.repository.ProductRepository;      @RestController  @RequestMapping(\"/api/product\")  public class ProductAPICountroller {          @Autowired ProductRepository prodRepo;          @PutMapping(\"/\")      public ResponseEntity&lt;Object&gt; addProduct(@RequestBody ProductInfoVo data){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          // if(prodRepo.countByName(data.getName())==1){          //     map.put(\"status\", false);          //     map.put(\"message\", data.getName()+\"가 이미 등록되었습니다.\");          //     return new ResponseEntity&lt;&gt;(map, HttpStatus.NOT_ACCEPTABLE);          // }          prodRepo.save(data);          map.put(\"status\", true);          map.put(\"message\", \"제품이 등록되었습니다.\");          return new ResponseEntity&lt;&gt;(map, HttpStatus.OK);      }  }        ]]        페이지기능      package com.green.jpa_test.repository;      import java.util.List;      import org.springframework.data.domain.Page;  import org.springframework.data.domain.Pageable;  import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.green.jpa_test.entity.ProductInfoVo;      @Repository  public interface ProductRepository extends JpaRepository&lt;ProductInfoVo, Long&gt; {      // public Long countByName(String name);      // public List&lt;ProductInfoVo&gt; findAll(); //DB안의 데이터 모두 조회 가능      public Page&lt;ProductInfoVo&gt; findAll(Pageable pageable);  }          @GetMapping(\"/list\")      public ResponseEntity&lt;Object&gt; getProductList(Pageable pageable){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();                      map.put(\"list\", prodRepo.findAll(pageable));              return new ResponseEntity&lt;&gt;(map, HttpStatus.OK);      }            http://localhost:8999/api/product/list?page=0&amp;size=10&amp;sort=seq,desc    1페이지 10개, 최신등록순 정렬        로그인      package com.green.jpa_test.member.vo;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  public class LoginVO {      private String id;      private String pwd;  }          package com.green.jpa_test.member.repository;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.green.jpa_test.member.entity.MemberInfoVO;      @Repository  public interface MemberRepository extends JpaRepository&lt;MemberInfoVO, Long&gt; { //repository의 기본키 값이 Long이라 Long을 넣음      // MemberInfoVO findById(String id);      public Long countById(String id); //select count(*) from member_info where mi_id = \"\"; 자동생성해줌.       //이미 만들어진것은 커스텀하기까다로움      public MemberInfoVO findByIdAndPwd(String id, String pwd); //0아니면 1로 값이 나옴.      //member_info db의 id, pwd를 조회함. findByMi_IdAndMi_Pwd를 spring이 인식하기 못하기때문에 MemberInfo에서 이름지정을 해줌  }          @PostMapping(\"/login\")      public ResponseEntity&lt;Object&gt; userLogin(@RequestBody LoginVO data){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          MemberInfoVO loginUser = repo.findByIdAndPwd(data.getId(),data.getPwd());          if(loginUser ==null){              map.put(\"status\", false);              map.put(\"message\", \"아이디 또는 비밀번호 오류입니다.\");              return new ResponseEntity&lt;&gt;(map, HttpStatus.UNAUTHORIZED);          }          map.put(\"status\", true);          map.put(\"message\", \"로그인 되었습니다.\");          return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);      }          package com.green.jpa_test.member.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import com.fasterxml.jackson.annotation.JsonIgnore;  import com.fasterxml.jackson.annotation.JsonIgnoreProperties;  import com.fasterxml.jackson.annotation.JsonProperty;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name = \"member_info\")  @JsonIgnoreProperties(      value = {\"pwd\"}, allowSetters = true, allowGetters = false //setter는 권한허용, getter는 권한비허용.       //불러올때는 비번안나온다는소리  )  public class MemberInfoVO {      //jpa가 _는 제대로 인식을 못함      //mi_seq;mi_id;mi_pwd;mi_name;mi_nickname;mi_reg_dt;mi_status      @Id @GeneratedValue(strategy=GenerationType.IDENTITY) //MYSQL의 AUTO_INCREMENT      @Column(name=\"mi_seq\") //기본키의 이름이 mi_seq임      private Long seq;               @Column(name=\"mi_id\")      private String id;      // @JsonIgnore //json형식으로 내보낼때 빠져서 나오나 입력할때도 빼고입력해야해서 적절하지않음      @JsonProperty(\"pwd\")      @Column(name=\"mi_pwd\")      private String pwd;      @Column(name=\"mi_name\")      private String name;      @Column(name=\"mi_nickname\")      private String nickname;      @Column(name=\"mi_reg_dt\")      private Date regDt;      @Column(name=\"mi_status\")      private Integer status;  }            한개 조회      @GetMapping(\"/detail\")      public ResponseEntity&lt;Object&gt; getProductDetail(@RequestParam Integer prodNo){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          map.put(\"detail\", prodRepo.findBySeq(prodNo));          return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);      }          @Repository  public interface ProductRepository extends JpaRepository&lt;ProductInfoVo, Long&gt; {      // public Long countByName(String name);      // public List&lt;ProductInfoVo&gt; findAll(); //DB안의 데이터 모두 조회 가능      public Page&lt;ProductInfoVo&gt; findAll(Pageable pageable);      public ProductInfoVo findBySeq(Integer seq);  }            default 지정      \t\t@Column(name=\"pi_name\")      private String name;      @Column(name=\"pi_price\")      private Integer price=0;      @Column(name=\"pi_discount\")      private Double discount=0.0;      @Column(name=\"pi_reg_dt\")      private Date regDt= new Date();      @Column(name=\"pi_status\")      private Integer stauts=1;      @Column(name=\"pi_stock\")      private Integer stock=0;        가장 간단한 방법      package com.green.jpa_test.product.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import org.hibernate.annotations.DynamicInsert;  import org.hibernate.annotations.DynamicUpdate;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name=\"product_info\")  @DynamicInsert  @DynamicUpdate  public class ProductInfoVo {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"pi_seq\")      private Integer seq;          @Column(name=\"pi_name\")      private String name;      @Column(name=\"pi_price\")      private Integer price;//=0;      @Column(name=\"pi_discount\")      private Double discount;//=0.0;      @Column(name=\"pi_reg_dt\")      private Date regDt;//= new Date();      @Column(name=\"pi_status\")      private Integer stauts;//=1;      @Column(name=\"pi_stock\")      private Integer stock;//=0;  }        확실한 방법        제품 삭제      package com.green.jpa_test.product.repository;      import java.util.List;      import org.springframework.data.domain.Page;  import org.springframework.data.domain.Pageable;  import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.green.jpa_test.product.entity.ProductInfoVo;      @Repository  public interface ProductRepository extends JpaRepository&lt;ProductInfoVo, Long&gt; {      // public Long countByName(String name);      // public List&lt;ProductInfoVo&gt; findAll(); //DB안의 데이터 모두 조회 가능      public Page&lt;ProductInfoVo&gt; findAll(Pageable pageable);      public ProductInfoVo findBySeq(Integer seq);      public void deleteBySeq(Integer seq);  }          @DeleteMapping(\"\")      @Transactional  //sql실행시 오류가 발생한다면 실행이전으로 되돌림      public ResponseEntity&lt;Object&gt; deleteProduct(@RequestParam Integer prodNo){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          prodRepo.deleteBySeq(prodNo); //delete from product_info where pi_seq=\"\";          map.put(\"status\", true);          map.put(\"message\", \"제품 정보를 삭제했습니다.\");          return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);  \t  }            제품 수정      package com.green.jpa_test.product.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import org.hibernate.annotations.DynamicInsert;  import org.hibernate.annotations.DynamicUpdate;      import lombok.AllArgsConstructor;  import lombok.Builder;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name=\"product_info\")  @DynamicInsert  @DynamicUpdate  @Builder  public class ProductInfoVo {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"pi_seq\")      private Integer seq;          @Column(name=\"pi_name\")      private String name;      @Column(name=\"pi_price\")      private Integer price;//=0;      @Column(name=\"pi_discount\")      private Double discount;//=0.0;      @Column(name=\"pi_reg_dt\")      private Date regDt;//= new Date();      @Column(name=\"pi_status\")      private Integer stauts;//=1;      @Column(name=\"pi_stock\")      private Integer stock;//=0;  }        Builder 추가    save시 기본값이 없이 세팅되면 insert, 기본값이 있으면 update      @PatchMapping(\"/update/{type}\")      @Transactional  //sql실행시 오류가 발생한다면 실행이전으로 되돌림      public ResponseEntity&lt;Object&gt; updateProduct(          @RequestParam Integer prodNo,           @PathVariable String type,          @RequestParam String value          ){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          ProductInfoVo data = prodRepo.findBySeq(prodNo);          if(data==null){              map.put(\"status\", false);              map.put(\"message\", \"해당 제품이 존재하지 않습니다. 제품번호를 확인해주세요.\");              return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);          }          if(type.equals(\"name\")){               data.setName(value);          }else if(type.equals(\"price\")){              data.setPrice(Integer.parseInt(value));          }else if(type.equals(\"discount\")){              data.setDiscount(Double.parseDouble(value));          }else if(type.equals(\"regDt\")){              SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMddHHmmss\");              try{data.setRegDt(format.parse(value));}              catch(Exception e){e.printStackTrace();}                          }else if(type.equals(\"status\")){              data.setStauts(Integer.parseInt(value));                          }else if(type.equals(\"stock\")){              data.setStock(Integer.parseInt(value));                          }else{              map.put(\"status\", false);              map.put(\"message\", \"타입이 잘못되었습니다. {name, price, discount, regDt}\");              return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);          }          prodRepo.save(data);          map.put(\"status\", true);          map.put(\"message\", \"제품 정보를 수정했습니다.\");          return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);      }        http://localhost:8999/api/product/update/stock?prodNo=44&amp;value=100    주소예시  todolist— rest client 사용법파일 생성 후작성 후 send Request 또는 ctrl+alt+R 누르면이런식으로 뜸— 파일파일 저장 경로(꼭 이렇게해야하는건아니나 이걸 추천)application.properties에서 관리함.파일 경로 지정. 사용자 정의 설정값(여기 주석 #이라서 사진 그대로 쓰면 안됨;;. 주소치고 띄어쓰기해도 오류남.)  파일 업로드 메소드package com.jh_project.todo.todoList.file.api;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;import java.util.LinkedHashMap;import java.util.Map;import javax.servlet.http.HttpServletRequest;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.Resource;import org.springframework.core.io.UrlResource;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestPart;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;@RestControllerpublic class FileAPIController {    // 파일 업로드, 다운로드는 어느 프로젝프든 거의 동일함. 복붙추천    @Value(\"${file.image.todo}\") String todo_img_path; //springframework.beans임    @Value(\"${file.image.member}\") String member_img_path;     //이것도 DI임. 이미지 파일의 경로가 바뀌어도 application.properties만 고쳐주면 됨    @PutMapping(\"/{type}/upload\") //todo이미지를 올릴것인지 file이미지를 올릴것인지    public ResponseEntity&lt;Object&gt; putImageUpload(        @PathVariable String type,        @RequestPart MultipartFile file //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함        ){            Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();            System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력            //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스            Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.            if(type.equals(\"todo\")){                folderLocation = Paths.get(todo_img_path);                            }else if(type.equals(\"member\")){                folderLocation = Paths.get(member_img_path);            }else{                map.put(\"status\", false);                map.put(\"message\", \"타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload\");                return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);            }            Path targerFile = folderLocation.resolve(file.getOriginalFilename()); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성            try{                //Files는 파일 처리에 대한 유틸리티 클래스                //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비                //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.                Files.copy(file.getInputStream(), targerFile, StandardCopyOption.REPLACE_EXISTING);             }catch(Exception e){e.printStackTrace();}            return new ResponseEntity&lt;&gt;(map, HttpStatus.OK);        } //파일 업로드 메소드postman에서 key File로 만들고 file이라고 파라미터 적어주고(메소드의 파라미터 변수명과 동일하게 작성) value에 파일을 첨부 send하면 위에 지정해둔 폴더에 파일이 저장된걸 확인할 수 있음      파일 업로드 수정버전      @PutMapping(\"/{type}/upload\") //todo이미지를 올릴것인지 file이미지를 올릴것인지      public ResponseEntity&lt;Object&gt; putImageUpload(          @PathVariable String type,          @RequestPart MultipartFile file, //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함          @RequestParam Long seq           ){              Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();              System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력              //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스              Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.              if(type.equals(\"todo\")){                  folderLocation = Paths.get(todo_img_path);                                  }else if(type.equals(\"member\")){                  folderLocation = Paths.get(member_img_path);              }else{                  map.put(\"status\", false);                  map.put(\"message\", \"타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload\");                  return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);              }                  String originFileName = file.getOriginalFilename();              String[] split = originFileName.split((\"\\\\.\")); //.을 기준으로 나눔              String ext = split[split.length-1]; //확장자              String fileName = null;              for(int i=0;i&lt;split.length-1;i++){                  fileName += split[i]; //원래 split[i]+\".\" 이렇게 해줘야함              }              String saveFileName = type+\"_\"; //보통 원본 이름을 저장하는것이아니라 시간대를 입력함              Calendar c = Calendar.getInstance();              saveFileName+=c.getTimeInMillis()+\".\"+ext; // todo_161310135.png 이런식으로 저장됨                      Path targerFile = folderLocation.resolve(saveFileName); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성              try{                  //Files는 파일 처리에 대한 유틸리티 클래스                  //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비                  //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.                  Files.copy(file.getInputStream(), targerFile, StandardCopyOption.REPLACE_EXISTING);               }catch(Exception e){e.printStackTrace();}              return new ResponseEntity&lt;&gt;(map, HttpStatus.OK);          } //파일 업로드 메소드           파일이름 member_1671076931157으로 저장됨        url접속시 파일다운 메소드  @GetMapping(\"/image/{filename}\")        public ResponseEntity&lt;Resource&gt; putImageUpload( //core.io.Resource import해야함        @PathVariable String filename, HttpServletRequest request        ){            //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스            Path folderLocation = Paths.get(todo_img_path); //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.            Path targerFile = folderLocation.resolve(filename); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성            //다운로드 가능한 형태로 변환하기 위해 Resource객체 생성함            Resource r = null;             try{                //일반파일 -&gt; Url로 첨부 가능한 형태로 변환                r = new UrlResource(targerFile.toUri());            }catch(Exception e){e.printStackTrace();} //fileNotFoundException이 많이 나옴            //첨부된 파일의 타입을 저장하기 위한 변수 생성            String contentType = null;            try{                //첨부할 파일의 타입정보 산출                contentType =  request.getServletContext().getMimeType(r.getFile().getAbsolutePath());                 if(contentType == null){ //산출한 파일의 타입이 null이면                     //일반 파일로 처리                    contentType = \"application/octet-stream\"; //파일종류에따라서 동작이 다름. 만약 contentType이 안들어오면 그냥 다운로드함.                }            }catch(Exception e){e.printStackTrace();}            return ResponseEntity.ok() // 200 OK가 나옴                .contentType(MediaType.parseMediaType(contentType)) //산출한 타입을 응답에 맞는 형태로 변환                //내보낼 내용의 타입을 설정(파일),                 // attachment; filename*=\\\"\"+r.getFilename()+\"\\\" - 요청한 쪽에서 다운로드한 파일의 이름을 결정(원본 파일 이름 그대로 결정)                .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename*=\\\"\"+r.getFilename()+\"\\\"\")                .body(r); //변환된 파일을 ResponseEntity에 추가        }http://localhost:9988/image/Fj8pPNYaAAAoWja.jpg 아래 주소로 가면 파일 다운됨. 파일이름을 확장자까지 정확하게 써줘야함.      멤버      package com.jh_project.todo.member.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import com.fasterxml.jackson.annotation.JsonIgnoreProperties;  import com.fasterxml.jackson.annotation.JsonProperty;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name = \"member_info\")  @JsonIgnoreProperties(      value = {\"pwd\"}, allowGetters = false, allowSetters = true  )  public class MemberInfoEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name=\"mi_seq\")    private Long seq;          @Column(name=\"mi_email\")  private String email;      @JsonProperty(\"pwd\")      @Column(name=\"mi_pwd\")    private String pwd;      @Column(name=\"mi_name\")   private String name;      @Column(name=\"mi_birth\")  private Date birth;      @Column(name=\"mi_reg_dt\") private Date regDt;  }          package com.jh_project.todo.member.repository;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.jh_project.todo.member.entity.MemberInfoEntity;  @Repository  public interface memberRepository extends JpaRepository&lt;MemberInfoEntity, Long&gt; {      public Integer countByEmail(String email);      public MemberInfoEntity findByEmailAndPwd(String email, String pwd);          }          package com.jh_project.todo.member.data;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  public class LoginVO {      private String email;      private String pwd;      }          package com.jh_project.todo.member.service;      import java.util.LinkedHashMap;  import java.util.Map;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.stereotype.Service;      import com.jh_project.todo.member.data.LoginVO;  import com.jh_project.todo.member.entity.MemberInfoEntity;  import com.jh_project.todo.member.repository.memberRepository;  import com.jh_project.todo.utils.AESAlgorith;      @Service  public class MemberService {      @Autowired memberRepository m_repo;              public Map&lt;String, Object&gt; addMember(MemberInfoEntity data){          Map&lt;String, Object&gt; resultMap = new LinkedHashMap&lt;String, Object&gt;();          if(m_repo.countByEmail(data.getEmail())==1){              resultMap.put(\"status\", false);              resultMap.put(\"message\", data.getEmail()+\"은/는 이미 가입된 이메일입니다.\");              resultMap.put(\"code\", HttpStatus.BAD_REQUEST);          }else{              try{                  String encPwd = AESAlgorith.Encrypt(data.getPwd());                  data.setPwd(encPwd);              }catch(Exception e){e.printStackTrace();}                  resultMap.put(\"status\", true);              resultMap.put(\"message\", \"회원이 등록되었습니다.\");              resultMap.put(\"code\", HttpStatus.CREATED);              m_repo.save(data);          }          return resultMap;      }      public Map&lt;String, Object&gt; loginMember(LoginVO data){          Map&lt;String, Object&gt; resultMap = new LinkedHashMap&lt;String, Object&gt;();          MemberInfoEntity loginUser = null;          try{              loginUser = m_repo.findByEmailAndPwd(data.getEmail(), AESAlgorith.Encrypt(data.getPwd()));          }catch(Exception e){e.printStackTrace();}          if(loginUser==null){              resultMap.put(\"status\", false);              resultMap.put(\"message\", \"로그인 실패. 이메일 또는 비밀번호를 확인해주세요.\");              resultMap.put(\"code\", HttpStatus.BAD_REQUEST);          }else{              resultMap.put(\"status\", true);              resultMap.put(\"message\", \"로그인 성공\");              resultMap.put(\"code\", HttpStatus.ACCEPTED);              resultMap.put(\"loginUser\", loginUser);          }          return resultMap;      }  }          package com.jh_project.todo.member.api;      import java.util.Map;      import javax.servlet.http.HttpSession;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.http.ResponseEntity;  import org.springframework.web.bind.annotation.PostMapping;  import org.springframework.web.bind.annotation.PutMapping;  import org.springframework.web.bind.annotation.RequestBody;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RestController;      import com.jh_project.todo.member.data.LoginVO;  import com.jh_project.todo.member.entity.MemberInfoEntity;  import com.jh_project.todo.member.service.MemberService;      @RestController  @RequestMapping(\"/api/member\")  public class MemberAPIController {      @Autowired MemberService mService;      @PutMapping(\"/join\")      public ResponseEntity&lt;Object&gt; memberJoin(@RequestBody MemberInfoEntity data){          Map&lt;String, Object&gt; resultMap = mService.addMember(data);          return new ResponseEntity&lt;Object&gt;(resultMap, (HttpStatus)resultMap.get(\"code\"));      }      @PostMapping(\"/login\")      public ResponseEntity&lt;Object&gt; memberLogin(@RequestBody LoginVO data, HttpSession session){          Map&lt;String, Object&gt; resultMap = mService.loginMember(data);          session.setAttribute(\"loginUser\", resultMap.get(\"loginUser\"));           //실패하면 null이라 로그인 안됨.session의 값이 채워지면 로그인상태임. 모든 코드에서 사용가능(Html도 마찬가지임)          //프론트에서는 사용못함!!          return new ResponseEntity&lt;&gt;(resultMap, (HttpStatus)resultMap.get(\"code\"));      }  }            투두      package com.jh_project.todo.todoList.entity;      import java.util.Date;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data@AllArgsConstructor@NoArgsConstructor  @Entity(name = \"todo_info\")  public class TodoInfoEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name = \"ti_seq\") private Long seq;      @Column(name = \"ti_mi_seq\") private Long miSeq;      @Column(name = \"ti_content\") private String content;      @Column(name = \"ti_status\") private Integer status;      @Column(name = \"ti_start_dt\") private Date startDt;      @Column(name = \"ti_end_dt\") private Date endDt;              }          package com.jh_project.todo.todoList.repository;      import java.util.Date;  import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.jh_project.todo.todoList.entity.TodoInfoEntity;  @Repository  public interface TodoRepository extends JpaRepository&lt;TodoInfoEntity, Long&gt; {      public List&lt;TodoInfoEntity&gt; findAllByMiSeq(Long miSeq);      public TodoInfoEntity findBySeq(Long seq);      public void deleteBySeqAndMiSeq(Long seq, Long miSeq);      public TodoInfoEntity findBySeqAndMiSeq(Long seq, Long miSeq);      //select * from todo_info where ti_end_dt between [start] and [end] and ti_mi_seq=[miSeq]      public List&lt;TodoInfoEntity&gt; findByEndDtBetweenAndMiSeq(Date start, Date end, Long miSeq);  }          package com.jh_project.todo.todoList.service;      import java.text.SimpleDateFormat;  import java.util.Date;  import java.util.LinkedHashMap;  import java.util.List;  import java.util.Map;      import javax.servlet.http.HttpSession;  import javax.transaction.Transactional;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.stereotype.Service;      import com.jh_project.todo.member.entity.MemberInfoEntity;  import com.jh_project.todo.todoList.entity.TodoInfoEntity;  import com.jh_project.todo.todoList.repository.TodoRepository;      @Service  public class TodoInfoService {      @Autowired TodoRepository t_repo;          public Map&lt;String, Object&gt; addTodoList(TodoInfoEntity data, HttpSession session){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute(\"loginUser\");          if(loginUser==null){              map.put(\"status\", false);              map.put(\"message\", \"로그인이 필요합니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              data.setMiSeq(loginUser.getSeq());              t_repo.save(data);              map.put(\"status\", true);              map.put(\"message\", \"일정이 추가되었습니다.\");              map.put(\"code\", HttpStatus.CREATED);          }          return map;      }      public Map&lt;String, Object&gt; getTodoList(HttpSession session){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute(\"loginUser\");          if(loginUser==null){              map.put(\"status\", false);              map.put(\"message\", \"로그인이 필요합니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              map.put(\"list\", t_repo.findAllByMiSeq(loginUser.getSeq()));              map.put(\"status\", true);              map.put(\"message\", \"조회하였습니다.\");              map.put(\"code\", HttpStatus.OK);                          }          return map;      }      public Map&lt;String, Object&gt; updateTodoStatus(Integer status, Long seq){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          TodoInfoEntity todo = t_repo.findBySeq(seq);          if(todo==null){              map.put(\"status\", false);              map.put(\"message\", \"잘못된 todo번호입니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              todo.setStatus(status);              t_repo.save(todo);              map.put(\"status\", true);              map.put(\"message\", \"todo 상태가 변경되었습니다.\");              map.put(\"code\", HttpStatus.OK);          }                      return map;      }      public Map&lt;String, Object&gt; updateTodoContent(String content, Long seq){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          TodoInfoEntity todo = t_repo.findBySeq(seq);          if(todo==null){              map.put(\"status\", false);              map.put(\"message\", \"잘못된 todo번호입니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              todo.setContent(content);              t_repo.save(todo);              map.put(\"status\", true);              map.put(\"message\", \"todo 상태가 변경되었습니다.\");              map.put(\"code\", HttpStatus.OK);          }          return map;      }      @Transactional      public Map&lt;String, Object&gt; deleteTodo(Long seq, HttpSession session){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute(\"loginUser\");          if(loginUser==null){              map.put(\"status\", false);              map.put(\"message\", \"로그인 후 사용가능한 기능입니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);              return map;          }          TodoInfoEntity todo = t_repo.findBySeqAndMiSeq(seq, loginUser.getSeq());          if(todo==null){              map.put(\"status\", false);              map.put(\"message\", \"잘못된 Todo 번호입니다..\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              t_repo.deleteBySeqAndMiSeq(seq, loginUser.getSeq());              map.put(\"status\", true);              map.put(\"message\", \"todo가 삭제되었습니다.\");              map.put(\"code\", HttpStatus.OK);          }          return map;      }      public Map&lt;String, Object&gt; selectTodoListByTrem(HttpSession session, String start, String end){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();          MemberInfoEntity loginUser = (MemberInfoEntity)session.getAttribute(\"loginUser\");          if(loginUser==null){              map.put(\"status\", false);              map.put(\"message\", \"로그인 후 사용가능한 기능입니다.\");              map.put(\"code\", HttpStatus.FORBIDDEN);              return map;          }          SimpleDateFormat format = new SimpleDateFormat(\"yyMMdd\");          Date startDt=null;          Date endDt=null;          try{              startDt = format.parse(start);              endDt = format.parse(end);          }catch(Exception e){              map.put(\"status\", false);              map.put(\"message\", \"날짜 형식을 확인해주세요(yyMMdd ex:221214)\");              map.put(\"code\", HttpStatus.BAD_REQUEST);              return map;                          }          List&lt;TodoInfoEntity&gt; list = t_repo.findByEndDtBetweenAndMiSeq(startDt, endDt, loginUser.getSeq());          if(list.size()==0){              map.put(\"status\", false);              map.put(\"message\", \"일치하는 Todo가 없습니다. 날짜를 확인해주세요\");              map.put(\"code\", HttpStatus.FORBIDDEN);          }else{              map.put(\"list\", list);              map.put(\"status\", true);              map.put(\"message\", \"조회완료되었습니다.\");              map.put(\"code\", HttpStatus.OK);          }          return map;      }  }          package com.jh_project.todo.todoList.api;      import java.text.SimpleDateFormat;  import java.util.LinkedHashMap;  import java.util.Map;      import javax.servlet.http.HttpSession;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.http.HttpStatus;  import org.springframework.http.ResponseEntity;  import org.springframework.web.bind.annotation.DeleteMapping;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PatchMapping;  import org.springframework.web.bind.annotation.PathVariable;  import org.springframework.web.bind.annotation.PutMapping;  import org.springframework.web.bind.annotation.RequestBody;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RequestParam;  import org.springframework.web.bind.annotation.RestController;      import com.jh_project.todo.todoList.entity.TodoInfoEntity;  import com.jh_project.todo.todoList.service.TodoInfoService;      import net.bytebuddy.agent.builder.AgentBuilder.FallbackStrategy.Simple;      @RestController  @RequestMapping(\"/api/todo\")  public class TodoAPIController {      @Autowired TodoInfoService tService;      @PutMapping(\"/add\")      public ResponseEntity&lt;Object&gt; addTodo(@RequestBody TodoInfoEntity data, HttpSession session){          Map&lt;String, Object&gt; map = tService.addTodoList(data, session);                      return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      }      @GetMapping(\"/list\")      public ResponseEntity&lt;Object&gt; getTodoList(HttpSession session){          Map&lt;String, Object&gt; map = tService.getTodoList(session);          return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      }      @PatchMapping(\"/update/{type}\")      public ResponseEntity&lt;Object&gt; updateTodo(          @RequestParam Long seq,          @PathVariable String type,          @RequestParam String value      ){          if(type.equals(\"status\")){              Map&lt;String, Object&gt; map = tService.updateTodoStatus(Integer.parseInt(value), seq);              return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));          }else if(type.equals(\"content\")){              Map&lt;String, Object&gt; map = tService.updateTodoContent(value, seq);              return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));          }else{              Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();              map.put(\"stauts\", false);              map.put(\"message\", \"type은 status, content 둘 중 한가지만 가능합니다\");              return new ResponseEntity&lt;&gt;(map, HttpStatus.BAD_REQUEST);                          }      }      // @DeleteMapping(\"/delete\")      // @Transactional      // public ResponseEntity&lt;Object&gt; deleteTodo(@RequestParam Long seq, @RequestParam Long miSeq){      //     Map&lt;String, Object&gt; map = tService.deleteTodo(seq, miSeq);      //     return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      // }      @DeleteMapping(\"/delete\")      public ResponseEntity&lt;Object&gt; deleteTodo(@RequestParam Long seq, HttpSession session){          Map&lt;String, Object&gt; map = tService.deleteTodo(seq, session);          return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      }      @GetMapping(\"/list/term\")      public ResponseEntity&lt;Object&gt; getDetailTodoList(HttpSession session, String start, String end){          Map&lt;String, Object&gt; map = tService.selectTodoListByTrem(session, start, end);          return new ResponseEntity&lt;&gt;(map, (HttpStatus)map.get(\"code\"));      }          }          ###제품 추가  PUT http://localhost:9988/api/member/join HTTP/1.1  content-type : application/json      {      \"email\" : \"user002@service.com\",      \"pwd\" : \"1234\",      \"name\" : \"사용자2\",      \"birth\" : \"2022-12-14T00:00:00\",      \"regDt\" : \"2022-12-14T00:00:00\"  }  ###로그인  POST http://localhost:9988/api/member/login HTTP/1.1  content-type : application/json      {      \"email\" : \"user001@service.com\",      \"pwd\" : \"1234\"  }      ##\\#Todo 등록  PUT http://localhost:9988/api/todo/add HTTP/1.1  content-type : application/json      {      \"content\" : \"Todo5\",      \"status\" : 1,      \"startDt\" : \"2022-12-30T00:00:00\",      \"endDt\" : \"2022-12-30T00:00:00\"  }  ###내 TodoList 조회  GET http://localhost:9988/api/todo/list HTTP/1.1      ##\\#Todo 내용 수정  PATCH  http://localhost:9988/api/todo/update/content?&amp;value=sssss&amp;seq=1 HTTP/1.1  ##\\#Todo 상태 변경  PATCH  http://localhost:9988/api/todo/update/status?&amp;value=2&amp;seq=1 HTTP/1.1  ##\\#Todo 삭제  DELETE http://localhost:9988/api/todo/delete?seq=3 HTTP/1.1  ##\\#Todo 날짜범위 조회  GET http://localhost:9988/api/todo/list/term?start=221226&amp;end=221230 HTTP/1.1    restClient 사용 링크        파일관리      package com.jh_project.todo.todoList.entity;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name = \"todo_images_info\")  public class TodoImageEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name = \"tii_seq\")       private Long seq;      @Column(name = \"tii_ti_seq\")    private Long tiSeq;      @Column(name = \"tii_file_name\") private String fileName;      @Column(name = \"tii_uri\")       private String uri;  }          package com.jh_project.todo.member.entity;      import javax.persistence.Column;  import javax.persistence.Entity;  import javax.persistence.GeneratedValue;  import javax.persistence.GenerationType;  import javax.persistence.Id;      import lombok.AllArgsConstructor;  import lombok.Data;  import lombok.NoArgsConstructor;      @Data  @AllArgsConstructor  @NoArgsConstructor  @Entity(name = \"member_images_info\")  public class MemberImageEntity {      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)      @Column(name = \"mii_seq\")       private Long seq;      @Column(name = \"mii_mi_seq\")    private Long miSeq;      @Column(name = \"mii_file_name\") private String fileName;      @Column(name = \"mii_uri\")       private String uri;  }          package com.jh_project.todo.member.repository;      import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.jh_project.todo.member.entity.MemberImageEntity;      @Repository  public interface MemberImageRepository extends JpaRepository&lt;MemberImageEntity, Long&gt; {      public List&lt;MemberImageEntity&gt; findByMiSeq(Long miSeq);      //select * from todo_image_info where tii_uri = uri order by tii_seq desc limit 1;      //가장 나중에 입력된 이미지를 가져옴.      public List&lt;MemberImageEntity&gt; findTopByUriOrderBySeqDesc(String uri);          }          package com.jh_project.todo.todoList.repository;      import java.util.List;      import org.springframework.data.jpa.repository.JpaRepository;  import org.springframework.stereotype.Repository;      import com.jh_project.todo.todoList.entity.TodoImageEntity;      @Repository  public interface TodoImageRepository extends JpaRepository&lt;TodoImageEntity, Long&gt; {      public List&lt;TodoImageEntity&gt; findByTiSeq(Long tiSeq);      //select * from todo_image_info where tii_uri = uri order by tii_seq desc limit 1;      //가장 나중에 입력된 이미지를 가져옴.      public List&lt;TodoImageEntity&gt; findTopByUriOrderBySeqDesc(String uri);  }          @Autowired TodoImageRepository tiRepo;          public Map&lt;String, Object&gt;  addTodoImage(TodoImageEntity data, Long tiSeq){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          data.setTiSeq(tiSeq);          tiRepo.save(data);          map.put(\"status\", true);          map.put(\"message\", \"이미지가 저장되었습니다.\");          map.put(\"code\", HttpStatus.OK);          return map;      }          @Autowired MemberImageRepository mi_repo;              public Map&lt;String, Object&gt;  addMemberImage(MemberImageEntity data, Long miSeq){          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();          data.setMiSeq(miSeq);          mi_repo.save(data);          map.put(\"status\", true);          map.put(\"message\", \"이미지가 저장되었습니다.\");          map.put(\"code\", HttpStatus.OK);          return map;      }      public String getFileNameByUri(String uri){          List&lt;MemberImageEntity&gt; data = mi_repo.findTopByUriOrderBySeqDesc(uri);          return data.get(0).getFileName();      }          package com.jh_project.todo.todoList.file.api;      import java.net.URLEncoder;  import java.nio.file.Files;  import java.nio.file.Path;  import java.nio.file.Paths;  import java.nio.file.StandardCopyOption;  import java.util.Calendar;  import java.util.LinkedHashMap;  import java.util.Map;      import javax.servlet.http.HttpServletRequest;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.beans.factory.annotation.Value;  import org.springframework.core.io.Resource;  import org.springframework.core.io.UrlResource;  import org.springframework.http.HttpHeaders;  import org.springframework.http.HttpStatus;  import org.springframework.http.MediaType;  import org.springframework.http.ResponseEntity;  import org.springframework.web.bind.annotation.GetMapping;  import org.springframework.web.bind.annotation.PathVariable;  import org.springframework.web.bind.annotation.PutMapping;  import org.springframework.web.bind.annotation.RequestParam;  import org.springframework.web.bind.annotation.RequestPart;  import org.springframework.web.bind.annotation.RestController;  import org.springframework.web.multipart.MultipartFile;      import com.jh_project.todo.member.entity.MemberImageEntity;  import com.jh_project.todo.member.service.MemberService;  import com.jh_project.todo.todoList.entity.TodoImageEntity;  import com.jh_project.todo.todoList.service.TodoInfoService;      @RestController  public class FileAPIController {      // 파일 업로드, 다운로드는 어느 프로젝프든 거의 동일함. 복붙추천      @Value(\"${file.image.todo}\") String todo_img_path; //springframework.beans임      @Value(\"${file.image.member}\") String member_img_path;      //이것도 DI임. 이미지 파일의 경로가 바뀌어도 application.properties만 고쳐주면 됨      @Autowired TodoInfoService tService;      @Autowired MemberService mService;          @PutMapping(\"/{type}/upload\") //todo이미지를 올릴것인지 file이미지를 올릴것인지      public ResponseEntity &lt; Object &gt; putImageUpload(          @PathVariable String type,          @RequestPart MultipartFile file, //파일을 받는 객체. postman에 file이라고 변수 그대로 적어주어야함          @RequestParam Long seq      ) {          Map &lt; String, Object &gt; map = new LinkedHashMap &lt; &gt; ();          System.out.println(file.getOriginalFilename()); //업로드 할 파일의 원본이름 확장자까지 출력          //Path - 폴더 및 파일의 위치를 나타내는 객체, Paths - 폴더 및 파일을 가져오고 경로를 만들기 위한 파일 유틸리티 클래스          Path folderLocation = null; //todo_img_path 문자열로부터 실제 폴더 경로를 가져옴.          if (type.equals(\"todo\")) {              folderLocation = Paths.get(todo_img_path);              } else if (type.equals(\"member\")) {              folderLocation = Paths.get(member_img_path);          } else {              map.put(\"status\", false);              map.put(\"message\", \"타입정보가 잘못되었습니다. ex:/todo/upload, /member/upload\");              return new ResponseEntity &lt; &gt; (map, HttpStatus.BAD_REQUEST);          }          String originFileName = file.getOriginalFilename();          String[] split = originFileName.split((\"\\\\.\")); //.을 기준으로 나눔          String ext = split[split.length - 1]; //확장자          String fileName = \"\";          for (int i = 0; i &lt; split.length - 1; i++) {              fileName += split[i]; //원래 split[i]+\".\" 이렇게 해줘야함          }          String saveFileName = type + \"_\"; //보통 원본 이름을 저장하는것이아니라 시간대를 입력함          Calendar c = Calendar.getInstance();          saveFileName += c.getTimeInMillis() + \".\" + ext; // todo_161310135.png 이런식으로 저장됨              Path targetFile = folderLocation.resolve(saveFileName); //폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로 생성          try {              //Files는 파일 처리에 대한 유틸리티 클래스              //copy - 복사, file.getInputStream() - 파일을 열어서 파일의 내용을 읽는 준비              //targetFile 경로로, standardCopyOption.REPLACE_EXISTING - 같은 파일이 있다면 덮어쓰기.              Files.copy(file.getInputStream(), targetFile, StandardCopyOption.REPLACE_EXISTING);          } catch (Exception e) {              e.printStackTrace();          }          if (type.equals(\"todo\")) {              TodoImageEntity data = new TodoImageEntity();              data.setFileName(saveFileName);              data.setUri(fileName);              tService.addTodoImage(data, seq);          } else if (type.equals(\"member\")) {              MemberImageEntity data = new MemberImageEntity();              data.setFileName(saveFileName);              data.setUri(fileName);              mService.addMemberImage(data, seq);              }          return new ResponseEntity &lt; &gt; (map, HttpStatus.OK);      } //파일 업로드 메소드          @GetMapping(\"/images/{type}/{uri}\")      public ResponseEntity getImage(          @PathVariable String uri, HttpServletRequest request,          @PathVariable String type      ) throws Exception {          // todo_img_path 문자열로부터 실제 폴더 경로를 가져온다.           Path folderLocation = null;          if (type.equals(\"todo\")) {              folderLocation = Paths.get(todo_img_path);          } else if (type.equals(\"member\")) {              folderLocation = Paths.get(member_img_path);          }          String filename = null;          if (type.equals(\"todo\")) {              filename = tService.getFileNameByUri(uri);          } else if (type.equals(\"member\")) {              filename = mService.getFileNameByUri(uri);          }          String[] split = filename.split(\"\\\\.\");          String ext = split[split.length - 1];          String exportName = uri + \".\" + ext;          // 내보낼 파일의 이름을 만든다.           // 폴더 경로와 파일의 이름을 합쳐서 목표 파일의 경로를 만든다.           Path targetFile = folderLocation.resolve(filename);          // 다운로드 가능한 형태로 변환하기 위한 Resource 객체 생성           Resource r = null;          try {              // 일반파일 -&gt; Url로 첨부 가능한 형태로 변환               r = new UrlResource(targetFile.toUri());          } catch (Exception e) {              e.printStackTrace();          }          // 첨부된 파일의 타입을 저장하기위한 변수 생성           String contentType = null;          try {              // 첨부할 파일의 타입 정보 산출               contentType = request.getServletContext().getMimeType(r.getFile().getAbsolutePath());              // 산출한 파일의 타입이 null 이라면               if (contentType == null) {                  // 일반 파일로 처리한다.                   contentType = \"application/octet-stream\";              }          } catch (Exception e) {              e.printStackTrace();          }          return ResponseEntity.ok()              // 응답의 코드를 200 OK로 설정하고               // 산출한 타입을 응답에 맞는 형태로 변환               .contentType(MediaType.parseMediaType(contentType))              // 내보낼 내용의 타입을 설정 (파일),               // attachment; filename*=\\\"\"+r.getFilename()+\"\\\" 요청한 쪽에서 다운로드 한               // 파일의 이름을 결정               .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"\" + URLEncoder.encode(exportName, \"UTF-8\") + \"\\\"\")              .body(r);          // 변환된 파일을 ResponseEntity에 추가 }                  }  }      "
  },
  
  {
    "title": "[김영한 스프링 입문] AOP",
    "url": "/posts/AOP/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링입문, AOP",
    "date": "2022-12-12 00:00:00 +0900",
    





    
    "snippet": "public Long join(Member member) {\t long start = System.currentTimeMillis();\t try {\t\t validateDuplicateMember(member); //중복 회원 검증\t\t memberRepository.save(member);\t\t return member.getId();\t } finally...",
    "content": "public Long join(Member member) {\t long start = System.currentTimeMillis();\t try {\t\t validateDuplicateMember(member); //중복 회원 검증\t\t memberRepository.save(member);\t\t return member.getId();\t } finally {\t\t long finish = System.currentTimeMillis();\t\t long timeMs = finish - start;\t\t System.out.println(\"join \" + timeMs + \"ms\");\t } }터미널보면 시간 나와있음. 모든 메소드에 이 코드를 추가하기엔 너무 많음AOP를 사용하지 않고 모든 코드를 입력할 때 문제  핵심관심사항이 아니고(핵심기능아님) 공통관심사항(공통기능)임  여러 기능이 섞여있어서 유지보수가 힘들다.  공통로직으로 만들기 힘듦  하나를 변경하면 모두 변경해줘야함⇒ AOP 사용AOP(Aspect Oriented Programming) : 모든 메소드의 호출시간 측정 가능.  공통 관심사항과 핵심관심사항 분리(시간측정 로직을 한군데에 모아서 원하는 곳에 적용)package com.greenart.practice.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Component@Aspectpublic class TimeTraceAop {    @Around(\"execution(* com.greenart.practice..*(..))\")    /* ↑ 아니면 Springconfig에 아래 코드 추가     @Bean    public TimeTraceAop timeTraceAop(){        return new TimeTraceAop();    } */    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {        long start = System.currentTimeMillis();        System.out.println(\"START: \" + joinPoint.toString());        try {            return joinPoint.proceed();        } finally {            long finish = System.currentTimeMillis();            long timeMs = finish - start;            System.out.println(\"END: \" + joinPoint.toString() + \" \" + timeMs + \"ms\");        }    }}@Around(“execution(* com.greenart.practice..*(..))”)에서 com.greenart.practice는 패키지명. 이걸 변경하면 대상 지정 가능"
  },
  
  {
    "title": "[김영한 스프링 입문] 웹 MVC",
    "url": "/posts/%EC%9B%B9_MVC/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링입문, mvc",
    "date": "2022-12-10 00:00:00 +0900",
    





    
    "snippet": "package com.greenart.practice.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframew...",
    "content": "package com.greenart.practice.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import com.greenart.practice.domain.Member;import com.greenart.practice.service.MemberService;@Controllerpublic class MemberController {    private final MemberService memberservice;    @Autowired//Spring 컨테이너의 memberservice와 연결시켜줌.    public MemberController(MemberService memberservice){        this.memberservice = memberservice;    }        @GetMapping(\"/members/new\")    public String createForm(){        return \"members/createMemberForm\";    }    @PostMapping(\"/members/new\")    public String createForm(MemberForm form){        Member member = new Member();        member.setName(form.getName());                MemberService.join(member);        return \"redirect:/\";    }    @GetMapping(\"/members\")    public String list(Model model){        List&lt;Member&gt; members = memberservice.findMembers();        model.addAttribute(\"members\", members);        return \"members/memberList\";    }}&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class =\"container\"&gt;        &lt;div&gt;            &lt;h1&gt;hello Spring&lt;/h1&gt;            &lt;p&gt;회원 기능&lt;/p&gt;            &lt;p&gt;                &lt;a href=\"/members/new\"&gt;회원 가입&lt;/a&gt;                &lt;a href=\"/members/\"&gt;회원 목록&lt;/a&gt;            &lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class =\"container\"&gt;        &lt;form action = \"/members/new\" method =\"post\"&gt;            &lt;div class=\"form-group\"&gt;                &lt;label for = \"name\"&gt;이름&lt;/label&gt;                &lt;input type=\"text\" id=\"name\" name =\"name\" placeholder=\"이름을 입력하세요\"&gt;            &lt;/div&gt;            &lt;button type=\"submit\"&gt;등록&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class =\"container\"&gt;        &lt;div&gt;            &lt;table&gt;                &lt;thead&gt;                    &lt;tr&gt;                        &lt;th&gt;#&lt;/th&gt;                        &lt;th&gt;이름&lt;/th&gt;                    &lt;/tr&gt;                &lt;/thead&gt;                &lt;tbody&gt;                    &lt;tr th:each=\"member:${members}\"&gt;                        &lt;td th:text=\"${member.id}\"&gt;&lt;/td&gt;                        &lt;td th:text=\"${member.name}\"&gt;&lt;/td&gt;                    &lt;/tr&gt;                &lt;/tbody&gt;            &lt;/table&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "[김영한 스프링 입문] 스프링 DB 접근",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81_DB_%EC%A0%91%EA%B7%BC/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링입문",
    "date": "2022-12-10 00:00:00 +0900",
    





    
    "snippet": "순수 JDBCh2 사용package com.greenart.practice.repository;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;im...",
    "content": "순수 JDBCh2 사용package com.greenart.practice.repository;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import java.util.Optional;import javax.sql.DataSource;import org.springframework.jdbc.datasource.DataSourceUtils;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;public class jdbcMemberRepository implements MemberRepository {    private final DataSource dataSource;    public jdbcMemberRepository(DataSource dataSource) {        this.dataSource = dataSource;    }    @Override    public Member save(Member member) {        String sql = \"insert into member(name) values(?)\";        Connection conn = null;        PreparedStatement pstmt = null;        ResultSet rs = null;        try {            conn = getConnection();            pstmt = conn.prepareStatement(sql,                Statement.RETURN_GENERATED_KEYS);            pstmt.setString(1, member.getName());            pstmt.executeUpdate();            rs = pstmt.getGeneratedKeys();            if (rs.next()) {                member.setId(rs.getLong(1));            } else {                throw new SQLException(\"id 조회 실패\");            }            return member;        } catch (Exception e) {            throw new IllegalStateException(e);        } finally {            close(conn, pstmt, rs);        }    }    @Override    public Optional &lt; Member &gt; findById(Long id) {        String sql = \"select * from member where id = ?\";        Connection conn = null;        PreparedStatement pstmt = null;        ResultSet rs = null;        try {            conn = getConnection();            pstmt = conn.prepareStatement(sql);            pstmt.setLong(1, id);            rs = pstmt.executeQuery();            if (rs.next()) {                Member member = new Member();                member.setId(rs.getLong(\"id\"));                member.setName(rs.getString(\"name\"));                return Optional.of(member);            } else {                return Optional.empty();            }        } catch (Exception e) {            throw new IllegalStateException(e);        } finally {            close(conn, pstmt, rs);        }    }    @Override    public List &lt; Member &gt; findAll() {        String sql = \"select * from member\";        Connection conn = null;        PreparedStatement pstmt = null;        ResultSet rs = null;        try {            conn = getConnection();            pstmt = conn.prepareStatement(sql);            rs = pstmt.executeQuery();            List &lt; Member &gt; members = new ArrayList &lt; &gt; ();            while (rs.next()) {                Member member = new Member();                member.setId(rs.getLong(\"id\"));                member.setName(rs.getString(\"name\"));                members.add(member);            }            return members;        } catch (Exception e) {            throw new IllegalStateException(e);        } finally {            close(conn, pstmt, rs);        }    }    @Override    public Optional &lt; Member &gt; findByName(String name) {        String sql = \"select * from member where name = ?\";        Connection conn = null;        PreparedStatement pstmt = null;        ResultSet rs = null;        try {            conn = getConnection();            pstmt = conn.prepareStatement(sql);            pstmt.setString(1, name);            rs = pstmt.executeQuery();            if (rs.next()) {                Member member = new Member();                member.setId(rs.getLong(\"id\"));                member.setName(rs.getString(\"name\"));                return Optional.of(member);            }            return Optional.empty();        } catch (Exception e) {            throw new IllegalStateException(e);        } finally {            close(conn, pstmt, rs);        }    }    private Connection getConnection() {        return DataSourceUtils.getConnection(dataSource);    }    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) {        try {            if (rs != null) {                rs.close();            }        } catch (SQLException e) {            e.printStackTrace();        }        try {            if (pstmt != null) {                pstmt.close();            }        } catch (SQLException e) {            e.printStackTrace();        }        try {            if (conn != null) {                close(conn);            }        } catch (SQLException e) {            e.printStackTrace();        }    }    private void close(Connection conn) throws SQLException {        DataSourceUtils.releaseConnection(conn, dataSource);    }}과거에 사용했던…수업시간에도 들었음. 일단 알아만 두기package com.greenart.practice;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.repository.jdbcMemberRepository;import com.greenart.practice.service.MemberService;@Configurationpublic class SpringConfig {    DataSource dataSource;    @Autowired    public SpringConfig(DataSource dataSource){        this.dataSource = dataSource;    }    @Bean    public MemberService memberService(){        return new MemberService(memberRepository());    }    @Bean    public MemberRepository memberRepository(){        // return new MemoryMemberRepository();        return new jdbcMemberRepository(dataSource);    }}MemoryMemberRepository → jdbcMemberRepository 변경, SpringConfig 생성자 생스프링 아님. 순수 자바코드로 jdbc설정spring 통합 테스트package com.greenart.practice.service;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.transaction.annotation.Transactional;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;@SpringBootTest@Transactional //테스트 실행 후 데이터 바로 삭제.(같은 값 계속 입력 가능함) = 실제 DB에 반영이 안class MemberServiceIntegrationTest {    @Autowired MemberService memberService;    @Autowired MemberRepository memberRepository;    @Test    public void 회원가입() throws Exception {        //Given        Member member = new Member();        member.setName(\"hello\");        //When        Long saveId = memberService.join(member);        //Then        Member findMember = memberRepository.findById(saveId).get();        assertEquals(member.getName(), findMember.getName());    }    @Test    public void 중복_회원_예외() throws Exception {        //Given        Member member1 = new Member();        member1.setName(\"spring\");        Member member2 = new Member();        member2.setName(\"spring\");        //When        memberService.join(member1);        IllegalStateException e = assertThrows(IllegalStateException.class,        () -&gt; memberService.join(member2));//예외가 발생해야 한다.        assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");    }}assertThat import가 잘 안됨검색해보니 import static org.junit.Assert.*;를 지우고 import org.assertj.core.api.Assertions_;_를 수동으로 넣으라는데 안돼서 걍 껏다키니까 됨;;순수한 단위테스트(순수 자바코드로 최소한의 단위로 하는 테스트)가 더 효율적임. 미리 연습 많이할것..jdbcTemplateJDBC API의 반복적인 코드 대부분 제거. SQL은 직접 작성해야함package com.greenart.practice.repository;import java.sql.ResultSet;import java.sql.SQLException;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Optional;import javax.sql.DataSource;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;import org.springframework.jdbc.core.simple.SimpleJdbcInsert;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;public class JdbcTemplateMemberRepository implements MemberRepository {    private final JdbcTemplate jdbcTemplate;    // @Autowired //생성자 하나일시 생략 가능    public JdbcTemplateMemberRepository(DataSource dataSource){        this.jdbcTemplate = new JdbcTemplate(dataSource);    }    @Override    public Member save(Member member) throws Exception {        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);        jdbcInsert.withTableName(\"member\").usingGeneratedKeyColumns(\"id\"); //sql문 작성할 필요없음. member테이블의 id에 insert해        Map&lt;String, Object&gt; parameters = new HashMap&lt;&gt;();        parameters.put(\"name\", member.getName());        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));        member.setId(key.longValue());        return member;    }    @Override    public Optional&lt;Member&gt; findById(Long id) throws Exception {        List&lt;Member&gt; result = jdbcTemplate.query(\"select * from member where id=?\",memberRowMapper(), id );        return result.stream().findAny(); //순수 jdbc와 같은 코드    }    @Override    public Optional&lt;Member&gt; findByName(String name) {        List&lt;Member&gt; result = jdbcTemplate.query(\"select * from member where name=?\",memberRowMapper(), name );        return result.stream().findAny(); //순수 jdbc와 같은 코드    }    @Override    public List&lt;Member&gt; findAll() {        return jdbcTemplate.query(\"select * from member\",memberRowMapper() );    }    private RowMapper&lt;Member&gt; memberRowMapper(){        // return new RowMapper&lt;Member&gt;(){        //     @Override        //     public Member mapRow(ResultSet rs, int rowNum) throws SQLException{        //         Member member = new Member();        //         member.setId(rs.getLong(\"id\"));        //         member.setName(rs.getString(\"name\"));        //         return member;        //     } //람다로 변환 가능            return (rs, rowNum) -&gt; {                Member member = new Member();                member.setId(rs.getLong(\"id\"));                member.setName(rs.getString(\"name\"));                return member;        };    }}package com.greenart.practice;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.repository.JdbcTemplateMemberRepository;import com.greenart.practice.repository.jdbcMemberRepository;import com.greenart.practice.service.MemberService;@Configurationpublic class SpringConfig {    DataSource dataSource;    @Autowired    public SpringConfig(DataSource dataSource){        this.dataSource = dataSource;    }    @Bean    public MemberService memberService(){        return new MemberService(memberRepository());    }    @Bean    public MemberRepository memberRepository(){        // return new MemoryMemberRepository();        // return new jdbcMemberRepository(dataSource);        return new JdbcTemplateMemberRepository(dataSource);    }}jdbcMemberRepository → JdbcTemplateMemberRepository 변경JPA반복코드 제거 + sql문도 JPA가 직접 만들어줌build.gradle에 dependencies안에implementation ‘org.springframework.boot:spring-boot-starter-data-jpa’추가application에spring.jpa.show-sql=truespring.jpa.hibernate.ddl-auto=none추가저장, 업데이트, 단건 조회문은 sql문을 짤 필요 없음여러 값을 가져오는 경우에는 sql문을 짜줘야함. Spring data jpa를 사용하면 이것도 안짜줘도 됨.package com.greenart.practice.repository;import java.util.List;import java.util.Optional;import javax.persistence.EntityManager;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;public class JpaMemberRepository implements MemberRepository {    private final EntityManager em;    public JpaMemberRepository(EntityManager em) {    this.em = em;    } //자동으로 만들어짐    @Override    public Member save(Member member) {        em.persist(member);        return member;    }    @Override    public Optional&lt;Member&gt; findById(Long id) {        Member member = em.find(Member.class, id);        return Optional.ofNullable(member);        }    @Override    public Optional&lt;Member&gt; findByName(String name) {        List&lt;Member&gt; result = em.createQuery(\"select m from Member m where m.name = :name\", Member.class).setParameter(\"name\", name).getResultList();        return result.stream().findAny();        }    @Override    public List&lt;Member&gt; findAll() {        return em.createQuery(\"select m from Member m\", Member.class).getResultList();         //\"select m from Member m\" - jpql 쿼리 언어. 테이블대상이아니고 객체 대상으로 쿼리를 날림.         //member entity를 향해 쿼리를 날림. member m은 member as m의 줄임말. 그래서 select m은 member entity 객체 자체를 가져온다는 말임. *랑 같은말인듯?    }     }package com.greenart.practice.service;import java.util.List;import java.util.Optional;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.transaction.annotation.Transactional;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;@Transactionalpublic class MemberService {    private static MemberRepository memberRepository;        @Autowired    public MemberService(MemberRepository memberRepository){        this.memberRepository=memberRepository;    }    public static Long join(Member member) throws Exception{        //같은 이름x        // Optional&lt;Member&gt; result = memberRepository.findByName(member.getName());         //Optional을 바로 반환하는 것을 권장하지 않음(아래 메소드 참고)                validateDuplicateMember(member);        //null이 들어올 확률이 있어서 Optional로 감싸줌. .get으로 바로 꺼내도 되나 권장하지 않음        //.orElseGet(값이 있으면 꺼내고 값이 없으면 메소드를 실행하거나 디폴트값을 꺼냄)을 써도됨.                 // result.ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원입니다.\"); // - 위에써서 주석처리함        // })/; //일치하는 회원이 있다면 로직이 동작        memberRepository.save(member);        return member.getId();    } //jpa는 데이터 변경이 모두 Transactional안에서 이루어져야함. 여기선 @Transactional이 join메소드에만 붙어도 되지만 일단 class에 붙여줌    private static void validateDuplicateMember(Member member){        memberRepository.findByName(member.getName())            .ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원\");});               }    //전체회원 조회    public static List&lt;Member&gt; findMembers(){        return memberRepository.findAll();    }    public Optional&lt;Member&gt; findOne(Long memberId) throws Exception{        return memberRepository.findById(memberId);    }}Spring data jpa인터페이스만으로 개발 가능. CRUD도 JPA가 모두 제공함.package com.greenart.practice.repository;import java.util.Optional;import org.springframework.data.jpa.repository.JpaRepository;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;public interface SpringDataJpaMemverRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepository { //Member의 Id타입, 다중상    @Override    Optional&lt;Member&gt; findByName(String name); //..끝}package com.greenart.practice;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.service.MemberService;@Configurationpublic class SpringConfig {    // private final DataSource dataSource;    // private final EntityManager em;    // public SpringConfig(EntityManager em) {    //     // this.dataSource = dataSource;    //     this.em = em;    // }    private final MemberRepository memberRepository;    @Autowired //생성자가 하나라서 생략가    public SpringConfig(MemberRepository memberRepository){        this.memberRepository = memberRepository;    }    @Bean    public MemberService memberService() {        return new MemberService(memberRepository);    }    // @Bean    // public MemberRepository memberRepository() {        // return new MemoryMemberRepository();        // return new JdbcMemberRepository(dataSource);        // return new JdbcTemplateMemberRepository(dataSource);        // return new JpaMemberRepository(em);    // }}스프링 데이터 JPA가 SpringDataJpaMemberRepository를 보고 자동으로 bean을 만들어서 객체를 생성한 후 bean에 올려줌. JpaRepository안에 save, findById 등 만들어둔 메소드가 모두 있음. 기본적인 CRUD가 다 제공되어있는 상태임.그러나 만약 공통되지 않는 사항은 메소드를 만들어주어야함. email, phone같은 상황에따라 다른 경우를 뜻함.메소드 이름을 findByName(String name) 이라고 지으면 자동으로 select m from member m where m.name=?으로 sql문을 짜줌findByNameAndId(String name, Long id) 는 select m from member m where m.name=? and id = ?으로 짜줌. 인터페이스의 이름만으로 자동으로 만들어준다는 뜻임"
  },
  
  {
    "title": "[김영한 스프링 입문] 스프링 빈과 의존관계",
    "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EB%B9%88%EA%B3%BC_%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84/",
    "categories": "Spring",
    "tags": "spring, 김영한스프링입문",
    "date": "2022-12-08 00:00:00 +0900",
    





    
    "snippet": "controller가 service를 이용해서 데이터 추가, 조회 등을 실행할 수 있어야함(=의존관계가 있어야함).Acontroller만 Aservice를 사용할 수 있어야함. Bcontroller는 Bservice만 사용가능. Aservice는 사용불가능.→— 스프링 빈 등록하는 방법  컴포넌트 스캔과 자동 의존관계 설정package com.gree...",
    "content": "controller가 service를 이용해서 데이터 추가, 조회 등을 실행할 수 있어야함(=의존관계가 있어야함).Acontroller만 Aservice를 사용할 수 있어야함. Bcontroller는 Bservice만 사용가능. Aservice는 사용불가능.→— 스프링 빈 등록하는 방법  컴포넌트 스캔과 자동 의존관계 설정package com.greenart.practice.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import com.greenart.practice.service.MemberService;@Controller //안에 component이 있음public class MemberController {    private final MemberService memberservice;    @Autowired//Spring 컨테이너의 memberservice와 연결시켜줌.\t\t// 단, 순수한 java클래스와는 연결이 안됨. @Service를 클래스앞에 붙여서 어떤 클래스인지 지정먼저 해줘야    public MemberController(MemberService memberservice){        this.memberservice = memberservice;    }        }package com.greenart.practice.service;import java.util.List;import java.util.Optional;import org.springframework.stereotype.Service;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.domain.MemoryMemberRepository;@Service //연결을 위해 이 클래스가 service인것을 알려줌.//service안에 component이 있음public class MemberService {    private MemberRepository memberRepository = new MemoryMemberRepository();        public MemberService(MemberRepository memberRepository){        this.memberRepository=memberRepository;    }    public Long join(Member member){        //같은 이름x        // Optional&lt;Member&gt; result = memberRepository.findByName(member.getName());         //Optional을 바로 반환하는 것을 권장하지 않음(아래 메소드 참고)                validateDuplicateMember(member);        //null이 들어올 확률이 있어서 Optional로 감싸줌. .get으로 바로 꺼내도 되나 권장하지 않음        //.orElseGet(값이 있으면 꺼내고 값이 없으면 메소드를 실행하거나 디폴트값을 꺼냄)을 써도됨.                 // result.ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원입니다.\"); // - 위에써서 주석처리함        // })/; //일치하는 회원이 있다면 로직이 동작        memberRepository.save(member);        return member.getId();    }    private void validateDuplicateMember(Member member){        memberRepository.findByName(member.getName())            .ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원\");});               }    //전체회원 조회    public List&lt;Member&gt; findMembers(){        return memberRepository.findAll();    }    public Optional&lt;Member&gt; findOne(Long memberId){        return memberRepository.findById(memberId);    }}package com.greenart.practice.domain;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Optional;import org.springframework.stereotype.Repository;@Repository //안에 component이 있음public class MemoryMemberRepository implements MemberRepository {    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();    private static long sequence = 0L;    public void clearStore(){        store.clear();    }    @Override    public Member save(Member member) {        member.setId(++sequence); //멤버 저장시 일련번호 값 1 증가        store.put(member.getId(), member);        return member;    }    @Override    public Optional&lt;Member&gt; findById(Long id) {        return Optional.ofNullable(store.get(id)); //null이라도 감싸서 반환가능    }    @Override    public Optional&lt;Member&gt; findByName(String name) {        return store.values().stream()                .filter(member -&gt; member.getName().equals(name)) //같은 name을 가지고 있는 객체를 찾으면 반환. 없으면 null반환                .findAny();    }    @Override    public List&lt;Member&gt; findAll() {        return new ArrayList&lt;&gt;(store.values());    }    }@controller - @Service - @Repository 세가지가 정형화된 패턴controller는 service가 필요하고 service는 repositry가 필요함.❗스프링 컨테이너에 스프링 빈 등록시 기본으로 싱글톤으로 등록함(설정으로 아니게 할수있지만 특별한경우아니면 다 싱글톤임)  자바 코드로 직접 스프링 빈 등록package com.greenart.practice;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.greenart.practice.domain.MemberRepository;import com.greenart.practice.domain.MemoryMemberRepository;import com.greenart.practice.service.MemberService;@Configurationpublic class SpringConfig {    @Bean    public MemberService memberService(){        return new MemberService(memberRepository());    }    @Bean    public MemberRepository memberRepository(){        return new MemoryMemberRepository();    }}과거에는 XML을 사용했으나 요즘은 잘 사용하지 않음.— DI      필드 주입      package com.greenart.practice.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;      import com.greenart.practice.service.MemberService;      @Controller  public class MemberController {      @Autowired private MemberService memberservice;   }        별로 안좋음;;        setter주입      package com.greenart.practice.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;      import com.greenart.practice.service.MemberService;      @Controller  public class MemberController {      private MemberService memberservice;     \t\t  \t\t@Autowired  \t\tpublic void setMemberService(MemberService memberService){  \t\t\tthis.memberservice = memberservice;  \t\t}      }        MemberController를 누군가 호출했을 때 public으로 열려있어야함. 외부에서 호출하기 쉬(중간에 잘못 바뀌면 문제생길가능성 농후함)        생성자 주입      package com.greenart.practice.controller;      import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Controller;      import com.greenart.practice.service.MemberService;      @Controller  public class MemberController {      private final MemberService memberservice;          @Autowired//Spring 컨테이너의 memberservice와 연결시켜줌.      public MemberController(MemberService memberservice){          this.memberservice = memberservice;      }                  }        생성자를 통해 memberservice가 membercontroller에 주입  bean이 객체를 의미하는거고 스프링 컨테이너는 bean에 들어있는 객체를 관리하는거같음. 그래서 생성한 객체를 스프링 컨테이너에서 사용하려면 bean에 등록하는 과정이 필요해서 @component를 붙여줘야 하는거같음!!"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 웹페이지 생성 3",
    "url": "/posts/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%803/",
    "categories": "Spring",
    "tags": "spring, 국비교육",
    "date": "2022-12-08 00:00:00 +0900",
    





    
    "snippet": "package com.green.practice5.data;import java.util.Date;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Pro...",
    "content": "package com.green.practice5.data;import java.util.Date;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class ProductInfo {    private Integer no;    private String name;    private Integer price;    private Double discount;    private Date regDt;    }package com.green.practice5.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.green.practice5.data.ProductInfo;@RestController@RequestMapping(\"/api\")public class APIController {    private static List&lt;ProductInfo&gt; prod_list = new ArrayList&lt;ProductInfo&gt;();    private static Integer nextNo = 1;    //제품 전체 조회    @GetMapping(\"/product/list\")    public Map&lt;String, Object&gt; getProductList(){        // Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //HashMap이라 순서가 뒤죽박죽임        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); //LinkedHashMap이라 순서가 입력한 순서대로임        map.put(\"status\", true);        map.put(\"total\", prod_list.size());        map.put(\"totalPage\", (int)(Math.ceil(prod_list.size()/12.0)));        map.put(\"list\", prod_list); //입력값이 없다면 \"list\": []으로 나옴.         return map;    }    //제품 등록    @PutMapping(\"/product\")    public Map&lt;String, Object&gt; putProduct(@RequestBody ProductInfo data){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        System.out.println(data);        data.setNo(nextNo);        prod_list.add(data);        nextNo++;        map.put(\"status\", true);        map.put(\"message\", \"제품이 추가되었습니다\");                return map;    }    //제품 한개 조회    @GetMapping(\"/product/select_one\")    public ProductInfo getProductSelect(@RequestParam Integer prodNo){        for(ProductInfo p : prod_list){            if(p.getNo()==prodNo) return p;        }        return null;    }    //제품 정보 수정    @PatchMapping(\"/product\")    public Map&lt;String, Object&gt; patchProduct(@RequestBody ProductInfo data){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        for(ProductInfo p : prod_list){            if(p.getNo()==data.getNo()){                if(data.getName()!=null){                    p.setName(data.getName());                }                if(data.getPrice()!=null){                    p.setPrice(data.getPrice());                }                if(data.getDiscount()!=null){                    p.setDiscount(data.getDiscount());                }                if(data.getRegDt()!=null){                    p.setRegDt(data.getRegDt());                }                map.put(\"status\", true);                map.put(\"message\", \"제품 수정 완료\");                return map;            }        }        map.put(\"status\", false);        map.put(\"message\", \"제품 수정 실패. 제품번호를 확인해주세요\");        return map;    }}다시 시작하면 전에 입력해둔 prod_list가 다 날아가서 새로 입력해야함— 영화package com.green.practice5.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.green.practice5.data.MovieInfo;@RestController@RequestMapping(\"/api\")public class MovieController {    private static List&lt;MovieInfo&gt; mlist = new ArrayList&lt;MovieInfo&gt;();    private static Integer nextNo=1;    @PutMapping(\"/movie\")    public Map&lt;String, Object&gt; putMovie(@RequestBody MovieInfo m){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        m.setNo(nextNo);        nextNo++;        map.put(\"status\", true);        map.put(\"massage\", \"제품등록이 완료되었습니다.\");        // map.put(\"movie\", m);        mlist.add(m);        return map;    }    @GetMapping(\"/movie\")    public Map&lt;String, Object&gt; getMovieList(){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"total\", mlist.size());        map.put(\"totalpage\",(int)(Math.ceil(mlist.size()/10.0)));        map.put(\"list\", mlist);        return map;    }    @PatchMapping(\"/movie\")    public Map&lt;String, Object&gt; patchMovie(@RequestBody MovieInfo m){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        for(MovieInfo mo : mlist){            if(mo.getNo()==m.getNo()){                if(m.getTitle()!=null){                    mo.setTitle(m.getTitle());                }                if(m.getGenre()!=null){                    mo.setGenre(m.getGenre());                }                if(m.getRegDt()!=null){                    mo.setRegDt(m.getRegDt());                }                if(m.getStatus()!=null){                    mo.setStatus(m.getStatus());                }                map.put(\"massage\", \"수정완료\");                map.put(\"status\", true);                return map;            }        }        map.put(\"massage\", \"수정실패. 제품번호를 확인하세요\");        map.put(\"status\", false);        return map;    }    @DeleteMapping(\"/movie\")    public Map&lt;String, Object&gt; deleteMovie(@RequestParam Integer mNo){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        for(MovieInfo m : mlist){            if(m.getNo()==mNo){                mlist.remove(m);                map.put(\"message\", \"제품 삭제 완료\");                map.put(\"status\", true);                return map;            }        }        map.put(\"message\", \"제품 삭제 실패. 제품번호를 확인하세요\");        map.put(\"status\", false);        return map;    }    @GetMapping(\"movie/select_no\")    public Map&lt;String, Object&gt; getMovieNo(@RequestParam Integer mno){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        for(MovieInfo m : mlist){            if(m.getNo()==mno){                map.put(\"status\", true);                map.put(\"message\", \"영화정보를 찾았습니다\");                map.put(\"info\", m);                return map;            }        }        map.put(\"status\", false);        map.put(\"message\", \"해당 영화가 존재하지않습니다. 번호를 다시확인해주세요\");        return map;    }    @GetMapping(\"movie/select_genre\")    public Map&lt;String, Object&gt; getMovieGenre(@RequestParam String genre){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        List&lt;MovieInfo&gt; list = new ArrayList&lt;MovieInfo&gt;();        for(MovieInfo m : mlist){            if(m.getGenre().contains(genre)){                list.add(m);            }        }        map.put(\"total\", list.size());        map.put(\"totalpage\",(int)(Math.ceil(list.size()/10.0)));        map.put(\"list\", list);        return map;    }    @GetMapping(\"movie/select_status\")    public Map&lt;String, Object&gt; getMovieStatus(@RequestParam Integer status){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        List&lt;MovieInfo&gt; list = new ArrayList&lt;MovieInfo&gt;();        for(MovieInfo m : mlist){            if(m.getStatus()==status){                list.add(m);            }        }        map.put(\"total\", list.size());        map.put(\"totalpage\",(int)(Math.ceil(list.size()/10.0)));        map.put(\"list\", list);        return map;    }    @GetMapping(\"movie/select_all\")    public Map&lt;String, Object&gt; getMovieAll(            @RequestParam @Nullable Integer status,             @RequestParam @Nullable Integer mno,            @RequestParam @Nullable String genre        ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        List&lt;MovieInfo&gt; list = new ArrayList&lt;MovieInfo&gt;();        for(MovieInfo m : mlist){            if(m.getStatus()==status || m.getGenre().contains(genre) || m.getNo()==mno){                list.add(m);            }        }        map.put(\"total\", list.size());        map.put(\"totalpage\",(int)(Math.ceil(list.size()/10.0)));        map.put(\"list\", list);        return map;    }}PathVariable@GetMapping(\"/user/{id}\") //{}에 PathVariable이 들어감. 이경우는 매개변수로 받은 id 값이 들어감    public Map&lt;String, Object&gt; getUserInfo(@PathVariable String id){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"id\", id);                return map;    } //@PathVariable : URL로 받은 값이 파라미터로 바로 들어감. = URL로 받은 값을 변수 데이터로 사용//http://localhost:8080/api/movie/info/genre?value=판타 //http://localhost:8080/api/movie/info/status?value=2 URL이런식으로 들어감//만약 위에 장르와 상태값 조회 메소드 경로를 /movie/info/status로 받았다면 중복이라 제거했어야함. //지금은 다르게 만들어서 제거하지않아도 됨.//단 이제 /movie/info/~~~형태의 URL은 사용하지 못함// /movie/info/~~~/~~~~ 는 가능    @GetMapping(\"movie/info/{type}\")    public Map&lt;String, Object&gt; getMovieInfoByKeyword(            @PathVariable String type, @RequestParam @Nullable String value        ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        if(!type.equals(\"genre\") &amp;&amp; !type.equals(\"status\")){            map.put(\"status\", false);            map.put(\"message\", \"타입정보가 잘못되었습니다.\");        }        List&lt;MovieInfo&gt; list = new ArrayList&lt;MovieInfo&gt;();        for(MovieInfo m : mlist){            if(type.equals(\"status\") &amp;&amp;  m.getStatus()==Integer.parseInt(value)){                list.add(m);            }            if(type.equals(\"genre\") &amp;&amp;  m.getGenre().contains(value)){                list.add(m);            }        }        map.put(\"total\", list.size());        map.put(\"totalpage\",(int)(Math.ceil(list.size()/10.0)));        map.put(\"list\", list);        return map;    }하나의 메소드로 두가지 값을 확인가능함.헷갈리면 안쓰는게 좋음..product/1351?aa=45 → PathVariable(쿠팡)~~/?pcode=454 →RequestParam(다나와)PathVariable는 변수 명이 외부 노출이 안됨.만약 결과값이 없을때 에러코드를 띄우려면package com.green.practice6.api;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class APIController {    @GetMapping(\"/test\")    public ResponseEntity&lt;String&gt; getTest(){                return new ResponseEntity&lt;String&gt;(\"요청받음\",HttpStatus.OK);    }}HttpStatus.OK→HttpStatus.ACCEPTED 변경package com.green.practice6.api;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class APIController {    @GetMapping(\"/test\")    public ResponseEntity&lt;String&gt; getTest(){        return new ResponseEntity&lt;String&gt;(\"요청받음\",HttpStatus.ACCEPTED);    }}입력값에따라 에러 코드가 변경됨BAD_REQUEST - 사용자가 잘못된 값을 입력함 (제일 자주쓰임)@GetMapping(\"/test2\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getTest2(){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"status\", true);        map.put(\"message\", \"요청 성공\");        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map,HttpStatus.OK);    }위에게 복잡하다면 클래스를 하나 더 생성해서package com.green.practice6.data;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class ResponseVO {    private Boolean status;    private String message;}@GetMapping(\"/test3\")    public ResponseEntity&lt;ResponseVO&gt; getTest3(){        ResponseVO res = new ResponseVO(true, \"요청 성공\");        return new ResponseEntity&lt;ResponseVO&gt;(res,HttpStatus.OK);    }이렇게 해도 결과는 같음프론트에서 결과가 성공인지 실패인지 구분을 할 수 있어야함. 잘못된 호출은 에러코드를 확실히 내줘야함— 책package com.greenart.practice7.data;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class BookInfo {    private Integer no;    private String title;    private Integer price;    private String writer;    public void copyData(BookInfo src){        if(src.getTitle()!=null) this.title = src.getTitle();        if(src.getPrice()!=null) this.price = src.getPrice();        if(src.getWriter()!=null) this.writer = src.getWriter();    }}package com.greenart.practice7.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.greenart.practice7.data.BookInfo;@RestController@RequestMapping(\"/api/book\")public class BookAPIController {    private static List&lt;BookInfo&gt; book_list = new ArrayList&lt;BookInfo&gt;();    private static Integer nextNo = 1;    @PutMapping(\"/add\")    public ResponseEntity&lt; Map&lt;String, Object&gt; &gt; addBookInfo(@RequestBody BookInfo b){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        HttpStatus status = HttpStatus.OK;        String message = \"도서정보를 추가했습니다.\";        if(b.getTitle()==null || b.getTitle().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else if(b.getPrice()==null){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else if(b.getWriter()==null || b.getWriter().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else{            b.setNo(nextNo);            nextNo++;            book_list.add(b);        }        map.put(\"message\", message);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);    }    @GetMapping(\"/list\")    public ResponseEntity&lt; Map&lt;String, Object&gt; &gt; getBookList(        @RequestParam @Nullable Integer pageNo,        @RequestParam @Nullable String keyword,        @RequestParam @Nullable String searchType        ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();                    List&lt;BookInfo&gt; result_list = new ArrayList&lt;BookInfo&gt;();        if(pageNo==null) pageNo =1;        if(keyword==null){            result_list = book_list;        }else{            for(BookInfo b : book_list){                if(searchType==null){ //타입이 지정안됐으면 작가, 책제목 둘중하나만 같아도 list추가                    if(b.getTitle().contains(keyword) || b.getWriter().contains(keyword)){                        result_list.add(b);                    }                }else if(searchType.equals(\"title\")){                    if(b.getTitle().contains(keyword)){                        result_list.add(b);                    }                }else if(searchType.equals(\"writer\")){                    if(b.getWriter().contains(keyword)){                        result_list.add(b);                    }                }            }                    }        int totalPage = (int)Math.ceil(result_list.size()/10.0);        if(totalPage!=0 &amp;&amp; totalPage &lt; pageNo){            map.put(\"message\", \"페이지 범위를 넘어섭니다. 총 페이지 수 : \"+totalPage);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);        }        map.put(\"total\", result_list.size());        map.put(\"totalPage\", totalPage);        map.put(\"info\", result_list);        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);    }    // 책 여러개 등록    @PutMapping(\"/add/list\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; addBookInfoList(@RequestBody List&lt;BookInfo&gt; dataList) {        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : dataList){            b.setNo(nextNo);            book_list.add(b);            nextNo++;        }        map.put(\"message\", \"총 \"+dataList.size()+\"개의 데이터를 입력했습니다.\");        return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);    }    @PatchMapping(\"/update\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; updateBookInfo(        @RequestBody BookInfo data    ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : book_list){            if(b.getNo()==data.getNo()){                b.copyData(data);                map.put(\"message\", \"데이터가 변경되었습니다\");                return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);            }        }        map.put(\"message\", \"잘못된 책 번호 : \"+data.getNo());        return new ResponseEntity&lt;&gt;(map,HttpStatus.BAD_REQUEST);    }}— 음식점 메뉴등록package com.greenart.practice7.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.greenart.practice7.data.StoreMenuInfo;@RestController@RequestMapping(\"/api/menu\")public class MenuController {    private static List&lt;StoreMenuInfo&gt; menu_list = new ArrayList&lt;StoreMenuInfo&gt;();    private static Integer nextNo = 1;    @PutMapping(\"/add\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; putManuInfo(@RequestBody StoreMenuInfo data){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        HttpStatus status = HttpStatus.OK;        String message = \"메뉴를 추가했습니다.\";        if(data.getName()==null || data.getName().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";        }else if(data.getPrice()==null){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";        }else if(data.getDiscount()==null || data.getDiscount().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";        }else{            data.setNo(nextNo);            nextNo++;            menu_list.add(data);        }        map.put(\"message\", message);        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);    }    @PutMapping(\"/add/list\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; putMenuInfoList(@RequestBody List&lt;StoreMenuInfo&gt; dataList){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        HttpStatus status = HttpStatus.OK;        String message = \"총 \"+dataList.size()+\"개의 데이터를 입력했습니다.\";        List&lt;StoreMenuInfo&gt; errorList = new ArrayList&lt;StoreMenuInfo&gt;();        for(StoreMenuInfo data : dataList){            if(data.getName()==null || data.getName().equals(\"\")){                status = HttpStatus.BAD_REQUEST;                message = \"입력되지 않은 데이터입니다. 모든 항목을 입력해주세요. \";                message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";                errorList.add(data);            }else if(data.getPrice()==null){                status = HttpStatus.BAD_REQUEST;                message = \"입력되지 않은 데이터입니다. 모든 항목을 입력해주세요. \";                message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";                errorList.add(data);            }else if(data.getDiscount()==null){                status = HttpStatus.BAD_REQUEST;                message = \"입력되지 않은 데이터입니다. 모든 항목을 입력해주세요. \";                message += \"데이터 구조 : {name:메뉴 이름,price:가격,discount:할인률}\";                errorList.add(data);            }else{                data.setNo(nextNo);                nextNo++;                menu_list.add(data);            }        }        map.put(\"errorList\", errorList);        map.put(\"message\", message);        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map,status);    }    @GetMapping(\"/show\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getMenuInfo(@RequestParam Integer no){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        if(menu_list.size()==0){            map.put(\"message\", \"아직 제품이 등록되지 않았습니다..\");            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);        }        for(StoreMenuInfo s : menu_list){            if(s.getNo()==no){                map.put(\"manu\", s);                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }        }        map.put(\"message\", \"일치하는 제품이 존재하지 않습니다.\");        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);    }    @GetMapping(\"/show/list\")    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getMenuList(        @RequestParam @Nullable String name        ){            Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;            if(menu_list.size()==0){                map.put(\"message\", \"아직 제품이 등록되지 않았습니다.\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }            List&lt;StoreMenuInfo&gt; list = new ArrayList&lt;StoreMenuInfo&gt;();            if(name==null) list = menu_list;            else{                for(StoreMenuInfo s : menu_list){                    if(s.getName().contains(name)){                        list.add(s);                    }                }            }            if(list.size()==0){                map.put(\"message\", \"일치하는 제품이 존재하지않습니다. 검색어를 다시 확인해주세요.\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);            }            map.put(\"message\", \"총 \"+list.size()+\"개의 데이터가 조회되었습니다.\");            map.put(\"info\", list);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);        }        @PatchMapping(\"/update\")        public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; updateMenuInfo(@RequestBody StoreMenuInfo data){            Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;            if(menu_list.size()==0){                map.put(\"message\", \"아직 제품이 등록되지 않았습니다.\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }            for(StoreMenuInfo s : menu_list){                if(s.getNo()==data.getNo()){                    s.copyData(data);                    map.put(\"message\", \"데이터가 수정되었습니다\");                    return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);                }            }            map.put(\"message\", \"일치하는 제품번호가 존재하지 않습니다.\");            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);        }        @DeleteMapping(\"/delete\")        public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; deleteMenuInfo(@RequestParam Integer no){            Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;            if(menu_list.size()==0){                map.put(\"message\", \"아직 제품이 등록되지 않았습니다.\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }            for(StoreMenuInfo s : menu_list){                if(s.getNo()==no){                    menu_list.remove(s);                map.put(\"message\", \"데이터가 삭제되었습니다\");                return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);            }        }                map.put(\"message\", \"일치하는 제품 번호가 존재하지 않습니다.\");        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);    }}package com.greenart.practice7.data;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class StoreMenuInfo {    private Integer no;    private String name;    private Integer price;    private Double discount;    public void copyData(StoreMenuInfo s){        if(s.name!=null) this.name=s.name;        if(s.price!=null) this.price=s.price;        if(s.discount!=null) this.discount=s.discount;    }}/데이터 추가 삭제가 빈번히 발생해서 순서가 유지되는 ArrayList보다 LinkedList가 나음VO : Values Object, 멤버변수로만 이루어진 클래스 타입. 객체적 특성보다는 데이터 타입의 특성이 더 강조되어있음"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] JPA",
    "url": "/posts/green_jpa/",
    "categories": "JPA",
    "tags": "spring, jpa, 국비교육, ORM",
    "date": "2022-12-08 00:00:00 +0900",
    





    
    "snippet": "생성후 sql DB생성package com.greenart.dbconnect.api;import java.util.Date;import java.util.LinkedHashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.spr...",
    "content": "생성후 sql DB생성package com.greenart.dbconnect.api;import java.util.Date;import java.util.LinkedHashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;import com.greenart.dbconnect.entity.UserInfo;import com.greenart.dbconnect.respository.UserInfoRepository;@RestControllerpublic class MemberAPIController {  @Autowired UserInfoRepository repository; //bean에 매핑. controller와 repository를 연결함  @PutMapping(\"/member/join\")  public Map&lt;String, Object&gt; putMemberJoin(@RequestBody UserInfo data) {    Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();    data.setRegDt(new Date());    repository.save(data);    map.put(\"status\", true);    map.put(\"message\", \"회원이 등록되었습니다\");    return map;      }  }package com.greenart.dbconnect.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity(name = \"user_info\") //DB테이블과 class를 맵핑public class UserInfo {  @Id //primary key를 의미  @GeneratedValue(strategy = GenerationType.IDENTITY)  //GeneratedValue:주 키의 값을 위한 자동 생성 전략  //IDENTITY : 기본 키 생성을 DB에 위임(DB에 의존적)  // = 기본키 생성을 DB에 위임(=id값을 null로 하면 DB가 알아서 AUTO_INCREMENT해줌)    @Column(name = \"ui_seq\") //컬럼의 맵핑    private Integer seq;    @Column(name = \"ui_id\")    private String id;    @Column(name = \"ui_pwd\")    private String pwd;    @Column(name = \"ui_reg_dt\")    private Date regDt;    //각 칼럼 이름을 저렇게 부르겠다고 지정하는것같음.}package com.greenart.dbconnect.respository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import com.greenart.dbconnect.entity.UserInfo;@Repository //이 인터페이스가 JpaRepository임을 나타냄.public interface UserInfoRepository extends JpaRepository&lt;UserInfo,Long&gt;{  //JpaRepository : 미리 검색 메소드를 정의해둠. 호출만으로 데이터검색가능   //&lt;UserInfo,Long&gt; - 엔티티 클래스 이름, ID 필드 타임}— 책package com.greenart.practice7.data;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class BookInfo {    private Integer no;    private String title;    private Integer price;    private String writer;    public void copyData(BookInfo src){        if(src.getTitle()!=null) this.title = src.getTitle();        if(src.getPrice()!=null) this.price = src.getPrice();        if(src.getWriter()!=null) this.writer = src.getWriter();    }}package com.greenart.practice7.api;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.greenart.practice7.data.BookInfo;@RestController@RequestMapping(\"/api/book\")public class BookAPIController {    private static List&lt;BookInfo&gt; book_list = new ArrayList&lt;BookInfo&gt;();    private static Integer nextNo = 1;    @PutMapping(\"/add\")    public ResponseEntity&lt; Map&lt;String, Object&gt; &gt; addBookInfo(@RequestBody BookInfo b){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        HttpStatus status = HttpStatus.OK;        String message = \"도서정보를 추가했습니다.\";        if(b.getTitle()==null || b.getTitle().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else if(b.getPrice()==null){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else if(b.getWriter()==null || b.getWriter().equals(\"\")){            status = HttpStatus.BAD_REQUEST;            message = \"잘못된 데이터입니다. \";            message += \"데이터 구조 : {title:글제목,price:가격,writer:작가}\";        }else{            b.setNo(nextNo);            nextNo++;            book_list.add(b);        }        map.put(\"message\", message);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);    }    @GetMapping(\"/list\")    public ResponseEntity&lt; Map&lt;String, Object&gt; &gt; getBookList(        @RequestParam @Nullable Integer pageNo,        @RequestParam @Nullable String keyword,        @RequestParam @Nullable String searchType        ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();                    List&lt;BookInfo&gt; result_list = new ArrayList&lt;BookInfo&gt;();        if(pageNo==null) pageNo =1;        if(keyword==null){            result_list = book_list;        }else{                                                                 for(BookInfo b : book_list){                if(searchType==null){ //타입이 지정안됐으면 작가, 책제목 둘중하나만 같아도 list추가                    if(b.getTitle().contains(keyword) || b.getWriter().contains(keyword)){                        result_list.add(b);                    }                }else if(searchType.equals(\"title\")){                    if(b.getTitle().contains(keyword)){                        result_list.add(b);                    }                }else if(searchType.equals(\"writer\")){                    if(b.getWriter().contains(keyword)){                        result_list.add(b);                    }                }            }                    }        int totalPage = (int)Math.ceil(result_list.size()/10.0);        if(totalPage!=0 &amp;&amp; totalPage &lt; pageNo){            map.put(\"message\", \"페이지 범위를 넘어섭니다. 총 페이지 수 : \"+totalPage);            return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.BAD_REQUEST);        }        map.put(\"total\", result_list.size());        map.put(\"totalPage\", totalPage);        map.put(\"info\", result_list);        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, HttpStatus.OK);    }    // 책 여러개 등록    @PutMapping(\"/add/list\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; addBookInfoList(@RequestBody List&lt;BookInfo&gt; dataList) {        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : dataList){            b.setNo(nextNo);            book_list.add(b);            nextNo++;        }        map.put(\"message\", \"총 \"+dataList.size()+\"개의 데이터를 입력했습니다.\");        return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);    }    @PatchMapping(\"/update\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; updateBookInfo(        @RequestBody BookInfo data    ){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : book_list){            if(b.getNo()==data.getNo()){                b.copyData(data);                map.put(\"message\", \"데이터가 변경되었습니다\");                return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);            }        }        map.put(\"message\", \"잘못된 책 번호 : \"+data.getNo());        return new ResponseEntity&lt;&gt;(map,HttpStatus.BAD_REQUEST);    }    @DeleteMapping(\"/delete\")    public ResponseEntity&lt;Map&lt;String, Object&gt; &gt; deleteBookInfo(        @RequestParam Integer bookNo){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String,Object&gt;() ;        for(BookInfo b : book_list){            if(b.getNo()==bookNo){                book_list.remove(b);                map.put(\"message\", \"데이터가 삭제되었습니다\");                return new ResponseEntity&lt;&gt;(map,HttpStatus.OK);            }        }        map.put(\"message\", \"잘못된 책 번호 : \"+bookNo);        return new ResponseEntity&lt;&gt;(map,HttpStatus.BAD_REQUEST);    }}branch develop생성, branch mywork생성Spring 생성server.port=8999spring.datasource.url = jdbc:mysql://localhost:3306/spring.datasource.username = rootspring.datasource.password = 1234mysql db생성후 연결package com.green.jpa_test.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Entity(name = \"member_info\")public class MemberInfoVO {    //jpa가 _는 제대로 인식을 못함    //mi_seq;mi_id;mi_pwd;mi_name;mi_nickname;mi_reg_dt;mi_status    @Id @GeneratedValue(strategy=GenerationType.IDENTITY) //MYSQL의 AUTO_INCREMENT    @Column(name=\"mi_seq\") //기본기의 이름이 mi_seq임    private Integer seq;         @Column(name=\"mi_id\")    private String id;    @Column(name=\"mi_pwd\")    private String pwd;    @Column(name=\"mi_name\")    private String name;    @Column(name=\"mi_nickname\")    private String nickname;    @Column(name=\"mi_reg_dt\")    private Date regDt;    @Column(name=\"mi_status\")    private Integer status;}package com.green.jpa_test.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import com.green.jpa_test.entity.MemberInfoVO;@Repositorypublic interface MemberRepository extends JpaRepository&lt;MemberInfoVO, Long&gt; { //repository의 기본키 값이 Long이라 Long을 넣음    }package com.green.jpa_test;import java.util.Date;import java.util.List;import javax.transaction.Transactional;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import com.green.jpa_test.entity.MemberInfoVO;import com.green.jpa_test.repository.MemberRepository;@SpringBootTestclass JpaTestApplicationTests {\t@Autowired MemberRepository repo; //DI. 의존성 주입, MemberRepository에 해당하는 객체(bean)를 가져와서 repo안에 넣음\t//new 로 객체를 생성하지 않아도 사용가능함. \t@Test\t@Transactional //테스트 후 실행 데이터 삭제\t//아래 코드에서 수행한 insert를 수행 이전으로 되돌림\t//sql에서 확인해보니 seq 숫자는 테스트한만큼 올라감\tpublic void testMemberAdd(){\t\tMemberInfoVO data = new MemberInfoVO();\t\tdata.setId(\"user001\");\t\tdata.setPwd(\"1234\");\t\tdata.setName(\"사용자\");\t\tdata.setNickname(\"닉네임\");\t\tdata.setRegDt(new Date());\t\tdata.setStatus(1);\t\trepo.save(data); //JpaRepository에 있음\t}\t@Test\tpublic void testSelectMember(){\t\tList&lt;MemberInfoVO&gt; list =  repo.findAll(); //JpaRepository에 있음\t\tfor(MemberInfoVO m : list){\t\t\tSystem.out.println(m);\t\t}\t}}디비버에서 이렇게 해두면 아이디 코드 안적어도 중복일때 자동으로 막힘package com.green.jpa_test.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import com.green.jpa_test.entity.MemberInfoVO;@Repositorypublic interface MemberRepository extends JpaRepository&lt;MemberInfoVO, Long&gt; { //repository의 기본키 값이 Long이라 Long을 넣음    // MemberInfoVO findById(String id);    public Long countById(String id); //select count(*) from member_info where mi_id = \"\"; 자동생성해줌.     //이미 만들어진것은 커스텀하기까다로움}@Test\tpublic void idDupChkTest(){\t\tLong cnt = repo.countById(\"user001\");\t\tassertEquals(cnt,1); //cnt가 1과 동일하지않다면 \t}@PutMapping(\"/\")    public ResponseEntity&lt;Object&gt; memberJoin(@RequestBody MemberInfoVO data){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        if(repo.countById(data.getId())==1){            map.put(\"status\", false);            map.put(\"message\", data.getId()+\"은/는 이미 가입된 아이디입니다.\");            return new ResponseEntity&lt;&gt;(map, HttpStatus.NOT_ACCEPTABLE);        }        repo.save(data);        map.put(\"status\", true);        return new ResponseEntity&lt;&gt;(map, HttpStatus.CREATED);    }"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 웹페이지 생성 2",
    "url": "/posts/%EC%9B%B9_%ED%8E%98%EC%9D%B4%EC%A7%80_%EC%83%9D%EC%84%B12/",
    "categories": "Spring",
    "tags": "spring, 국비교육",
    "date": "2022-12-07 00:00:00 +0900",
    





    
    "snippet": "DI : 객체간의 관계 설정IOC : 제어 역전. 실행의 주체가 바뀜.AOP : 상속등의 개념을 적극활용 . 파편화위험있음GoF : 디자인 패턴package com.greenart.practice3;import java.util.HashMap;import java.util.Map;import org.springframework.stereotype.Co...",
    "content": "DI : 객체간의 관계 설정IOC : 제어 역전. 실행의 주체가 바뀜.AOP : 상속등의 개념을 적극활용 . 파편화위험있음GoF : 디자인 패턴package com.greenart.practice3;import java.util.HashMap;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;@Controller//DI. 의존성 주입함public class PraticeController { //싱글톤. 계속살아있고 유일함.    @GetMapping(\"/\") //DI를 할수있는 객체 생성. 스프링프레임워크가 사용하는 DI    public String getMain(Model model){        // model.addAttribute(\"user\", \"member001\");//속성추가. viewResolver가 return값과 함께 내보내줌        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"id\", \"user001\");        map.put(\"name\", \"사용자\");        model.addAttribute(\"userInfo\", map); //이거 안쓰면 에러남.        //html에서 userInfo.id를 했는데 model을 사용하지 않으면 userInfo가 null이라서 null의 id를 가져오려고 연산을 하는것.        // 최종적으로 nullpointerException이 발생함        return \"main.html\";    } //IOC 사용자가 웹페이지에 URL을 입력해야 메소드가 실행됨.    @GetMapping(\"/main\")    public String getMain2(Model model){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"name\", \"제품이름\");        map.put(\"price\", 15000);        model.addAttribute(\"product\", map);        Product p = new Product(\"제품명\", 5000);        model.addAttribute(\"product2\", p);        return \"mymain.html\";    }    // parameter {RequestParam, PathVariable}    @GetMapping(\"/param\")    public String getParamTest(Model model, @RequestParam String prodNo){        model.addAttribute(\"prodNo\", prodNo);        return \"param.html\";    }}&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;main.html &lt;span th:text=\"${user}\"&gt;&lt;/span&gt;&lt;/h1&gt;    &lt;!-- 만약 Model에 입력값이 없으면 user는 출력되지 않음(null처리됨) model은 문제가 없으나 map이나 객체였다면 에러가 남 --&gt;    &lt;h1&gt;        &lt;span th:text=\"${userInfo.id}\"&gt;&lt;/span&gt;        &lt;span th:text=\"${userInfo.name}\"&gt;&lt;/span&gt;    &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;package com.greenart.practice3;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor //모든 멤버변수를 입력받는 생성자 자동 생성@NoArgsConstructor //기본 생성자 자동 생성public class Product {    private String name;    private Integer price;}&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;mymain.html&lt;/h1&gt;    &lt;p&gt;        &lt;span th:text = \"${product.name}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product.price}\"&gt;&lt;/span&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;span th:text = \"${product2.name}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product2.price}\"&gt;&lt;/span&gt;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;param.html&lt;/h1&gt;    &lt;p th:text=\"${prodNo}\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;— get 로그인&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;main.html &lt;span th:text=\"${user}\"&gt;&lt;/span&gt;&lt;/h1&gt;    &lt;!-- 만약 Model에 입력값이 없으면 user는 출력되지 않음(null처리됨) model은 문제가 없으나 map이나 객체였다면 에러가 남 --&gt;    &lt;h1&gt;        &lt;span th:text=\"${userInfo.id}\"&gt;&lt;/span&gt;        &lt;span th:text=\"${userInfo.name}\"&gt;&lt;/span&gt;    &lt;/h1&gt;    &lt;form action=\"/login\"&gt;        &lt;input type=\"text\" name =\"id\"&gt;        &lt;input type=\"password\" name =\"pwd\"&gt;        &lt;button&gt;로그인&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1 th:text=\"${msg}\"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;@GetMapping(\"/login\")    public String getLogin(@RequestParam String id, @RequestParam String pwd, Model model){        System.out.println(id);        System.out.println(pwd);         if(id.equals(\"admin\") &amp;&amp; pwd.equals(\"1234\")){            model.addAttribute(\"msg\",\"로그인 성공했습니다\");        }else{            model.addAttribute(\"msg\", \"로그인 실패. 아이디 또는 비밀번호 오류입니다.\");        }        return \"login.html\";    }만들어준 회원리스트가 없어서 if문으로 처리원래 로그인은 get이아니라 post로 처리함. url에 아이디랑 비밀번호가 노출되면 안되기때문임.— post 로그인&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;main.html &lt;span th:text=\"${user}\"&gt;&lt;/span&gt;&lt;/h1&gt;    &lt;!-- 만약 Model에 입력값이 없으면 user는 출력되지 않음(null처리됨) model은 문제가 없으나 map이나 객체였다면 에러가 남 --&gt;    &lt;h1&gt;        &lt;span th:text=\"${userInfo.id}\"&gt;&lt;/span&gt;        &lt;span th:text=\"${userInfo.name}\"&gt;&lt;/span&gt;    &lt;/h1&gt;    &lt;form action=\"/login\" method=\"post\"&gt;        &lt;input type=\"text\" name =\"id\"&gt;        &lt;input type=\"password\" name =\"pwd\"&gt;        &lt;button&gt;로그인&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;@PostMapping(\"/login\")    public String postLogin(String id, String pwd, Model model){ //post는 @RequestParam 못씀.(쓸수는있는데 못쓴다고 알아두면됨)        //민감정보는 파라미터가 아니라 내부 홈데이터로 받도록 처리함.        System.out.println(id);        System.out.println(pwd);         if(id.equals(\"admin\") &amp;&amp; pwd.equals(\"1234\")){            model.addAttribute(\"msg\",\"로그인 성공했습니다\");        }else{            model.addAttribute(\"msg\", \"로그인 실패. 아이디 또는 비밀번호 오류입니다.\");        }        return \"login.html\";    }이것도 완전한건아님. 추적하면 바로 아이디 비번 확인가능함일단 주소창에 아이디 비번이 표시되지는 않음public String postLogin(UserInfo user, Model model){ //post는 @RequestParam 못씀.(쓸수는있는데 못쓴다고 알아두면됨)        //민감정보는 파라미터가 아니라 내부 홈데이터로 받도록 처리함.        System.err.println(user.getId());        System.err.println(user.getPwd());        if(user.getId().equals(\"admin\") &amp;&amp; user.getPwd().equals(\"1234\")){            model.addAttribute(\"msg\",\"로그인 성공했습니다\");        }else{            model.addAttribute(\"msg\", \"로그인 실패. 아이디 또는 비밀번호 오류입니다.\");        }        return \"login.html\";    }postLogin의 매개변수를 객체로 받아도 결과는 동일함. 받아야할 변수가 많을수록 객체가 효율적임.단, html의 이름과 객체의 이름이 완전히 동일해야함.            ![[IMG-20240908144934-3.png      IMG-20240908144934-3.png]]      이거 두개❗@RequestParam은 1대1매칭만 가능— 제품추가&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;main.html &lt;span th:text=\"${user}\"&gt;&lt;/span&gt;&lt;/h1&gt;    &lt;!-- 만약 Model에 입력값이 없으면 user는 출력되지 않음(null처리됨) model은 문제가 없으나 map이나 객체였다면 에러가 남 --&gt;    &lt;h1&gt;        &lt;span th:text=\"${userInfo.id}\"&gt;&lt;/span&gt;        &lt;span th:text=\"${userInfo.name}\"&gt;&lt;/span&gt;    &lt;/h1&gt;    &lt;form action=\"/login\" method=\"post\"&gt;        &lt;input type=\"text\" name =\"id\"&gt;        &lt;input type=\"password\" name =\"pwd\"&gt;        &lt;button&gt;로그인&lt;/button&gt;    &lt;/form&gt;    &lt;form action=\"/product/add\" method=\"post\"&gt;        &lt;input type=\"text\" name =\"name\"&gt;        &lt;input type=\"text\" name =\"price\"&gt;        &lt;input type=\"text\" name =\"discount\"&gt;        &lt;input type=\"text\" name =\"cate\"&gt;        &lt;button&gt;추가&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;        &lt;span th:text = \"${product.name}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product.price}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product.discount}\"&gt;&lt;/span&gt;        &lt;span th:text = \"${product.cate}\"&gt;&lt;/span&gt;    &lt;/h1&gt;    &lt;p&gt;제품 추가 완료&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;@PostMapping(\"product/add\")    public String postMain(Product p, Model model){        model.addAttribute(\"product\", p);        return \"product.html\";    }404 - URL잘못(백, 프론트 둘다 잘못된 가능성있음)405 - crud 잘못됨401 - 인증안됨415 - 프론트 잘못(json을 텍스트로 읽음)400 - 파라미터 빠짐408 - 백, 프론트 둘다 잘못된 가능성있음409 - 충돌410 - 데이터 도착실패415 - JSON요청→text도착500대 - 서버에러. 백엔드 잘못  500 - 자바코드에러  501 - 구현불가  502 - 서버터짐  503 - 서버는되는데 서비스가안됨  504 - 서버아이피부터 응답없음  508 - 서버 무한루프  [!info] HTTP response status codes - HTTP | MDNThis interim response indicates that the client should continue the request or ignore the response if the request is already finished.https://developer.mozilla.org/en-US/docs/Web/HTTP/Status200~399 - 성공자세한 번호package com.g.gg.data;import java.util.Date;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class MemberInfoVO {    private String id;    private String pwd;    private String phone;    private Date reg_dt;    private Integer status;    }package com.g.gg.api;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.g.gg.data.MemberInfoVO;@RestController //데이터 전송 전용public class APIController {    @GetMapping(\"/api/getSomething\")    public String getSomething(){        return \"something\";    }    @GetMapping(\"/api/getData\")    public Map&lt;String, Object&gt; getData(){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"status\", true);        map.put(\"code\", 200);        map.put(\"message\", \"요청이 성공했습니다.\");        return map;    }        @GetMapping(\"/api/member/add\")    public Map&lt;String, Object&gt; getAddMember(@RequestParam String id, @RequestParam String pwd, @RequestParam String phone){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        if(id.contains(\"admin\")){            map.put(\"status\", false);            map.put(\"code\", 452);            map.put(\"message\", id+\"은/는 사용할 수 없습니다.\");            return map;        }        MemberInfoVO m = new MemberInfoVO(id, pwd, phone, new Date(), 1);        map.put(\"status\", true);        map.put(\"code\", 201);        map.put(\"message\", id+\"정상적으로 등록되었습니다.\");        map.put(\"data\", m);        return map;    }    @PostMapping(\"/api/member/add\")    public Map&lt;String, Object&gt; postAddMember(@RequestBody MemberInfoVO data){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        if(data.getId().contains(\"admin\")){            map.put(\"status\", false);            map.put(\"code\", 452);            map.put(\"message\", data.getId()+\"은/는 사용할 수 없습니다.\");            return map;        }        // MemberInfoVO m = new MemberInfoVO(id, pwd, phone, new Date(), 1);        map.put(\"status\", true);        map.put(\"code\", 201);        map.put(\"message\", data.getId()+\"이 정상적으로 등록되었습니다.\");        map.put(\"data\", data);        return map;    }    @PutMapping(\"/api/member/add\")    public Map&lt;String, Object&gt; putAddMember(@RequestBody MemberInfoVO data){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        if(data.getId().contains(\"admin\")){            map.put(\"status\", false);            map.put(\"code\", 452);            map.put(\"message\", data.getId()+\"은/는 사용할 수 없습니다.\");            return map;        }        // MemberInfoVO m = new MemberInfoVO(id, pwd, phone, new Date(), 1);        map.put(\"status\", true);        map.put(\"code\", 201);        map.put(\"message\", data.getId()+\"이 정상적으로 등록되었습니다.\");        map.put(\"data\", data);        return map;    } //위에거랑 같은데 회원추가라서 굳이 따지면 put이 맞음}  [!info] API Documentation &amp; Design Tools for Teams | SwaggerSimplify API development for users, teams, and enterprises with our open source and professional toolset.https://swagger.io/API문서 관련 사이트@GetMapping(\"/product\")    public Map&lt;String, Object&gt; getProduct(){        ProductInfoVo p = new ProductInfoVo(\"제품명\", 10000, 0.2, \"prod.png\", new Date(), 100);        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"status\", true);        map.put(\"message\", \"제품조회 완료\");        map.put(\"product\", p);        return map;    }    @PutMapping(\"/product\")    public Map&lt;String, Object&gt; putProduct(@RequestBody ProductInfoVo p){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"status\", true);        map.put(\"message\", \"제품등록 완료\");        p.setReg_dt(new Date());        map.put(\"product\", p);        return map;    }@GetMapping(\"product/list\")    public Map&lt;String, Object&gt; getProductList(        @RequestParam @Nullable String keyword,        @RequestParam @Nullable Integer page,        @RequestParam @Nullable  Integer status    ){        if(keyword==null) keyword=\"\";        if(page==null) page=1;        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        String sql = \"select * from movie_info where mi_kor_title like '%\"+keyword+\"%'\";        if(status!=null){            sql+=\" and mi_status = \"+status;        }        sql += \"limit 10 offset \"+(page-1)*10;        map.put(\"sql\", sql);        return map;    }"
  },
  
  {
    "title": "[김영한 스프링 입문] 회원관리",
    "url": "/posts/%ED%9A%8C%EC%9B%90%EA%B4%80%EB%A6%AC/",
    "categories": "",
    "tags": "spring, 김영한스프링입문",
    "date": "2022-12-06 00:00:00 +0900",
    





    
    "snippet": "      비지니스 요구사항 정리          데이터 : 회원id, 이름      기능 : 회원등록, 조회      아직 테이터 저장소가 선정되지 않음.(가상 시나리오)                    회원 도메인과 리포지토리 만들기      package com.greenart.practice.domain;      import lombok.D...",
    "content": "      비지니스 요구사항 정리          데이터 : 회원id, 이름      기능 : 회원등록, 조회      아직 테이터 저장소가 선정되지 않음.(가상 시나리오)                    회원 도메인과 리포지토리 만들기      package com.greenart.practice.domain;      import lombok.Data;      @Data  public class Member {      private Long id;      private String name;          }          package com.greenart.practice.domain;      import java.util.List;  import java.util.Optional;      public interface MemberRepository {      Member save(Member member);      Optional&lt;Member&gt; findById(Long id);      Optional&lt;Member&gt; findByName(String name);      List&lt;Member&gt; findAll();  }          package com.greenart.practice.domain;      import java.util.ArrayList;  import java.util.HashMap;  import java.util.List;  import java.util.Map;  import java.util.Optional;      public class MemoryMemberRepository implements MemberRepository {          private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;();      private static long sequence = 0L;          public void clearStore(){          store.clear();      }          @Override      public Member save(Member member) {          member.setId(++sequence); //멤버 저장시 일련번호 값 1 증가          store.put(member.getId(), member);          return member;      }          @Override      public Optional&lt;Member&gt; findById(Long id) {          return Optional.ofNullable(store.get(id)); //null이라도 감싸서 반환가능      }          @Override      public Optional&lt;Member&gt; findByName(String name) {          return store.values().stream()                  .filter(member -&gt; member.getName().equals(name)) //같은 name을 가지고 있는 객체를 찾으면 반환. 없으면 null반환                  .findAny();      }          @Override      public List&lt;Member&gt; findAll() {          return new ArrayList&lt;&gt;(store.values());      }          }            회원 리포지토리 테스트 케이스 작성      package com.greenart.practice.repository;      import java.util.List;      import org.assertj.core.api.Assertions;  import org.junit.jupiter.api.AfterEach;  import org.junit.jupiter.api.Test;      import com.greenart.practice.domain.Member;  import com.greenart.practice.domain.MemoryMemberRepository;      public class MemoryMemberRepositoryTest {      MemoryMemberRepository repository = new MemoryMemberRepository();             @Test      public void save(){          Member member = new Member();          member.setName(\"Spring\");              repository.save(member);          Member result= repository.findById(member.getId()).get(); //Optional이라서 .get() 써줌          // System.out.println(result == member); //이렇게 비교하기 애매함          // Assertions.assertEquals(member, result); //테스트 통과. 초록불이 들어옴          // Assertions.assertEquals(member, null); //테스트 실패. 빨간불이 들어옴              Assertions.assertThat(member).isEqualTo(result); //요즘에 더 많이 씀          // 일치할때만 초록불인듯      }      @Test      public void findByName(){          Member member1 = new Member();          member1.setName(\"spring1\");          repository.save(member1);              Member member2 = new Member();          member2.setName(\"spring2\");          repository.save(member2);              Member result = repository.findByName(\"spring1\").get();          Assertions.assertThat(member1).isEqualTo(result);          //밑에 findAll을 추가하기 전까지 잘 작동했는데 추가후 에러가 뜸          //findAll이 먼저 수행되었기때문에 spring1, spring2가 이미 지정되어있어서 에러가 뜸          // -&gt; test가 끝날때마다 공용데이터나 저장소(repository)를 지워줘야함(아래 afterEach메소드 추가로 해결. 하나의 테스트가 끝날때마다 실행됨)      }      @AfterEach      public void afterEach(){          repository.clearStore();      }          @Test      public void findAll(){          Member member1 = new Member();          member1.setName(\"spring1\");          repository.save(member1);              Member member2 = new Member();          member2.setName(\"spring2\");          repository.save(member2);              List&lt;Member&gt; result = repository.findAll();              Assertions.assertThat(result.size()).isEqualTo(2);      }  }        구현클래스를 먼저 만들고 테스트 코드를 실행. 반대로 테스트를 먼저 작성한다면 테스트 주도 개발 = PDD 라고 부름        회원 서비스 개발      package com.greenart.practice.service;      import java.util.List;  import java.util.Optional;      import com.greenart.practice.domain.Member;  import com.greenart.practice.domain.MemberRepository;  import com.greenart.practice.domain.MemoryMemberRepository;      public class MemberService {      private final MemberRepository memberRepository = new MemoryMemberRepository();              public Long join(Member member){          //같은 이름x          // Optional&lt;Member&gt; result = memberRepository.findByName(member.getName());           //Optional을 바로 반환하는 것을 권장하지 않음(아래 메소드 참고)                  validateDuplicateMember(member);              //null이 들어올 확률이 있어서 Optional로 감싸줌. .get으로 바로 꺼내도 되나 권장하지 않음          //.orElseGet(값이 있으면 꺼내고 값이 없으면 메소드를 실행하거나 디폴트값을 꺼냄)을 써도됨.                       // result.ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원입니다.\"); // - 위에써서 주석처리함          // })/; //일치하는 회원이 있다면 로직이 동작          memberRepository.save(member);          return member.getId();      }      private void validateDuplicateMember(Member member){          memberRepository.findByName(member.getName())              .ifPresent(m-&gt;{throw new IllegalStateException(\"이미 존재하는 회원\");});                 }      //전체회원 조회      public List&lt;Member&gt; findMembers(){          return memberRepository.findAll();      }      public Optional&lt;Member&gt; findOne(Long memberId){          return memberRepository.findById(memberId);      }  }            회원 서비스 테스트  https://velog.io/@ddingmun8/test위 링크 참고해서 단축키 설정후 generate test선택, 모두 선택하고 생성하면 테스트 폴더에 파일 생성됨.package com.greenart.practice.repository;import java.util.List;import org.assertj.core.api.Assertions;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.Test;import com.greenart.practice.domain.Member;import com.greenart.practice.domain.MemoryMemberRepository;public class MemoryMemberRepositoryTest {    MemoryMemberRepository repository = new MemoryMemberRepository();       @Test    public void save(){        Member member = new Member();        member.setName(\"Spring\");        repository.save(member);        Member result= repository.findById(member.getId()).get(); //Optional이라서 .get() 써줌        // System.out.println(result == member); //이렇게 비교하기 애매함        // Assertions.assertEquals(member, result); //테스트 통과. 초록불이 들어옴        // Assertions.assertEquals(member, null); //테스트 실패. 빨간불이 들어옴        Assertions.assertThat(member).isEqualTo(result); //요즘에 더 많이 씀        // 일치할때만 초록불인듯    }    @Test    public void findByName(){        Member member1 = new Member();        member1.setName(\"spring1\");        repository.save(member1);        Member member2 = new Member();        member2.setName(\"spring2\");        repository.save(member2);        Member result = repository.findByName(\"spring1\").get();        Assertions.assertThat(member1).isEqualTo(result);        //밑에 findAll을 추가하기 전까지 잘 작동했는데 추가후 에러가 뜸        //findAll이 먼저 수행되었기때문에 spring1, spring2가 이미 지정되어있어서 에러가 뜸        // -&gt; test가 끝날때마다 공용데이터나 저장소(repository)를 지워줘야함(아래 afterEach메소드 추가로 해결. 하나의 테스트가 끝날때마다 실행됨)    }    @AfterEach    public void afterEach(){        repository.clearStore();    }    @Test    public void findAll(){        Member member1 = new Member();        member1.setName(\"spring1\");        repository.save(member1);        Member member2 = new Member();        member2.setName(\"spring2\");        repository.save(member2);        List&lt;Member&gt; result = repository.findAll();        Assertions.assertThat(result.size()).isEqualTo(2);    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 웹페이지 생성",
    "url": "/posts/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EC%83%9D%EC%84%B1/",
    "categories": "Spring",
    "tags": "spring, 국비교육",
    "date": "2022-12-06 00:00:00 +0900",
    





    
    "snippet": "!하고 탭@Controller, getTest 추가 후http://localhost:8081/test에 들어가면Hello World 뜸package com.greenart.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind....",
    "content": "!하고 탭@Controller, getTest 추가 후http://localhost:8081/test에 들어가면Hello World 뜸package com.greenart.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;//http://localhost:8081/test//http://localhost:8081 - 서버주소// /test - 매핑경로@Controllerpublic class TestContoller {    //http://localhost:8081/test를 요청했을때(웹 페이지에 접속했을때)    @GetMapping(\"/test\") //매핑경로.     public String getTest(){ //메소드 실행        System.out.println(\"요청을 받음\"); //터미널에 출력됨        return \"pages/test.html\"; //    }}model view controller→MVC위 자바 코드를 예시로 들면 contoller에서 pages/test.html파일이 return되서 view의 viewResolver한테 넘김.그럼 templates를 경로에 붙여서 view에게 최종적으로 templates/pages/test.html를 넘김경로가 잘못됐을경우 아래와같이 뜸앞뒤로 templates랑 html 붙여줌사용자(end user, front end[web], application 등) ←→ 백엔드(가공담당[data factory]) ←→ 데이터베이스(Raw data)MVC 패턴. 여기서 view(프론트)가 빠지면 Restful임[데이터 요청→데이터로(json형태) 응답]view와 controller사이에 viewResolver(thymeleaf)가 있음사용자(제품번호10번 요청) → controller→service→reoisutory(select)→DB →repository→service→controller→view→사용자  https://www.data.go.kr/  restful의 대표적인 사례bin 폴더 : binary타입.src 폴더  test폴더 - 테스트코드 저장(무결성검사 등) - TDD  main - develop          Practice3Application, ServletInitializer파일은 어지간하면 건들지말것. main안쪽에 파일을 만들어야 사용가능      static 폴더 : 별도의 지정없이 접속시 바로 실행bean - 싱글톤을 관리@controller를 붙여서 bean에 추가됨(다른폴더라도 같은이름이 2개면 에러남)뜨긴하지만 에러상태임❗static폴더에 html을 넣으면 경로지정없이 http://localhost:8080/링크로들어갔을때 바로 실행됨.만약package com.greenart.practice.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;// @RestController //viewResolver가 붙지않아서 return값이 String으로 표시됨@Controllerpublic class MainController {    //http://localhost:8080/ //static의 html의 주소와 같아서 현재 메소드가 실행됨    //@GetMapping(\"/\") - Get요청에 대한 URL매핑을 /로 하고, /로 요청이 들어오면 다음에 이어지는 메서드를 실행시킴    //Request방법 종류 - Get, Post, Delete, Patch, Put, Option    // Get 요청 - URL을 넣어서 해당하는 메소드를 실행시킴    // patch : update    // put : insert    // post : insert    // option : 선택사항(자동로그인)    @GetMapping(\"/\")     // @PostMapping(\"/\") // 브라우저에서 주소를 넣으면 에러남. Postman에서 post로 바꿔서 주소값넣으면 정상표시    public String getMain(){        return \"views/main.html\"; //file을 찾아서 파일 내용을 표시    }}이런식으로 경로 두개가 겹치면 메소드의 html이 실행됨  [!info] Download Postman | Get Started for FreeTry Postman for free!https://www.postman.com/downloads/설치package com.greenart.practice.data;import lombok.Data;@Data public class UserInfo {    private String id;    private String name;    public UserInfo(){}    public UserInfo(String id, String name){        this.id = id;        this.name = name;    }}package com.greenart.practice.data;import lombok.Data;@Datapublic class ProductInfo {    private Integer pi_seq;    private String pi_name;    private Double pi_discount_rate;    private Integer pi_price;    private Integer pi_score;    private String pi_img;}&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;views/main.html&lt;/h1&gt;    &lt;h3&gt;&lt;span th:text=\"${name}\"&gt;&lt;/span&gt;&lt;/h3&gt;    &lt;p&gt;&lt;span th:text=\"${product}\"&gt;&lt;/span&gt;&lt;/p&gt;    &lt;div&gt;        &lt;img th:src=\"${product.pi_img}\"&gt;        &lt;p th:text=\"${product.pi_name}\"&gt;        &lt;p&gt;            &lt;span th:text=\"${product.pi_discount_rate*100}\"&gt;&lt;/span&gt;%            &lt;span th:text=\"${product.pi_price}\" style=\"text-decoration:line-through\"&gt;&lt;/span&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;span th:text=\"${product.pi_price*(1-product.pi_discount_rate)}\"&gt;&lt;/span&gt;&lt;span&gt;원&lt;/span&gt;        &lt;/p&gt;         &lt;p th:text=\"${product.pi_score}\"&gt;&lt;/p&gt;    &lt;/div&gt;    &lt;p th:text=\"${userList}\"&gt;&lt;/p&gt;    &lt;table border=\"1\"&gt;        &lt;tbody&gt;            &lt;tr th:each=\"user, i : ${userList}\"&gt;                &lt;td th:text=\"${i.count}\"&gt;&lt;/td&gt;                &lt;td th:text=\"${user.id}\"&gt;&lt;/td&gt;                &lt;td th:text=\"${user.name}\"&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;package com.greenart.practice.controller;import java.util.ArrayList;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import com.greenart.practice.data.ProductInfo;import com.greenart.practice.data.UserInfo;// @RestController //viewResolver가 붙지않아서 return값이 String으로 표시됨@Controllerpublic class MainController {    @GetMapping(\"/main\")     // @PostMapping(\"/\") // 브라우저에서 주소를 넣으면 에러남. Postman에서 post로 바꿔서 주소값넣으면 정상표시    public String getMain(Model model){        model.addAttribute(\"name\", \"pjh\");        ProductInfo p = new ProductInfo();        p.setPi_seq(1);        p.setPi_name(\"하림 치킨너겟(냉동)\");        p.setPi_price(21020);        p.setPi_discount_rate(0.3);        p.setPi_score(5);        p.setPi_img(\"http://placekitten.com/80/80\");        model.addAttribute(\"product\", p);        List&lt;UserInfo&gt; userList = new ArrayList&lt;UserInfo&gt;();        userList.add(new UserInfo(\"user001\", \"일용자\"));        userList.add(new UserInfo(\"user002\", \"이용자\"));        userList.add(new UserInfo(\"user003\", \"삼용자\"));        userList.add(new UserInfo(\"user004\", \"사용자\"));        userList.add(new UserInfo(\"user005\", \"오용자\"));        model.addAttribute(\"userList\", userList);        return \"main\"; //file을 찾아서 파일 내용을 표시    }    @GetMapping(\"/main2\")    public String getMain2(Model model){        model.addAttribute(\"name\", \"pjh\");        ProductInfo p = new ProductInfo();        p.setPi_seq(1);        p.setPi_name(\"하림 치킨너겟(냉동)\");        p.setPi_price(21020);        p.setPi_discount_rate(0.3);        p.setPi_score(5);        p.setPi_img(\"http://placekitten.com/300/300\");        model.addAttribute(\"product\", p);        List&lt;UserInfo&gt; userList = new ArrayList&lt;UserInfo&gt;();        userList.add(new UserInfo(\"user001\", \"일용자\"));        userList.add(new UserInfo(\"user002\", \"이용자\"));        userList.add(new UserInfo(\"user003\", \"삼용자\"));        userList.add(new UserInfo(\"user004\", \"사용자\"));        userList.add(new UserInfo(\"user005\", \"오용자\"));        model.addAttribute(\"userList\", userList);        return \"/main\"; //매핑경로가 다르다=다른메소드를 실행한다. (위 메소드에서 보내는 데이터를 받지못함)                         // =&gt; main.html의 product와 user값이 없어서 에러남. (위에 메소드 내용을 복하면 가능함)                        //그래서 html을 탬플릿이라고 부름. 형태는 유지되지만 접근하는 url에 따라 안의 데이터는 다름    }    @GetMapping(\"/main3\")    public String getMain3(){        return \"redirect:/main\"; //main3으로 들어갔을때 main으로 강제 이동시킴. redirect가 붙으면 매핑경로를, 아니면 파일위치를 찾음        //로그인, 로그아웃에서 많이 사용됨    }}api - application programming interfacepackage com.greenart.practice.api;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class APIController {    // http://localhost:8080/api/main    @GetMapping(\"/api/main\")    public String getAPIMain(){        return \"API Main\";    }    @GetMapping(\"/api/main\")    public String getAPIMain2(){        return \"API Main2\";    }}같은 주소로 매핑시 빌드 실패함package com.greenart.practice.api;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class APIController {    // http://localhost:8080/api/main    @GetMapping(\"/api/main\")    public String getAPIMain(){        return \"[Get] API Main\";    }    @PostMapping(\"/api/main\")    public String postAPIMain(){        return \"[Post] API Main\";    }    @PutMapping(\"/api/main\")    public String putAPIMain(){        return \"[Put] API Main\";    }    @DeleteMapping(\"/api/main\")    public String deleteAPIMain(){        return \"[delete] API Main\";    }    @PatchMapping(\"/api/main\")    public String patchAPIMain(){        return \"[Patch] API Main\";    }}이건 가능스프링부트 대시보드 @GetMapping(\"/api/user_info\")    public UserInfo getAPIUserInfo(){        return new UserInfo(\"user001\", \"사용자\");    }나옴 프론트한테 여기 링크만 주면 됨URL에는 snake case를 추천함.@GetMapping(\"/api/datas\")    public Map&lt;String, Object&gt; getAPIDatas(){        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();        map.put(\"totalCnt\", 12438);        map.put(\"totalPages\", (int)Math.ceil(12438/10.0));        map.put(\"currentPage\", 1);        List&lt;UserInfo&gt; list = new ArrayList&lt;UserInfo&gt;();        list.add(new UserInfo(\"user001\", \"사용일\"));        list.add(new UserInfo(\"user002\", \"사용이\"));        list.add(new UserInfo(\"user003\", \"사용삼\"));        list.add(new UserInfo(\"user004\", \"사용사\"));        list.add(new UserInfo(\"user005\", \"사용오\"));        list.add(new UserInfo(\"user006\", \"사용육\"));        list.add(new UserInfo(\"user007\", \"사용칠\"));        map.put(\"list\", list);        return map;    }URL로 파라미터 받기//http://localhost:8080/api/parameter?productNo=84313511 이런식의 주소를 넣어야함.     @GetMapping(\"/api/parameter\")    public String getAPIParameter(@RequestParam String productNo){        return \"Received Parameter : \"+productNo;    }    //http://localhost:8080/info/?pcode=17203826&amp;cate=860 //다나와 형태    @GetMapping(\"/info\")    public String getInfo(@RequestParam String pcode, @RequestParam String cate){        return \"pcode : \"+pcode+\" / cate : \"+cate;    }//http://localhost:8080/info/?pcode=17203826&amp;cate=860 //다나와 형태    @GetMapping(\"/info\")    public String getInfo(@RequestParam String pcode, @RequestParam @Nullable String cate){ //@Nullable - null이 올수도 있음        return \"pcode : \"+pcode+\" / cate : \"+cate;    }@GetMapping(\"/myservice/aaa\")    public String getTest(){        return \"aaa\";    }    @GetMapping(\"/myservice/bbb\")     public String getTest2(Model model){        model.addAttribute(\"user\", \"user001\");        model.addAttribute(\"grade\", 1);        return \"bbb\";    }@GetMapping(\"/data/board\")    public Map&lt;String,Object&gt; getPost(){        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"board_seq\", 1);        map.put(\"title\", \"글의 제목\");        map.put(\"content\", \"글의 내용\");        return map;    }        @GetMapping(\"data/user_list\")    public Map&lt;String, Object&gt; getjson(){        List&lt;UserInfo&gt; user = new ArrayList&lt;UserInfo&gt;();        user.add(new UserInfo(\"user1\", \"일름\"));        user.add(new UserInfo(\"user2\", \"이름\"));        user.add(new UserInfo(\"user3\", \"삼름\"));        user.add(new UserInfo(\"user4\", \"사름\"));        user.add(new UserInfo(\"user5\", \"오름\"));        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"list\", user);        return map;    }"
  },
  
  {
    "title": "[김영한 스프링 입문] 웹개발 방법",
    "url": "/posts/%EC%9B%B9%EA%B0%9C%EB%B0%9C_%EB%B0%A9%EB%B2%95/",
    "categories": "Spring",
    "tags": "김영한스프링입문, spring",
    "date": "2022-12-05 00:00:00 +0900",
    





    
    "snippet": "웹개발 방법      정적 컨텐츠 : 파일을 웹브라우저에 그대로 내려줌  resources안의 static폴더안에 html을 지정해주면 메소드를 만들지않고  http://localhost:8081/test2.html 처럼 파일명을 그대로 써주면 접속 가능함.            MVC와 템플릿 엔진 : jsp 등 서버에서 프로그래밍해서 html을 동적...",
    "content": "웹개발 방법      정적 컨텐츠 : 파일을 웹브라우저에 그대로 내려줌  resources안의 static폴더안에 html을 지정해주면 메소드를 만들지않고  http://localhost:8081/test2.html 처럼 파일명을 그대로 써주면 접속 가능함.            MVC와 템플릿 엔진 : jsp 등 서버에서 프로그래밍해서 html을 동적으로 바꿔서 내려줌. view와 contoller를 쪼개서 개발  D:\\vscode\\Spring\\demo\\src\\main\\resources\\templates\\pages\\testtemplates.html처럼 파일 경로를 웹에 직접 입력해서 접근 가능함.      &lt;!DOCTYPE html&gt;  &lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;  &lt;head&gt;      &lt;meta charset=\"UTF-8\"&gt;      &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;      &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;      &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;p th:text=\"'hello ' + ${name}\"&gt;hello! empty&lt;/p&gt;  &lt;/body&gt;  &lt;/html&gt;          @GetMapping(\"/testmvc\")      public String testMVC(@RequestParam(\"name\") String name, Model model){          model.addAttribute(\"name\", name);          return \"pages/testtemplates\";      }        매개변수 name을 주소로 받음.    http://localhost:8081/testmvc?name=spring 에서 name=spring이 매개변수로 들어감            API : json이라는 데이터 포멧으로 전달      @GetMapping(\"/testapi\")      @ResponseBody //html없미 return을 그대로 표시해줌      public String getapi(@RequestParam(\"name\") String name){          return \"hello \" + name;      }            페이지에 접속해서 소스보기를하면 HTML문서가 뜨지않고 return한 내용이 그대로 표시      @GetMapping(\"/testapi2\")      @ResponseBody      public hello helloapi(@RequestParam(\"name\") String name){          hello h = new hello();          h.setname(name);          return h;      }      static class hello{          private String name;          public String getname() {              return name;          }          public void setname(String name){              this.name = name;          }      }            객체를 return했을때. json방식으로 표시됨        @responseBody를 사용하면 HTML의 BODY에 문자내용을 직접 반환. HttpMessageConverter사 동작 (기본문자처리-StringHttpMessageConverter, 기본 객체처리-MappingJackson2HttpMessageConverter), byte처리 등등 기타 여러 HttpMessageConverter가 기본등록되있음  클라이언트의 HTTP Accept해더와 서버의 컨트롤러 반환타입 정보 둘을 조합해서 HttpMessageConverter가 선택됨.  "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] Spring 환경설정",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/",
    "categories": "Spring",
    "tags": "spring, 국비교육",
    "date": "2022-12-05 00:00:00 +0900",
    





    
    "snippet": "vscode에서 해도됨  [!info] Spring InitializrInitializr generates spring boot project with just what you need to start quickly!https://start.spring.io/Dependencies에서 사진의 3가지 추가 +lombok위 설정으로 generate누르면 ...",
    "content": "vscode에서 해도됨  [!info] Spring InitializrInitializr generates spring boot project with just what you need to start quickly!https://start.spring.io/Dependencies에서 사진의 3가지 추가 +lombok위 설정으로 generate누르면 폴더 다운됨. 다운폴더 압축풀어서 vscode에 열기. 코끼리 안떠도 스프링부트만 뜨면 됨c드라이브 사용자 폴더에 .gradle안에 어지간한건 다 들어있음tomcat이 내장되어있음.DemoApplication에서 프로젝트 실행 후 아래 링크 들어가면  [!info]  http://localhost:8080/뜸❗실행한거 안끄고 또 실행하면 실행안됨.resources안의 application에서 서버 포트 설정 가능실행시 포트번호 바뀜만약 devtools가 있다면 포트번호가 바뀌었을때 자동재실행이됨. 배포전에 지우고 배포해야함resources폴더 안에 banner.txt파일 생성후 배너로 지정할 것을 입력하고 저장하면 실행시 뜨는 Spring이 변경됨https://patorjk.com/software/taag/#p=testall&amp;f=Graffiti&amp;t=Type%20Something%20여기서 양식받을수있음  [!info] Download Postman | Get Started for FreeTry Postman for free!https://www.postman.com/downloads/API 테스트를 위해 포스트맨 설치"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 날짜",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EB%82%A0%EC%A7%9C/",
    "categories": "JAVA",
    "tags": "java, 국비교육",
    "date": "2022-11-09 00:00:00 +0900",
    





    
    "snippet": "substring, splitpublic class UtilitiesEx {  public static void main(String[] args) {    String str = \"Hello world\";    System.out.println(str.substring(0,5));    System.out.println(str.substring(5)...",
    "content": "substring, splitpublic class UtilitiesEx {  public static void main(String[] args) {    String str = \"Hello world\";    System.out.println(str.substring(0,5));    System.out.println(str.substring(5));    String filename = \"data_12346513.dat\";    System.out.println(filename.substring(5));    String imgFile=\"image.jpg\";    String[] split = imgFile.split(\"\\\\.\");    String ext = split[split.length-1];    if(ext.equals(\"jpg\") || ext.equals(\"png\") || ext.equals(\"gif\"));{      System.out.println(\"이미지파일입니다.\");    }  }}Dateimport java.text.SimpleDateFormat;import java.util.Date;public class DateEx {  public static void main(String[] args) {    Date dt = new Date();    System.out.println(dt);    SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd a HH:mm:ss\"); //a - 오전, 오후    System.out.println(f.format(dt));    Date dt2 = new Date(122,10,9); //년, 월, 일, 시, 분, 초 입력가능(단 년은 연도-1900 해야함, 월은 0이 1월임)    System.out.println(f.format(dt2));    // System.out.println(dt2&lt;dt); //안됨. 에러    //자바에서 권장안하나 변수로 사용은 많이함    //1970-01-01부터 지정날짜까지 흐른 시간을 ms단위로 표시    System.out.println(dt.getTime()); //long형. Unix TimeStamp.    System.out.println(dt2.getTime()); //long형 Unix TimeStamp.    Long diff = (dt.getTime()-dt2.getTime())/1000; //ms단위라서 /1000해줌    System.out.println(diff);    System.out.println(diff/60); //분    System.out.println(diff/60/60+\"시\"); //시간    System.out.println(diff/60%60+\"분\"); //시간계산하고 남은 분 표시    Date now = new Date();    long time = now.getTime() + 30*24*60*60*1000L;     Date dt3 = new Date(time);    System.out.println(f.format(dt3));  }}import java.util.Date;import java.util.Scanner;public class DateCounterEx {  public static void main(String[] args) {    Scanner s = new Scanner(System.in);    Date now = new Date(); //현재날짜    System.out.println(\"기준 날짜를 입력하세요\");    System.out.print(\"연도 : \");    Integer year = s.nextInt()-1900;    System.out.print(\"월 : \");    Integer month = s.nextInt()-1;    System.out.print(\"일 : \");    Integer date = s.nextInt();        Date targe = new Date(year, month, date);    long diff = targe.getTime()-now.getTime();    long remain = diff/1000/60/60/24;    String suffix = remain&gt;0?\"일 남음\":\"일 지남\";    System.out.println(Math.abs(remain)+suffix);  }}calendarimport java.util.Calendar;public class CalendarEx {  public static void main(String[] args) {    Calendar c = Calendar.getInstance(); //이미 만들어진 인스턴스를 가져옴    System.out.println(c);    System.out.println(c.getTime()); //Wed Nov 09 17:05:19 KST 2022    c.add(Calendar.DATE,30); //1달 후    System.out.println(c.getTime()); //Fri Dec 09 17:05:19 KST 2022    c.add(Calendar.DATE,-60); //2달전    System.out.println(c.getTime()); //Mon Oct 10 17:06:21 KST 2022    c.set(Calendar.YEAR, 2021);    c.set(Calendar.MONTH, 10); //월은 1    c.set(Calendar.DATE, 9);    System.out.println(c.getTime()); //Tue Nov 09 17:07:24 KST 2021  }}import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.LocalTime;import java.util.ArrayList;import java.util.Calendar;import java.util.List;import java.util.Locale;import java.util.Scanner;public class CalendarEx02 {  public static void main(String[] args) {    Calendar c1 = Calendar.getInstance();    Calendar c2 = Calendar.getInstance();    c2.set(Calendar.MONTH,10);    c2.set(Calendar.DATE, 28);    System.out.println(c2.getTimeInMillis() - c1.getTimeInMillis());    long diff = c2.getTimeInMillis()-c1.getTimeInMillis();     SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd\");    int interval = (int)(diff/1000/60/60/24);    List&lt;String&gt; dates = new ArrayList&lt;String&gt;();    for(int i=0;i&lt;interval;i++){      dates.add(f.format(c1.getTime()));      c1.add(Calendar.DATE, 1);    }     Scanner s = new Scanner(System.in);    System.out.print(\"예약할 날짜 (yyyy-MM-dd) : \");    String strDt = s.nextLine();    if(dates.contains(strDt)){      System.out.println(\"선택한 날짜는 예약할 수 없습니다.\");    }else{      System.out.println(\"선택한 날짜로 예약하였습니다.\");    }    LocalDate ldt = LocalDate.now();    System.out.println(ldt); //2022-11-09 출력    LocalTime ltime = LocalTime.now();    System.out.println(ltime); //17:45:19.156900100 출력  } }"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 예외처리 - 파일입출력",
    "url": "/posts/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC_%ED%8C%8C%EC%9D%BC%EC%9E%85%EC%B6%9C%EB%A0%A5/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 예외",
    "date": "2022-11-08 00:00:00 +0900",
    





    
    "snippet": "예외처리public class ExceptionEx {  public static void main(String[] args) {    int a=10;    int b=0;    int[] arr={10,20};    try {      //예외가 발생할 수도 있는 명령문은 try안에      System.out.println(a/b);      S...",
    "content": "예외처리public class ExceptionEx {  public static void main(String[] args) {    int a=10;    int b=0;    int[] arr={10,20};    try {      //예외가 발생할 수도 있는 명령문은 try안에      System.out.println(a/b);      System.out.println(arr[3]); //ArrayIndexOutOfBoundException발생(위에코드가 예외가 뜨면 작동되지 않음)    // } catch (ArithmeticException e) { //괄호 안쪽은, 처리할 예외의 종류를 씀(산술연산 예외)     //   //a/b했을때 발생할 수 있는 예외 - ArithmeticException이므로, 여기에서 예외처리됨    //   System.out.println(\"0으로 나눌 수 없습니다.\");    }catch(ArrayIndexOutOfBoundsException e){      System.out.println(\"배열범위를 넘어섰습니다.\");    }catch(Exception e){      System.out.println(\"뭔가 터졌다\");    }  }}메소드에서 exception이 발생한다면 메소드에서 try-catch문을 사용해야함만약 메소드에 throws Exception이 있다면 밖에서 처리해줘야함public class ExceptionEx2 {  public static void main(String[] args) /* throws Exception */ { //운영체제로 예외를 던짐 -&gt; 아무 처리하지않은상태와 같음 = 실행불가    // divide(10, 0); //예외처리안해서 에러    try {      divide(10, 0);           } catch (Exception e) {      e.printStackTrace(); //어떤 오류인지 출력. ArithmeticException 출력됨      System.out.println(\"0으로 나눌 수 없음\");      return;    }finally{      System.out.println(\"예외 발생, return과 상관없이 실행\");      //try-catch구문에 return이 있어도 실행이된다. 그 외에는 finally없이 밑에 적어줘도 크게 다르지않음    }  }  public static void divide(int a, int b) throws Exception{ //밖에서 예외를 처리하라는 구문. (밖에서는 무조건 처리해야함.)    // try {      System.out.println(a/b);    // } catch (Exception e) {    //   System.out.println(\"0으로 나눌 수 없음\");    // }  }}보통 프로젝트 말미에 한꺼번에 예외처리함. 제대로 작동하는건지 try-catch가 해결해준건지 구분이안감.public class MyException extends Exception{  @Override  public String getMessage(){  return \"내가 만든 예외 클래스\";  }}import java.util.Scanner;public class ExceptionEx3 {  public static void main(String[] args) throws Exception {    Scanner s = new Scanner(System.in);    while(true){      int n = s.nextInt();      if(n==0){        throw new MyException();        //0이 입력됐을때 예외를 발생시킴. 거의안씀      }    }  }}import java.util.InputMismatchException;import java.util.Scanner;public class ExceptionEx04 {  public static void main(String[] args) {    //Error / Exception    //Error - 에러상황 복구불가    //Complie time -실행파일 만드는 시간 / Runtime - 프로그램 사용 중  시간    //Exception - 에러상황 복구가능    //예외처리 - Exception이 발생했을때 대체코드를 실행함.    // Scanner s = new Scanner(System.in);    // try{    //   System.out.print(\"최소 : \");    //   int min = s.nextInt();    //   System.out.print(\"최대 : \"); //위에서 Exception이 일어나면 실행되지않음    //   int max = s.nextInt();    // }catch(InputMismatchException e){    //   System.out.println(\"정수만 입력가능합니다.\");    // }    // // System.out.println(\"min : \"+min+\" / max : \"+max); //try-catch안에있어서 min, max 사용 불가    // System.out.println(\"실행 후 문자열 출력\");    Scanner s = new Scanner(System.in);    int min=0, max=0;    String input = \"\"; //차라리 String으로 받아서 변환하는게 나을수도있음    input = s.nextLine();        int num = Integer.parseInt(input);    System.out.println(num);    try{      System.out.print(\"최소 : \");      min = s.nextInt();    }catch(InputMismatchException e){      System.out.println(\"정수만 입력가능합니다.\");      min=0;    }finally{      s.nextLine(); //위에서 에러가나서 처리하지못했을때 처리하지못한 문자열을 max가 먹음      //성공여부에 상관없이 finally구분이 필요해짐    }    try{      System.out.print(\"최대 : \");       max = s.nextInt();    }catch(InputMismatchException e){      System.out.println(\"정수만 입력가능합니다.\");      max = 255;    };     System.out.println(\"min : \"+min+\" / max : \"+max);    System.out.println(\"실행 후 문자열 출력\");    s.close();      }  }public class ExceptionEx07 {  public static final int MAX_VAlUE = 255;  public static void main(String[] args) throws Exception{    // try{      myMethod(0);      myMethod(1);      myMethod(2);      myMethod(10);      myMethod(1000);    // }catch(Exception e){    //   System.out.println(e.getMessage());    // }  }  public static void myMethod(int n) throws Exception {    if(n&gt;MAX_VAlUE){      //예외 객체를 만들어서 throw      throw new Exception(\"최대값을 초과합니다. 최댓값 : \"+MAX_VAlUE);    }      System.out.println(\"n : \"+n);  }}      아이디      public class MemberInfo {    public static final int MIN_LENGTH=6;    private String id;    private String pwd;            public String getId() {      return this.id;    }        public void setId(String id) throws Exception {      if(id.length()&lt;MIN_LENGTH){        throw new InputValueLengthException();      }      this.id = id;    }          public String getPwd() {      return this.pwd;    }          public void setPwd(String pwd) throws Exception {      if(pwd.length()&lt;MIN_LENGTH){        throw new InputValueLengthException();      }      this.pwd = pwd;    }      }          public class InputValueLengthException extends Exception {    @Override    public String getMessage() {      return \"Input value's length is must more than 6\";    }        }          public class MemberMain {    public static void main(String[] args) throws Exception {      MemberInfo m = new MemberInfo();      m.setId(\"aaaa\");       m.setId(\"aaaaaaa\");     }  }      파일입출력import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class InputOutputEx {  public static void main(String[] args) throws Exception {    // InputStream input = new InputStream; //추상클래스라서 객체생성 불가    // OutputStream output = new OutputStream(); //추상클래스라서 객체생성 불가    //파일읽어오기    BufferedReader reader = new BufferedReader( //속도향상을 위한 메모리 임시공간 제공      new InputStreamReader(        new FileInputStream(          //상대경로방식의 표현방법(애매함)          //리눅스시스템의 명령어 입력시 많이사용          new File(\"aaa.txt\")           // new File(\"../aaa.txt\") //상위폴더를 가르킴          // new File(\"../../aaa.txt\") //상위폴더의 상위폴더          //절대경로표시법          // new File(\"/aaa.txt\") //드라이브의 최상위(루트디렉토리)를 찾음.(현재예시에서는 D드라이브)          // new File(\"D:/Students/jinhee/aaa.txt\") //드라이브의 최상위(루트디렉토리)를 찾음.(현재예시에서는 D드라이브)        )      )    );    System.out.println(reader.read()); //76출력.     System.out.println((char)reader.read()); //L출력.    System.out.println((char)reader.read()); //o출력.    System.out.println((char)reader.read()); //r출력.    System.out.println((char)reader.read()); //e출력.    System.out.println((char)reader.read()); //m출력.    System.out.println((char)reader.read()); //,출력.    System.out.println((char)reader.read()); //i출력.    System.out.println((char)reader.read()); //p출력.    System.out.println(reader.readLine());//sum dolor sit amet consectetur adipisicing....(생략) 출력. 한줄읽어오기    System.out.println(reader.readLine());    System.out.println(reader.readLine());    System.out.println(reader.readLine());        reader.close(); //꼭 닫아야함    BufferedWriter writer = new BufferedWriter(      new OutputStreamWriter(        new FileOutputStream(          new File(\"bbb.txt\"),true //실행할때마다 hello world추가됨        )      )    );    writer.write(\"hello world\");    writer.flush();    writer.close();  }}엑셀파일로 내보낼때 자주 쓰나 라이브러리가있음..      제품파일      import java.security.PublicKey;      public class Product {    public String name;    public Integer price;    public Integer stock;        @Override    public String toString() {      return name+\",\"+price+\",\"+stock;    }  }          import java.io.BufferedWriter;  import java.io.File;  import java.io.FileNotFoundException;  import java.io.FileOutputStream;  import java.io.OutputStreamWriter;      public class FileEx01 {    public static void main(String[] args) throws Exception {      //출력(파일에 쓰기)      // BufferedWriter w = new BufferedWriter(      //   new OutputStreamWriter(      //     new FileOutputStream(      //       // new File(\"a.txt\")//재실행시 덮어쓰기함.      //       new File(\"a.txt\"),true //true - 뒤에 문자열 추가      //     ), \"UTF-8\" //출력형식 지정      //   )      // );          // w.write(\"안녕하세요\");      // w.close();      // File f = new File(\"b.txt\");      // File f = new File(\"a.txt\");      File f = new File(\"prod.csv\"); //엑셀 파일형식      FileOutputStream os = new FileOutputStream(f);      // OutputStreamWriter osw = new OutputStreamWriter(os, \"MS949\"); //텍스트 엑셀호환타입      OutputStreamWriter osw = new OutputStreamWriter(os, \"UTF-8\"); //터미널출력을위해 UTF-8로 바꿈      BufferedWriter writer = new BufferedWriter(osw);      // writer.write(\"안녕\");      // writer.close();      // writer.write(\"name,price,stock\\r\\n\");      for(int i =0;i&lt;50;i++){        Product p = new Product();        p.name = \"제품\"+i;        p.price = 20000;        p.stock = 100;        writer.write(p.toString()+\"\\r\\n\"); //\"\\r\\n\" - 파일에서 다음 줄로 이동. \\r이 커서를 맨 앞으로 옮김          }      writer.close();              }  }          import java.io.BufferedReader;  import java.io.File;  import java.io.FileInputStream;  import java.io.InputStreamReader;  import java.util.ArrayList;  import java.util.List;  import java.util.Scanner;      public class FileEx02 {    public static void main(String[] args) throws Exception {      //파일 읽어오기      BufferedReader reader = new BufferedReader(        new InputStreamReader(          new FileInputStream(            new File(\"prod.csv\")          ),\"UTF-8\"        )      );      // String line=\"\";      // while(line!=null){      //   line = reader.readLine();      //   System.out.println(line);      // }      List&lt;Product&gt; plist = new ArrayList&lt;Product&gt;();      while(true){        String line = reader.readLine();        if(line == null) break;        String[] split = line.split(\",\");        Product p = new Product();        p.name = split[0];        p.price = Integer.parseInt(split[1]);        p.stock = Integer.parseInt(split[2]);        plist.add(p);        System.out.println(p);        // for(String s : line.split(\",\")){ //길이가 3인 배열 나옴          //   System.out.println(s); //모든 요소가 잘려서 출력          // }        }        for(Product p : plist){          System.out.println(\"제품명 : \"+p.name+\" / 가격 : \"+p.price+\" / 재고 : \"+p.stock);        }        reader.close();                  Scanner s = new Scanner(new File(\"prod.csv\")); //파일안쪽의 내용을 읽는 용도로 Scanner를 사용        while(true){          String line = \"\";          try{            line = s.nextLine();          }catch(Exception e){            break;          }          if(line == null) break;          System.out.println(line);        }        s.close();    }  }      "
  },
  
  {
    "title": "자바의 정석 연습문제 9장 - java.lang패키지와 유용한 클래스",
    "url": "/posts/9%EC%9E%A5/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제",
    "date": "2022-11-07 00:00:00 +0900",
    





    
    "snippet": "[9-1] equals를 맴버변수인 num과 isKwang을 비교하도록 오버라이딩public class Ex9_1{    public static void main(String[] args) {        SutdaCard c1 = new SutdaCard(3, true);        SutdaCard c2 = new SutdaCard(3, tru...",
    "content": "[9-1] equals를 맴버변수인 num과 isKwang을 비교하도록 오버라이딩public class Ex9_1{    public static void main(String[] args) {        SutdaCard c1 = new SutdaCard(3, true);        SutdaCard c2 = new SutdaCard(3, true);        System.out.println(\"c1 = \"+c1);        System.out.println(\"c2 = \"+c2);        System.out.println(\"c1.equals(c2) : \"+c1.equals(c2));    }}class SutdaCard{    int num;    boolean isKwang;    public SutdaCard(){        this(1,true);    }    public SutdaCard(int num, boolean isKwang) {        this.num = num;        this.isKwang = isKwang;    }    public boolean equals(Object obj){        if(obj instanceof SutdaCard){            SutdaCard c = (SutdaCard)obj;            return this.num==c.num &amp;&amp; this.isKwang == c.isKwang;        }else{            return false;        }    }    public String toString(){        return num+(isKwang?\"K\":\"\");    }}먼저 매개변수로 받은 obj가 어떤 클래스인지를 확인한 후 비교해줌[9-2] equals를 오버라이딩해서 멤버변수 x,y,z를 비교하도록 만들고 toSring을 오버라이딩public class Ex9_2 {    public static void main(String[] args) {        Point3D p1 = new Point3D(1,2,3);        Point3D p2 = new Point3D(1,2,3);        System.out.println(p1);        System.out.println(p2);        System.out.println(\"p1==p2?\"+(p1==p2));        System.out.println(\"p1.equals(p2)?\"+(p1.equals(p2)));    }    }class Point3D{    int x, y, z;    Point3D(int x, int y, int z){        this.x = x;        this.y = y;        this.z = z;    }    Point3D(){        this(0,0,0);    }    public boolean equals(Object obj){        if(obj instanceof Point3D){            Point3D p = (Point3D)obj;            return this.x == p.x &amp;&amp; this.y==p.y &amp;&amp; this.z==p.z;        }else{            return false;        }    }    public String toString(){        return \"[\"+x+\", \"+y+\", \"+z+\"]\";    }}위와 동일한 문제[9-3] 문자열을 잘라내는 문제public class Ex9_3 {    public static void main(String[] args) {        String fullPath = \"c:\\\\jdk1.5\\\\work\\\\PathSeparateTest.java\";        String path=\"\";        String fileName = \"\";        path = fullPath.substring(0,14);        fileName=fullPath.substring(15);        System.out.println(fullPath);        System.out.println(path);        System.out.println(fileName);    }}subString을 사용했다답지코드public class Ex9_3 {    public static void main(String[] args) {        String fullPath = \"c:\\\\jdk1.5\\\\work\\\\PathSeparateTest.java\";        String path=\"\";        String fileName = \"\";        // path = fullPath.substring(0,14);        // fileName=fullPath.substring(15);        int pos = fullPath.lastIndexOf(\"\\\\\");        if(pos!=-1){            path = fullPath.substring(0, pos);            fileName = fullPath.substring(pos+1);        }        System.out.println(fullPath);        System.out.println(path);        System.out.println(fileName);    }}subString으로 잘라낸 것은 동일하나 lastIndexOf를 사용해서 마지막 문자열부터 “\\”을 검색해서 가장 뒤쪽에 있는 \\의 위치를 인덱스값으로 받아왔다. (해당 값이 없으면 -1이 반환된다)[9-4]배열의 담긴 값만큼 가로로 입력받은 char형 문자를 찍어내는 메소드를 작성하는 문제public class Ex9_4 {    public static void main(String[] args) {        printGraph(new int[]{3,7,1,4}, '*');    }    public static void printGraph(int[] dateArr, char ch){        for(int i=0;i&lt;dateArr.length;i++){            for(int j=0;j&lt;dateArr[i];j++){                System.out.print(ch);            }            System.out.print(dateArr[i]);            System.out.println();        }    }}[9-5]주어진 문자열에 특정 문자가 몇번 포함되는지 구하는 메소드를 작성하는 문제public class Ex9_5 {    public static void main(String[] args) {        System.out.println(count(\"12345AB12AB345AB\", \"AB\"));        System.out.println(count(\"12345\",\"AB\"));    }    public static int count(String src, String target){        int count=0;        int pos=0;        while(pos&lt;src.length()){            pos=src.indexOf(target, pos);            if(pos!=-1){                count++;                pos += target.length();            }else{                break;            }        }        return count;    }}처음엔 for문을 이용하다가 i값을 pos로 바꿨다가 i++도 의미가 없다는 것을 깨달아서 그냥 while문으로 변경했다. 처음엔 else에 pos++을 넣었다가 무한반복에 빠져서 고민해보니 그냥 종료시키면되는거였다. 한번 검사했는데 없으면 그냥 없는거니까.. 너무 for문에 익숙해져서 실수한것같다.[9-6] 문자열과 문자열의 길이를 받아 오른쪽 정렬로 문자열을 정렬했을때 남는 왼쪽 빈공간에 0을 넣는 메소드를 작성import java.util.Arrays;public class Ex9_6 {    public static void main(String[] args) {        String src = \"12345\";        System.out.println(fillZero(src, 10));        System.out.println(fillZero(src, -1));        System.out.println(fillZero(src, 3));    }    public static String fillZero(String src, int length){        String result=\"\";        if(src==null || src.length()==length){            return src;        }else if( length&lt;=0){            return \"\";        }else if(src.length()&gt;length){            return src.substring(0, length);        }else{            char[] c = new char[length];            Arrays.fill(c, '0');            int idx = src.length()-1;            for(int i=c.length-1;idx&gt;=0;i--)            {                c[i]=src.charAt(idx--);            }            result = String.valueOf(c);            return result;        }    }}되긴되는데 뭔가 for문을 쓰라고 만들어진 문제가 아닌거같은느낌.. arraycopy를 써볼까?import java.util.Arrays;public class Ex9_6 {    public static void main(String[] args) {        String src = \"12345\";        System.out.println(fillZero(src, 10));        System.out.println(fillZero(src, -1));        System.out.println(fillZero(src, 3));    }    public static String fillZero(String src, int length){        String result=\"\";        if(src==null || src.length()==length){            return src;        }else if( length&lt;=0){            return \"\";        }else if(src.length()&gt;length){            return src.substring(0, length);        }else{            char[] c = new char[length];            Arrays.fill(c, '0');            System.arraycopy(src.toCharArray(), 0, c, length-src.length(), src.length());            result = String.valueOf(c);            return result;        }    }}성공했당[9-7] 문자열에 특정 문자열이 있는지 검사하는 메소드public class Ex9_7 {    public static void main(String[] args) {        System.out.println(contains(\"12345\", \"23\"));        System.out.println(contains(\"12345\", \"67\"));    }    public static boolean contains(String src, String target){        if(src.indexOf(target)&lt;0){            return false;        }else{            return true;        }    }}[9-8] 주어진 자리수만큼 반올림하는 메소드를 작성. Math.round와 Math.pow(제곱함수)사용public class Ex9_8 {    public static void main(String[] args) {        System.out.println(round(3.1415, 1));        System.out.println(round(3.1415, 2));        System.out.println(round(3.1415, 3));        System.out.println(round(3.1415, 4));        System.out.println(round(3.1415, 5));    }    public static double round(double d, int n){        return Math.round(d*Math.pow(10, n))/Math.pow(10, n);    }}[9-9] 문자열에서 금지된문자를 제거하고 반환하는 메소드를 작성public class Ex9_9 {    public static void main(String[] args) {        System.out.println(\"(1!2@3^4~5)\"+\" -&gt; \"+delChar(\"1!2@3^4~5\", \"~!@#$%^&amp;*()\"));        System.out.println(\"1 2    3    4\\t5\"+\" -&gt; \"+delChar(\"1 2    3    4\\t5\", \" \\t\"));    }    public static String delChar(String src, String delCh){        String result=\"\";        for(int i=0;i&lt;src.length();i++){            char c = src.charAt(i);            if(delCh.indexOf(c)==-1){                result += c;            }        }        return result;    }}문제에 StringBuffer를 사용하라는데 필요성을 잘 못느끼겠어서 일단 그냥해보았다. append를 써서 없는 문자열을 연결시키면될거같긴한데 굳이 이렇게 할 이유가 있나?public class Ex9_9 {    public static void main(String[] args) {        System.out.println(\"(1!2@3^4~5)\"+\" -&gt; \"+delChar(\"1!2@3^4~5\", \"~!@#$%^&amp;*()\"));        System.out.println(\"1 2    3    4\\t5\"+\" -&gt; \"+delChar(\"1 2    3    4\\t5\", \" \\t\"));    }    public static String delChar(String src, String delCh){        StringBuffer sb = new StringBuffer(src.length());        for(int i=0;i&lt;src.length();i++){            char c = src.charAt(i);            if(delCh.indexOf(c)==-1){                sb.append(c);            }        }        return sb.toString();    }}일단 변환해주었다.[9-10] 문자열을 왼쪽정렬, 가운데정렬, 오른쪽정렬하는 메소드를 작성하라  1차시도(개선필요)import java.util.Arrays;public class Ex9_10 {    public static void main(String[] args) {        String str = \"가나다\";        System.out.println(format(str,7,0));        System.out.println(format(str,7,1));        System.out.println(format(str,7,2));            }    public static String format(String str, int length, int alignment){        if(length&lt;str.length()){            return str.substring(0, length);        }else{            char[] c = new char[length];            Arrays.fill(c, '.');            char[] sarr = str.toCharArray();            String result=\"\";            if(alignment==0){                System.arraycopy(sarr, 0, c, 0, sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else if(alignment==1){                System.arraycopy(sarr, 0, c, c.length/str.length(), sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else if(alignment==2){                System.arraycopy(sarr, 0, c, c.length-str.length(), sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else{                System.out.println(\"번호를 잘못입력하셨습니다\");            }            return result;        }    }}보기좋으라고 c배열을 공백이아닌 .으로 처리했다. 일단 값은 나오는데 배열값이 커지면 뭐랄까.. 3분의 1정도에 위치한다고해야하나.. 이식은 잘못된듯  2차시도(성공)import java.util.Arrays;public class Ex9_10 {    public static void main(String[] args) {        String str = \"가나다\";        System.out.println(format(str,7,0));        System.out.println(format(str,70,1));        System.out.println(format(str,7,2));            }    public static String format(String str, int length, int alignment){        if(length&lt;str.length()){            return str.substring(0, length);        }else{            char[] c = new char[length];            Arrays.fill(c, '.');            char[] sarr = str.toCharArray();            String result=\"\";            if(alignment==0){                System.arraycopy(sarr, 0, c, 0, sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else if(alignment==1){                System.arraycopy(sarr, 0, c, (c.length-str.length())/2, sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else if(alignment==2){                System.arraycopy(sarr, 0, c, c.length-str.length(), sarr.length);                for(int i=0;i&lt;length;i++){                    result+=c[i];                }            }else{                System.out.println(\"번호를 잘못입력하셨습니다\");            }            return result;        }    }}length가 11이라면 11-x = 4, 7이라면 7-x = 2, 5-x = 1…하면서 여러 식을 써보고있었는데 갑자기 5-str.length는 2인데 /1하면 안되나 하고 다른식에 적용해보았더니 됐다!! 정확히 중간에 위치함[9-11] 입력받은 숫자의 범위만큼 구구단을 출력하는 메소드를 작성하는 문제import java.util.Scanner;public class Ex9_11 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        int start = s.nextInt();        int end = s.nextInt();        gugudan(start, end);            }    public static void gugudan(int start, int end){        for(int i=start;i&lt;=end;i++){            for(int j=1;j&lt;=9;j++){                System.out.println(i+\" x \"+j+\" = \"+i*j);            }            System.out.println();        }    }}간단한 문제다[9-12] 범위를 지정하고 범위 내 랜덤값 뽑는 메소드 작성. 단, 범위 시작보다 범위 끝이 작을 수도 있음public class Ex9_12 {    public static void main(String[] args) {        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, -3)+\",\");        }    }    public static int getRand(int from, int to) {        int r = (int)(Math.random()*to);        return r;    }}일단 일반적으로 하던 방법으로 시도해보았다 당연히 안된다. 나와야하는 값은 1~-3인데 0~-2가 나온다. 범위값을 1추가해주는 것이 좋을 듯 하다. 문제의 main문에 to가 음수이니까 단순히 +1을 해주면 안될것같다.public class Ex9_12 {    public static void main(String[] args) {        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, -3)+\",\");        }    }    public static int getRand(int from, int to) {        int r = (int)(Math.random()*(Math.abs(to)+1));        return r;    }}일단 범위를 보기위해 실행해보았는데 역시 양수로 나온다. 음수로 전환할 방법이 필요하다현 상태에서 나오는 범위는 0~3. 음수로 변환만 해주면 된다. 간단하게 +to를 하면 안되나?public class Ex9_12 {    public static void main(String[] args) {        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, -3)+\",\");        }        System.out.println();        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, 10)+\",\");        }    }    public static int getRand(int from, int to) {        int r = (int)(Math.random()*(Math.abs(to)+1))+to;        return r;    }}음수값은 제대로 나오지만 to에 양수가 나왔을때 범위가10~20이다 음수일떄만 +to를 해주도록 if문을 사용해도 될것같지만.. 뭔가 마음에드는 방법이 아니라 고민이다. 문제를 자세히보니 나오는 범위가 1~-3이다 충격import java.text.Normalizer.Form;public class Ex9_12 {    public static void main(String[] args) {        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, -3)+\",\");        }        System.out.println();        for(int i=0;i&lt;20;i++){            System.out.print(getRand(1, 10)+\",\");        }    }    public static int getRand(int from, int to) {        int r = (int)(Math.random()*(Math.abs(to)+1))+(Math.min(from, to));        return r;    }}처음엔 삼항연산자를 사용했다가 Math의 min을 사용해서 더 작은 수를 더하도록 만들었다"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 컬렉션 프레임워크 2",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EC%BB%AC%EB%A0%89%EC%85%98%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC2/",
    "categories": "JAVA",
    "tags": "java, 국비교육, collection",
    "date": "2022-11-03 00:00:00 +0900",
    





    
    "snippet": "Hash Map!!프론트엔드에 데이터를 넘겨줄때 사용이걸로 출력하면 JSON으로 출력됨.import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class MapEx{  public static void main(String[] args) {    //Key,...",
    "content": "Hash Map!!프론트엔드에 데이터를 넘겨줄때 사용이걸로 출력하면 JSON으로 출력됨.import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;public class MapEx{  public static void main(String[] args) {    //Key, Value    //특정 key에 특정 값을 mapping(연결)    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();    map.put(\"asdf\", 1234); //추가    System.out.println(map); //{asdf=1234}    map.put(\"ffff\", 1111); //추가    System.out.println(map); //{asdf=1234, ffff=1111}    System.out.println(map.get(\"asdf\")); //1234 출력 키 값 \"asdf\"의 value 가지고오기    System.out.println(map.get(\"ffff\")); //1111 출력 키 값 \"ffff\"의 value 가지고오기    //key를 넣으면 연결된 값이 나옴    map.put(\"asdf\", 100); //변경    System.out.println(map); //{asdf=100, ffff=1111} 이미 있는 asdf에 100을 새로 연결시킴.    //Map에서 key값은 중복을 허용하지 않음.    map.put(\"ASDF\", 50); //추가    System.out.println(map); //{asdf=100, ASDF=50, ffff=1111} 대문자, 소문자는 따로 연결됨.    //같은 put이라도 추가, 변경이 나뉨.    map.put(\"a\", 100);    map.put(\"A\", 100);    System.out.println(map); //{a=100, A=100, asdf=100, ASDF=50, ffff=1111} 정확한 기준은 모르지만 추가순으로 추가되는것은 아님    //데이터의 순서가 중요하면 사용하면 안됨        Map&lt;String, Integer&gt; mapLink = new LinkedHashMap&lt;String, Integer&gt;(); //추가한 순서대로 추가가됨.    mapLink.put(\"c\", 123);    mapLink.put(\"A\", 123);    mapLink.put(\"b\", 123);    System.out.println(mapLink); //{c=123, A=123, b=123} 입력순    Map&lt;String, String&gt; user = new LinkedHashMap&lt;String, String&gt;();    user.put(\"id\", \"user001\");    user.put(\"pwd\",\"123456\");    System.out.println(user); //{id=user001, pwd=123456}    Map&lt;String,Integer&gt; dataMap = new LinkedHashMap&lt;String, Integer&gt;();    for(int i=0;i&lt;10;i++){      dataMap.put(\"data\"+i, i);    }    System.out.println(dataMap); //{data0=0, data1=1, data2=2, data3=3, data4=4, data5=5, data6=6, data7=7, data8=8, data9=9}    for(int i=0;i&lt;10;i++){      System.out.print(dataMap.get(\"data\"+i)+\", \"); //0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 출력. 일치하는 key의 value출력    }    System.out.println();    Map&lt;String,Integer&gt; dataMap2 = new LinkedHashMap&lt;String, Integer&gt;();    dataMap2.put(\"ab\", 10);    dataMap2.put(\"gdfafa\", 10);    dataMap2.put(\"ghfsqw\", 10);    dataMap2.put(\"hfsvs\", 10);    dataMap2.put(\"hthcae\", 10);    System.out.println(dataMap2); //{ab=10, gdfafa=10, ghfsqw=10, hfsvs=10, hthcae=10} 출력    //key의 규칙이 없어서 일반 반복문으로는 조회불가    System.out.println(dataMap2.keySet()); //[ab, gdfafa, ghfsqw, hfsvs, hthcae] 출력. key값의 배열    System.out.println(dataMap2.keySet().toArray()); //[Ljava.lang.Object;@5305068a 출력    //키 값에 대한 Object 배열을 저장    Object[] keys = dataMap2.keySet().toArray();    for(Object k : keys){ //keys배열을 순차 조회      System.out.print(k+ \", \"); //ab, gdfafa, ghfsqw, hfsvs, hthcae, 출력      //조회한 object를 문자열로 변환, 출력    }    for(Object k : keys){       System.out.println(k.toString()); //ab, gdfafa, ghfsqw, hfsvs, hthcae, 출력      System.out.println(dataMap2.get(k.toString())); //10 10 10 10 10 출력    }    //일반적인 방법이 아님. 가능은 하다 정도  }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 객체지향언어 2",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A52/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 객체",
    "date": "2022-11-03 00:00:00 +0900",
    





    
    "snippet": "상속 : 클래스의 확장. 프레임워크를 개발할때 많이사용함. 그외에는 잘안씀해당 클래스를 아무도 상속받지못하게하려면 final을 사용하면됨포함 : 클래스안에 클래스. 대표적으로 String      도형      public class Point {    int x,y;    public Point(){}    public Point(int x, int...",
    "content": "상속 : 클래스의 확장. 프레임워크를 개발할때 많이사용함. 그외에는 잘안씀해당 클래스를 아무도 상속받지못하게하려면 final을 사용하면됨포함 : 클래스안에 클래스. 대표적으로 String      도형      public class Point {    int x,y;    public Point(){}    public Point(int x, int y){      this.x = x;      this.y = y;    }    void printPoint(){      System.out.println(\"(\"+x+\", \"+y+\")\");    }      }          public class Point3D extends Point {    int z;    public Point3D(){}    public Point3D(int x, int y, int z){      super(x,y);      this.z = z;    }    void printPoint(){      System.out.println(\"(\"+x+\", \"+y+\", \"+z+\")\");    }      }          public class Circle extends Point {    double r;    public Circle(){}    public Circle(int x, int y, double r){      super(x, y);      this.r = r;    }    double getArea(){      return r*r*Math.PI;    }    void printPoint(){      System.out.println(\"(\"+x+\", \"+y+\") r: \"+r);    }  }          public class Rectangle extends Point {    int width;    int height;    public Rectangle(){}    public Rectangle(int x, int y, int width, int height){      super(x, y);      this.width = width;      this.height = height;    }    int getArea(){      return width * height;    }    void printPoint(){      System.out.println(\"(\"+x+\", \"+y+\") w: \"+width+\" / h: \"+height);    }  }            USB      import java.util.ArrayList;  import java.util.Date;  import java.util.List;      public class USBMain {    public static void main(String[] args) {      USBDevice d1 = new USBMouse(\"A\",\"2.0\",\"laser\",\"no\");      d1.input();      d1.output(); //오버라이딩 본문안에 구현을 안해놔서 상위클래스의 output실행      // d1.mousewheel(); //에러. USBDevice에는 mousewheel없음      // d1.sensor;//안됨. USBDevice에서는 하위클래스의 메소드 유무를 판단할수없음      ((USBMouse)d1).mousewheel();      ((USBMouse)d1).wireless=\"asd\";              List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //List가 부모, ArrayList가 자식. 상속과 다형성.       //LinkedList로 바꿔도 작동했던게 list는 부모클래스인 List의 변수라서              Object obj = new String(\"aaa\");      Object obj1 = new Date();      Object obj2 = new ArrayList&lt;String&gt;();      Object obj3 = new USBMouse();          // obj.add(\"a\"); //불가능      // obj3.input(); //불가능      System.out.println(obj.toString()); //Object로 유일하게 가능한 것      System.out.println();              System.out.println(obj); //aaa      System.out.println(obj1); //Thu Nov 03 16:50:44 KST 2022      System.out.println(obj2); //[]      System.out.println(obj3); //USBMouse@1b28cdfa -&gt; 오버라이딩 후 : 마우스 정보 출력 출력됨      //오버라이딩 된 toString이 있다면 해당 toString형식에 맞춰서 출력됨            }  }            직업 상속      public class Person {    String name;    String gen;        public Person(){}    public Person(String name, String gen){      this.name = name;      this.gen = gen;    }        void work(){      System.out.println(\"일을 시작합니다.\");    }        public String toString() {      return \"이름 : \"+name+\" / 성별 : \"+gen;    }  }          public class Developer extends Person {    String language; //프로그래밍언어        public Developer(){      //super()가 생략된 상태. 다 만들거나 다 만들지 말거나    }    public Developer(String name, String gen, String language){      super(name, gen);      this.language = language;    }    @Override    void work(){      super.work();      System.out.println(\"개발자 \"+name+\"가(이) \"+language+\"(으)로 프로그램을 개발한다.\");    }  }          public class Designer extends Person {    String tool; //사용 툴        public Designer(){      //super()가 생략된 상태. 다 만들거나 다 만들지 말거나    }    public Designer(String name, String gen, String tool){      super(name, gen);      this.tool = tool;    }        @Override    void work(){      super.work();      System.out.println(\"디자이너 \"+name+\"가(이) \"+tool+\"(으)로 디자인을 한다.\");    }  }          public class PersonMain {    public static void main(String[] args) {              Person[] persons ={        new Person(\"박진희\", \"여\"),        new Designer(\"박진희\", \"여\",\"photoshop\"),        new Developer(\"박진희\", \"여\",\"JAVA\")      };      for(Person p : persons){        System.out.println(p.toString());        p.work();        System.out.println();      }       /*이름 : 박진희 / 성별 : 여      일을 시작합니다.                이름 : 박진희 / 성별 : 여        일을 시작합니다.        디자이너 박진희가(이) photoshop(으)로 디자인을 한다.                  이름 : 박진희 / 성별 : 여        일을 시작합니다.        개발자 박진희가(이) JAVA(으)로 프로그램을 개발한다.*/ //출력됨                  //Person클래스 타입으로 Developer, Designer 클래스 타입의 객체를 생성가능 : 다형성. 상속관계에서만 사용가능        Person p1  = new Person(\"박진희\", \"여\");        Person p2 = new Designer(\"박진희\", \"여\",\"photoshop\");        Person p3 = new Developer(\"박진희\", \"여\",\"JAVA\");        p1.work(); //Person의 work실행        p2.work(); //Designer의 work실행        p3.work(); //Developer의 work실행        //기존클래스 Person의 work를 Developer와 Designer에서도 만들어줬다(재정의) : 오버라이딩          }  }            동물      public class Animal {    String name;    String color;    public Animal(){}    public Animal(String name, String color){      this(); //생성자. 위의 매개변수없는 기본생성자를 가르킴. 맨위에 써줘야함      // this(name, color); //무한반복에걸려서 에러      //this 포인터      // this; //현재 이 클래스 전체를 의미      if(name.length()==0){        this.name = \"동물\";      }else{        this.name = name;      }      this.color = color;      // this.someMethod();    }    // public void someMethod(){    //   System.out.println(\"some Method\");    // }        void makeSound(){      System.out.println(\"동물 \"+name+\"이(가) 소리를 냅니다.\");    }  }          public class Cat extends Animal {    String gen;    public Cat(){}    public Cat(String name, String color, String gen){      super(name, color);      this.gen = gen;    }        void makeSound(){      System.out.println(gen+\"고양이 \"+name+\"이(가) 야옹소리를 냅니다.\");    }  }          public class Dog extends Animal { //dog is a animal    String size;    public Dog(){}    public Dog(String name, String color, String size){      super(name, color); //Animal클래스안에 제약사항이 있어서 상위클래스에서 처리하는것이 효율적임.      this.size = size;    }    @Override //오버라이딩, 기능재정의    // dog타입의 객체들은 Animal클래스의 makeSound를 실행하지않고 아래의 makeSound를 실행함    void makeSound(){      System.out.println(size+\"견 \"+name+\"이(가) 멍멍 짖습니다.\");    }        }          public class Lion extends Cat{    Integer age;    public Lion(){}    public Lion(String name, String color, String gen, Integer age){       super(name, color, gen);      this.age = age;    }        @Override    void makeSound() {      System.out.println(gen+\"사자 \"+name+\"이(가) 어흥하고 소리를 냅니다.\" );    } //오버라이딩안해주면 Cat클래스의 makesound를 실행함.        }          import java.util.ArrayList;  import java.util.LinkedHashMap;  import java.util.List;  import java.util.Map;      public class AnimalMain {    public static void main(String[] args) {      //변수타입 - Animal / 객체타입 - Animal      Animal a = new Animal(\"동물1\", \"흰색\");      a.makeSound();      //변수타입 - Dog / 객체타입 - Dog      Dog d = new Dog(\"멍멍이\", \"검정\", \"중형\");      d.makeSound();      //변수타입 - Animal / 객체타입 - Dog  -&gt; 다형성.       Animal a1 = new Dog(\"강쥐\", \"흰색\", \"소형\");      a1.makeSound();          Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); //key - String, value - object      map.put(\"animal\", a);      map.put(\"dog\", d);      List&lt;String&gt; list = new ArrayList&lt;String&gt;();      list.add(\"1\");      list.add(\"2\");      list.add(\"3\");      map.put(\"list\",list);      map.put(\"integer\", 123);      System.out.println(map);  //{animal=Animal@5305068a, dog=Dog@1f32e575, list=[1,2,3], integer=123} 출력      // 집어넣는건 가능한데 꺼낼때 곤란해짐. 형변환도 정확하지않으면 에러남      // 프론트엔드에 넘겨주면 됨. JSON에서는 보임          Animal a2 = new Cat(\"냥이\", \"삼색\", \"암컷\");          a2.makeSound();          List&lt;Animal&gt; aniList = new ArrayList&lt;Animal&gt;();      aniList.add(a);      aniList.add(a1);      aniList.add(a2);      aniList.add(new Lion(\"사자\", \"누렁이\", \"암컷\", 5));       System.out.println(\"---------------------\");      for(Animal am : aniList){        am.makeSound();        System.out.println();      }      System.out.println(\"---------------------\");      Cat l = new Lion(\"사장\", \"노랑\", \"수컷\", 11);      l.makeSound();            // Lion a3 = new Animal(\"동뮬\", \"갈색\"); //불가능.       //하위클래스(Sub Class)타입으로 상위클래스(Super Class) 타입의 객체를 저장할 수 없음        }  }      object는 모든 객체의 최고 조상. 컬렉션프레임워크에서 많이쓰임집어넣는건 가능한데 꺼낼때 곤란해짐. 형변환도 정확하지않으면 에러남프론트엔드에 넘겨주면 됨. JSON에서는 보임package : 폴더. 다른패키지면 이름이 같아도 됨. 대신 위에 어느패키지인지 import문을 사용해서 표시해줘야함. 동시에 다른패키지 두개 import사용불가.아니면 import쓰지말고 앞에 패키지.클래스이름 사용개발시 각자 다른패키지를 사용함.대표적으로 Date클래스가있음설정 - compact folders 해제할것.import 폴더.폴더.폴더;Call By Value - 원본수정 불가능. 파라미터가 기본형일때public class CbrCbv {  public static void change(String str) { //Call By Value    str+=\"456\";       }  public static void main(String[] args) {    String str=\"ABC123\";    change(str);    System.out.println(str);  }}public class CbrCbv {  public static String change(String str) { //Call By Value    str+=\"456\";     return str;  }  public static void main(String[] args) {    String str=\"ABC123\";    str = change(str);    System.out.println(str);  }}Call By Reference - 원본수정 가능.public class CbrCbv {  public static void a(int[] arr) {    arr[0] = 100;      }  public static void main(String[] args) {    int[] arr = {10,20};    a(arr);    System.out.println(arr[0]);  }}주소값을 줘서 객체의 값도 바뀜. 파라미터가 참조형일때메소드는 public, 멤버변수는 private      접근제어자      package JAVA4;      public class Product {    // String name;    // public String sub_title;    // protected Integer price;    // private Integer stock;        private String name;    private String sub_title;    private Integer price;    private Integer stock;        public Product(){}    public Product(String name, String sub_title, Integer price, Integer stock){      setName(name);      setSub_title(sub_title);      setPrice(price);      setStock(stock);    }        public String getName() {      return this.name;    }        public void setName(String name) {      this.name = name;    }        public String getSub_title() {      return this.sub_title;    }        public void setSub_title(String sub_title) {      this.sub_title = sub_title;    }        public Integer getPrice() {      return this.price;    }        public void setPrice(Integer price) {      this.price = price;    }        public Integer getStock() {      return this.stock;    }        public void setStock(Integer stock) {      this.stock = stock;    }        // void showStock(){    //   System.out.println(\"재고 : \"+stock+\"개\");    // }              }          package JAVA3;      import JAVA4.Product;      public class Main {    public static void main(String[] args) {      // Product p = new Product();      // p.name = \"제품\"; //default. 클래스파일을 다른곳으로 옮기니 에러      // p.sub_title = \"제품간략설명\"; //public      // p.price = 10000; //protected/ 같은 폴더위치에서는 사용가능, 클래스파일을 다른곳으로 옮기니 에러      // p.stock = 100; 에러. private라서 안됨. 클래스내에 메소드를 만들어야 접근가능      // p.showStock();//클래스파일을 다른곳으로 옮기니 에러          //default와 protedcted는 같은 패키지 내에서만 사용가능              Product p = new Product(\"제품\",\"제품설명\",12300,100);      System.out.println(p.getName());                }  }      확장자 Getter and Setter Generator로 자동 생성가능(완벽x)생성할 변수 선택 후 f1 → &gt;gen검색해서 자동생성      암호화 복호화          [!info]      https://mvnrepository.com/        외부라이브러리 연결            자르파일 다운(외부에서 실행가능한상태로 압축한파일. 아카이브파일)          import javax.crypto.Cipher;  import javax.crypto.spec.IvParameterSpec;  import javax.crypto.spec.SecretKeySpec;      import org.apache.tomcat.util.codec.binary.Base64;      public class AESAlgorithm {    public static String Decrypt(String text) throws Exception{ //복호화      String key = \"pwd!@#$\"; //복호화시 사용하는 비밀번호(유출되면 큰일남)      Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");      byte[] keyBytes= new byte[16];      byte[] b= key.getBytes(\"UTF-8\");      int len= b.length;      if (len &gt; keyBytes.length) len = keyBytes.length;      System.arraycopy(b, 0, keyBytes, 0, len);      SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");      IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);      cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);              byte [] results = cipher.doFinal(Base64.decodeBase64(text));      return new String(results,\"UTF-8\");   }        public static String Encrypt(String text) throws Exception{ //암호화        String key = \"pwd!@#$\"; //암호화시 사용하는 비밀번호        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");        byte[] keyBytes= new byte[16];        byte[] b= key.getBytes(\"UTF-8\");        int len= b.length;        if (len &gt; keyBytes.length) len = keyBytes.length;        System.arraycopy(b, 0, keyBytes, 0, len);        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);        cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec);            byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));        return Base64.encodeBase64String(results);    }  }          public class Main {    public static void main(String[] args) throws Exception {      System.out.println(AESAlgorithm.Encrypt(\"1234\")); //4g9CwF3G17sk3kn/7DQTeQ== 출력      System.out.println(AESAlgorithm.Decrypt(\"4g9CwF3G17sk3kn/7DQTeQ==\")); //1234 출력    }  }        자동저장 설정 꺼놔야함                  복습          public /* final */ class SuperClass {    final int a=100; //변경불가 상수    /* final */ void printInfo(){      System.out.println(\"SuperClass\");            }  }                  public class SubClass extends SuperClass { // SuperClass에 final을 붙여서 상속금지임(주석처리함)    int b;            void printInfo(){ //SuperClass 메소드에 final붙어서 에러남(주석처리함)      System.out.println(\"Subclass\");    }          }                  public class StaticTest {    int a; //인스턴스변수 - 생성된 객체 수 만큼 존재    static int b; //클래스변수 - 단 1개만 생성 = 공유변수    static final int VALUE = 100; //클래스 상수 - 단 1개만 생성 = 공유상수            void nonStaticMethod(){ //클래스매소드      System.out.println(\"non static Method\");      StaticMethod();      //인스턴스메소드에서는 같은 클래스 내의 static메소드와 인스턴스 메소드 모두 사용 가능    }    static void StaticMethod(){ //인스턴스메소드(객체메소드)      System.out.println(\"static Method\");      // nonStaticMethod(); //불가능.       //Static메소드에서는 같은 클래스 내의 인스턴스 메소드 사용 불가                            }  }                  package group1;          public class AccessTest {    int a;    private int b;    protected int c;    public int d;            /* public */ int getB(){      return b;    }  }                  package group1;          public class SubAccessTest extends AccessTest {    public SubAccessTest(){      this.a=100; //default      // this.b=200; //private - 에러남. 자식클래스에서도 접근불가함.      this.c=300; //protected - 잘안씀      this.d=400; //publuc    }  }                  import group1.AccessTest; //패키지가 나눠져있어서 import해야 사용가능          public class Main {    public static void main(String[] args) throws Exception {      // StaticTest.a=10; //직접접근 불가 = 인스턴스변수(객체변수)      StaticTest.b=20; //직접접근 가능 = 클래스변수              StaticTest obj1 = new StaticTest();      obj1.a=10;  //인스턴스변수는 객체생성 후 접근 가능      StaticTest obj2 = new StaticTest();      obj2.a=20;      System.out.println(obj1.a);      System.out.println(obj2.a);//서로 다름              obj1.b=50;              System.out.println(obj1.b+\", \"+obj2.b+\",\"+StaticTest.b); //전부 같음                  System.out.println(Integer.MIN_VALUE); //클래스변수                  System.out.println(obj1.VALUE+\", \"+obj2.VALUE+\",\"+StaticTest.VALUE); //전부 같음                  StaticTest.StaticMethod();      // StaticTest.nonStaticMethod(); //불가능      obj1.nonStaticMethod();      obj1.StaticMethod();              AccessTest obj = new AccessTest();      // obj.a=10; //default - 에러남. 다른패키지라서 사용불가. 같은 패키지 내에서는 사용가능      // obj.b=20; //private - 에러남. 클래스외부에서 사용 불가능      // obj.c=30; //protected - 에러남. 다른패키지라서 사용불가. 같은 패키지 내에서는 사용가능      obj.d=40; //public 공개. 모은 곳에서 사용 가능      //private와 public을 많이 씀      // System.out.println(obj.getB()); //public이 빠져서 에러남.    }  }                인스턴스객체를 하나만 만들어야 할때 생성자에 private를 붙여준다.(singleton. 스프링으로가면 알아서 만들어줌)              ### 추상클래스    메소드가 추상적임. 개념만있음. 잘안만드나 이미 만들어진 추상클래스를 받는일이생김    상세내용 구체화      public abstract class AbstractSuperClass {     public int x;    public int y;    // public void showInfo(){    //   System.out.println(\"asdjaldlka\");    // }//모든 하위클래스에서 오버라이딩중이면 상위클래스에서 세부내용을 구현할 필요가 없ㅇ,ㅁ    public abstract void showInfo();  }          public class SubClass extends AbstractSuperClass{    // @Override    // public void showInfo() {    //   System.out.println(\"자식클래스에서 오버라이드\");    // } //만들지않으면 에러남.    @Override    public void showInfo() {      // TODO Auto-generated method stub    } //자동생성기능 사용              }            동물      public abstract class Animal {    public String name;    public String color;        //abstract : 추상의 / 구현의. 껍데기만 있는 상태    public abstract void makeSound();  }          public /* abstract */ class Dog extends Animal { //Dog도 추상클래스로 만들면 makeSound안만들어도됨    @Override    public void makeSound() {      // TODO Auto-generated method stub      System.out.println(\"이름 : \"+name+\" / 색깔 : \"+color);      System.out.println(\"멍멍\");    }        }          public class Cat extends Animal {    @Override    public void makeSound() {      // TODO Auto-generated method stub      System.out.println(\"이름 : \"+name+\" / 색깔 : \"+color);      System.out.println(\"야옹\");    }        }          public class AbsMain {    public static void main(String[] args) {      // AbstractSuperClass superClass = new AbstractSuperClass(); //불가능. 메소드가 구현안된 상태이기때문.       AbstractSuperClass obj = new SubClass(); //객체생성은 못하지만 하위클래스타입의 객체를 담는 변수타입으로는 사용가능      //추상클래스 = 상속 / 다형성 전용          obj.x = 10;      obj.showInfo();          Animal animal = new Dog();      Animal animal2 = new Cat();      animal.name = \"멍멍이\";      animal.color = \"흰색\";      animal.makeSound(); //멍멍출력      animal2.name = \"야옹이\";      animal2.color = \"치즈\";      animal2.makeSound(); //야옹출력          // Animal a = new Animal(); //불가능.         }  }            직업      public abstract class Person {    String name;    String gen;        public Person(){}    public Person(String name, String gen){      this.name = name;      this.gen = gen;    }          abstract void work();        public String toString() {      return \"이름 : \"+name+\" / 성별 : \"+gen;    }  }          public class Designer extends Person {    String tool; //사용 툴        public Designer(){      //super()가 생략된 상태. 다 만들거나 다 만들지 말거나    }    public Designer(String name, String gen, String tool){      super(name, gen);      this.tool = tool;    }        @Override    public void work(){      System.out.println(\"디자이너 \"+name+\"가(이) \"+tool+\"(으)로 디자인을 한다.\");    }  }          public class Developer extends Person {    String language; //프로그래밍언어        public Developer(){      //super()가 생략된 상태. 다 만들거나 다 만들지 말거나    }    public Developer(String name, String gen, String language){      super(name, gen);      this.language = language;    }    @Override    public void work(){      System.out.println(\"개발자 \"+name+\"가(이) \"+language+\"(으)로 프로그램을 개발한다.\");    }  }          public class PersonMain {    public static void main(String[] args) {              Person[] persons ={        // new Person(\"박진희\", \"여\"),        new Designer(\"박진희\", \"여\",\"photoshop\"),        new Developer(\"박진희\", \"여\",\"JAVA\")      };      for(Person p : persons){        System.out.println(p.toString());        p.work();        System.out.println();      }       /*이름 : 박진희 / 성별 : 여      일을 시작합니다.                이름 : 박진희 / 성별 : 여        일을 시작합니다.        디자이너 박진희가(이) photoshop(으)로 디자인을 한다.                  이름 : 박진희 / 성별 : 여        일을 시작합니다.        개발자 박진희가(이) JAVA(으)로 프로그램을 개발한다.*/ //출력됨                  //Person클래스 타입으로 Developer, Designer 클래스 타입의 객체를 생성가능 : 다형성. 상속관계에서만 사용가능        // Person p1  = new Person(\"박진희\", \"여\");        Person p2 = new Designer(\"박진희\", \"여\",\"photoshop\");        Person p3 = new Developer(\"박진희\", \"여\",\"JAVA\");        // p1.work(); //Person의 work실행        p2.work(); //Designer의 work실행        p3.work(); //Developer의 work실행        //기존클래스 Person의 work를 Developer와 Designer에서도 만들어줬다(재정의) : 오버라이딩          }  }      인터페이스껍데기. inplements로 상속받음상세내용 구현public interface MyInterface {  // int x; //멤버변수 불가능  public final int MAX_VALUE=10; //보통 상수를 많이 넣음  public void showInfo(); //껍데기  // {  // System.out.println(\"ㄴㄴㄴ\");      // } //절대 구현부가 올 수 없음 + 접근제한자가 무조건 public}public class MyRunnable implements Runnable {  @Override  public void run() {    // TODO Auto-generated method stub      } //}      로그인      public interface LoginInterface {    public boolean connect();    public boolean authorication();    public void showLoginInfo();    public boolean logout();    public boolean discounnect();  }          public class ShopLogin implements LoginInterface {        private String id;    private String pwd;              @Override    public boolean connect() {      return false;    }    @Override    public boolean authorication() {      return false;    }    @Override    public void showLoginInfo() {            }      @Override    public boolean logout() {      return false;    }    @Override    public boolean discounnect() {      return false;    }  }          public class InterfaceMain {    public static void main(String[] args) {      // LoginInterface i = new LoginInterface(); //불가능               LoginInterface obj = new ShopLogin();    }  }      mvc패턴. 모델(데이터)과 컨트롤러(기능처리→결과)사이의 관계성립. v는view(프론트, 화면).restful은 view없음데이터와 기능을 분리시키기위해 클래스를 나눔 - 스프링에서 사용할 개념"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 컬렉션 프레임워크",
    "url": "/posts/%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/",
    "categories": "JAVA",
    "tags": "java, 국비교육, collection",
    "date": "2022-11-01 00:00:00 +0900",
    





    
    "snippet": "listpublic class WrapperEx {  public static void main(String[] args) {    //wrapper Class    Integer value =10;    int value2= 20;    value = null; //Integer가 클래스타입이라서 null가능.     // value2 = null;...",
    "content": "listpublic class WrapperEx {  public static void main(String[] args) {    //wrapper Class    Integer value =10;    int value2= 20;    value = null; //Integer가 클래스타입이라서 null가능.     // value2 = null; //null불가능.     value=10;    System.out.println(value+value2);    String s = \"123456\";    System.out.println(s+100);    System.out.println(Integer.parseInt(s)+100); //Warpper class의 핵심기능. 문자있으면 Exception뜸    Byte v1 =100;    Short v2 = 200;    Integer v3 = 300;    Long v4 = 400L;    Float v5 = 1.23f;    Double v6 = 1.23;    Character v7 = 'a';    Boolean v8 = false; //null도 가능하니까 사용자가 값을 입력하지않았을때 null로 두기위해 주로 사용함    //전부 4byte    // BigDecimal aa;    // BigInteger bb;    System.out.println(v1);    System.out.println(v2);    System.out.println(v3);    System.out.println(v4);    System.out.println(v5);    System.out.println(v6);    System.out.println(v7);    System.out.println(v8);      }}primitive타입보다는 Wrapper클래스를 많이 사용하는것이 좋음List : 배열, 순서o,중복x(중간데이터삭제시 자동으로 빈값 땡겨줌)Set : 집합(중복불가)Map : 키와 값의 쌍으로 이루어짐. 라벨링. RestfulAPI를 내보낼때 무조건 사용ArrayList : 배열을 클래스화. (많이 씀.[비효율적으로 보이지만] 속도가 빠름)LinkedList : 배열단점보완, 중간데이터 삭제시 삭제데이터 다음 데이터의 주소와 삭제데이터 전데이터를 이어줌(덜씀)코드 호환가능. 바꿔도 쓸수있음import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;import java.util.List;import java.util.Vector;public class CollectionEx {  public static void main(String[] args) {    Integer[] arr = {10,20,30}; //크기변경 불가    System.out.println(arr);    // List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //제일많이씀    //&lt;&gt;사이에 무조건 클래스만 들어감    // List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); //위에꺼 주석하고 했는데도 전부 정상 작동함. 출력값 다른것도없음    List&lt;Integer&gt; list = new Vector&lt;Integer&gt;(); //마찬가지로 전부 정상 작동함. 출력값 다른것도없음    list.add(10);    list.add(20);    list.add(30);        for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }    System.out.println(\"-----------------------\");    list.add(40); //배열크기 추가 가능    for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }     System.out.println(\"-----------------------\");    // list.remove(30); //에러남. 30번째 데이터 삭제라는 뜻    Integer rm = 30;    list.remove(rm);    for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }     System.out.println(\"-----------------------\");    list.remove((Integer)20); //오 된다    for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }     System.out.println(\"-----------------------\");    list.remove(0); //첫번째 제거    for(int i=0;i&lt;list.size();i++){       System.out.println(list.get(i));    }     Integer target=30;    //현재 list에 Integer값 30이 있는가?    System.out.println(list.contains(target)); //false출력.    System.out.println(list.contains((Integer)40)); //true출력    //아이디 중복검사할때 유용함        System.out.println(\"-----------------------\");    list.add(10);    list.add(20);    list.add(30);    System.out.println(list.size());    list.removeAll(list); //전체삭제    System.out.println(list.size());    list.add(10);    list.add(20);    list.add(40);    System.out.println(\"-----------------------\");    List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();    list2.add(10);    list2.add(40);    list2.add(50);    System.out.println(list2.size());    list.removeAll(list2);    System.out.println(list2.size()); //삭제안됨    System.out.println(list.size()); //1출력. list와 list2에서 겹치는값만 삭제(차집합)    // System.out.println(Arrays.toString(list));  //안되는구만    System.out.println(list2.toString()); //되는구만    List&lt;Integer&gt; list3 = new LinkedList&lt;Integer&gt;();    System.out.println(list3); //[] 출력됨          }}      아이디 추가      public class MemberInfo {    private String id;    private String pwd;    private String name;        public MemberInfo(){}    public MemberInfo(String id, String pwd, String name){      setId(id);      setPwd(pwd);      setName(name);    }        void setId(String id){      if(id.length()&lt;6){        System.out.println(\"아이디는 6자리 이상입니다.\");      }else{        this.id = id;      }    }    void setPwd(String pwd){      if(pwd.length()&lt;6){        System.out.println(\"비밀번호는 6자리 이상입니다.\");      }else{        this.pwd = pwd;      }    }    void setName(String name){      if(name.length()==0){        System.out.println(\"이름이 입력되지 않았습니다.\");      }else{        this.name = name;      }    }    public String toString(){      return \"아이디 : \"+id+\" / 이름 : \"+name;    }    Boolean pwdCheck(String pwd){      return this.pwd.equals(pwd);    }          public static void main(String[] args) {            }  }          import java.util.ArrayList;  import java.util.LinkedList;  import java.util.List;  import java.util.Scanner;      public class MemberMain {    public static void main(String[] args) {      Scanner s = new Scanner(System.in);      // List&lt;MemberInfo&gt; memberList = new ArrayList&lt;MemberInfo&gt;();      List&lt;MemberInfo&gt; memberList = new LinkedList&lt;MemberInfo&gt;();      // MemberInfo m1 = new MemberInfo(\"user01\",\"123456\",\"사용자\");      // memberList.add(m1);      // System.out.println(memberList);      // memberList.add(new MemberInfo(\"user02\", \"123456\", \"사용자2\"));      // System.out.println(memberList);          while(true){        System.out.println(\"1.회원가입, 2.회원삭제, 3.회원수정, 4.회원목록 0.종료\");        int sel = s.nextInt();        s.nextLine();        if(sel==0){          System.out.println(\"종료합니다\");          s.close();          break;        }        else if(sel==1){          System.out.print(\"아이디 : &gt;&gt; \");          String id = s.nextLine();          System.out.print(\"비밀번호 : &gt;&gt; \");          String pwd = s.nextLine();          System.out.print(\"이름 : &gt;&gt; \");          String name = s.nextLine();                      MemberInfo m = new MemberInfo(id, pwd, name);          memberList.add(m);          System.out.println(\"회원가입이 완료되었습니다.\");                    }        else if(sel==2){          for(int i=0;i&lt;memberList.size();i++){            System.out.println((i)+\"번째 회원 - \"+memberList.get(i));          }          System.out.println(\"삭제할 회원의 번호를 입력하세요.\");          int idx = s.nextInt();          memberList.remove(idx);          System.out.println(\"삭제했습니다.\");        }        else if(sel==3){          for(int i=0;i&lt;memberList.size();i++){            System.out.println((i)+\"번째 회원 - \"+memberList.get(i));          }          System.out.println(\"수정할 회원의 번호를 입력하세요.\");          int idx = s.nextInt();          MemberInfo m = memberList.get(idx);          s.nextLine();          System.out.print(\"비밀번호 : &gt;&gt; \");          String pwd = s.nextLine();          if(m.pwdCheck(pwd)){            System.out.println(m);            System.out.print(\"변경할 아이디 : &gt;&gt; \");            String id = s.nextLine();            // m.setId(id);            System.out.print(\"변경할 비밀번호 : &gt;&gt; \");            pwd = s.nextLine();            // m.setPwd(pwd);            System.out.print(\"변경할 이름 : &gt;&gt; \");            String name = s.nextLine();            // m.setName(name);            memberList.set(idx, new MemberInfo(id,pwd,name)); //해당인덱스의 값을 바꿔줌. 이전 데이터를 날려서 주소값도 날리고 새로 입력함.            System.out.println(\"변경했습니다.\");          }else{            System.out.println(\"비밀번호가 일치하지 않습니다.\");          }        }        else if(sel == 4){          for(int i=0;i&lt;memberList.size();i++){            System.out.println((i)+\"번째 회원 - \"+memberList.get(i));          }        }else{          System.out.println(\"번호를 잘못입력하셨습니다.\");        }      }            }  }      메모리구조 추가설명import java.util.LinkedList;import java.util.List;public class MemberTestMain {  public static void main(String[] args) {    List&lt;MemberInfo&gt; mList = new LinkedList&lt;MemberInfo&gt;();    for(int i=0;i&lt;10;i++){      mList.add(new MemberInfo(\"user0\"+i,\"123456\",\"사용자\"+i));    }    System.out.println(mList);    System.out.println(mList.get(5));    MemberInfo m= mList.get(5);    System.out.println(m);    m.setId(\"iiiiiiiiiiiiii\");    System.out.println(m);    System.out.println(mList.get(5)); //같은 메모리주소라서 둘다 바뀜. 앞데이터를 삭제하면 5번을 지우려했는데 4번이 지워질수도    mList.get(5).setId(\"vvvvvvvvvvvvvvvvvv\");    System.out.println(m);    System.out.println(mList.get(5));      }}      학생점수등록      public class StudentScore {    private String name;    private Integer score;    private String grade=\"\";    private boolean check = true;    public StudentScore(String name, Integer score){      setName(name);      setScore(score);    }    public StudentScore(){    }        void setName(String name){      if(name.length()==0){        System.out.println(\"이름을 입력하지않으셨습니다.\");        this.check = false;      }else{        this.name = name;      }    }    void setScore(Integer score){      if(score &lt; 0 || score &gt;100){        System.out.println(\"입력값이 잘못되었습니다\");        this.check = false;      }else{        this.score = score;      }    }    boolean getCheck(){      return check;    }    String getGrade(Integer score){      if(score&gt;=90){        grade = \"A\"+ (score&gt;=95?\"+\":\"O\");      }else if(score&gt;=80){        grade = \"B\"+ (score&gt;=85?\"+\":\"O\");      }else if(score&gt;=70){        grade = \"C\"+(score&gt;=75?\"+\":\"O\");      }else if(score&gt;=60){        grade = \"D\"+ (score&gt;=65?\"+\":\"O\");      }else{        grade = \"F\";      }      return grade;    }    boolean checkName(String name){      this.name.equals(name);      return true;    }        Integer getScore(){      return score;    }        public String toString(){      return \"이름 : \"+name+\" / 점수 : \"+score + \" / 등급 \"+getGrade(score);    }      }          import java.util.ArrayList;  import java.util.List;  import java.util.Scanner;      public class StudentScoreMain {    public static void main(String[] args) {      List&lt;StudentScore&gt; studentlist = new ArrayList&lt;StudentScore&gt;();      Scanner s= new Scanner(System.in);              while(true){        System.out.print(\"1.추가, 2.수정, 3.삭제, 4.조회, 0.종료 &gt;&gt; \");        int sel = s.nextInt();         s.nextLine();            if(sel ==0){          System.out.println(\"프로그램을 종료합니다.\");          s.close();          break;        }        else if(sel ==1){          System.out.print(\"이름 : \");          String name = s.nextLine();          System.out.print(\"점수 : \");          Integer score = s.nextInt();          StudentScore std = new StudentScore(name, score);          if(std.getCheck()){            studentlist.add(new StudentScore(name, score));          }        }        else if(sel ==2 ){          if(studentlist.size()!=0){            System.out.println(\"===============목록================\");            for(int i=0;i&lt;studentlist.size();i++){              System.out.println(i+\"번째 학생 -\"+studentlist.get(i));            }            System.out.print(\"수정할 학생의 번호를 입력하세요 : &gt;&gt;\");                int index = s.nextInt();              StudentScore st = studentlist.get(index);              String name = s.nextLine();              if(st.checkName(name)){                System.out.print(\"이름 : \");                name = s.nextLine();                System.out.print(\"점수 : \");                Integer score = s.nextInt();                studentlist.set(index, new StudentScore(name, score));              }            }            else{              System.out.println(\"등록된 학생이 없습니다.\");            }          }          else if(sel ==3 ){            if(studentlist.size()!=0){            System.out.println(\"================목록==================\");            for(int i=0;i&lt;studentlist.size();i++){              System.out.println(i+\"번째 학생 -\"+studentlist.get(i));            }            System.out.print(\"삭제할 학생의 번호를 입력하세요 : &gt;&gt;\");              int index = s.nextInt();            studentlist.remove(index);            System.out.println(\"삭제되었습니다.\");            }          else{            System.out.println(\"등록된 학생이 없습니다.\");          }        }          else if(sel ==4 ){          int sum=0;          for(int i=0;i&lt;studentlist.size();i++){            // StudentScore st = studentlist.get(i);            // sum += st.getScore();            sum += studentlist.get(i).getScore();            System.out.println(\"===목록===\");            System.out.println(i+\"번째 학생 -\"+studentlist.get(i));          }          if(studentlist.size()!=0){            System.out.println(\"전체 학생의 평균 : \"+sum/studentlist.size());          }else{            System.out.println(\"등록된 학생이 없습니다.\");          }        }else{          System.out.println(\"번호를 잘못입력하셨습니다. 0~4사이의 번호를 입력해주세요\");        }      }    }  }            복습      import java.util.List;  import java.util.Scanner;      public class CollectionEx2 {    public static void main(String[] args) {      //Wrapper Class타입      //기본형 타입을 Reference형태로 만들어둔것      // int a = null; //불가      Integer b = null; //가능      System.out.println(b);      b = new Integer(10);  //추천하지않아서 취소선 그어짐. 자바에서 비추      b = 10; //자바 추천방법      Scanner s = null; //가능. 메모리상에 객체가 만들어지기 전 상태      s = new Scanner(System.in); //메모리에 Scanner 객체 생성          // List&lt;int&gt; list = null; //int는 null사용불가 -&gt; 에러      List&lt;Integer&gt; list = null; //List도 Reference타입.      String str = null; //Reference타입. null을 넣을수있다면 Reference타입임.      System.out.println(list);      System.out.println(str);          s.close();    }  }          import java.util.ArrayList;  import java.util.List;      public class CollectionEx3 {    public static void main(String[] args) {      List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();      list.add(10);      list.add(20);      list.add(30);      System.out.println(list); //[10, 20, 30]으로 출력됨. toString써줄필요없는듯?              List&lt;String&gt; strlist = new ArrayList&lt;String&gt;();          strlist.add(\"abcde\"); //\"abcde\"객체의 주소를 ArrayList객체의 첫번째 배열에 저장, ArrayList객체의 주소를 strlist에 저장      strlist.add(\"fghij\"); //\"abcde\"객체의 주소를 ArrayList객체의 두번째 배열에 저장, ArrayList객체의 주소를 strlist에 저장      strlist.add(\"klmno\"); //\"abcde\"객체의 주소를 ArrayList객체의 세번째 배열에 저장, ArrayList객체의 주소를 strlist에 저장      strlist.add(\"pqrst\");      strlist.add(\"uvwsyz\");      System.out.println(strlist);                     }  }            은행      import java.util.ArrayList;  import java.util.List;      public class AccountMain2 {    public static void main(String[] args) {      List&lt;Account&gt; accList = new ArrayList&lt;Account&gt;();      accList.add(new Account(\"aaa\",50000));      accList.add(new Account(\"bbb\",4600000));      accList.add(new Account(\"ccc\",1000));      accList.add(new Account(\"ddd\",100000000));          System.out.println(\"accList의 크기 : \"+accList.size());      for(int i=0;i&lt;accList.size();i++){        accList.get(i).showInfo();      }       System.out.println();      for(Account a:accList){        a.showInfo();      } //위 for문이랑 같음. 짧아서 씀      System.out.println();      accList.remove(1);      for(Account a:accList){        a.showInfo();      }      System.out.println();      System.out.println(accList.get(1));      Account acc =accList.remove(1); //제거한 값 변수에 저장. 잘 안쓰긴함      System.out.println(acc);       for(Account a:accList){        a.showInfo();      }    }  }          import java.text.DecimalFormat;      public class Account {    private String owner;    private Integer balance;          public Account(){    }    public Account(String owner, Integer balance){      setBalance(balance);      setowner(owner);        }    public void setBalance(Integer balance) {      this.balance = balance;    }    public void setowner(String owner) {      this.owner = owner;    }    public Integer getBalance() {      return balance;    }    public String getowner() {      return owner;    }        public void showInfo() {      DecimalFormat formatter = new DecimalFormat(\"###,###\");      System.out.println(\"예금주 : \"+owner+\" / 잔액 : \"+formatter.format(balance)+\"원\");    }    // public String toString() {    //   DecimalFormat formatter = new DecimalFormat(\"###,###\");    //   return \"예금주 : \"+owner+\" / 잔액 : \"+formatter.format(balance)+\"원\";    // }        }      CRUDCreate : addRead : getUpdate : setDelete : remove      대학생정보      public class Campuse {    private Integer no;    private String name;    private Integer grade;    private String major;        public Campuse(){}    public Campuse(Integer no, String name, Integer grade, String major){      setNo(no);      setName(name);      setgrade(grade);      setMajor(major);    }    void setNo(Integer no){      this.no = no;    }    void setName(String name){      this.name = name;    }    void setgrade(Integer grade){      this.grade = grade;    }    void setMajor(String major){      this.major = major;    }        public String toString(){      return \"학번 : \"+no+\" / 이름 : \"+name+\" / 학년 : \"+grade+\" / 전공 : \"+major;    }  }          import java.util.ArrayList;  import java.util.Arrays;  import java.util.List;      public class CampuseMain {    public static void main(String[] args) {      List&lt;Campuse&gt; camList = new ArrayList&lt;Campuse&gt;();          camList.add(new Campuse(20220001, \"남형남\", 1, \"전산공학\"));      camList.add(new Campuse(20220002, \"조현숙\", 3, \"정보공학\"));      camList.add(new Campuse(20220003, \"남희준\", 2, \"물리학\"));      camList.add(new Campuse(20220004, \"윤상원\", 2, \"국어교육과\"));      camList.add(new Campuse(20220005, \"문용태\", 3, \"전산공학\"));      camList.add(new Campuse(20220006, \"사공채은\", 4, \"정보공학\"));      camList.add(new Campuse(20220007, \"정문옥\", 1, \"경영학\"));      camList.add(new Campuse(20220008, \"황상훈\", 2, \"국어국문학\"));      camList.add(new Campuse(20220009, \"탁희아\", 2, \"국어국문학\"));      camList.add(new Campuse(20220010, \"봉성훈\", 4, \"정보공학\"));       //컬럼이름 = 멤버변수      //1학년 학생수, 전산공학 학생수, 남씨 학생 수 등 여러값을 구할수있음          for(Campuse c : camList){        System.out.println(c);      }              //학년 별 학생 수      // for(Campuse c : camList){      //   System.out.println(c.grade); //학년만 출력      // }              // Integer grade1 = 0;      // Integer grade2 = 0;      // Integer grade3 = 0;      // Integer grade4 = 0;      // for(Campuse c : camList){      //   if(c.grade == 1){      //     grade1++;      //   }else if(c.grade == 2){      //     grade2++;      //   }else if(c.grade == 3){      //     grade3++;      //   }else if(c.grade == 4){      //     grade4++;      //   }      // }      // System.out.println(\"1학년 : \"+grade1+\"명\");      // System.out.println(\"2학년 : \"+grade2+\"명\");      // System.out.println(\"3학년 : \"+grade3+\"명\");      // System.out.println(\"4학년 : \"+grade4+\"명\");              int[] grade_cnt = {0,0,0,0};      for(Campuse c : camList){        grade_cnt[c.grade-1]++;      }      System.out.println(Arrays.toString(grade_cnt));              for(int i=0;i&lt;grade_cnt.length;i++){        System.out.print((i+1)+\"학년 : \"+grade_cnt[i]+\"명\");        if(i!=grade_cnt.length-1){          System.out.print(\" / \");        }      }    }  }      자리뽑기import java.util.ArrayList;import java.util.List;public class SeatEx {  public static void main(String[] args) {    List&lt;String&gt; stuList = new ArrayList&lt;String&gt;();    stuList.add(\"이호진\");    stuList.add(\"주봉진\");    stuList.add(\"정아미\");    stuList.add(\"김호혁\");    stuList.add(\"이민석\");    stuList.add(\"유지은\");    stuList.add(\"김성민\");    stuList.add(\"차대군\");    stuList.add(\"유상연\");    stuList.add(\"권영장\");    stuList.add(\"신래은\");    stuList.add(\"박정은\");    stuList.add(\"류승지\");    stuList.add(\"이영은\");    stuList.add(\"이찬희\");    stuList.add(\"이태훈\");    stuList.add(\"박진희\");    stuList.add(\"박진혁\");    stuList.add(\"정인원\");    stuList.add(\"문주영\");    stuList.add(\"남현우\");    stuList.add(\"이영준\");    stuList.add(\"김동현\");    stuList.add(\"우민경\");    stuList.add(\"우현주\");    stuList.add(\"차경준\");    stuList.add(\"김한수\");    stuList.add(\"이도영\");        int num = 1;    while(stuList.size()&gt;0){        int n = (int)(Math.random()*stuList.size());        // System.out.println(stuList.get(n)); //이렇게하면 무한반복임        String name = stuList.remove(n);        System.out.println(num+\". \"+name);        num++;      }      // while(num&lt;28){        //   int n = (int)(Math.random()*stuList.size());    //   System.out.println(num+\". \"+stuList.get(n));  //이렇게하면 중복값나옴    //   num++;    // }  }}      마켓컬리      public class ProductInfo {    Integer prod_no; //제품번호    String prod_name; //제품명    Integer prod_price; //가격    Integer prod_stock; //재고     Double prod_dc_rate; //할인율          public ProductInfo(){}    public ProductInfo(Integer prod_no, String prod_name, Integer prod_price, Integer prod_stock, Double prod_dc_rate){      this.prod_no = prod_no;      this.prod_name = prod_name;      this.prod_price = prod_price;      this.prod_stock = prod_stock;      this.prod_dc_rate = prod_dc_rate;    }        void showInfo(){      System.out.println(\"제품번호 : \"+prod_no);      System.out.println(\"제품명 : \"+prod_name);      System.out.println(\"가격 : \"+prod_price);      System.out.println(\"재고 : \"+prod_stock);      System.out.println(\"할인률 : \"+(int)(prod_dc_rate*100)+\"%\");    }    int getDiscountedPrice(){      return (int)(prod_price*(1-prod_dc_rate));    }        public static void main(String[] args) {            }  }          import java.util.ArrayList;  import java.util.List;  import java.util.Scanner;      public class ShopMain {    static List&lt;ProductInfo&gt; prodList = new ArrayList&lt;ProductInfo&gt;();    static Integer no = 0; //중간에 데이터가 삭제돼도 제품번호를 당기지는 않음    static Scanner s = new Scanner(System.in);    public static void main(String[] args) {      for(int i=0;i&lt;10;i++){        initializeData(); //10개의 데이터추가 10번 반복      }      //1.제품추가, 2.제품삭제, 3.제품수정, 4.제품목록      while(true){        System.err.print(\"1.제품추가, 2.제품삭제, 3.제품수정, 4.제품목록, 0.종료 &gt;&gt; \" );        int sel = s.nextInt();        s.nextLine();        if(sel==0){          System.out.println(\"프로그램을 종료합니다.\");          s.close();          return;        }        else if(sel ==1){          addProduct();        }        else if(sel ==2){          deletedProduct();        }        else if(sel==3){          updateProduct();        }        else if(sel ==4){          showProductList();        }      }    }    public static void addProduct(){      System.out.print(\"제품 명 : \");      String name = s.nextLine();      System.out.print(\"가격 : \");      Integer price = s.nextInt();      System.out.print(\"재고 : \");      Integer stock = s.nextInt();      System.out.print(\"할인률(%) : \");      Integer dc_percent = s.nextInt();          prodList.add(new ProductInfo(no, name, price, stock, dc_percent/100.0));      no++;      System.out.println(\"제품정보가 등록되었습니다.\");    }    public static void deletedProduct(){      System.out.print(\"삭제할 제품의 번호(\"+(prodList.get(0).prod_no+\"-\"+(prodList.get(prodList.size()-1).prod_no)+\") : &gt;&gt; \"));      int n = s.nextInt();      s.nextLine();      int index=0;      boolean check=false;      for(int i=0;i&lt;prodList.size();i++){        if(prodList.get(i).prod_no == n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"등록된 제품번호가 아닙니다.\");        return;      }      // if(n&gt;= prodList.size()){      //   System.out.println(\"잘못된 제품번호입니다.\");      //   return; //메소드 종료      // }      ProductInfo p = prodList.get(index);      p.showInfo();      System.out.print(\"삭제하시겠습니까? (y/n) &gt;\");      String confirm = s.nextLine();      if(confirm.equalsIgnoreCase(\"y\")){        prodList.remove(index);        System.out.println(\"삭제하였습니다.\");      }else {        System.out.println(\"삭제가 취소되었습니다.\");      }    }    public static void updateProduct(){      System.out.print(\"수정할 제품의 번호(\"+(prodList.get(0).prod_no+\"-\"+(prodList.get(prodList.size()-1).prod_no)+\") : &gt;&gt; \"));      int n = s.nextInt();      s.nextLine();      int index=0;      boolean check=false;      for(int i=0;i&lt;prodList.size();i++){        if(prodList.get(i).prod_no == n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"등록된 제품번호가 아닙니다.\");        return;      }      ProductInfo p = prodList.get(index);      p.showInfo();      System.out.println(\"=======수정 정보 입력=========\");      System.out.print(\"제품명 (기존 : \"+p.prod_name+\") : &gt;&gt; \");      String name = s.nextLine();      if(name.length()==0){ //입력안했을때        name = p.prod_name; //기존정보 유지      }      System.out.print(\"가격 (기존 : \"+p.prod_price+\"원) : &gt;&gt; \");      Integer price = s.nextInt();      s.nextLine();      System.out.print(\"재고 (기존 : \"+p.prod_stock+\"개) : &gt;&gt; \");      Integer stock = s.nextInt();      s.nextLine();      System.out.print(\"할인율 (기존 : \"+p.prod_dc_rate+\"%) : &gt;&gt; \");      Integer dc_percent = s.nextInt();      s.nextLine();      System.out.print(\"수정하시겠습니까? (y/n) &gt;\");      String confirm = s.nextLine();      if(confirm.equalsIgnoreCase(\"y\")){        prodList.set(index, new ProductInfo(index, name, price, stock, dc_percent/100.0));        System.out.println(\"수정하였습니다.\");      }else {        System.out.println(\"수정이 취소되었습니다.\");      }                                            }    public static void showProductList(){      // for(ProductInfo p : prodList){      //   System.out.println(\"-------------------\");      //   p.showInfo();      //   System.out.println(\"할인 적용가 : \"+p.getDiscountedPrice()+\"원\");      // } //인덱스 번호 표시못함.      for(int i=0;i&lt;prodList.size();i++){        System.out.println(\"========[\"+i+\"]========\");        prodList.get(i).showInfo();        System.out.println(\"할인 적용가 : \"+prodList.get(i).getDiscountedPrice()+\"원\");      }//인덱스 번호 표시가능    }    public static void initializeData(){      prodList.add(new ProductInfo(no, \"입욕제 굿나잇 4구 세트\", 19500, 50, 0.0));      no++;      prodList.add(new ProductInfo(no, \"편백 스프레이 3종\", 24900, 50, 0.20));      no++;      prodList.add(new ProductInfo(no, \"볶음밥 5종\", 19980, 50, 0.36));      no++;      prodList.add(new ProductInfo(no, \"국산 콩두부 300g\", 1900, 50, 0.0));      no++;      prodList.add(new ProductInfo(no, \"머스크 멜론 1.5kg\", 9990, 50, 0.0));      no++;      prodList.add(new ProductInfo(no, \"유정란 20구\", 9550, 50, 0.07));      no++;      prodList.add(new ProductInfo(no, \"한우양지국거리 200g\", 12900, 50, 0.28));      no++;      prodList.add(new ProductInfo(no, \"실속 바나나 1kg\", 3700, 50, 0.15));      no++;      prodList.add(new ProductInfo(no, \"갈비탕\", 12000, 50, 0.0));      no++;      prodList.add(new ProductInfo(no, \"깐대파 500g\", 2990, 50, 0.0));      no++;    }  }        배열의 인덱스값을 받는게 마음에안들어서 제품번호를 입력받도록 바꿨음        게시판      import java.text.SimpleDateFormat;  import java.util.ArrayList;  import java.util.Date;  import java.util.List;          public class Board {    private Integer no; //글번호    private String title;    private String name;    private String mainText;    private String Sdate;    SimpleDateFormat format = new SimpleDateFormat(\"yyyy/MM/dd hh:mm:ss\");    List&lt;BoardDetail&gt; commentList = new ArrayList&lt;BoardDetail&gt;();    private int view;    Date nowDate = new Date();    private String[] category={\"정보\",\"유머\",\"이슈\",\" 팁\",\"잡담\"};    private int index =0;          public Board(){}    public Board(Integer no, int index, String title, String name, String mainText, Date date){      setNo(no);      setName(name);      setTitle(title);      setMainText(mainText);      setDate(date);      setIndex(index);      makeDummydata();    }        //랜덤용    public Board(Integer no, int index, String title, String name, String mainText, Date date, int view){      setNo(no);      setName(name);      setTitle(title);      setMainText(mainText);      setDate(date);      randomView(view);      setIndex(index);      makeDummydata();    }        void setNo(Integer no){      this.no = no;    }    void setTitle(String title){      this.title = title;    }    void setName(String name){      this.name = name;    }    void setMainText(String mainText){      this.mainText = mainText;    }    void setDate(Date nowdate){      this.Sdate = format.format(nowdate);    }    void randomView(int view){      this.view = (int)(Math.random()*view)+1;    }    void setView(int view){      this.view = view;    }    void setIndex(int index){      this.index = index;    }    Integer getNo(){      return this.no;    }    String getName(){      return this.name;    }    String getTitle(){      return this.title;    }    String getMainText(){      return this.mainText;    }    String getDate(){      return this.Sdate;    }    int getCategorysize(){      return category.length;    }    int getView(){      return view;    }        public String toString(){      return \"[\"+category[index]+\"] \"+title+\"(댓글 : \"+commentList.size()+\")\"+\" / 글쓴이 : \"+ name + \" / 작성일 : \"+ Sdate + \" / 조회수 : \"+view +\" / 글번호 : \"+no;    }    void showDetailInfo(){      view++;      System.out.println(\"-------------------------------------\");      System.out.println(\"[\"+category[index]+\"] \"+title + \"(no.\"+no+\")\");      System.out.println(\"글쓴이    : \"+name);      System.out.println(\"조회수    : \"+view);      System.out.println(\"작성일    : \"+Sdate);      System.out.println(\"-------------------------------------\");      System.out.println(mainText);      System.out.println(\"-------------------------------------\");      System.out.println(\"[댓글창] \"+commentList.size());      for(BoardDetail b : commentList){        b.showInfo();      }    }    int num;    void makeDummydata(){      int n = (int)(Math.random()*(view/5));      for(int  i=0;i&lt;n;i++){        commentList.add(new BoardDetail(\"name\"+num, \"댓글내용입니다.\"+num, nowDate));        num++;      }    }    // BoardDetail getcommentList(){    //   return commentList.    // }      }          import java.text.SimpleDateFormat;  import java.util.Date;      public class BoardDetail {    private String commentName;    private String comment;    private String Sdate;    SimpleDateFormat format = new SimpleDateFormat(\"yyyy/MM/dd hh:mm:ss\");        public BoardDetail(){}    public BoardDetail(String name, String comment, Date date){      setComment(comment);      setCommentName(name);      setDate(date);    }        void setCommentName(String commentName){      this.commentName = commentName;    }    void setComment(String comment){      this.comment = comment;    }    void setDate(Date nowdate){      this.Sdate = format.format(nowdate);    }    String getComment(){      return comment;    }    String getCommentName(){      return commentName;    }    void showInfo(){      System.out.println(commentName+\"(\"+Sdate+\")\" + \" : \"+comment );    }            }          import java.util.ArrayList;  import java.util.Date;  import java.util.List;  import java.util.Scanner;      public class Boardmain {    static List&lt;Board&gt; boardList = new ArrayList&lt;Board&gt;();    static Integer no = 0;    static Date date = new Date();    static Scanner s = new Scanner(System.in);    static List&lt;BoardDetail&gt; commentList = new ArrayList&lt;BoardDetail&gt;();        public static void main(String[] args) {      //글쓰기, 글수정, 글 삭제, 글목록(글내용 제외), 글내용 상세보기      dummydata(10);          while(true){        System.out.print(\"1.글쓰기, 2.글수정, 3.글 삭제, 4.글목록조회, 5.글내용 상세보기 0.종료 : &gt;&gt; \");        int sel = s.nextInt();        s.nextLine();        if(sel == 0){          System.out.println(\"프로그램을 종료합니다.\");          s.close();          break;        }        else if(sel==1){          addpost();        }        else if(sel==2){          updatePost();        }        else if(sel==3){          deletePost();        }        else if(sel==4){          showInfo();            }        else if(sel==5){          detailShowInfo();        }        else{          System.out.println(\"잘못된 번호를 입력하셨습니다. 번호를 다시 입력해주세요.\");        }      }    }    public static void dummydata(int n){      Board b = new Board();      for(int i=0;i&lt;n;i++){        int r = (int)(Math.random()*b.getCategorysize());        boardList.add(new Board(no, r,\"글\"+no, \"닉네임\"+no, \"글본문입니다.\"+no, date, 100));        no++;          }    }    public static void showInfo(){      System.out.println(\"===========글 목록=============\");      for(Board b : boardList){        System.out.println(b);      }    }    public static void addpost(){      System.out.println(\"글을 작성합니다.\");      System.out.print(\"카테고리 : 0.정보, 1.유머, 2.이슈, 3.팁, 4.잡담 &gt;&gt; \");      int a = s.nextInt();      System.out.print(\"제목 : \");      s.nextLine();      String title = s.nextLine();      System.out.print(\"글쓴이 : \");      String name = s.nextLine();      System.out.print(\"본문 내용 : \");      String mainText = s.nextLine();      boardList.add(new Board(no, a, title, name, mainText, date));      System.out.println(\"글 작성이 완료되었습니다.\");      no++;    }    public static void updatePost(){      System.out.print(\"수정할 글 번호를 입력하세요 : &gt;&gt; \");      int n = s.nextInt();      int index=0;      boolean check = false;      for(int i=0;i&lt;boardList.size();i++){        if(boardList.get(i).getNo()==n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"해당 글 번호가 존재하지 않습니다. 글 번호를 다시 확인해주세요.\");        return;      }      System.out.println(\"======수정할 내용 입력======\");      System.out.println(\"카테고리 : 0.정보, 1.유머, 2.이슈, 3.팁, 4.잡담\");      int a = s.nextInt();      System.out.print(\"제목 : \");      s.nextLine();      String title = s.nextLine();      System.out.print(\"글쓴이 : \");      String name = s.nextLine();      System.out.print(\"본문 내용 : \");      String mainText = s.nextLine();              System.out.print(\"정말로 수정하시겠습니까? 예-Y, 아니오 - 아무키나 입력하세요 : &gt;&gt; \");      String comfirm = s.nextLine();      if(comfirm.equalsIgnoreCase(\"y\")){        boardList.get(index).setTitle(title);        boardList.get(index).setName(name);        boardList.get(index).setMainText(mainText);        boardList.get(index).setIndex(a);            System.out.println(\"수정이 완료되었습니다.\");      }      else{        System.out.println(\"수정이 취소되었습니다.\");      }    }    public static void deletePost(){      System.out.print(\"삭제할 글 번호를 입력하세요 : &gt;&gt; \");      int n = s.nextInt();      int index=0;      boolean check = false;      for(int i=0;i&lt;boardList.size();i++){        if(boardList.get(i).getNo()==n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"해당 글 번호가 존재하지 않습니다. 글 번호를 다시 확인해주세요.\");        return;      }      System.out.println(boardList.get(index));      System.out.print(\"정말로 삭제하시겠습니까? 예-Y, 아니오 - 아무키나 입력하세요 : &gt;&gt; \");      s.nextLine();      String comfirm = s.nextLine();      if(comfirm.equalsIgnoreCase(\"y\")){        boardList.remove(index);        System.out.println(\"삭제 완료되었습니다.\");      }      else{        System.out.println(\"삭제가 취소되었습니다.\");      }    }    public static void detailShowInfo(){      System.out.print(\"조회할 글 번호를 입력하세요 : &gt;&gt; \");      int n = s.nextInt();      int index=0;      boolean check = false;      for(int i=0;i&lt;boardList.size();i++){        if(boardList.get(i).getNo()==n){          index = i;          check = true;          break;        }      }      if(!check){        System.out.println(\"해당 글 번호가 존재하지 않습니다. 글 번호를 다시 확인해주세요.\");        return;      }      boardList.get(index).showDetailInfo();      System.out.print(\"댓글을 다시려면 Y를 눌러주세요. 처음으로 돌아가려면 아무키나 누르세요 : &gt;&gt;\");      s.nextLine();      String comfirm = s.nextLine();      if(comfirm.equalsIgnoreCase(\"Y\")){        System.out.print(\"닉네임 : &gt;&gt; \");        String name = s.nextLine();        System.out.print(\"댓글 : &gt;&gt; \");        String comment = s.nextLine();        boardList.get(index).commentList.add(new BoardDetail(name, comment, date));        System.out.println(\"댓글 등록이 완료되었습니다.\");        boardList.get(index).showDetailInfo();      }    }  }        글 수정할때 객체를 새로만들어서 수정하려고하니까 댓글이랑 조회수가 날아가서 쌤한테 물어봄. 원래는 글이랑 댓글을 따로 관리하는게 좋다고하심. 이 상황에서는 새 객체를 만드는 것 보다는 기존객체를 수정하는 것이 낫다고 하심. 사본을 만들어서 고치는게 안전하긴함    오버헤드    회원가입 선생님코드      import java.text.SimpleDateFormat;  import java.util.Date;      //게시 글 정보  public class BoardPost{    //next_no는 클래스변수라서 객체생성 전에도 사용 가능함. 모든 BoardPost타입의 객체가 공유중임. 단 1개만 존재    static int next_no = 1;    Integer post_no; //글번호    String post_title;    String post_content; //글내용    Date post_reg_dt; //글 등록일    Date post_mod_dt; //글 수정일    String post_author;//작성자    Integer post_count; //조회수    String post_pwd; //게시글 비밀번호            public BoardPost(String title, String content, String author, String pwd){      post_no = next_no;      this.post_pwd=pwd;      this.post_title = title;      this.post_content = content;      this.post_author = author;      this.post_reg_dt = new Date(); //글 등록일 = 객체를 만든 시간      this.post_mod_dt = new Date(); //글 수정일 = 객체를 만든 시간      this.post_count = 0;      next_no++;    }    SimpleDateFormat f= new SimpleDateFormat(\"yy-MM-dd HH:mm:ss\");    void showPostSummary(boolean detail){      System.out.print(post_no+\"\\t\");      System.out.print(post_title+\"\\t\");      System.out.print(post_reg_dt+\"\\t\");      System.out.print(post_author+\"\\t\");      System.out.print(post_count+\"\\t\");      if(detail){        System.out.println(f.format(post_mod_dt)+\"\\t\");      }      System.out.println(post_content);      if(detail){        System.out.println(\"------------------------------------------------------\");        System.out.println(post_content);        System.out.println(\"------------------------------------------------------\");      }            }    public void showPostInfo(boolean b) {      System.out.println(post_no+\"\\t\"+post_title+\"\\t\"+post_author+\"\\t\"+f.format(post_mod_dt)+\"\\t\"+post_count);      if(b){        System.out.println(\"---------------------------------------------------------------------------------\");        System.out.println(post_content);        System.out.println(\"---------------------------------------------------------------------------------\");      }    }  }          import java.text.SimpleDateFormat;  import java.util.Date;      public class BoardComment {    Integer post_no;    String comment;    Date reg_dt;    String author;    String pwd;    SimpleDateFormat f = new SimpleDateFormat(\"yy-MM-dd HH:mm:ss\");        public BoardComment(Integer post_no, String comment, String author, String pwd){      this.post_no = post_no;      this.comment = comment;      this.author = author;      this.pwd = pwd;      reg_dt = new Date();    }    public void printCommentInfo(){      System.out.println(author+\" : \"+comment+\"(\"+f.format(reg_dt)+\")\");    }  }          import java.util.ArrayList;  import java.util.Date;  import java.util.List;  import java.util.Scanner;          public class BoardMain2 {    public static List&lt;BoardPost&gt; postList = new ArrayList&lt;BoardPost&gt;();    public static Scanner s = new Scanner(System.in);    public static List&lt;BoardComment&gt; commentList = new ArrayList&lt;BoardComment&gt;();    public static void main(String[] args) {      // System.out.println(BoardPost.next_no); //next_no는 클래스변수라서 객체생성 전에도 사용 가능함. 모든 BoardPost타입의 객체가 공유중임      // BoardPost post1 = new BoardPost(null, null, null);      // System.out.println(post1.next_no); //2      // System.out.println(BoardPost.next_no); //2      // BoardPost post2 = new BoardPost(null, null, null);      // System.out.println(BoardPost.next_no); //3      // System.out.println(post2.next_no); //3      // for(int i=0;i&lt;100;i++){      //   BoardPost post = new BoardPost(null, null, null);      // }      // System.out.println(BoardPost.next_no); //103    \t\t      initializeBoardPost(10);      while(true){        System.out.print(\"1.글 등록, 2.글 수정, 3.글 삭제, 4.글 목록 5.글 상세조회, 0.종료 : &gt;&gt; \");        int sel = s.nextInt();        s.nextLine();        // if(sel==0){        //   s.close();        //   System.out.println(\"프로그램을 종료합니다\");        //   break;        // }        // else if(sel==1){        //   addPost();        // }        // else if(sel==2){        //   updatePost();        // }        // else if(sel==3){        //   deletePost();        // }        // else if(sel==4){        //   printPostList();        // }        // else if(sel==5){        //   printPostDetail();        // }        // else{        //   System.out.println(\"번호를 잘못입력하셨습니다. 다시 입력해주세요.\");        // }        switch(sel){          case 1:            addPost();            break;          case 2:            updatePost();            break;          case 3:            deletePost();            break;          case 4:            printPostList();            break;          case 5:            printPostDetail();            break;          case 0:            System.out.println(\"종료합니다\");            return;          default :             System.out.println(\"번호를 잘못입력하셨습니다. 다시 입력해주세요.\");        }      }    }        public static void addPost(){      System.out.print(\"제목 : \");      String title = s.nextLine();      System.out.print(\"내용 : \");      String content = s.nextLine();      System.out.print(\"작성자 : \");      String author = s.nextLine();      System.out.print(\"비밀번호 : \");      String pwd = s.nextLine();      System.out.print(\"글을 등록하시겠습니까?(y/n): \");      String confirm =s.nextLine();      if(confirm.equalsIgnoreCase(\"y\")){        postList.add(new BoardPost(title, content, author, pwd));        System.out.println(\"글이 등록되었습니다\");      }else{        System.out.println(\"글 등록이 취소되었습니다.\");      }    }    public static void printPostList(){      System.out.println(\"글번호\\t글제목\\t\\t작성자\\t등록일\\t\\t\\t조회수\");      for(BoardPost p : postList){        p.showPostInfo(false);      }    }    public static void printPostDetail(){      System.out.print(\"글번호 : \");      int n = s.nextInt();      s.nextLine();      BoardPost p = searchPostDetailByNumber(n);      if(p != null){        p.post_count++;        p.showPostInfo(true);        showComment(p.post_no);        System.out.println(\"1.댓글쓰기 0.목록으로\");        int sel = s.nextInt();        s.nextLine();        if(sel == 1){          addComment(n);          p.showPostInfo(true);          showComment(p.post_no);        }else{          System.out.println(\"목록으로 돌아갑니다.\");        }      }    }            public static void showComment(Integer post_no) {      for(BoardComment c : commentList){        if(c.post_no==post_no){        c.printCommentInfo();        }      }    }    public static void addComment(Integer post_no){      System.out.print(\"닉네임 : \");      String author = s.nextLine();      System.out.print(\"내용 : \");      String comment = s.nextLine();      System.out.print(\"비밀번호 : \");      String pwd = s.nextLine();      System.out.println(\"정말 등록하시겠습니까? (y/n\");      String confirm = s.nextLine();      if(confirm.equalsIgnoreCase(\"y\")){        commentList.add(new BoardComment(post_no, comment, author, pwd));      }else{      System.out.println(\"댓글 등록이 취소되었습니다.\");      }    }    public static void initializeBoardPost(int count){      for(int i=0;i&lt;count;i++){        postList.add(new BoardPost(\"dummytitle\"+i, \"dummycontent\"+i, \"autor\"+i, \"123\"+i));      }    }    public static void updatePost(){      System.out.print(\"수정할 글 번호 : \");      int n = s.nextInt();      s.nextLine();      BoardPost p =searchPostDetailByNumber(n);      if(p!=null){        p.showPostInfo(true);        System.out.print(\"글 비밀번호 : &gt;&gt; \");        String pwd = s.nextLine();        if(p.post_pwd.equals(pwd)){          System.out.print(\"제목 : \");          String title = s.nextLine();          if(title.equals(\"\")){            title = p.post_title;          }          System.out.print(\"내용 : \");          String content = s.nextLine();          if(content.equals(\"\")){            content = p.post_content;          }          System.out.print(\"수정하시겠습니까?(y/n) : &gt;&gt; \");          String confirm = s.nextLine();          if(confirm.equalsIgnoreCase(\"y\")){            p.post_title = title;            p.post_content = content;            p.post_mod_dt = new Date();            System.out.println(\"수정되었습니다.\");          }        }else{          System.out.println(\"비밀번호가 일치하지않습니다.\");        }      }    }            public static void deletePost(){      System.out.print(\"삭제할 글 번호 : \");      int n = s.nextInt();      s.nextLine();      BoardPost p =searchPostDetailByNumber(n);      if(p!=null){        p.showPostInfo(true);        System.out.print(\"삭제하시겠습니까?(y/n) : &gt;&gt; \");        String confirm = s.nextLine();        if(confirm.equalsIgnoreCase(\"y\")){          System.out.print(\"글 비밀번호 : &gt;&gt; \");          String pwd = s.nextLine();          if(p.post_pwd.equals(pwd)){            postList.remove(p); //일치하는 것 삭제            System.out.println(\"삭제되었습니다.\");          }else{            System.out.println(\"비밀번호가 일치하지않습니다.\");          }        }      }    }    public static BoardPost searchPostDetailByNumber(int post_no){      for(BoardPost p : postList){        if(p.post_no==post_no){          System.out.println(\"글번호\\t글제목\\t\\t작성자\\t등록일\\t\\t\\t조회수\");          // p.post_count++;          // p.showPostInfo(true);          return p;        }      }      System.out.println(post_no+\"번 글이 존재하지않습니다.\");      return null;    }      }        Integer같은 Wapper클래스는 null값이 올수있어서 return값에 null을 넣어도 되는구나  "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 객체지향언어",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%96%B8%EC%96%B4/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 객체",
    "date": "2022-10-28 00:00:00 +0900",
    





    
    "snippet": "객체≥인스턴스, 객체가 상위개념이나 거의 동일하게 사용함      마우스      package JAVA_221028;      public class Mouse {        //클래스 상수    final static int VALUE = 100;        //클래스변수    //static - 정적메모리(프로그램 실행시에 생성됨)    //...",
    "content": "객체≥인스턴스, 객체가 상위개념이나 거의 동일하게 사용함      마우스      package JAVA_221028;      public class Mouse {        //클래스 상수    final static int VALUE = 100;        //클래스변수    //static - 정적메모리(프로그램 실행시에 생성됨)    //모든 인스턴스가 공유하는 변수    static int count = 0;        //인스턴스변수(Mouse클래스의 멤버변수)    //인스턴스화가 되어야 사용가능(메모리에 생성되어야 사용가능)    boolean wireless;    boolean wheel;    boolean leftBtn;    boolean rightBtn;    int sensor; //0.광 / 1.레이저 / 2.트랙패드 / 3.트랙볼    int shape; //0.일반 / 1.인체공학 / 2.게이밍 / 3.패드        boolean connect;    int posX;    int posY;    int wheelDelta; //휠을 아래로돌렸는지 위로돌렸는지, 속도는 어느정도인지        void deviceConnectToggle() {      connect = !connect;    }        void changeMousePos(int x, int y) {      posX = x;      posY = y;    }        void rollingMouseWheel(int delta) {      wheelDelta = delta;    }        void showStatus() {      System.out.println(\"장치 연결 상태 : \" + (connect ? \"연결됨\" : \"연결안됨\"));      if (connect) {        System.out.println(\"마우스 위치 : (\" + posX + \", \" + posY + \")\");        System.out.println(\"휠 변화량 : \"+wheelDelta);      }    }        void printInfo() {      System.out.println(\"마우스 연결 방식 : \" + (wireless ? \"무선\" : \"유선\"));      System.out.println(\"마우스 휠 유무 : \"+(wheel?\"있음\":\"없음\"));      System.out.println(\"마우스 버튼(왼쪽) : \"+(leftBtn?\"있음\":\"없음\"));      System.out.println(\"마우스 버튼(오른쪽) : \" + (rightBtn ? \"있음\" : \"없음\"));      if(sensor==0) System.out.println(\"감응방식 : 광\");      else if(sensor==1) System.out.println(\"감응방식 : 레이저\");      else if(sensor==2) System.out.println(\"감응방식 : 트랙패드\");      else if(sensor==3) System.out.println(\"감응방식 : 트랙볼\");              if(sensor==0) System.out.println(\"마우스 형태 : 일반\");      else if(sensor==1) System.out.println(\"마우스 형태 : 인체공학\");      else if(sensor==2) System.out.println(\"마우스 형태 : 게이밍\");      else if(sensor==3) System.out.println(\"마우스 형태 : 패드\");    }        void mouseClick(int btn) {      if (btn == 0) {        System.out.println(\"왼쪽 클릭\");      }      else if (btn == 1) {        System.out.println(\"오른쪽 클릭\");      }      else if (btn == 2) {        System.out.println(\"휠버튼 클릭\");      }    }    public static void main(String[] args) {    }  }          package JAVA_221028;      public class ObjectTestEx01 {          public static void main(String[] args) {      Mouse m1 = new Mouse(); // 클래스의 인스턴스화(메모리에 생성) - 사용가능한상태          m1.wireless = false;      m1.wheel = true;      m1.leftBtn = true;      m1.rightBtn = true;      m1.sensor = 0;      m1.shape = 0;      System.out.println(m1.wireless);      System.out.println(m1.wheel);      System.out.println(m1.leftBtn);      System.out.println(m1.rightBtn);      System.out.println(m1.sensor);      System.out.println(m1.shape);      Mouse m2 = null;      // m2.leftBtn = false; //NullPointerException 에러. 객체생성이안된상태에서 사용하려고해서 에러남      m2.count = 2;      System.out.println(m2.count); // 객체생성없이 사용가능          m1.count = 10;      m2.count = 5;      // m1, m2의 count값이 둘다 5로 바뀜 - static이라서      System.out.println(m1.count);      System.out.println(m2.count);          Mouse.count = 7;      System.out.println(m1.count);      System.out.println(m2.count);      System.out.println(Mouse.count); // 객체 생성없이 사용가능해서 클래스이름을 바로 적어줌      // 전부 7로 바뀜          System.out.println(Integer.MAX_VALUE); // Integer클래스의 MAX_VALUE 클래스변수          System.out.println(Mouse.VALUE);      // Mouse.VALUE = 50; //에러, 상수라서 수정불가          m1.mouseClick(0);      m1.mouseClick(1);      m1.mouseClick(2); // Mouse클래스안의 mouseClick메소드 호출      System.out.println();      // Mouse.mouseClick(2); // 에러. static이 없어서 인스턴스메소드임 = 객체생성필요 or mouseClick메소드에      // static붙이기      m1.printInfo();      // m2.printInfo(); //null에러 값을 모두 안채워줌      // Mouse.printInfo(); //사용불가      System.out.println();      m2 = new Mouse();      m2.wireless = true;      m2.wheel = false;      m2.leftBtn = false;      m2.rightBtn = false;      m2.sensor = 1;      m2.shape = 1;      m2.printInfo();      System.out.println();      m1.deviceConnectToggle();      m1.changeMousePos(960, 540);      m1.rollingMouseWheel(-240);      m1.showStatus();            }  }            회원가입      package JAVA_221028;      import java.util.Date;  import java.util.Scanner;      public class MemberInfo {        String id;    String pwd;    String name;    Date birth;    int gen;    String address;    String phone;    String email;    String profileImg;    String nickname;    String statusMsg;          boolean login(String loginId, String loginPwd) {      return id.equals(loginId) &amp;&amp; pwd.equals(loginPwd);    }        void changePassword(/*String oldPass, String newPass*/) {      Scanner s = new Scanner(System.in);      System.out.print(\"기존 비밀번호 : \");      String oldPass = s.nextLine();      if (!pwd.equals(oldPass)) {        System.out.println(\"비밀번호가 틀렸습니다.\");        return;      }      System.out.print(\"새 비밀번호 : \");      String newPass = s.nextLine();      pwd = newPass;      System.out.println(\"비밀번호가 변경되었습니다.\");    }        void changeDetailInfo(String attr) {      Scanner s = new Scanner(System.in);      if (attr.equals(\"address\")) {        System.out.print(\"변경할 주소 : \");        address = s.nextLine();        System.out.println(\"주소가 변경되었습니다.\");      }      if (attr.equals(\"phone\")) {        System.out.print(\"변경할 전화번호(-제외) : \");        phone = s.nextLine();        System.out.println(\"번호가 변경되었습니다.\");      }      if (attr.equals(\"email\")) {        System.out.print(\"변경할 이메일 : \");        email = s.nextLine();        System.out.println(\"이메일이 변경되었습니다.\");      }      if (attr.equals(\"profileImg\")) {        System.out.print(\"프로필 이미지 파일 : \");        profileImg = s.nextLine();        System.out.println(\"프로필 이미지가 변경되었습니다.\");      }      if (attr.equals(\"nickname\")) {        System.out.print(\"변경할 닉네임 : \");        nickname = s.nextLine();        System.out.println(\"닉네임이 변경되었습니다.\");      }      if (attr.equals(\"statusMsg\")) {        System.out.print(\"변경할 상태메세지 : \");        statusMsg = s.nextLine();        System.out.println(\"상태메세지가 변경되었습니다.\");      }    }        void showInfo() {      System.out.println(\"아이디 : \"+id);      System.out.println(\"이름 : \"+name);      System.out.println(\"생일 : \"+birth);      System.out.println(\"성별 : \"+gen);      System.out.println(\"주소 : \"+address);      System.out.println(\"전화번호 : \"+phone);      System.out.println(\"이메일 : \"+email);      System.out.println(\"프로필사진 : \"+profileImg);      System.out.println(\"닉네임 : \"+nickname);      System.out.println(\"상태메시지 : \"+statusMsg);    }  }          package JAVA_221028;      import java.util.Date;  import java.util.Scanner;      public class Object_memberTestEx {    public static void main(String[] args) {      MemberInfo member1 = new MemberInfo();      member1.id = \"user1\";      member1.pwd = \"123456\";      member1.name = \"사용자\";      member1.birth = new Date(); // 실행 시 날짜      member1.gen = 0;      member1.address = \"대구 중구 중앙대로 394\";      member1.phone = \"01012345678\";      member1.email = \"user@service.com\";      member1.profileImg = \"pfimg.jpg\";      member1.nickname = \"사용자\";      member1.statusMsg = \"ㅁㅁㅁㅁ\";          member1.showInfo();      if (member1.login(\"user1\", \"123456\")) {        System.out.println(\"로그인 성공\");      } else {        System.out.println(\"로그인 실패\");      } // 성공          if (member1.login(\"user2\", \"123456\")) {        System.out.println(\"로그인 성공\");      } else {        System.out.println(\"로그인 실패\");      } // 실패          member1.changePassword();          System.out.println(\"변경할 상세정보[phone, email, profileImg, nickname, statusMsg\");      Scanner s = new Scanner(System.in);      String field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();      field = s.nextLine();      member1.changeDetailInfo(field);      member1.showInfo();          s.close();    }  }            영화      package JAVA_221028;      import java.util.Date;      public class MovieBasicInfo {    String[] status_list = { \"개봉예정\", \"상영중\", \"상영종료\", \"재개봉\", \"VOD\" };    String title_kor; //한글제목    String title_eng; //영어제목    int status; //0:개봉예정, 1:상영중, 2:상영종료, 3:재개봉, 4:VOD    double audience_score; //관람객평점    double netizen_score; //네티즌 평점    double critic_score; //기자,평론가 평점    String genre; //장르    String country; //국가    int running_time; //상영시간    Date opening_dt; //날짜데이터를 dt로 씀, 개봉일    String director; //감독    String main_actor; //주연배우    String sub_actor; //조연배우    int viewing_age; //관람등급    int acc_audience; //누적관객    String poster_img; //포스터이미지        void showInfo(){      System.out.println(title_kor + \"(\" + title_eng + \")\"+\" [\"+status_list[status]+\"]\");      System.out.printf(\"관람객 평점 : %.2f / 네티즌 평점 : %.2f / 기자, 평론가 평점 : %.2f\\n\",audience_score, netizen_score, critic_score);      System.out.println(\"장르 : \" + genre + \" / 국가 : \" + country + \" / 상영시간 : \" + running_time + \"분\");      System.out.println(\"개봉일 : \" + opening_dt + \" / 감독\" + director + \" / 주연 : \" + main_actor + \" / 조연 : \" + sub_actor);      String str_viewing_age = \"\";      if (viewing_age == 0){        str_viewing_age = \"전체관람\";      }      else {        str_viewing_age = viewing_age + \"세 이상 관람가\";      }      System.out.println(\"관람등급 : \"+str_viewing_age+\"누적관객 : \"+acc_audience+\"명 / 포스터이미지 : \"+poster_img);    }    void changeMovieStatus(int status){      if(status&lt;0 || status &gt;= status_list.length){        System.out.println(\"상태변경 실패 (0~4중 입력)\");        return;      }      System.out.println(\"상태 변경 : \"+status_list[this.status]+\" -&gt; \"+status_list[status]);      status=status;    }    void changeAudienceScore(double score){      System.out.println(\"관람객 평점 변경 : \"+this.audience_score+\" -&gt; \"+score);      audience_score=score;    }    void changeNetizenScore(double score){      System.out.println(\"네티즌 평점 변경 : \"+this.netizen_score+\" -&gt; \"+score);      netizen_score=score;            }    void changeCriticScore(double score){      System.out.println(\"기자, 평론가 평점 변경 : \"+this.critic_score+\" -&gt; \"+score);      this.critic_score=score;    }    void addAudienceCount(int count){      System.out.println(\"누적 관객 수 : \"+acc_audience+\" -&gt; \"+count);      acc_audience=count;    }  }          package JAVA_221028;      import java.util.Date;      public class MovieTest {    public static void main(String[] args) {      MovieBasicInfo movie = new MovieBasicInfo();      movie.title_kor = \"블랙 아담\";      movie.title_eng = \"Black Adam\";      movie.status = 1;      movie.audience_score = 7.60;      movie.netizen_score = 7.70;      movie.critic_score = 5.67;      movie.genre = \"액션, 모험, SF\";      movie.country = \"미국\";      movie.running_time = 125;      //연도는 현재연도에서 1900뻼      movie.opening_dt = new Date(122,9,19); //쓰는거 권장안한다고 줄그어짐      movie.director = \"자움 콜렛 세라\";      movie.main_actor = \"드웨인 존슨\";      movie.sub_actor = \"노아센티네오, 피어스 프로스넌\";      movie.viewing_age = 12;      movie.acc_audience = 531013;      movie.poster_img = \"poster.jpg\";              movie.showInfo();      System.out.println();          movie.changeMovieStatus(2);      System.out.println();      movie.showInfo();      System.out.println();      movie.changeMovieStatus(9);      movie.changeMovieStatus(1);      movie.changeMovieStatus(3);      movie.changeMovieStatus(4);      System.out.println();      movie.showInfo();          movie.changeAudienceScore(8.05);      movie.changeNetizenScore(6.80);      movie.changeCriticScore(5.98);      movie.addAudienceCount(853153);      movie.showInfo();    }  }        접근제한자를 안쓰면 다른폴더에서는 못씀  마켓컬리(그나마 간단함..마켓컬리→쿠팡→다나와)들어가서 제품정보 클래스로 작성할인가격, 원가 모두 표시해야함setter mothod : 속성이 private인 멤버변수의 값을 설정하는 용도getter method : 값을 내어보이는 역할을 하는 메소드마켓컬리      마켓컬리      public class KurlyProduct {    public static void main(String[] args) {            }        final String[] delivery = {\"일반택배\",\"샛별배송\",\"낮배송\"};    String prod_img; //상품이미지    String prod_manufacturer; //상품제조사    String prod_title; //상품명    String prod_sub_title; //상품부제목    String prod_seller; //판매자    String prod_unit; //상품판매단위    String prod_quantity; //상품용량    String prod_notice; //안내사항          //정보 은닉    private int prod_price; //가격    private double prod_discount_rate; //할인률    private double prod_Point_rate; //적립률    private int prod_delivery_type; //배송타입 0-일반택배/ 1-샛별배송 / 2-낮배송    private int prod_stock; //재고        void printProductInfo(boolean login){      System.out.println(\"제품 이미지 :\"+prod_img);      System.out.println(\"배송구분 :\"+delivery[prod_delivery_type]);      System.out.println(\"[\"+prod_manufacturer+\"]\"+prod_title);      System.out.println(prod_sub_title);      if(login){        System.out.println(\"제품 원가 : \"+prod_price+\"원\");        System.out.println(\"할인률 : \"+(int)(prod_discount_rate*100)+\"%\");        System.out.println(\"할인 적용 가 : \"+getDiscountedPrice(login)+\"원\");        System.out.println(\"적립율 : \"+(int)(prod_Point_rate*100)+\"%\");        System.out.println(\"적립포인트 : \"+getSavingPoint(login)+\"점\");      }else{        System.out.println(\"제품 가격 : \"+prod_price+\"원\");      }      System.out.println(\"판매자 : \"+prod_seller);      System.out.println(\"판매단위 : \"+prod_unit);      System.out.println(\"제품용량 : \"+prod_quantity);      System.out.println(\"제품안내사항 : \"+prod_notice);    }    int getDiscountedPrice(boolean login){      if(login){        return (int)(prod_price*(1-prod_discount_rate));      }      return prod_price;      }    int getSavingPoint(boolean login){      if(login){        return (int)(getDiscountedPrice(login)*prod_Point_rate);      }      return 0;    }    boolean isOrderAvailable(){ //재고가없으면 false      return prod_stock&gt;0;    }    boolean productOrder(int stock){      if(prod_stock-stock&gt;=0){        System.out.println(\"제품을 \"+stock+\"개 주문했습니다.\");        prod_stock -= stock;        return true;      }        System.out.println(\"제품의 재고가 부족합니다. (재고수량 : \"+prod_stock+\")\");        return false;    }        void setProductPrice(int price){      if(price&lt;0){        prod_price = 0;      }else {        prod_price = price;      }    }    void setProductDiscountRate(double discount_rate){      if(discount_rate&lt;0){        prod_discount_rate = 0;      }else if(discount_rate&gt;=1){        prod_discount_rate=1;      }else {        prod_discount_rate = discount_rate;      }    }    void setProductPointRate(double point_rate){      if(point_rate&lt;0){        prod_Point_rate = 0;      }else if(point_rate&gt;=1){        prod_Point_rate=1;      }else {        prod_Point_rate = point_rate;      }    }    void setProductDeliveryType(int delivery_type){      if(delivery_type&gt;=0 &amp;&amp; delivery_type &lt; delivery.length){        prod_delivery_type = delivery_type;      }else{        prod_delivery_type=0;      }    }    void setProductStock(int stock){      if(stock&lt;0){        stock = 0;      }else{        prod_stock=stock;      }    }  }          public class KurlyMain {    public static void main(String[] args) {      KurlyProduct prod1 = new KurlyProduct();      // prod1.printProductInfo(false);      // System.out.println();      // prod1.printProductInfo(true);      // System.out.println();              prod1.prod_img = \"product.jpg\";      prod1.prod_manufacturer = \"루메나\";      prod1.prod_title = \"루메나 FAN STAND 3X 무선 써큘레이터\";      prod1.prod_sub_title = \"감성 캠핑의 완성\";      prod1.prod_seller = \"컬리\";      prod1.prod_unit = \"1개\";      prod1.prod_quantity = \"-\";      prod1.prod_notice = \"-\";              // prod1.prod_price = -50000; //에러, private를 붙여서 직접접근 불가능함. KurlyProduct클래스 안에서만 접근 가능       // System.out.println(prod1.prod_price); //에러. 직접접근 불가능          //setter mothod (속성이 private인 멤버변수의 값을 설정하는 용도)      prod1.setProductPrice(39900);      prod1.setProductDiscountRate(0.1253);      prod1.setProductPointRate(0.05);      prod1.setProductDeliveryType(2);      prod1.setProductStock(10);          boolean login = true;      // login = false;      System.out.println();      prod1.printProductInfo(login);          int order = 8;      //getter method : 값을 내어보이는 역할을 하는 메소드      if(prod1.productOrder(order)){        System.out.println(\"총 구매 금액 : \"+prod1.getDiscountedPrice(login)*order+\"원\");      }      order = 5;      if(prod1.productOrder(order)){        System.out.println(\"총 구매 금액 : \"+prod1.getDiscountedPrice(login)*order+\"원\");      }      order = 2;      if(prod1.productOrder(order)){        System.out.println(\"총 구매 금액 : \"+prod1.getDiscountedPrice(login)*order+\"원\");      }    }  }      예제public class Account {  private int balance; //계좌 잔액  private String owner;  // 계좌 소유자 이름  public Account(int balance, String owner){    this.balance = balance;    this.owner = owner;  }  public Account(){  }  void setBalance(int balance){    if(balance&lt;0){      System.out.println(\"입력값이 잘못되었습니다.\");      return;    }    this.balance = balance;  }  int getBalance(){    return this.balance; //일반적으로 this 붙임  }  void setOwner(String owner){    this.owner = owner;  }  String getOwner(){    return this.owner;  }  void withdraw(int money){    System.out.println(\"출금 신청 액 : \"+money+\"원\");    if(money&lt;0){      System.out.println(\"출금액이 잘못 입력되었습니다.\");      return;    }    if(this.balance&lt;money){      System.out.println(\"잔액이 부족합니다.\");      return;    }    this.balance -= money;    System.out.println(money+\"원을 출금하였습니다. (잔액 : \"+balance+\"원)\");  }  void deposit(int money){    System.out.println(\"입금 신청 액 : \"+money+\"원\");    if(money&lt;0){      System.out.println(\"입금액이 잘못 입력되었습니다.\");      return;    }    this.balance += money;    System.out.println(money+\"원을 입금하였습니다. (잔액 : \"+balance+\"원)\");  }  void showInfo(){    System.out.println(\"소유주 : \"+this.owner+\" / 잔액 : \"+this.balance);  }}public class AccountEx {  public static void main(String[] args) {    Account account = new Account(10000,\"빅데이터\");    account.showInfo();    account.withdraw(100000);    account.withdraw(-100000);    account.withdraw(1000);    account.deposit(35000);    account.deposit(-10000);    account.showInfo();    account.setBalance(-1000);    account.showInfo();  }}      점수      public class StudentScore { //클래스 선언(정의, define)        //멤버변수(=인스턴스변수)    private String name;    private double score;        //생성자 : 객체를 생성함과 동시에 실행되는 메소드    //생성자 오버로딩    public StudentScore(){ //기본생성자. 만들지 않으면 빈 상태로 자바에서 생성함      System.out.println(\"StudentScore생성자 실행\");      this.name = \"aaa\";      // this.score = 95;      setScore(95);    }    public StudentScore(String name, double score){ //입력 값이 있는 생성자      System.out.println(\"StudentScore(name, score)\");      this.name = name;      // this.score = score;      setScore(score);    } //입력값이있는 생성자(Constructor)가 있으면 기본생성자는 자바가 자동으로 안만들어줌            //메소드(기능)    void showInfo(){      System.out.println(\"이름 : \"+name);      System.out.println(\"점수 : \"+score);      System.out.println(\"등급 : \"+getGrade());    }        void setScore(double s){ //int s : 파라미터, 외부 입력값      System.out.println(\"double\");      if(s &lt; 0 || s&gt;100){        System.out.println(\"입력값이 잘못되었습니다.\");        return;      }      this.score = s;    }          void setScore(int s){ //int s : 파라미터, 외부 입력값      System.out.println(\"int\");      if(s &lt; 0 || s&gt;100){        System.out.println(\"입력값이 잘못되었습니다.\");        return;      }        this.score = s;    }        String getGrade(){      String grade=\"\";          if(score&gt;100 || score&lt;0){        System.out.println(\"입력값이 잘못되었습니다.\");      }else if(score&gt;=90){        grade = \"A\"+(score&gt;=95?\"+\":\"0\");      }else if(score&gt;=80){        grade = \"B\"+(score&gt;=85?\"+\":\"0\");      }else if(score&gt;=70){        grade = \"C\"+(score&gt;=75?\"+\":\"0\");      }else if(score&gt;=60){        grade = \"D\"+(score&gt;=65?\"+\":\"0\");      }else{        grade = \"F\";      }      return grade;        }      }          public class ScoreMain{    public static void main(String[] args) {      StudentScore std1 = new StudentScore(); //new - 인스턴스화, 객체생성      std1.showInfo();      // std1.name = \"가나다\";      // std1.score = 85.7;      System.out.println();          // System.out.println(std1.name); 뒤늦게 private를 붙여서 에러뜸      // System.out.println(std1.score);              StudentScore std2 = new StudentScore();      std2.showInfo();      System.out.println();          // std2.name=\"라마바\";      // std2.score=95.2; //직접접근방식. 유효성검사를 못해서 거의 안씀      // System.out.println(std2.name);      // System.out.println(std2.score);              System.out.println(std1);      System.out.println(std2);              StudentScore[] std = {std1,std2};      System.out.println(std[0]);      System.out.println(std[1]);      System.out.println();      // System.out.println(std[0].name);      // System.out.println(std[1].name);              std1.showInfo();      std2.showInfo();      System.out.println();      std[0].showInfo();      std[1].showInfo();      System.out.println();      std[0].setScore(807.0);      std[0].showInfo();      System.out.println();      std[0].setScore(80.7); //간접접근방식      std[0].showInfo();              System.out.println(std[0].getGrade());      System.out.println(std[1].getGrade());              String g = std2.getGrade();      System.out.println(g);              StudentScore std3 = new StudentScore();      System.out.println(std3.getGrade()); //double초기값이 0이라서 f나옴          StudentScore std4 = new StudentScore(\"aaaa\",75);      std4.showInfo();      std4.setScore(85);      std4.setScore(85.7);        }  }            배달의 민족    일단 내가 짠거      public class restaurant {            final String[] pay = {\"만나서 결제, 바로결제\",\"매장, 포장\"};    private int min_amount;    private int min_time;    private int max_time;    private int min_delivery_tips;    private int max_delivery_tips;    private int pickup_amount;    private int pickup_min_time;    private int pickup_max_time;    private String address;    private String img;    private String name;    private String open_time;    private String close_time;    private String delivery_area;    private String notice;        restaurant(){}    restaurant(String attr[],int min_amount, int min_time, int max_time,               int min_delivery_tips, int max_delivery_tips, int pickup_amount, int pickup_min_time,               int pickup_max_time,String address)      {      this.img = attr[0];      this.name = attr[1];      this.open_time = attr[2];      this.close_time = attr[3];      this.delivery_area = attr[4];      this.notice = attr[5];      setMinAmount(min_amount);      setMinTime(min_time);      setMaxTime(max_time);      setMinDeliveryTips(min_delivery_tips);      setMaxDeliveryTips(max_delivery_tips);      setPickUpAmount(pickup_amount);      setPickUpMinTime(min_time);      setPickUpMinTime(max_time);      setPickUpMinTime(pickup_min_time);      setPickUpMaxTime(pickup_max_time);      setAddress(address);    }          void setName(String name){      this.name = name;    }    void setMinAmount(int min_amount){      if(min_amount&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");      }      this.min_amount = min_amount;    }    void setAddress(String address){      this.address = address;    }    void setMinTime(int min_time){      if(min_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.min_time = min_time;    }    void setMaxTime(int max_time){      if(max_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.max_time = max_time;    }    void setMinDeliveryTips(int min_delivery_tips){      if(min_delivery_tips&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.min_delivery_tips = min_delivery_tips;    }    void setMaxDeliveryTips(int max_delivery_tips){      if(max_delivery_tips&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.max_delivery_tips = max_delivery_tips;    }    void setPickUpAmount(int pickup_amount){      if(pickup_amount&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_amount = pickup_amount;    }    void setPickUpMinTime(int pickup_min_time){      if(pickup_min_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_min_time = pickup_min_time;    }    void setPickUpMaxTime(int pickup_max_time){      if(pickup_max_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_max_time = pickup_max_time;    }    void showInfo(){      System.out.println(\"이미지 : \"+img);      System.out.println(\"상호 : \"+name);      System.out.println(\"운영시간 : \"+open_time+\" ~ \"+close_time);      System.out.println(\"배달가능지역 : \"+delivery_area);      System.out.println(\"공지 : \"+notice);      System.out.println(\"===배달주문===\");      System.out.println(\"최소 주문 금액 : \"+min_amount);      System.out.println(\"결제방법 : \"+pay[0]);      if(min_time == 0){        System.out.println(\"배달시간 : \"+max_time+\"분 소요 예상\");      }else{        System.out.println(\"배달시간 : \"+min_time+\"~\"+max_time+\"분 소요 예상\");      }      if(min_delivery_tips == 0){        System.out.println(\"배달팁 : \"+max_delivery_tips+\"원\");      }else{        System.out.println(\"배달팁 : \"+min_delivery_tips+\"~\"+max_delivery_tips+\"원\");      }          System.out.println(\"===포장/방문주문===\");      if(pickup_amount != 0){        System.out.println(\"할인 : \"+pickup_amount+\"(\"+min_amount+\"원 이상 포장시 할인됩니다.)\");      }      System.out.println(\"최소 주문 금액 : 없음\");      System.out.println(\"이용방법 : \"+pay[1]);      if(pickup_min_time == 0){        System.out.println(\"픽업시간 : \"+pickup_max_time+\"분 소요 예상\");      }else{        System.out.println(\"픽업시간 : \"+pickup_min_time+\"~\"+pickup_max_time+\"분 소요 예상\");      }      System.out.println(\"주소 : \"+address);      System.out.println();      showMenu();      System.out.println();    }        private String[][] menu = new String[10][2];    private int index;    void addmenu(String item_name, String price){      if(index&gt;=menu.length){        System.out.println(\"상품을 등록할 수 없습니다. 관리자에게 문의하세요\");        index=9;        return;      }      if(Integer.parseInt(price)&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      menu[index][0]=item_name;      menu[index][1]= (String)price;      index++;    }    void showMenu(){      System.out.println(\"=======메뉴=======\");      for(int i=0;i&lt;=index;i++){        if(menu[i][0]==null){          System.out.println(\"아직 등록된 메뉴가 없습니다.\");          System.out.println(\"==================\");          continue;        }         System.out.println(\"상품 : \"+menu[i][0]);        System.out.println(\"가격 : \"+menu[i][1]);        System.out.println(\"===================\");      }    }    void order(String item_name, int num, int delivery_type){      for(int i=0;i&lt;=index;i++){        if(item_name.equals(menu[i][0])){          int sum = num*Integer.parseInt(menu[i][1]);          if(sum&lt;min_amount){            System.out.println(\"최소주문금액보다 주문금액이 적습니다.\");            return;          }          if(sum&gt;=20000){            System.out.println((sum)+\"원 주문하셨습니다\");            System.out.println(\"주문 메뉴 : \"+menu[i][0]);            System.out.println(\"주문 수량 : \"+num);            if(delivery_type==0){              System.out.println(\"배달비 : \"+min_delivery_tips);              System.out.println(\"총 결제금액 : \"+(sum+min_delivery_tips));            }else{              System.out.println(\"총 결제금액 : \"+sum);            }          }else{            System.out.println((sum)+\"원 주문하셨습니다\");            System.out.println(\"주문 메뉴 : \"+menu[i][0]);            System.out.println(\"주문 수량 : \"+num);            if(delivery_type==0){              System.out.println(\"배달비 : \"+max_delivery_tips);              System.out.println(\"총 결제금액 : \"+(sum+max_delivery_tips));            }else{              System.out.println(\"총 결제금액 : \"+sum);            }          }          return;        }      }      System.out.println(\"메뉴를 잘못입력하셨습니다.\");    }  }          public class restaurantEx {    public static void main(String[] args) {      String attr[] = {\"cafe.jpg\",\"커피홀\",\"오전 8:50\",\"오후 11:00\",\"내당동, 비산동, ...\",\"디저트만 배달이 불가합니다. 음료와 함께 주문해주세요\"};      restaurant cafe = new restaurant(attr,10000,9,24,1000,2500,0,5,15,\"대구 서구 내당동 890-37\");      cafe.showInfo();      System.out.println();      // restaurant chicken = new restaurant();      // chicken.setName(\"동근이숯불두마리치킨\");      // chicken.setMinAmount(16000);      // chicken.setMinTime(49);      // chicken.setMaxTime(64);      // chicken.setMaxDeliveryTips(2000);      // chicken.setPickUpAmount(1000);      // chicken.setAddress(\"대구광역시 북구 고성동2가 114-9 1층\");      // chicken.setPickUpMaxTime(32);      // chicken.setPickUpMinTime(22);      // chicken.showInfo();      // System.out.println();              cafe.addmenu(\"아메리카노\", \"3700\");      cafe.addmenu(\"바닐라라떼\", \"4500\");      cafe.addmenu(\"흑당카페라떼\", \"5300\");      cafe.addmenu(\"제주한라봉스무디\", \"5300\");      cafe.addmenu(\"콜드브루 아인슈페너\", \"5500\");      cafe.addmenu(\"홍시주스\", \"5500\");      cafe.addmenu(\"초코렛라떼\", \"4300\");      cafe.addmenu(\"그린티라떼\", \"4300\");      cafe.addmenu(\"캐모마일허브티\", \"4300\");      cafe.addmenu(\"망고쥬스\", \"5500\");      cafe.addmenu(\"레몬에이드\", \"5000\");      System.out.println();      System.out.println();      cafe.showInfo();          cafe.order(\"아메리카노\", 2,0);      System.out.println();      cafe.order(\"아메\", 2,1);      System.out.println();      cafe.order(\"바닐라라떼\", 10,1);      System.out.println();      cafe.order(\"콜드브루 아인슈페너\", 3,0);        }  }          public class restaurant {            final String[] pay = {\"만나서 결제, 바로결제\",\"매장, 포장\"};    private int min_amount;    private int min_time;    private int max_time;    private int min_delivery_tips;    private int max_delivery_tips;    private int pickup_amount;    private int pickup_min_time;    private int pickup_max_time;    private String address;    private String img;    private String name;    private String open_time;    private String close_time;    private String delivery_area;    private String notice;        restaurant(){}    restaurant(String attr[],int min_amount, int min_time, int max_time,         int min_delivery_tips, int max_delivery_tips, int pickup_amount, int pickup_min_time,         int pickup_max_time,String address)      {      this.img = attr[0];      this.name = attr[1];      this.open_time = attr[2];      this.close_time = attr[3];      this.delivery_area = attr[4];      this.notice = attr[5];      setMinAmount(min_amount);      setMinTime(min_time);      setMaxTime(max_time);      setMinDeliveryTips(min_delivery_tips);      setMaxDeliveryTips(max_delivery_tips);      setPickUpAmount(pickup_amount);      setPickUpMinTime(min_time);      setPickUpMinTime(max_time);      setPickUpMinTime(pickup_min_time);      setPickUpMaxTime(pickup_max_time);      setAddress(address);    }          void setName(String name){      this.name = name;    }    void setMinAmount(int min_amount){      if(min_amount&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");      }      this.min_amount = min_amount;    }    void setAddress(String address){      this.address = address;    }    void setMinTime(int min_time){      if(min_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.min_time = min_time;    }    void setMaxTime(int max_time){      if(max_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.max_time = max_time;    }    void setMinDeliveryTips(int min_delivery_tips){      if(min_delivery_tips&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.min_delivery_tips = min_delivery_tips;    }    void setMaxDeliveryTips(int max_delivery_tips){      if(max_delivery_tips&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.max_delivery_tips = max_delivery_tips;    }    void setPickUpAmount(int pickup_amount){      if(pickup_amount&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_amount = pickup_amount;    }    void setPickUpMinTime(int pickup_min_time){      if(pickup_min_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_min_time = pickup_min_time;    }    void setPickUpMaxTime(int pickup_max_time){      if(pickup_max_time&lt;0){        System.out.println(\"입력시간이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      this.pickup_max_time = pickup_max_time;    }    void showInfo(){      System.out.println(\"이미지 : \"+img);      System.out.println(\"상호 : \"+name);      System.out.println(\"운영시간 : \"+open_time+\" ~ \"+close_time);      System.out.println(\"배달가능지역 : \"+delivery_area);      System.out.println(\"공지 : \"+notice);      System.out.println(\"===배달주문===\");      System.out.println(\"최소 주문 금액 : \"+min_amount);      System.out.println(\"결제방법 : \"+pay[0]);      if(min_time == 0){        System.out.println(\"배달시간 : \"+max_time+\"분 소요 예상\");      }else{        System.out.println(\"배달시간 : \"+min_time+\"~\"+max_time+\"분 소요 예상\");      }      if(min_delivery_tips == 0){        System.out.println(\"배달팁 : \"+max_delivery_tips+\"원\");      }else{        System.out.println(\"배달팁 : \"+min_delivery_tips+\"~\"+max_delivery_tips+\"원\");      }          System.out.println(\"===포장/방문주문===\");      if(pickup_amount != 0){        System.out.println(\"할인 : \"+pickup_amount+\"(\"+min_amount+\"원 이상 포장시 할인됩니다.)\");      }      System.out.println(\"최소 주문 금액 : 없음\");      System.out.println(\"이용방법 : \"+pay[1]);      if(pickup_min_time == 0){        System.out.println(\"픽업시간 : \"+pickup_max_time+\"분 소요 예상\");      }else{        System.out.println(\"픽업시간 : \"+pickup_min_time+\"~\"+pickup_max_time+\"분 소요 예상\");      }      System.out.println(\"주소 : \"+address);      System.out.println();      showMenu();      System.out.println();    }        private String[][] menu = new String[10][2];    private int index;    void addmenu(String item_name, String price){      if(index&gt;=menu.length){        System.out.println(\"상품을 등록할 수 없습니다. 관리자에게 문의하세요\");        index=9;        return;      }      if(Integer.parseInt(price)&lt;0){        System.out.println(\"입력금액이 잘못되었습니다. 양수로 입력해주세요\");        return;      }      menu[index][0]=item_name;      menu[index][1]= (String)price;      index++;    }    void showMenu(){      System.out.println(\"=======메뉴=======\");      for(int i=0;i&lt;=index;i++){        if(menu[i][0]==null){          System.out.println(\"아직 등록된 메뉴가 없습니다.\");          System.out.println(\"==================\");          continue;        }         System.out.println(\"상품 : \"+menu[i][0]);        System.out.println(\"가격 : \"+menu[i][1]);        System.out.println(\"===================\");      }    }    private String[][] cart = new String[10][3];    int cart_index;    void addcart(String item_name, int num, int delivery_type){      for(int i=0;i&lt;=index;i++){        if(item_name.equals(menu[i][0])){          cart[cart_index][0] = menu[i][0];          cart[cart_index][1] = Integer.toString(num);          cart[cart_index][2] = menu[i][1];          cart_index++;        }      }      System.out.println(\"메뉴를 잘못입력하셨습니다.\");    }          void order(int delivery_type){      int sum=0;      String order_list=\"\";      for(int i=0;i&lt;=index;i++){        if(cart[i][0]==null){          continue;        }        sum += Integer.parseInt(cart[i][1])*Integer.parseInt(cart[i][2]);        order_list += cart[i][0] +\" \" + cart[i][1]+ \"개, \"+\"\\n\";      }      if(sum&lt;min_amount){        System.out.println(\"최소주문금액보다 주문금액이 적습니다.\");        return;      }      if(sum&gt;=20000){        System.out.println(\"주문 메뉴 : \\n\"+order_list);        if(delivery_type==0){          System.out.println(\"배달비 : \"+min_delivery_tips);          System.out.println(\"총 결제금액 : \"+(sum+min_delivery_tips));        }else{          System.out.println(\"총 결제금액 : \"+sum);        }      }else{        System.out.println((sum)+\"원 주문하셨습니다\");        System.out.println(\"주문 메뉴 : \"+order_list);        if(delivery_type==0){          System.out.println(\"배달비 : \"+max_delivery_tips);          System.out.println(\"총 결제금액 : \"+(sum+max_delivery_tips));        }else{          System.out.println(\"총 결제금액 : \"+sum);        }      }    }  }          public class restaurantEx {    public static void main(String[] args) {      String attr[] = {\"cafe.jpg\",\"커피홀\",\"오전 8:50\",\"오후 11:00\",\"내당동, 비산동, ...\",\"디저트만 배달이 불가합니다. 음료와 함께 주문해주세요\"};      restaurant cafe = new restaurant(attr,10000,9,24,1000,2500,0,5,15,\"대구 서구 내당동 890-37\");      cafe.showInfo();      System.out.println();      // restaurant chicken = new restaurant();      // chicken.setName(\"동근이숯불두마리치킨\");      // chicken.setMinAmount(16000);      // chicken.setMinTime(49);      // chicken.setMaxTime(64);      // chicken.setMaxDeliveryTips(2000);      // chicken.setPickUpAmount(1000);      // chicken.setAddress(\"대구광역시 북구 고성동2가 114-9 1층\");      // chicken.setPickUpMaxTime(32);      // chicken.setPickUpMinTime(22);      // chicken.showInfo();      // System.out.println();              cafe.addmenu(\"아메리카노\", \"3700\");      cafe.addmenu(\"바닐라라떼\", \"4500\");      cafe.addmenu(\"흑당카페라떼\", \"5300\");      cafe.addmenu(\"제주한라봉스무디\", \"5300\");      cafe.addmenu(\"콜드브루 아인슈페너\", \"5500\");      cafe.addmenu(\"홍시주스\", \"5500\");      cafe.addmenu(\"초코렛라떼\", \"4300\");      cafe.addmenu(\"그린티라떼\", \"4300\");      cafe.addmenu(\"캐모마일허브티\", \"4300\");      cafe.addmenu(\"망고쥬스\", \"5500\");      cafe.addmenu(\"레몬에이드\", \"5000\");      System.out.println();      System.out.println();      cafe.showInfo();          cafe.addcart(\"아메리카노\", 2,0);      System.out.println();      cafe.addcart(\"아메\", 2,1);      System.out.println();      cafe.addcart(\"바닐라라떼\", 10,1);      System.out.println();      cafe.addcart(\"콜드브루 아인슈페너\", 3,0);          cafe.order(0);      System.out.println();      cafe.order(1);        }  }        이차원 String배열에 int값을 받는게 애매해서 선생님께 이럴때는 일차원배열을 여러개 쓰는게 낫냐고 물어봤는데 일반적으로는 클래스배열을 사용한다고 하심!!클래스배열….      public class StoreBasicInfo {    String thumbnail;    String name;    Double score;    Integer min_order_price;    String[] payments;    Integer min_delivery_time;    Integer max_delivery_time;    Integer min_delivery_price;    Integer max_delivery_price;        public StoreBasicInfo(        String thumbnail, String name, double score, int min_order_price, String[] payments,       int min_delivery_time, int max_delivery_time, int min_delivery_price, int max_delivery_price    ){      this.thumbnail=thumbnail;      setName(name);      setScore(score);      setMinOrderPrice(min_order_price);      setPayments(payments);      setDeliveryTime(min_delivery_time, max_delivery_time);      setDeliveryPrice(min_delivery_price, max_delivery_price);    }        void setName(String name){      if(name.length() ==0){        System.out.println(\"가게 이름을 올바르게 설정하세요.\");      }else{        this.name = name;      }    }    void setScore(double score){      if(score&lt;0 || score&gt;5){        System.out.println(\"별점을 올바르게 입력하세요\");      }else{        this.score = score;      }    }    void setMinOrderPrice(int min_order_price){      if(min_order_price ==0){        System.out.println(\"올바른 최소주문 금액을 입력하세요.\");      }else{        this.min_order_price = min_order_price;      }    }    void setPayments(String[] payments){      if(payments==null || payments.length ==0){        System.out.println(\"올바른 결제방법을 입력하세요.\");      }else{        this.payments = payments;      }    }    void setDeliveryTime(int min, int max){      if(min&lt;0){        System.out.println(\"올바른 배달시간을 입력하세요.\");      }else{        this.min_delivery_time = min;        this.max_delivery_time = max;      }    }    void setDeliveryPrice(int min, int max){      if(min&lt;0){        System.out.println(\"올바른 배달팁을 입력하세요.\");      }else{        this.min_delivery_price = min;        this.max_delivery_price = max;      }    }    public String toString(){      String str =\"\";      str += \"=======================기존정보=======================\\n\";      str += name+\"\\n\";      int nScore = (int)(Math.round(score));      str += \"별점 : \";      for(int i=0;i&lt;5;i++){        if(i &lt; nScore){          str+=\"★ \";        }else{          str+=\"☆\";        }      }      str+=\" \"+score+\"\\n\";      str +=\"최소주문금액 : \"+min_order_price+\"원\\n\";      str += \"결제 방법 : \";      for(int i=0;i&lt;payments.length;i++){        str += payments[i]+ \" \";      }      str+=\"배달시간 : \"+min_delivery_time+\" ~ \"+max_delivery_time+\"분\\n\";      str+=\"배달 팁 : \"+min_delivery_price + \" ~ \"+max_delivery_price+\"원\\n\";          return str;    }  }          public class StoreBusinessInfo {    String business_owner;    String business_name;    String business_address;    String business_number;        public StoreBusinessInfo(        String business_owner,        String business_name,        String business_address,        String business_number      ){        this.business_owner = business_owner;        this.business_name = business_name;        this.business_address = business_address;        this.business_number = business_number;                }      public String toString(){        String str = \"\";        str +=\"대표자 : \"+business_owner+\"\\n\";        str +=\"상호명 : \"+business_name+\"\\n\";        str +=\"사업자주소 : \"+business_address+\"\\n\";        str +=\"사업자등록번호 : \"+business_number;            return str;      }  }          public class StoreDetailInfo {    String introduce;    String origin_name;    String open_time;    String close_time;    String[] close_day;    String phone;    String delivery_area;    String notice;    // int[][] delivery_boundary;    DeliveryBoundary[] delivery_boundaries;          public StoreDetailInfo(      String introduce, String origin_name, String open_time, String close_time, String[] close_day, String phone,       String delivery_area, String notice, DeliveryBoundary[] delivery_boundaries    ){      this.introduce = introduce;      this.origin_name = origin_name;      this.open_time = open_time;      this.close_time = close_time;      this.close_day=close_day;      this.phone = phone;      this.delivery_area = delivery_area;      this.notice = notice;      this.delivery_boundaries =delivery_boundaries;    }        public String toString(){      String str=\"\";      str += \"가게소개 \\n\";      str +=introduce+\"\\n\";      str = \"영업정보\\n\";      str = \"상호명 : \"+origin_name+\"\\n\";      str = \"영업시간 : \"+open_time+\" ~ \"+close_time+\"\\n\";      str = \"휴무일 : \";      if(close_day == null){        str+=\"연중무후\";      }else{        str+=close_day+\"/n\";      }      str = \"전화번호 : \"+phone+\"\\n\";      str = \"배달지역 : \"+delivery_area+\"\\n\";      str = \"배달팁\\n\";      if(delivery_area == null){        str+=\"무료\";      }else{        for(int i=0;i&lt;delivery_boundaries.length;i++){          str+=delivery_boundaries[i].boundary+\"원 이상 : \";          str+=delivery_boundaries[i].price+\"원\\n\";        }      }          return str;    }      }          public class StoreInfo {    StoreBasicInfo store_basic;    StoreDetailInfo store_detail;    StoreBusinessInfo store_business;    public String toString(){      String str =\"\";      str+=store_basic.toString();      str+=store_detail.toString();      str+=store_business.toString();      return str;    }        public StoreInfo(StoreBasicInfo basicInfo, StoreDetailInfo detial, StoreBusinessInfo business){      store_basic = basicInfo;      store_detail = detial;      store_business = business;    }  }          public class StoreMain {    public static void main(String[] args) {      // StoreInfo store = new StoreInfo();      String[] payments={\"바로결제\",\"만나서결제\"};      StoreBasicInfo basicInfo = new StoreBasicInfo(\"store.jpg\", \"교촌치킨 송현점\", 4.9, 16000, payments, 38, 53, 2000, 3000);      System.out.println(basicInfo);      // store.store_basic = basicInfo;      DeliveryBoundary[] boundaries = {        new DeliveryBoundary(50000, 2000),        new DeliveryBoundary(16000, 3000)      };      StoreDetailInfo detailInfo = new StoreDetailInfo(\"바쁘면 오래걸림, 따뜻한 치킨 배달하겠음\",        \"교촌치킨 송현1호점\", \"12:30\", \"23:35\", null, \"050-6115-1090\", \"송현1동 송현2동 본동일부 상인동 대명동\",         \"포장은 접수번호를 말하세요, 귀찮으면 전번 알려주세요\", boundaries);        // store.store_detail=detailInfo;        StoreBusinessInfo businessInfo = new StoreBusinessInfo(\"노경곤\", \"교촌치킨 송현 1호점\", \"대구광역시 달서구 송현동 207-2\", \"541-25-55195\");        // store.store_business = businessInfo;        StoreInfo store = new StoreInfo(basicInfo, detailInfo, businessInfo);        System.out.println(store);        StoreInfo store2 = new StoreInfo(          new StoreBasicInfo(\"store.jpg\", \"교촌치킨 송현점\", 4.9, 16000, payments, 38, 53, 2000, 3000),          new StoreDetailInfo(\"바쁘면 오래걸림, 따뜻한 치킨 배달하겠음\",            \"교촌치킨 송현1호점\", \"12:30\", \"23:35\", null, \"050-6115-1090\", \"송현1동 송현2동 본동일부 상인동 대명동\",             \"포장은 접수번호를 말하세요, 귀찮으면 전번 알려주세요\", boundaries),          new StoreBusinessInfo(\"노경곤\", \"교촌치킨 송현 1호점\", \"대구광역시 달서구 송현동 207-2\", \"541-25-55195\"));          System.out.println(store2);    }  }          public class DeliveryBoundary{    int boundary;    int price;    public DeliveryBoundary(int boundary, int price){      setBountdary(boundary);      setPrice(price);    }    void setBountdary(int boundary){      if(boundary&gt;0){        this.boundary=boundary;      }    }    void setPrice(int price){      if(price&gt;0){        this.price=price;      }    }  }      "
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 변수와 메소드",
    "url": "/posts/%EB%B3%80%EC%88%98%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C/",
    "categories": "",
    "tags": "java, 국비교육, 변수",
    "date": "2022-10-27 00:00:00 +0900",
    





    
    "snippet": "인스턴스변수 : 대표적으로 String str = new String(0);지역변수 : 메소드내에서 변수선언문 수행 시메소드 : 명령문의 집합. 값을 입력받아처리 후 결과를 돌려줌(결과 안돌려줄수도있음 - void[공허]), ()붙은건 전부 메소드임. - 정보은닉, 캡슐화  cmd로 args값 받는 법M누르고 탭누르면 해당 자바파일 자동완성됨프로그램실...",
    "content": "인스턴스변수 : 대표적으로 String str = new String(0);지역변수 : 메소드내에서 변수선언문 수행 시메소드 : 명령문의 집합. 값을 입력받아처리 후 결과를 돌려줌(결과 안돌려줄수도있음 - void[공허]), ()붙은건 전부 메소드임. - 정보은닉, 캡슐화  cmd로 args값 받는 법M누르고 탭누르면 해당 자바파일 자동완성됨프로그램실행시에 완전 외부에서 특정 데이터를 심어서 같이실행하는 방법(java -version과 같은것임)프로그램으로 받을수도 있음실행결과가 뜨는 터미널이 파워쉘(cmd비슷한거)임.import java.util.Scanner;public class Member_method {    static final int MAX_MOMBER = 100;    static String user_id = \"\";    static String user_pw = \"\";    static String user_name = \"\";    static String user_birth = \"\";            static String user[][] = new String[MAX_MOMBER][4];    static int index = 0;    static Scanner s = new Scanner(System.in);    static int input=0;    static boolean id_check = true;    static boolean login_check=false;    public static void main(String[] args) {        while(true){            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 4.회원탈퇴, 5.회원정보조회, 0.종료 : &gt; \");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1: //회원가입                    String result = input_member();                    // 아이디, 비번 6자리 이상. 미만이면 실패                    for(index=0;index&lt;user.length;index++){                        if(user[index][0] == null){                            break;                        }                    }                    if(index==user.length){                        System.out.println(\"회원가입에 실패했습니다. 관리자에게 문의하십시오.\");                        break;                    }                    if(result.split(\",\").length==4){                        user[index][0] = result.split(\",\")[0];                         user[index][1] = result.split(\",\")[1];                         user[index][2] = result.split(\",\")[2];                         user[index][3] = result.split(\",\")[3];                     }                    break;                case 2:  // 로그인(조회)                    login();                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 3:// 회원정보 수정                    login();                    if(login_check){                        result = input_member();                        if(result.split(\",\").length==4){                            user[index][0] = result.split(\",\")[0];                             user[index][1] = result.split(\",\")[1];                             user[index][2] = result.split(\",\")[2];                             user[index][3] = result.split(\",\")[3];                         }                    }                    else {                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 4:                     login();                    if(login_check){                        System.out.print(\"정말 회원탈퇴하시겠습니까?(1-예. 0-아니오) &gt; \");                        input =s.nextInt();                        if(input==1){                            user[index][0] = null;                            user[index][1] = null;                            user[index][2] = null;                            user[index][3] = null;                            break;                        }                        else {                            System.out.println(\"회원탈퇴가 취소되었습니다. 처음으로 돌아갑니다.\");                        }                    }else {                            System.out.println(\"아이디와 비밀번호를 확인해주세요\");                            break;                    }                    break;                case 5:                    int manager_code = 1234;                    System.out.print(\"관리자 코드를 입력하세요 : &gt;\");                    input = s.nextInt();                    if(input == manager_code){                        for(int i=0;i&lt;user.length;i++){                            if(user[i][0]!=null){                                System.out.println(\"===회원정보====\");                                System.out.println(\"아이디 : \"+user[i][0]);                                System.out.print(\"비밀번호 : \");                                for(int j=0;j&lt;user[i][1].length();j++){                                    System.out.print(\"*\");                                }                                System.out.println();                                System.out.println(\"이름 : \"+user[i][2]);                                System.out.println(\"생년월일 : \"+user[i][3]);                            }                        }                    }                    break;                case 0:                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"입력번호가 잘못되었습니다.\");            }//switch        }//while    }//main       public static String input_member(){        System.out.print(\"아이디를 입력하세요(6자리 이상) : &gt; \");        user_id=s.nextLine();        if(user_id.length()&lt;6){            System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");            return \"\";        }        id_check = true;        for(int i=0;i&lt;user.length;i++){            if(user_id.equals(user[i][0])){                System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                id_check = false;            }        }        if(id_check){            System.out.print(\"비밀번호를 입력하세요(6자리 이상) : &gt; \");            user_pw=s.nextLine();            if(user_pw.length()&lt;6){                System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                return \"\";            }            System.out.print(\"이름을 입력하세요 : &gt; \");            user_name=s.nextLine();            System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");            user_birth=s.nextLine();            if(user_birth.length()!=8){                System.out.println(\"생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                return \"\";            }        }        return user_id+\",\"+user_pw+\",\"+user_name+\",\"+user_birth;    }//input_member    public static boolean login(){        System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");        user_id = s.nextLine();        System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");        user_pw = s.nextLine();        login_check=false;        for(int i=0;i&lt;user.length;i++){            if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                login_check =true;                index = i;                System.out.println(\"=====회원정보=====\");                System.out.println(\"아이디 : \"+user[i][0]);                System.out.println(\"이름 : \"+user[i][2]);                System.out.println(\"생년월일 : \"+user[i][3]);            }        }        return login_check;    }}//class회원가입 코드 예습겸 로그인이랑 입력받은 회원정보 유효성검사하는부분 메소드안에 넣어봤다. input_member()메소드 중간중간에 return때문에 main메소드안에서 if(result.split(“,”).length == 4)를 사용했는데 조금 마음에 안든다..내일 학원가서 물어보던가해야지..package JAVA_221027;import java.util.Scanner;public class Ex01_Method2 {    final static int MAX_VALUE = 10;    static String[] member_id = new String[MAX_VALUE];    static String[] member_pwd = new String[MAX_VALUE];    static String[] member_name = new String[MAX_VALUE];    static String[] member_birth = new String[MAX_VALUE];    static int next_index = 0;    static Scanner  s = new Scanner(System.in);    public static int checkMember(){        System.out.print(\"아이디 : \");        String login_id = s.nextLine();        System.out.print(\"비밀번호 : \");        String login_pwd = s.nextLine();        int member_index=-1;        for(int i=0;i&lt;MAX_VALUE;i++){            if(login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){                 System.out.println(\"==인증 성공==\");                System.out.println(\"아이디 : \"+member_id[i]);                System.out.println(\"이름: \"+member_name[i]);                System.out.println(\"생년월일 : \"+member_birth[i]);                member_index=i;                break;            }        }        return member_index;    }    public static void makeDummyDate(int num){        if(num&lt;0){                        return; //음수가 입력되면 실행안함        }        else if(num&gt;MAX_VALUE){            num=MAX_VALUE;        }        for(int i=0;i&lt;num;i++){            member_id[i] = \"member\"+i;            member_pwd[i] = \"123456\";            member_name [i] = \"사용자\";            member_birth[i] = \"20221027\";        } //더미값넣기        next_index=num;    }    public static String inputMemberInfo(){        System.out.print(\"아이디(8자이상) : \");        String id;        while(true){            id = s.nextLine();            if(id.length()&lt;8) {                System.out.print(\"아이디는 8자리 이상이어야합니다. 다시 입력해주세요 \");                continue;            }            boolean isDuplicate = false;            for(int i=0;i&lt;MAX_VALUE;i++){                if(id.equals(member_id[i])){                    System.out.print(\"이미 가입된 아이디 입니다. 다시입력해주세요\");                    isDuplicate=true;                }            }            if(!isDuplicate) break;        }        System.out.print(\"비밀번호(6자이상) : \");        String pwd;        while(true){            pwd = s.nextLine();            if(pwd.length()&lt;6) {                System.out.print(\"비밀번호는 6자리 이상이어야합니다. 다시 입력해주세요 \");                continue;            }else {                break;            }        }        System.out.print(\"이름 : \");        String name = s.nextLine();        System.out.print(\"생년월일(8자리) : \");        String birth;        while(true){            birth = s.nextLine();            if(birth.length()!=8) {                System.out.print(\"생년월일은 8자리로 입력하세요. 다시 입력해주세요 \");                continue;            }else {                break;            }        }        return id+\",\"+pwd+\",\"+name+\",\"+birth;    }    public static void deleteMember(int member){        member_id[member] = null;        member_pwd[member] = null;        member_name[member] = null;        member_birth[member] = null;        System.out.println(\"==회원 탈퇴 완료==\");        String[] temp1 = new String[MAX_VALUE];        String[] temp2 = new String[MAX_VALUE];        String[] temp3 = new String[MAX_VALUE];        String[] temp4 = new String[MAX_VALUE];        for(int i=0;i&lt;MAX_VALUE;i++){            temp1[i] = member_id[i]; //배열복사            temp2[i] = member_pwd[i]; //배열복사            temp3[i] = member_name[i]; //배열복사            temp4[i] = member_birth[i]; //배열복사        }        for(int i=0;i&lt;MAX_VALUE;i++){            member_id[i]=null;            member_pwd[i]=null;            member_name[i]=null;            member_birth[i]=null;        }        int n =0;        int n2=0;        while(n&lt;MAX_VALUE){            if(temp1[n]!=null){                member_id[n2]=temp1[n];                member_pwd[n2]=temp2[n];                member_name[n2]=temp3[n];                member_birth[n2]=temp4[n];                n2++;            }            n++; //만약 temp[i]가 null이라면, n2는 증가하지 않아서 한자리씩 땡겨짐.        }        next_index--;    }    public static void main(String[] args) {        //1차원배열로 진행, 재차입력요구까지 구현        makeDummyDate(5);        while(true){            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 4.회원탈퇴, 5.회원정보조회, 0.종료 : &gt; \");            int sel = s.nextInt();            if(sel == 0) {                System.out.println(\"종료합니다.\");                s.close();                return;            }            s.nextLine();            switch(sel){                case 1 :                    if(next_index==MAX_VALUE){                        System.out.println(\"더 이상 가입불가능합니다.\");                        break;                    }                    System.out.println(\"=====회원정보 등록=====\");                    String input_value = inputMemberInfo();                    member_id[next_index] = input_value.split(\",\")[0];                    member_pwd[next_index] = input_value.split(\",\")[1];                    member_name[next_index] = input_value.split(\",\")[2];                    member_birth[next_index] = input_value.split(\",\")[3];                    next_index++;                    System.out.println(\"==회원등록 완료==\");                    break;                case 2 :                    System.out.println(\"==로그인==\");                    int member_index = checkMember();                    if(member_index==-1){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                    }                    break;                case 3 :                    member_index=checkMember();                    if(member_index==-1){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                        break;                    }                    System.out.println(\"====등록된 정보 수정====\");                    input_value = inputMemberInfo();                    System.out.print(\"수정하시겠습니까? 1:예. 0:아니오.&gt; \");                    int confirm =s.nextInt();                    if(confirm==1){                        member_id[member_index] = input_value.split(\",\")[0];                        member_pwd[member_index] = input_value.split(\",\")[1];                        member_name[member_index] = input_value.split(\",\")[2];                        member_birth[member_index] = input_value.split(\",\")[3];                        System.out.println(\"==회원 정보 수정 완료==\");                    }                    else {                        System.out.println(\"정보수정이 취소되었습니다\");                    }                    break;                case 4 :                    member_index = checkMember();                    if(member_index==-1){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                        break;                    }                    System.out.print(\"탈퇴하시겠습니까? 1:예. 0:아니오.&gt; \");                    confirm =s.nextInt();                    if(confirm==1){                        deleteMember(member_index);                    }                    else {                        System.out.println(\"회원탈퇴가 취소되었습니다\");                    }                    break;                case 5 :                    for(int i=0;i&lt;MAX_VALUE;i++){                        if(member_id[i]!=null){                                System.out.println(\"===회원정보===\");                                System.out.println(\"아이디 : \"+member_id[i]);                                System.out.println(\"생년월일 : \"+member_pwd[i]);                                System.out.println(\"비밀번호 : \"+member_birth[i]);                            }                        }                    break;                default :                     System.out.println(\"잘못된 메뉴번호입니다.\");            }        }    }}선생님 코드 메소드화함. 메소드를 사용하지않고 같은 부분을 반복작성하는것을 하드코딩이라고함. 틀린건아님"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 배열2",
    "url": "/posts/%EB%B0%B0%EC%97%B42/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 배열",
    "date": "2022-10-26 00:00:00 +0900",
    





    
    "snippet": "회원가입package JAVA_221026;import java.util.Scanner;public class Ex01 {    public static void main(String[] args) {        String user_id = \"\";        String user_pw = \"\";        String user_name = \"\"...",
    "content": "회원가입package JAVA_221026;import java.util.Scanner;public class Ex01 {    public static void main(String[] args) {        String user_id = \"\";        String user_pw = \"\";        String user_name = \"\";        String user_birth = \"\";                String user[][] = new String[10][4];        int index = 0;        for(int i=0;i&lt;user.length;i++){            user[i][0] = \"\";        }        while(true){            Scanner s = new Scanner(System.in);            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 0.종료 : &gt; \");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1: //회원가입                    // 아이디, 비번 6자리 이상. 미만이면 실패                    if(index&gt;=user.length){                        System.out.println(\"허용 가입인원수를 초과하였습니다. 더이상 등록할 수 없습니다.\");                    }                    System.out.print(\"아이디를 입력하세요(6자리 이상) : &gt; \");                    user_id=s.nextLine();                    if(user_id.length()&lt;6){                        System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    System.out.print(\"비밀번호를 입력하세요(6자리 이상) : &gt; \");                    user_pw=s.nextLine();                    if(user_pw.length()&lt;6){                        System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    System.out.print(\"이름을 입력하세요 : &gt; \");                    user_name=s.nextLine();                    // 생년월일 8자리 아니면 실패                    System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                    user_birth=s.nextLine();                    if(user_birth.length()!=8){                        System.out.println(\"생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                        break;                    }                    //이미 가입된 아이디가 있으면 실패                    boolean id_check = true;                    for(int i=0;i&lt;user.length;i++){                        if(user[i][0].equals(user_id)){                            System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                            id_check = false;                            break;                        }                    }                    if(id_check){                        user[index][0] = user_id;                         user[index][1] = user_pw;                         user[index][2] = user_name;                         user[index][3] = user_birth;                         index++;                    }                    break;                case 2:  // 로그인(조회)                    // 아이디,비번입력                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    boolean login_check=false;                    for(int i=0;i&lt;user.length;i++){                        // 성공시 비번제외 회원정보 출력                        if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                            login_check =true;                            System.out.println(\"=====회원정보=====\");                            System.out.println(\"아이디 : \"+user[i][0]);                            System.out.println(\"이름 : \"+user[i][2]);                            System.out.println(\"생년월일 : \"+user[i][3]);                        }                    }                    // 일치아니면 실패. 로그인 정보가 잘못되었습니다                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 3:// 회원정보 수정                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    login_check=false;                    for(int i=0;i&lt;user.length;i++){                        // 성공시 비번제외 회원정보 출력                        if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                            login_check =true;                            System.out.print(\"변경할 아이디를 입력하세요(6자리 이상) : &gt; \");                            user_id=s.nextLine();                            if(user_id.length()&lt;6){                                System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            System.out.print(\"변경할 비밀번호를 입력하세요(6자리 이상) : &gt; \");                            user_pw=s.nextLine();                            if(user_pw.length()&lt;6){                                System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            System.out.print(\"변경할 이름을 입력하세요 : &gt; \");                            user_name=s.nextLine();                            System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                            user_birth=s.nextLine();                            if(user_birth.length()!=8){                                System.out.println(\"변경할 생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                                break;                            }                            id_check = true;                            for(int j=0;j&lt;user.length;j++){                                if(user[j][0].equals(user_id)){                                    System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                                    id_check = false;                                    break;                                }                            }                            if(id_check){                                // 수정하시겠습니까?(condirm처리)                                System.out.println(\"수정하시겠습니까?(1-예. 0-아니오) &gt; \");                                int input = s.nextInt();                                if(input==1){                                    user[i][0] = user_id;                                     user[i][1] = user_pw;                                     user[i][2] = user_name;                                     user[i][3] = user_birth;                                 }                            }                        }                    }                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 0:                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"입력번호가 잘못되었습니다.\");            }//switch        }//while    }//main}//class2차원배열 씀package JAVA_221026;import java.util.Scanner;public class Ex01ver2 {    public static void main(String[] args) {        String user_id = \"\";        String user_pw = \"\";        String user_name = \"\";        String user_birth = \"\";                String arr_id[] = new String[10];        String arr_pw[] = new String[10];        String arr_name[] = new String[10];        String arr_birth[] = new String[10];        int index = 0;        for(int i=0;i&lt;arr_id.length;i++){            arr_id[i] = \"\";        }        while(true){            Scanner s = new Scanner(System.in);            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 0.종료 : &gt; \");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1: //회원가입                    // 아이디, 비번 6자리 이상. 미만이면 실패                    if(index&gt;=arr_id.length){                        System.out.println(\"허용 가입인원수를 초과하였습니다. 더이상 등록할 수 없습니다.\");                    }                    System.out.print(\"아이디를 입력하세요(6자리 이상) : &gt; \");                    user_id=s.nextLine();                    if(user_id.length()&lt;6){                        System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    System.out.print(\"비밀번호를 입력하세요(6자리 이상) : &gt; \");                    user_pw=s.nextLine();                    if(user_pw.length()&lt;6){                        System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    System.out.print(\"이름을 입력하세요 : &gt; \");                    user_name=s.nextLine();                    // 생년월일 8자리 아니면 실패                    System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                    user_birth=s.nextLine();                    if(user_birth.length()!=8){                        System.out.println(\"생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                        break;                    }                    //이미 가입된 아이디가 있으면 실패                    boolean id_check = true;                    for(int i=0;i&lt;arr_id.length;i++){                        if(arr_id[i].equals(user_id)){                            System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                            id_check = false;                            break;                        }                    }                    if(id_check){                        arr_id[index] = user_id;                         arr_pw[index] = user_pw;                         arr_name[index] = user_name;                         arr_birth[index] = user_birth;                         index++;                    }                    break;                case 2:  // 로그인(조회)                    // 아이디,비번입력                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    boolean login_check=false;                    for(int i=0;i&lt;arr_id.length;i++){                        // 성공시 비번제외 회원정보 출력                        if(user_id.equals(arr_id[i]) &amp;&amp;  user_pw.equals(arr_pw[i])){                            login_check =true;                            System.out.println(\"=====회원정보=====\");                            System.out.println(\"아이디 : \"+arr_id[i]);                            System.out.println(\"이름 : \"+arr_name[i]);                            System.out.println(\"생년월일 : \"+arr_birth[i]);                        }                    }                    // 일치아니면 실패. 로그인 정보가 잘못되었습니다                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 3:// 회원정보 수정                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    login_check=false;                    for(int i=0;i&lt;arr_id.length;i++){                        // 성공시 비번제외 회원정보 출력                        if(user_id.equals(arr_id[i]) &amp;&amp;  user_pw.equals(arr_pw[i])){                            login_check =true;                            System.out.print(\"변경할 아이디를 입력하세요(6자리 이상) : &gt; \");                            user_id=s.nextLine();                            if(user_id.length()&lt;6){                                System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            System.out.print(\"변경할 비밀번호를 입력하세요(6자리 이상) : &gt; \");                            user_pw=s.nextLine();                            if(user_pw.length()&lt;6){                                System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            System.out.print(\"변경할 이름을 입력하세요 : &gt; \");                            user_name=s.nextLine();                            System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                            user_birth=s.nextLine();                            if(user_birth.length()!=8){                                System.out.println(\"변경할 생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                                break;                            }                            id_check = true;                            for(int j=0;j&lt;arr_id.length;j++){                                if(arr_id[j].equals(user_id)){                                    System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                                    id_check = false;                                    break;                                }                            }                            if(id_check){                                // 수정하시겠습니까?(condirm처리)                                System.out.println(\"수정하시겠습니까?(1-예. 0-아니오) &gt; \");                                int input = s.nextInt();                                if(input==1){                                    arr_id[i] = user_id;                                     arr_pw[i] = user_pw;                                     arr_name[i] = user_name;                                     arr_birth[i] = user_birth;                                 }                            }                        }                    }                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 0:                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"입력번호가 잘못되었습니다.\");            }//switch        }//while    }//main}//class혹시몰라서 1차원배열도 만들어놨음회원탈퇴, 회원조회기능 추가import java.util.Scanner;public class Member_method {    public static void main(String[] args) {        final int MAX_MOMBER = 100;        String user_id = \"\";        String user_pw = \"\";        String user_name = \"\";        String user_birth = \"\";                String user[][] = new String[MAX_MOMBER][4];        int index = 0;        Scanner s = new Scanner(System.in);        int input=0;        while(true){            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 4.회원탈퇴, 5.회원정보조회, 0.종료 : &gt; \");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1: //회원가입                    // 아이디, 비번 6자리 이상. 미만이면 실패                    for(index=0;index&lt;user.length;index++){                        if(user[index][0] == null){                            break;                        }                    }                    if(index==user.length){                        System.out.println(\"허용 가입인원수를 초과하였습니다. 더 이상 등록할 수 없습니다. 관리자에게 문의하십시오.\");                        break;                    }                    System.out.print(\"아이디를 입력하세요(6자리 이상) : &gt; \");                    user_id=s.nextLine();                    if(user_id.length()&lt;6){                        System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                        break;                    }                    boolean id_check = true;                    for(int i=0;i&lt;user.length;i++){                        if(user_id.equals(user[i][0])){                            System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                            id_check = false;                        }                    }                    if(id_check){                        System.out.print(\"비밀번호를 입력하세요(6자리 이상) : &gt; \");                        user_pw=s.nextLine();                        if(user_pw.length()&lt;6){                            System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                            break;                        }                        System.out.print(\"이름을 입력하세요 : &gt; \");                        user_name=s.nextLine();                        System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                        user_birth=s.nextLine();                        if(user_birth.length()!=8){                            System.out.println(\"생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                            break;                        }                            user[index][0] = user_id;                             user[index][1] = user_pw;                             user[index][2] = user_name;                             user[index][3] = user_birth;                         }                    break;                case 2:  // 로그인(조회)                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    boolean login_check=false;                    for(int i=0;i&lt;user.length;i++){                        if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                            login_check =true;                            System.out.println(\"=====회원정보=====\");                            System.out.println(\"아이디 : \"+user[i][0]);                            System.out.println(\"이름 : \"+user[i][2]);                            System.out.println(\"생년월일 : \"+user[i][3]);                        }                    }                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 3:// 회원정보 수정                    System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    login_check=false;                    for(int i=0;i&lt;user.length;i++){                        if(user_id.equals(user[i][0]) &amp;&amp;  user_pw.equals(user[i][1])){                            login_check =true;                            System.out.print(\"변경할 아이디를 입력하세요(6자리 이상) : &gt; \");                            user_id=s.nextLine();                            if(user_id.length()&lt;6){                                System.out.println(\"아이디가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                break;                            }                            id_check = true;                            for(int j=0;j&lt;user.length;j++){                                if(user_id.equals(user[j][0])){                                    System.out.println(\"이미 등록된 아이디입니다. 처음부터 다시 시도해주세요\");                                    id_check = false;                                    break;                                }                            }                            if(id_check){                                System.out.print(\"변경할 비밀번호를 입력하세요(6자리 이상) : &gt; \");                                user_pw=s.nextLine();                                if(user_pw.length()&lt;6){                                    System.out.println(\"비밀번호가 6자리 미만입니다. 처음부터 다시 시도해주세요\");                                    break;                                }                                System.out.print(\"변경할 이름을 입력하세요 : &gt; \");                                user_name=s.nextLine();                                System.out.print(\"생년월일을 입력하세요(8자리) : &gt; \");                                user_birth=s.nextLine();                                if(user_birth.length()!=8){                                    System.out.println(\"변경할 생년월일을 8자리로 입력해주세요. 처음부터 다시 시도해주세요\");                                    break;                                }                                System.out.print(\"수정하시겠습니까?(1-예. 0-아니오) &gt; \");                                input = s.nextInt();                                if(input==1){                                    user[i][0] = user_id;                                     user[i][1] = user_pw;                                     user[i][2] = user_name;                                     user[i][3] = user_birth;                                 }                            }                        }                    }                    if(!login_check){                        System.out.println(\"로그인 실패. 아이디와 비밀번호를 확인해주세요\");                    }                    break;                case 4:                     System.out.print(\"가입한 아이디를 입력하세요 : &gt; \");                    user_id = s.nextLine();                    System.out.print(\"가입한 비밀번호를 입력하세요 : &gt; \");                    user_pw = s.nextLine();                    login_check=false;                    for(int i=0;i&lt;user.length;i++){                        if(user_id.equals(user[i][0]) &amp;&amp; user_pw.equals(user[i][1])){                            login_check=true;                            System.out.print(\"정말 회원탈퇴하시겠습니까?(1-예. 0-아니오) &gt; \");                            input =s.nextInt();                            if(input==1){                                    user[i][0] = null;                                    user[i][1] = null;                                    user[i][2] = null;                                    user[i][3] = null;                                    break;                            }                        }else {                            System.out.println(\"아이디와 비밀번호를 확인해주세요\");                            break;                        }                    }                    break;                case 5:                    int manager_code = 1234;                    System.out.print(\"관리자 코드를 입력하세요 : &gt;\");                    input = s.nextInt();                    if(input == manager_code){                        for(int i=0;i&lt;user.length;i++){                            if(user[i][0]!=null){                                System.out.println(\"===회원정보====\");                                System.out.println(\"아이디 : \"+user[i][0]);                                System.out.print(\"비밀번호 : \");                                for(int j=0;j&lt;user[i][1].length();j++){                                    System.out.print(\"*\");                                }                                System.out.println();                                System.out.println(\"이름 : \"+user[i][2]);                                System.out.println(\"생년월일 : \"+user[i][3]);                            }                        }                    }                    break;                case 0:                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"입력번호가 잘못되었습니다.\");            }//switch        }//while    }//main}//class선생님께 물어봤는데 배열을 생성해서 값을 당기는 것이(가입순서대로 정렬하는것이) 일반적인 데이터베이스관점이라고하심작동하면 이것도 상관은없다고하셨당equals에서 자꾸 nullException이 생겼는데 검색해보니 a.equals(b)에 a에 null값이 오면 오류가 나는거였다.. 반대로 하니 오류가 안나서 수정해줬음..선생님 버전package JAVA_221027;import java.util.Scanner;public class Ex01teach {    public static void main(String[] args) {        //1차원배열로 진행, 재차입력요구까지 구현        final int MAX_VALUE = 10;        String[] member_id = new String[MAX_VALUE];        String[] member_pwd = new String[MAX_VALUE];        String[] member_name = new String[MAX_VALUE];        String[] member_birth = new String[MAX_VALUE];        Scanner  s = new Scanner(System.in);        for(int i=0;i&lt;MAX_VALUE;i++){            member_id[i] = \"member\"+i;            member_pwd[i] = \"123456\";            member_name [i] = \"사용자\";            member_birth[i] = \"20221027\";        } //더미값넣기        int next_index = 10;        while(true){            System.out.print(\"1.회원가입, 2.로그인, 3.회원정보 수정, 4.회원탈퇴, 5.회원정보조회, 0.종료 : &gt; \");            int sel = s.nextInt();            if(sel == 0) {                System.out.println(\"종료합니다.\");                s.close();                return;            }            s.nextLine();            switch(sel){                case 1 :                    if(next_index==MAX_VALUE){                        System.out.println(\"더 이상 가입불가능합니다.\");                        break;                    }                    System.out.println(\"=====회원정보 등록=====\");                    System.out.print(\"아이디(6자이상) : \");                    String id;                    while(true){                        id = s.nextLine();                        if(id.length()&lt;6) {                            System.out.print(\"아이디는 6자리 이상이어야합니다. 다시 입력해주세요 \");                            continue;                        }                        boolean isDuplicate = false;                        for(int i=0;i&lt;MAX_VALUE;i++){                            if(id.equals(member_id[i])){                                System.out.print(\"이미 가입된 아이디 입니다. 다시입력해주세요\");                                isDuplicate=true;                            }                        }                        if(!isDuplicate) break;                    }                    System.out.print(\"비밀번호(6자이상) : \");                    String pwd;                    while(true){                        pwd = s.nextLine();                        if(pwd.length()&lt;6) {                            System.out.print(\"비밀번호는 6자리 이상이어야합니다. 다시 입력해주세요 \");                            continue;                        }else {                            break;                        }                    }                    System.out.print(\"이름 : \");                    String name = s.nextLine();                    System.out.print(\"생년월일(8자리) : \");                    String birth;                    while(true){                        birth = s.nextLine();                        if(birth.length()!=8) {                            System.out.print(\"생년월일은 8자리로 입력하세요. 다시 입력해주세요 \");                            continue;                        }else {                            break;                        }                    }                    member_id[next_index] = id;                    member_pwd[next_index] = pwd;                    member_name[next_index] = name;                    member_birth[next_index] = birth;                    next_index++;                    System.out.println(\"==회원등록 완료==\");                    break;                case 2 :                    System.out.println(\"==로그인==\");                    System.out.print(\"아이디 : \");                    String login_id = s.nextLine();                    System.out.print(\"비밀번호 : \");                    String login_pwd = s.nextLine();                    boolean loginStatus = false;                    for(int i=0;i&lt;MAX_VALUE;i++){                        if(loginStatus=login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){                             //아이디 비번이 같으면 loginStatus를 true로 변경                            System.out.println(\"==로그인 성공==\");                            System.out.println(\"아이디 : \"+member_id[i]);                            System.out.println(\"이름: \"+member_name[i]);                            System.out.println(\"생년월일 : \"+member_birth[i]);                            break;                        }                    }                    //if(loginStatus=login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){는 {}안에                    //loginStatus = true한거랑 같음. 한줄로 만든것.                    if(!loginStatus){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                    }                    break;                case 3 :                    System.out.println(\"==정보수정==\");                    System.out.print(\"아이디 : \");                    login_id = s.nextLine();                    System.out.print(\"비밀번호 : \");                    login_pwd = s.nextLine();                    loginStatus = false;                    int moidfy_index=0;                    for(int i=0;i&lt;MAX_VALUE;i++){                        if(loginStatus=login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){                             System.out.println(\"==기존정보==\");                            System.out.println(\"아이디 : \"+member_id[i]);                            System.out.println(\"이름: \"+member_name[i]);                            System.out.println(\"생년월일 : \"+member_birth[i]);                            moidfy_index=i;                            break;                        }                    }                    if(!loginStatus){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                        break;                    }                    System.out.println(\"====등록된 정보 수정====\");                    System.out.print(\"아이디(6자이상) : \");                    while(true){                        id = s.nextLine();                        if(id.length()&lt;6) {                            System.out.print(\"아이디는 6자리 이상이어야합니다. 다시 입력해주세요 \");                            continue;                        }                        boolean isDuplicate = false;                        for(int i=0;i&lt;MAX_VALUE;i++){                            if(id.equals(member_id[i])){                                System.out.print(\"이미 가입된 아이디 입니다. 다시입력해주세요\");                                isDuplicate=true;                            }                        }                        if(!isDuplicate) break;                    }                    System.out.print(\"비밀번호(6자이상) : \");                    while(true){                        pwd = s.nextLine();                        if(pwd.length()&lt;6) {                            System.out.print(\"비밀번호는 6자리 이상이어야합니다. 다시 입력해주세요 \");                            continue;                        }else {                            break;                        }                    }                    System.out.print(\"이름 : \");                    name = s.nextLine();                    System.out.print(\"생년월일(8자리) : \");                    while(true){                        birth = s.nextLine();                        if(birth.length()!=8) {                            System.out.print(\"생년월일은 8자리로 입력하세요. 다시 입력해주세요 \");                            continue;                        }else {                            break;                        }                    }                    System.out.print(\"수정하시겠습니까? 1:예. 0:아니오.&gt; \");                    int confirm =s.nextInt();                    if(confirm==1){                        member_id[moidfy_index] = id;                        member_pwd[moidfy_index] = pwd;                        member_name[moidfy_index] = name;                        member_birth[moidfy_index] = birth;                        System.out.println(\"==회원 정보 수정 완료==\");                    }                    else {                        System.out.println(\"정보수정이 취소되었습니다\");                    }                    break;                case 4 :                    System.out.println(\"==로그인==\");                    System.out.print(\"아이디 : \");                    login_id = s.nextLine();                    System.out.print(\"비밀번호 : \");                    login_pwd = s.nextLine();                    loginStatus = false;                    int del_index =0;                    for(int i=0;i&lt;MAX_VALUE;i++){                        if(loginStatus=login_id.equals(member_id[i]) &amp;&amp; login_pwd.equals(member_pwd[i])){                             System.out.println(\"==로그인 성공==\");                            System.out.println(\"아이디 : \"+member_id[i]);                            System.out.println(\"이름: \"+member_name[i]);                            System.out.println(\"생년월일 : \"+member_birth[i]);                            del_index=i;                            break;                        }                    }                    if(!loginStatus){                        System.out.println(\"로그인 정보가 잘못되었습니다\");                        break;                    }                    System.out.print(\"탈퇴하시겠습니까? 1:예. 0:아니오.&gt; \");                    confirm =s.nextInt();                    if(confirm==1){                        member_id[del_index] = null;                        member_pwd[del_index] = null;                        member_name[del_index] = null;                        member_birth[del_index] = null;                        System.out.println(\"==회원 탈퇴 완료==\");                        String[] temp1 = new String[MAX_VALUE];                        String[] temp2 = new String[MAX_VALUE];                        String[] temp3 = new String[MAX_VALUE];                        String[] temp4 = new String[MAX_VALUE];                        for(int i=0;i&lt;MAX_VALUE;i++){                            temp1[i] = member_id[i]; //배열복사                            temp2[i] = member_pwd[i]; //배열복사                            temp3[i] = member_name[i]; //배열복사                            temp4[i] = member_birth[i]; //배열복사                        }                        for(int i=0;i&lt;MAX_VALUE;i++){                            member_id[i]=null;                            member_pwd[i]=null;                            member_name[i]=null;                            member_birth[i]=null;                        }                        int n =0;                        int n2=0;                        while(n&lt;MAX_VALUE){                            if(temp1[n]!=null){                                member_id[n2]=temp1[n];                                member_pwd[n2]=temp2[n];                                member_name[n2]=temp3[n];                                member_birth[n2]=temp4[n];                                n2++;                            }                            n++; //만약 temp[i]가 null이라면, n2는 증가하지 않아서 한자리씩 땡겨짐.                        }                        next_index--;                    }                    else {                        System.out.println(\"회원탈퇴가 취소되었습니다\");                    }                    break;                case 5 :                for(int i=0;i&lt;MAX_VALUE;i++){                    if(member_id[i]!=null){                            System.out.println(\"===회원정보===\");                            System.out.println(\"아이디 : \"+member_id[i]);                            System.out.println(\"생년월일 : \"+member_pwd[i]);                            System.out.println(\"비밀번호 : \"+member_birth[i]);                        }                    }                    break;                default :                     System.out.println(\"잘못된 메뉴번호입니다.\");            }        }    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 중간정리(변수~배열)",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EC%A0%95%EB%A6%AC/",
    "categories": "",
    "tags": "",
    "date": "2022-10-21 00:00:00 +0900",
    





    
    "snippet": "public class Variables {    public static void main(String[] args) {    //     //정수    //     // byte val1 = 10000;    //     // short val2 = 100000;    //     // int val3 = 10000000000;     //    ...",
    "content": "public class Variables {    public static void main(String[] args) {    //     //정수    //     // byte val1 = 10000;    //     // short val2 = 100000;    //     // int val3 = 10000000000;     //     long val4 = 10000000000L;    //     long val5 = 10000000000l; //대소문자 둘다 가능    //     // System.out.println(val1);    //     // System.out.println(val2);    //     // System.out.println(val3);    //     System.out.println(val4);    //     //실수    //     float f1 = 10.23f;    //     double d1 = 10.23;    //     System.out.println(f1);    //     System.out.println(d1);    //     //논리    //     boolean b1 = false;    //     System.out.println(b1);    //     //문자    //     char ch = ' ';    //     System.out.println(ch);    //     //참조    //     String str = new String(\"Hello World\");    //     System.out.println(str);        System.out.println(\"double size : \"+Double.BYTES);        System.out.println(\"byte min : \"+Byte.MIN_VALUE+\", byte max : \"+Byte.MAX_VALUE);        System.out.println(\"Short min : \"+Short.MIN_VALUE+\", Short max : \"+Short.MAX_VALUE);        System.out.println(\"int min : \"+Integer.MIN_VALUE+\", int max : \"+Integer.MAX_VALUE);        System.out.println(\"long min : \"+Long.MIN_VALUE+\", long max : \"+Long.MAX_VALUE);        System.out.println(\"float min : \"+Float.MIN_VALUE+\", float max : \"+Float.MAX_VALUE);        System.out.println(\"double min : \"+Double.MIN_VALUE+\", double max : \"+Double.MAX_VALUE);        /*  double size : 8            byte min : -128, byte max : 127            Short min : -32768, Short max : 32767                  int min : -2147483648, int max : 2147483647            long min : -9223372036854775808, long max : 9223372036854775807            float min : 1.4E-45, float max : 3.4028235E38            double min : 4.9E-324, double max : 1.7976931348623157E308             출력됨            */            Integer i = 1000;            int aa = 100;             System.out.println(i);            System.out.println(aa); //두개 차이없음                }}public class Variables2222 {    public static void main(String[] args) {        //예약어(키워드) 사용 불가        //public, static, void, String        //int, short, byte, long, double, float, boolean, char        //Integer, Short, Byte, Long, Double, Float, Boolean, Charater        //if, for, while, new , delete, try, catch, class, private, protedcted        //yield, return, goto.... 등 사용 불가        //int static = 10; //오류                //2개 이상 단어 사용불가(공백문자안됨)        // int number of student = 10; //오류        int number_of_studrent=10; //snake case        int numberOfStudent = 10; //camel case 요즘은 이걸 더 많이 씀        System.out.println(numberOfStudent);        System.out.println(number_of_studrent);        //숫자로 시작 불가        // int 1number =10; //오류        int number1 =10; //가능        System.out.println(number1);        //대소문자 구분        // int apple, Apple, aPPle, appLe, appLE, APPLE;         //모두 다른 변수임. 그래도 이렇게 쓰지말기(유지보수 어렵게 할때 사용함[프리랜서작업시])        // int Int = 10; //가능하나 쓰지말것        // float Float = 10; //가능하나 쓰지말것        // int $$$$$____$$$$$ =10; //가능하나 알아보기힘드니 쓰지말것        //이미 만든 변수 재선언 불가        // int number_of_studrent=10; //에러            }}import java.util.Scanner;public class InputEx01 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"숫자를 입력하세요 : &gt; \");        int n=0;        try{            n=s.nextInt();        }catch(Exception e){            System.out.println(\"잘못된 입력값입니다.\");            s.close();            // return;        }        System.out.println(n);                s.close();    }}8장 예외처리 잠깐 봄power=!power를 toggle이라고 부름import java.util.Scanner;public class OperatorEx {    public static void main(String[] args) {        //연산자        //1.부호, 2.산술, 3.비교, 4.논리, 5.비트, 6.증가감소, 7.대입        //8.조건선택        //1.단항 (부호, 증가감소, typecasting)        //2.이항 (산술, 비교, 논리, 비트, 대입)        //3.삼항 (조건선택)        //1.부호연산자        int value1 = -10+20; //10        System.out.println(value1);        int value2 = (int)10.23 * 10;         System.out.println(value2); //100나옴        int value3 = (int)(10.23 * 10);         System.out.println(value3); //102나옴        int r = (int)Math.random()*10;         System.out.println(r);         //무조건 0나옴. Math.random이 0.xxxxx...이 나오는데 (int)처리되서 0됨. 0*10인꼴        //(int)(Math.random*10) 으로 해야 원하는 값이 나옴        //2.산술연산자        int result1 = 10 + 20;        int result2 = result1 + 20;        int result3 = result1 + result2;        int result4 = 10+20*5/3-10; // * / + - 순서로 계산됨        System.out.println(result4);        //3.비교연산(대소비교, 동일비교)        boolean b1 = result3 == result2;        boolean b2 = result2 != 20;        System.out.println(b1);        System.out.println(b2);        boolean b3 = result3&gt;=200; //이상        boolean b4 = result3&lt;=200; //이하        boolean b5 = result3&gt;200; //초과        boolean b6 = result3&lt;200; //미만        System.out.println(b3);        System.out.println(b4);        System.out.println(b5);        System.out.println(b6);        //논리연산 (&amp;&amp;, ||, !)        // final int PRICE = 8000; //가격        // Scanner s = new Scanner(System.in);        // final int STANDARD_PRICE = s.nextInt(); //점심값사용가능금액        // s.close();        // int money = 10000; //현금        // int balance = 5000; //계좌        // System.out.println(money&gt;=PRICE || balance &gt;= PRICE? \"구매가능\":\"구매불가능\");        // System.out.println(money&gt;=PRICE &amp;&amp; PRICE&lt;=STANDARD_PRICE?\"구매가능\":\"구매불가능\");        double bmi=25.5;        System.out.println(\"저체중 인가? \"+(bmi&gt;=0 &amp;&amp; bmi&lt;18.5));        System.out.println(\"정상체중 인가? \"+(bmi&gt;=18.5 &amp;&amp; bmi&lt;23));        System.out.println(\"과체중 인가? \"+(bmi&gt;=23 &amp;&amp; bmi &lt;25));        System.out.println(\"비만 인가? \"+(bmi&gt;=25 &amp;&amp; bmi &lt;30));        System.out.println(\"고도비만 인가? \"+(bmi&gt;=30));                boolean power = false;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power; //toggle        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        System.out.println(\"전원이 켜져있나?\"+power);        power = !power;        String phone_manufacturer[] = {\"삼성전자\",\"Apple\",\"샤오미\",\"Oppo\",\"화웨이\",\"LG\"};        for(int i=0;i&lt;phone_manufacturer.length;i++){            if(phone_manufacturer[i].equals(\"LG\")) System.out.println(phone_manufacturer[i]);        }        // 5.증감감소연산자(증감문)        int number = 0;        number++;        System.out.println(number); //1        number--;        System.out.println(number); //0        System.out.println(number++);//0        System.out.println(++number);//2        System.out.println(number--);//2        System.out.println(--number);//0        int i=0;        while(i&lt;phone_manufacturer.length)            System.out.println(phone_manufacturer[i++]);        //6. 대입연산        int num = 10+20;         num += 10;         num -= 10;         num /= 10;         num *= 10;         num %= 10;         System.out.println(num);    }}import java.util.Scanner;public class Exercise01 {    public static void main(String[] args) {        // int arr[] = {80,75,55};        // int sum=0;        // for(int i=0;i&lt;arr.length;i++){        //     sum += arr[i];        // }        // System.out.println(\"평균 : \"+sum/(double)arr.length); //70나옴        Scanner s = new Scanner(System.in);        String sarr[] = {\"국어\",\"수학\",\"영어\",\"물리\",\"화학\",\"생물\"};        int arr[] = new int[sarr.length];        int sum=0;                for(int i=0;i&lt;arr.length;i++){            System.out.print(sarr[i]+\"의 점수를 입력하세요. &gt; \");            // arr[i]=s.nextInt();            sum+=arr[i] = s.nextInt(); //한줄로 받는 법        }        System.out.println(\"입력받은 점수의 평균 : \"+sum/(double)arr.length);                s.close();    }}import java.util.Arrays;public class StringClassEx {    public static void main(String[] args) {        String str1= \"Hello\";        System.out.println(str1);        String str2 = new String(\"Hello\");        System.out.println(str2);        str1 = str1 + 10 + 20 ;        System.out.println(str1); //Hello1020 출력        String str3 = \"Java Programming\";        System.out.println(str3.length()); //공백까지 셀려서 16출력        System.out.println(str3.substring(0, 4)); //0&lt;=x&lt;4         System.out.println(str3.substring(5, 16)); //5&lt;=x&lt;16        String str4 = str3.substring(0, 4);        System.out.println(str4);         String str5 = str3.substring(5, 16);         System.out.println(str5);        System.out.println(str3.contains(\"Java\")); //str3이 \"java\"를 포함하고 있는가? true출력됨        System.out.println(str3.contains(\"python\")); //str3이 \"python\"를 포함하고 있는가? false출력됨        System.out.println(str3.indexOf(\"Java\")); //Java가 몇번째 문자열부터 시작되는가? 없으면 -1 출력.  0출력됨        System.out.println(str3.replaceAll(\"Java\", \"Python\")); //Java를 Python으로 변경. Python Programming 출력됨        System.out.println(str3);//값을 대체시킨것이 아니라서 str3의 값은 그대로임        System.out.println(str3.equals(\"Java Programming\"));//괄호안의 문자열과 완전히 일치하는가? true출력        System.out.println(str3.equalsIgnoreCase(\"java programming\")); //대소문자구분안하고 완전히일치하는가? true출력                System.out.println(str3.toUpperCase()); //전부 대문자        System.out.println(str3.toLowerCase()); //전부 소문자        String splitStr = \"1,2,3,4,5,6,7,8,9\";        System.out.println(splitStr.split(\",\"));        String arr[] = splitStr.split(\",\"); //spliter - 구분이되는 문자기준. 여기서는 \",\" 임        System.out.println(Arrays.toString(arr));    }}for문에 i를 많이쓰는 이유, 배열의 index를 의미함. 배열에서 가장 많이쓰이기때문임.다음으로 j,k가 많이쓰이는것은 그냥 i다음이라서뒤에 ()가 붙으면 함수임package JAVA_221024;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class DiceEx {    public static void main(String[] args) throws IOException {        int dice1 = (int)(Math.random()*6)+1;        int dice2 = (int)(Math.random()*6)+1;                System.out.println(\"주사위의 눈금은 \"+dice1+\"입니다.\");        System.out.println();        System.out.println(\"=====if문 사용=====\");        if(dice1==1) System.out.println(\"주사위의 눈금은 1입니다.\");        else if(dice1==2) System.out.println(\"주사위의 눈금은 2입니다.\");        else if(dice1==3) System.out.println(\"주사위의 눈금은 3입니다.\");        else if(dice1==4) System.out.println(\"주사위의 눈금은 4입니다.\");        else if(dice1==5) System.out.println(\"주사위의 눈금은 5입니다.\");        else System.out.println(\"주사위의 눈금은 6입니다.\");        System.out.println();        System.out.println(\"=====switch문 사용=====\");        switch(dice1){            case 1:                 System.out.println(\"주사위의 눈금은 1입니다.\");                break;            case 2:                 System.out.println(\"주사위의 눈금은 2입니다.\");                break;            case 3:                 System.out.println(\"주사위의 눈금은 3입니다.\");                break;            case 4:                 System.out.println(\"주사위의 눈금은 4입니다.\");                break;            case 5:                 System.out.println(\"주사위의 눈금은 5입니다.\");                break;                default :                 System.out.println(\"주사위의 눈금은 6입니다.\");            }            int sum = dice1+dice2;            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));            System.out.print(\"홀짝을 입력하세요. (홀 : 1, 짝 : 0) &gt;&gt;\");            int input=0;            while(true){                input = Integer.parseInt(br.readLine());                if(input==0 || input ==1) {                    break;                }else {                    System.out.println(\"입력값이 잘못되었습니다\");                    continue;                }            }                        int result= sum%2;            System.out.println(\"주사위 눈의 합 : \"+sum);            System.out.println(\"=====if문 사용=====\");            if(result == input) System.out.println(\"사용자 승\");            else System.out.println(\"컴퓨터 승\");            System.out.println();                        System.out.println(\"=====switch문 사용=====\");            switch(result){                case 1:                    switch(input){                        case 1:                            System.out.println(\"사용자 승\");                            break;                        default:                            System.out.println(\"컴퓨터 승\");                    }                    break;                default :                     switch(input){                         case 0 :                             System.out.println(\"사용자 승\");                            break;                        default :                             System.out.println(\"컴퓨터 승\");                    }            }            br.close();    }}package JAVA_221024;// import java.io.BufferedReader;// import java.io.IOException;// import java.io.InputStreamReader;public class LoopEx01 {    public static void main(String[] args) //throws IOException    {        for(int i=0;i&lt;3;i++){            System.out.println(\"for반복:\"+i);        }        // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        // int dan = Integer.parseInt(br.readLine());        // for(int i=1;i&lt;=9;i++){        //     System.out.println(dan+\" X \"+i+\" = \"+dan*i);        // }        String str = \"Hello World!!\";        for(int i=0;i&lt;str.length();i++){            if(str.charAt(i)=='l') continue;            System.out.println(i+\" : \"+str.charAt(i));            // if(str.charAt(i)=='o') break;        }    }}for문에서 i&lt;arr.size() 데이터가 몇개인지 모를때 사용  공공데이터 api   https://www.data.go.kr/package JAVA_221024;import java.util.Scanner;public class InfiniteLoop {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        int dice1,dice2;        int total=0,user_win=0;        while(true){                dice1 = (int)(Math.random()*6)+1;                dice2 = (int)(Math.random()*6)+1;                int sum = dice1+dice2;                int input=0;                                System.out.print(\"홀짝을 입력하세요. (홀 : 1, 짝 : 0) &gt;&gt;\");                input = s.nextInt();                if(!(input==0 || input ==1)) {                    System.out.println(\"입력값이 잘못되었습니다\");                    System.out.println();                    continue;                }                int result= sum%2;                System.out.println(\"주사위 눈의 합 : \"+sum);                if(result == input) {                    System.out.println(\"사용자 승\");                    user_win++;                }                else{                    System.out.println(\"컴퓨터 승\");                }                total++;                System.out.println();                System.out.println(\"다시 하시겠습니까?(0:아니오 / 계속하려면 아무키나 누르세요.\");                input = s.nextInt();                if(input==0) {                    System.out.println(\"프로그램을 종료합니다.\");                    s.close();                    break;                }        }        System.out.println(\"총 시도 : \"+total+\" / 승률 : \"+user_win/(double)total*100+\"%\");    }}홀짝게임FileReaderpackage JAVA_221025;import java.io.File;import java.io.FileReader;public class FileReaderEx {    public static void main(String[] args) throws Exception{        File file = new File(\"JAVA_221025/test.txt\"); //작업영역에 폴더를 여러개 열어서 폴더 명을 적어줘야함.        FileReader reader = new FileReader(file);        while(true){            int rd = reader.read();            if(rd == -1){                break;            }            System.out.print((char)rd);        }        reader.close();    }}만약 안되면 txt파일있는 폴더의 경로를 복사해서 넣을 것. \\를 /로 수정해줘야함플래쉬메모리 : usb 등package JAVA_221025;import java.util.Scanner;public class ArrayEx3 {    public static void main(String[] args) {        int[] score = {95,85,80,70,92};        String[] name = {\"송종하\", \"정시안\", \"손경은\", \"송효빈\", \"안해일\"};        Scanner s = new Scanner(System.in);                while(true){            System.out.print(\"조회 할 학생의 번호 (0-4) -1 to quit : &gt; \");            int n = s.nextInt();            if(n==-1) break;            else if(n&gt;=0 &amp;&amp; n&lt;score.length) {                System.out.println(\"이름 : \"+name[n]);                System.out.println(\"점수 : \"+score[n]);            }else {                System.out.println(\"잘못된 번호입니다 [번호범위 : 0-4]\");                System.out.println();            }        }        System.out.println(\"종료합니다.\");        s.close();    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 배열",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 배열",
    "date": "2022-10-20 00:00:00 +0900",
    





    
    "snippet": "배열 - 레퍼런스 타입public class ArrayEx {    public static void main(String[] args) {        int arr[] = new int[5];        //배열 요소의 초기화        System.out.println(arr);        for(int i=0;i&lt;arr.length;...",
    "content": "배열 - 레퍼런스 타입public class ArrayEx {    public static void main(String[] args) {        int arr[] = new int[5];        //배열 요소의 초기화        System.out.println(arr);        for(int i=0;i&lt;arr.length;i++){            arr[i]=(i+1)*10;        //배열 요소의 조회        System.out.println(arr[i]);//인덱스 기반 조회방법        }         //arr배열의 첫번째부터 차례대로 접근해서 조회        //조회된 값을 i에 복사        for(int i:arr){            System.out.println(i);        } //무조건 처음부터 끝까지 순차조회    }}import java.util.ArrayList;import java.util.List;public class ArrayEx01 {    public static void main(String[] args) {        int arr[] = new int[3]; //생성(선언)        // int i=0;        // arr[i] = (i+1)*10;        // System.out.println(arr[i]);        // i++;        // arr[i] = 20;        // System.out.println(arr[i]);        // i++;        // arr[i] = 30;        // System.out.println(arr[i]);        for(int i=0;i&lt;3;i++){            arr[i] = (i+1)*10;            System.out.println(arr[i]);        }        arr = new int[5]; //덮어쓰기 (정적 - static)        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        list.add(10);        list.add(10);        list.add(10);        list.add(10);        list.add(10); //컬렉션 프레임워크. 추가하는대로 배열의 길이가 늘어남.    }    }import java.util.Arrays;public class ArrayEx02 {    public static void main(String[] args) {        int arr[] = new int[3];        int arr2[] = {5,10,15};        arr2[0] =55;        double arr3[] = new double[3];        arr3[0]=70;        boolean arr4[] = new boolean[3];        arr4[0] = true;        char arr5[] = {'H','e','l','l','o',' ','W','o','r','l','d','!','\\0'}; // \\0 = null문자. 문자열의 끝을 나타내는 문자.        // arr5[0]='a';        String arr6[] = new String[3];        arr6[0] = \"abcd1234\";        String str = \"Hello World!\";        System.out.println(str.charAt(0));        System.out.println(str.toCharArray()[0]); //charAt(0)과 같은 것임        System.out.println(str.substring(0, 5)); //Hello 나옴        System.out.println(str.substring(6, 12)); //World 나옴        String strArr[] = new String[5];        String strArr2[] = {\"asd\",\"fgh\",\"jkl\"};        for(int i=0;i&lt;strArr2.length;i++){            System.out.println(strArr2[i]);        }        System.out.println(Arrays.toString(strArr2));    }}import java.util.Arrays;public class ArrayEx03 {    public static void main(String[] args) {        int arr[] = {10,20,30};        // int arr2[] = arr;        int arr2[] = new int[arr.length];        // System.out.println(\"before\");        // System.out.println(Arrays.toString(arr));        // System.out.println(Arrays.toString(arr2));        // arr[0]=100;        // System.out.println(\"after\");        // System.out.println(Arrays.toString(arr));        // System.out.println(Arrays.toString(arr2));        //둘다 0번째 자리 값이 바뀜. arr2가 arr의 주소값을 받아왔기때문임. 레퍼런스 타입의 특징임!!!        //배열 복사        System.out.println();        System.arraycopy(arr, 0, arr2, 0, 3);        System.out.println(\"before\");        System.out.println(Arrays.toString(arr));        System.out.println(Arrays.toString(arr2));        arr[0]=100;        System.out.println(\"after\");        System.out.println(Arrays.toString(arr));        System.out.println(Arrays.toString(arr2));    }}package JAVA_221025;import java.util.Scanner;public class ArrayEx3 {    public static void main(String[] args) {        // int[] score = {95,85,80,70,92};        // String[] name = {\"송종하\", \"정시안\", \"손경은\", \"송효빈\", \"안해일\"};        Scanner s = new Scanner(System.in);        int next_index=0;        System.out.print(\"학생 수를 입력하세요 : &gt; \");        int t=s.nextInt();        int[] score = new int[t];        String[] name = new String[t];        while(true){            System.out.println(\"1.점수추가, 2.점수조회, 0:종료\");            int sel = s.nextInt();            s.nextLine();            switch(sel){                case 1:                    if(next_index&gt;=t){                        System.out.println(\"더 이상 입력할 수 없습니다.\");                        System.out.println();                    }else{                        System.out.print(\"이름 : &gt; \");                        String stu_name = s.nextLine();                        System.out.print(\"점수 : &gt; \");                        int stu_score = s.nextInt();                        s.nextLine(); //엔터키 입력 비우기                        name[next_index] = stu_name;                        score[next_index] = stu_score;                        System.out.println(\"점수가 저장되었습니다\");                        next_index++;                    }                    break;                case 2:                    System.out.print(\"조회 할 학생의 번호 (0-\"+(t-1)+\") -1 to quit : &gt; \");                    int n = s.nextInt();                    if(n&gt;=0 &amp;&amp; n&lt;score.length) {                        System.out.println(\"이름 : \"+name[n]);                        System.out.println(\"점수 : \"+score[n]);                    }else {                        System.out.println(\"잘못된 번호입니다 [번호범위 : 0-4]\");                        System.out.println();                    }                    System.out.println();                    break;                case 0:                    System.out.println(\"종료합니다.\");                    s.close();                    return;                default :                     System.out.println(\"잘못된 메뉴 번호입니다.\");            }                    }    }}점수 입력, 조회package JAVA_221025;import java.util.Scanner;public class ArrayEx3 {    public static void main(String[] args) {        // int[] score = {95,85,80,70,92};        // String[] name = {\"송종하\", \"정시안\", \"손경은\", \"송효빈\", \"안해일\"};        Scanner s = new Scanner(System.in);        System.out.print(\"학생 수를 입력하세요 : &gt; \");        int t=s.nextInt(); //다음에 받은게 int sel이라서 nextInt안해줘도됨        int[] score = new int[t];        String[] name = new String[t];        int next_index=0; //점수 추가시 점수를 저장할 위치        while(true){            System.out.println(\"1.점수추가, 2.점수조회, 3.점수수정, 0:종료\");             int sel = s.nextInt();            s.nextLine();            switch(sel){                 case 1: //점수추가기능 시작                    if(next_index&gt;=t){ //현재 입력할 위치가 최대 인덱스를 넘어설경우 오류처리                        System.out.println(\"더 이상 입력할 수 없습니다.\");                        System.out.println();                    }else{                        System.out.print(\"이름 : &gt; \");                        String stu_name = s.nextLine();                        System.out.print(\"점수 : &gt; \");                        int stu_score = s.nextInt();                        s.nextLine(); //엔터키 입력 비우기                        name[next_index] = stu_name;//next_index위치에 저장                        score[next_index] = stu_score;                        System.out.println(\"점수가 저장되었습니다\");                        next_index++; //다음번호로 이동                    }                    break;//switch문 종료                case 2://점수 조회기능                    System.out.print(\"조회 할 학생의 번호 (0-\"+(t-1)+\") : &gt; \");                    int n = s.nextInt();                    if(n&gt;=0 &amp;&amp; n&lt;score.length) { //조회할 인덱스가 범위내인지 검사                        System.out.println(\"이름 : \"+name[n]);                        System.out.println(\"점수 : \"+score[n]);                    }else {                        System.out.println(\"잘못된 번호입니다 [번호범위 : 0-\"+(t-1)+\"]\");                        System.out.println();                    }                    System.out.println();                    break;//switch문 종료                    case 3://점수수정기능                    System.out.print(\"수정할 번호 : &gt; \");                    int num1 =s.nextInt();                                        //범위확인 코드 빠짐                    //(구현필요)                    if(num1&gt;=0 &amp;&amp; num1&lt;score.length) { //조회할 인덱스가 범위내인지 검사                        System.out.println(\"====수정 전 데이터====\");                        System.out.println(\"이름 : \"+name[num1]);                        System.out.println(\"점수 : \"+score[num1]);                    }else {                        System.out.println(\"잘못된 번호입니다 [번호범위 : 0-\"+(t-1)+\"]\");                        System.out.println();                        break;                    }                                        System.out.println(\"====수정 후 데이터====\");                    s.nextLine();                    System.out.print(\"이름 : &gt; \");                    String stu_name = s.nextLine();                    System.out.print(\"점수 : &gt; \");                    int stu_score = s.nextInt();                    s.nextLine(); //엔터키 입력 비우기                    System.out.println(\"이름 : \"+name[num1]+\" -&gt; \"+stu_name);                    System.out.println(\"점수 : \"+score[num1]+\" -&gt; \"+stu_score);                    System.out.print(\"수정하시겠습니까? 1-수정, 0-적용안함\");                    int num2 = s.nextInt();                    if(num2 == 1){                        name[num1] = stu_name;                        score[num1] = stu_score;                        System.out.println();                        System.out.println(\"점수가 저장되었습니다\");                    }else System.out.println(\"취소했습니다.\");                    System.out.println();                    break;//switch문 종료                case 0: //프로그램종료                    System.out.println(\"종료합니다.\");                    s.close();                    return; //main메소드 종료 = 프로그램종료                default : //숫자 잘못입력한경우                    System.out.println(\"잘못된 메뉴 번호입니다.\");            }        }    }}수정기능 추가nextInt nextdouble nextbyte 뒤에는 s.nextLine으로 엔터 날려주는게 좋음package JAVA_221025;public class ArrayLoopEx01 {    public static void main(String[] args) {        // int[] arr = new int[10];        // for(int i=0;i&lt;arr.length;i++){        //     arr[i] = (i+1)*10;        //     System.out.println(arr[i]);        // }        //시도별코로나감염자수        int[] corona = {            12888,10066,2032,2310,2641,1893,1831,1647,1046,1028,1369,1344,843,1443,771,141,439        };        //지역정보        String[] region = {            \"경기\", \"서울\", \"경남\", \"부산\", \"인천\",            \"경북\", \"대구\", \"충남\", \"전북\", \"전남\",             \"충북\", \"강원\", \"광주\", \"대전\", \"울산\",             \"제주\", \"세종\"        };        int sum=0;         int max=-1; //최소값으로 초기화 -&gt; 최대 확진자 수를 저장        int min=Integer.MAX_VALUE; //최대값으로 초가화 -&gt; 최소확진자수 저장        int max_idx =0; //최대값의 배열인덱스        int min_idx =0; //최소값의 배열인덱스        for(int i=0;i&lt;corona.length;i++){ //i값이 17미만일동일 반복            //for문 활용 corona배열의 모든 값 출력            //총 확진자 수 구하기            sum +=corona[i]; //누적            //최댓값 구하기            if(max&lt;corona[i]){ //변수 max가 corona배열의 i위치보다 작으면 max 수정                max = corona[i];                max_idx=i;            }            //최소값            if(min&gt;corona[i]){  //변수 min가 corona배열의 i위치보다 크면 min 수정                min = corona[i];                min_idx=i;            }        }        System.out.println(\"일일 확진자 수 : \"+sum); //합계        System.out.println(\"지역별 최대 확진자 수 : \"+max); //최대값출력        System.out.println(\"지역별 최소 확진자 수 : \"+min); //최소값출력        System.out.println(\"최대 확진 지역 : \"+region[max_idx]); //최대확진지역 이름        System.out.println(\"최소 확진 지역 : \"+region[min_idx]); //최소확진지역 이름            }}Integer.MAX_VALUE; int의 최대값을 반환package JAVA_221025;import java.util.Scanner;public class ArrayLoopEx02 {    public static void main(String[] args) {        //제일 높은 시간대, 낮은 시간대, 평균        int[] arr = {199,165,90,107,89,99,195,284,307,598,545,674,726,581,560,673,498,908,944,742,429,489,402,307}; //시간대별무단횡단        int max_idx=0,min_idx=0,sum=0; //최대치 인덱스, 최소치인덱스, 총합계        for(int i=0;i&lt;arr.length;i++){            if(arr[i]&gt;arr[max_idx]) max_idx=i; //지금 비교하는 arr의 i번째값이 최대치자리수의 값보다 크다면 max_idx변경            if(arr[i]&lt;arr[min_idx]) min_idx=i;//지금 비교하는 arr의 i번째값이 최소치자리수의 값보다 작다면 min_idx변경            sum+=arr[i]; //총 합계        }        System.out.println(\"최대 시간대 : \"+max_idx+\"시\"); //최대인원의 시간대        System.out.println(\"최소 시간대 : \"+min_idx+\"시\"); //최소인원의 시간대        System.out.println(\"평균 : \"+sum/(double)arr.length+\"명\"); //총합계/(double형변환)하루시간 -&gt; 평균 출력        double[] score = {80.75,59.7,60.5,78.8,96.8,100.0,45.21,63.66,45.2,56.48,98.6,94.89,78.9,49.87,88.97,78.9}; //점수배열        int pass_cnt=0; //합격자수        for(int i=0;i&lt;score.length;i++){ //16회 반복(i=0~15)                if(score[i]&gt;=60) pass_cnt++; //i번째 위치하는 데이터가 60이상이면 합격 pass_cnt 1 증가        }        //합불/합격률 계산        System.out.println(\"합격률 : \"+(pass_cnt/(double)score.length)*100+\"%\");         //합격한사람/(double형으로변환)전체응시인원수*100 -&gt; double형 평균 산출        System.out.println(\"불합격률 : \"+((score.length-pass_cnt)/(double)score.length)*100+\"%\");        //(전체응시인원수-합격한사람)/(double형으로변환)전체응시인원수*100 -&gt; double형 평균 산출        //만약 조건에 변경이있을확률이있으면 (ex.0점 미응시자) 불합격인원수도 변수로 지정해서 for문에서 같이적어줘야 덜번거로움        int[] covid={32451,29581,25434,13296,35177,31352,28130}; //코로나 확진자수        int total=0; //전체 합        double avg=0; //평균        for(int i=0;i&lt;covid.length;i++){ //전체 합계 구하는 for문            total +=covid[i];        }        avg = total/(double)covid.length; //전체합계/(double형 변환)총 일자 - double형 굳이 안해줘도됨        Scanner s = new Scanner(System.in);        System.out.print(\"감염자 수를 입력하세요 : \");        int input = s.nextInt(); //오늘 감염자수 입력        if(input&gt;=avg) System.out.println(\"코로나 감염 주의 단계 : 위험\"); //오늘의 단계.평균이상이면 위험        else System.out.println(\"코로나 감염 주의 단계 : 주의\"); //오늘의 단계. 평균미만이면 주의        s.close();    }}2차원 배열package JAVA_221025;public class NestedArrayEx01 {    public static void main(String[] args) {        int[][] arr= {            {10,20,30},            {40,50,60},            {70,80,90}        };        System.out.println(arr[0]); //주소값 출력        for(int i=0;i&lt;arr.length;i++){            for(int j=0;j&lt;arr[i].length;j++){                System.out.print(arr[i][j]+\" \");            }            System.out.println();        }    }}side effect : 내쪽이 아니고 다른쪽에서 문제생김EOF : end of file.문서의 끝(-1) - 완벽하지는않음ref : reference. 주소값"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 조건문과 반복문",
    "url": "/posts/%EC%A1%B0%EA%B1%B4%EB%AC%B8%EA%B3%BC_%EB%B0%98%EB%B3%B5%EB%AC%B8/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 조건문, 반복문",
    "date": "2022-10-19 00:00:00 +0900",
    





    
    "snippet": "조건문import java.util.Scanner;public class ConditionalCheck01 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"점수를 입력하세요 &gt; \");     ...",
    "content": "조건문import java.util.Scanner;public class ConditionalCheck01 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"점수를 입력하세요 &gt; \");        double score = s.nextDouble();        final int PASS_SCORE = 60;                if(score&gt;100){            System.out.println(\"입력값이 잘못되었습니다.\");        }else if(score &gt;=PASS_SCORE) {            //score의 값이 PASS_SCORE이상일때 실행            System.out.println(\"합격입니다.\");            if(score&lt;=100 &amp;&amp; score&gt;=90){                System.out.print(\"A\"+(score&gt;=95?\"+\":\"0\"));                // if(score&gt;=95){                //  System.out.println(\"+\");                // }else if(score&lt;95){                //     System.out.println(\"0\");                // }            }else if(score&gt;=80) {                System.out.print(\"B\");            }else if(score&gt;=70) {                System.out.print(\"c\");            }else if(score&gt;=60) {                System.out.print(\"d\");            }        }else{            System.out.println(\"불합격입니다\");         }        s.close();    }}import java.util.Scanner;public class SwitchEx {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.println(\"=======================\");        System.out.println(\"      1. 1번 기능\");        System.out.println(\"      2. 2번 기능\");        System.out.println(\"      3. 3번 기능\");        System.out.println(\"      4. 4번 기능\");        System.out.print(\"선택 : &gt;\");        int sel = s.nextInt();        // switch(sel){        //     case 1:         //         System.out.println(\"1번 기능 선택됨\");        //         break;        //     case 2:         //         System.out.println(\"2번 기능 선택됨\");        //         break;        //     case 3:         //         System.out.println(\"3번 기능 선택됨\");        //         break;        //     case 4:         //         System.out.println(\"4번 기능 선택됨\");        //         break;        //     default:        //         System.out.println(\"잘못된 번호 선택입니다.\");        // }        if(sel ==1 )        System.out.println(\"1번 기능 선택됨\");        else if(sel ==2 )   System.out.println(\"2번 기능 선택됨\");        else if(sel ==3 )   System.out.println(\"3번 기능 선택됨\");        else if(sel ==4 )   System.out.println(\"4번 기능 선택됨\");        else                System.out.println(\"잘못된 번호 선택입니다.\");        s.close();    }}import java.util.Scanner;public class ScannerExercise {    public static void main(String[] args) {        System.out.println(\"=====회원등록=====\");        Scanner s = new Scanner(System.in);        System.out.print(\"아이디 : &gt;\");        String user_id = s.nextLine();        System.out.print(\"비밀번호 : &gt;\");        String user_pwd = s.nextLine();        System.out.print(\"이름 : &gt;\");        String user_name = s.nextLine();        System.out.print(\"이메일 : &gt;\");        String user_email = s.nextLine();        System.out.print(\"생년월일(8자리로 입력하세요.) : &gt;\");        String user_birth = s.nextLine();        if(user_birth.length()!=8){            System.out.println(\"입력값이 잘못되었습니다.\");            s.close();            return;        }                // String user_gen = \"\";        System.out.print(\"성별을 입력하세요. 0-선택안함. 1-남자, 2-여자 : &gt;\");        int n = s.nextInt();                // if(n==0) user_gen=\"선택안함\";        // else if(n==1) user_gen=\"남\";        // else if(n==2) user_gen=\"여\";        // else{         //     System.out.println(\"입력값이 잘못되었습니다.\");        //     s.close();        //     return;        // }        String user_gen = n==0?\"선택안함\":n==1?\"남\":\"여\";        s.close();        System.out.println(\"=====회원등록정보=====\");        System.out.println(\"아이디 : \"+user_id);        System.out.println(\"비밀번호 : \"+user_pwd);        System.out.println(\"이름 : \"+user_name);        System.out.println(\"이메일 : \"+user_email);        System.out.println(\"생년월일 (8자리) : \"+user_birth);        System.out.println(\"성별 : \"+user_gen);        System.out.println(\"====가입정보====\");        System.out.print(\"아이디 : \"+user_id +\" / 비밀번호 : \");        for(int i=0;i&lt;user_pwd.length();i++){            System.out.print(\"*\");        }        System.out.println();        System.out.println(\"이름 : \"+user_name +\" / 생년월일 : \"+user_birth+\" / 성별 : \"+user_gen);        System.out.println(\"이메일 : \"+user_email);    }    }import java.util.Scanner;public class ScannerEx2 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"정수값을 입력해주세요 &gt; \");        int input_value=s.nextInt();        final int MAX_VALUE = 255;        // System.out.println(\"입력 값이 최대 값을 초과하는가? \"+(input_value&gt;MAX_VALUE));        // System.out.println(\"입력 값이 최대 값을 이하인가? \"+(input_value&lt;=MAX_VALUE));        String msg = input_value&gt;MAX_VALUE?\"최대 초과\":\"최대 이하\";        System.out.println(msg);        s.close();    }}import java.util.Calendar;import java.util.Scanner;public class ConditionalCheck01 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        // System.out.print(\"점수를 입력하세요 &gt; \");        // double score = s.nextDouble();        // final int PASS_SCORE = 60;                // if(score&gt;100 || score&lt;0){        //     System.out.println(\"잘못된 점수입니다.\");        // }else if(score &gt;=PASS_SCORE) {        //     //score의 값이 PASS_SCORE이상일때 실행        //     System.out.println(\"합격입니다.\");        //     if(score&gt;=90){        //         System.out.print(\"A\"+(score&gt;=95?\"+\":\"0\"));        //         // if(score&gt;=95){        //         //  System.out.println(\"+\");        //         // }else if(score&lt;95){        //         //     System.out.println(\"0\");        //         // }        //     }else if(score&gt;=80) {        //         System.out.print(\"B\");        //     }else if(score&gt;=70) {        //         System.out.print(\"c\");        //     }else if(score&gt;=60) {        //         System.out.print(\"d\");        //     }        // }else{        //     System.out.println(\"불합격입니다\");        //     System.out.println(\"f\");        //  }        // String grade = \"\";        // if(score&gt;100 || score&lt;0)        grade =\"잘못된 입력값입니다\";        // else if(score &gt;=90)             grade =\"A\";        // else if(score &gt;=80)             grade =\"B\";        // else if(score &gt;=70)             grade =\"C\";        // else if(score &gt;=60)             grade =\"D\";        // else if(score &gt;=0)              grade =\"F\";        // System.out.println(grade);        //생년월일 입력하기, 현재 연도와 계산 후 나이를 구함        //어린이, 청소년, 성인을 판별하여 표시하는 프로그램을 작성하세요        //어린이 0~13세, 청소년 14~17세, 성인 18세 이상        //입력한 생년이 현재 연도보다 큰 경우 오류로 처리한다.        //계산한 연령이 120세를 넘으면 오류로 처리한다                //추가사항) 연령대를 표시한다. 생년을 2000을 입력했을 경우, \"20대입니다\" 표시        System.out.println(\"태어난년도를 입력하세요 &gt; \");        int birthyear = s.nextInt();        Calendar c = Calendar.getInstance();        final int CURRENT_YEAR = c.get(Calendar.YEAR);        int age = CURRENT_YEAR-birthyear;                s.close();        if(birthyear&gt;CURRENT_YEAR) {            System.out.println(\"입력값이 잘못되었습니다. 출생년도는 현재년도보다 높을 수 없습니다.\");            // return;        }        else if(age&gt;=120) {            System.out.println(\"출생년도 입력 오류입니다.\");            // return;        }        else if(age&lt;=13) System.out.println(\"어린이입니다\");        else if(age&lt;=17) System.out.println(\"청소년입니다\");        else System.out.println(\"성인입니다.\");        if(!(birthyear&gt;CURRENT_YEAR || age&gt;=120))        System.out.println(age/10*10+\"대 입니다.\");            }}import java.util.Scanner;public class ScoreSwitch {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.println(\"점수를 입력하세요. &gt; \");        int score = s.nextInt();        switch(score/10){        case 10: case 9:            System.out.println(\"A\");            break;            case 8:            System.out.println(\"B\");            break;            case 7:            System.out.println(\"C\");            break;            case 6:            System.out.println(\"D\");            break;        default :            System.out.println(\"F\");        }        //150처럼 100점이 넘는것도 입력이 가능함. 입력값을받을때는 if문을 써야함    }}비교횟수가 최소화되어야 속도가 빠름.높은수부터 비교하는것이 좋음랜덤값public class RandomEx {    public static void main(String[] args) {        System.out.println((int)(Math.random()*10+1)); //0~10        System.out.println(Math.round(Math.random()*10)); //반올림        System.out.println(Math.ceil(Math.random()*10)); //올림        System.out.println(Math.floor(Math.random()*10)); //내림        System.out.println();        System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));         System.out.println((int)(Math.random()*45+1));     }}반복문import java.util.Scanner;public class LoopEx {    public static void main(String[] args) {        // for(int i=0;i&lt;3;i++){        //     System.out.println(\"반복합니다.\"+i);                    // }        // int j=0;        // while(j&lt;10){        //     int value = 10;        //     System.out.println(\"while반복\"+j+\"번째\");        //     j++;        // }        // int value=10;        // System.out.println();        System.out.println(\"====구구단 출력====\");        for(int i=1;i&lt;10;i++){            System.out.println(\"7 * \"+i+\" = \"+i*7);        }        System.out.println();        for(int i=1;i&lt;=7;i++){            for(int k=1;k&lt;=9;k++){                System.out.println(i +\" * \"+k+\" = \"+i*k);            }            System.out.println();        }        System.out.println(\"====구구단 while문 사용====\");        int i=1, k=1;        while(i&lt;=7){            System.out.println(i +\" * \"+k+\" = \"+i*k);            k++;            if(k==9){                i++;                k=1;                System.out.println();            }        }         System.out.println();        int arr[] = {10,20,30,40,50};        for(int index = 0;index&lt;arr.length;index++){            System.out.println(arr[index]);        }    }    }public class NestedLoop {    public static void main(String[] args) {        for(int i=0;i&lt;4;i++){            for(int j=0;j&lt;3;j++){                System.out.println(\"i : \"+i+\" / j : \"+j);            }            System.out.println();        }        for(int i=1;i&lt;=7;i++){            for(int j=1;j&lt;=9;j++){                System.out.println(i +\" * \"+j+\" = \"+i*j);            }            System.out.println();        }        // System.out.println(\"====구구단 while문 사용====\");        // int i=1, j=1;        // while(i&lt;=7){        //     System.out.println(i +\" * \"+j+\" = \"+i*j);        //     j++;        //     if(j==9){        //         i++;        //         j=1;        //         System.out.println();        //     }        // }        for(int i=0;i&lt;5;i++){            for(int j=0;j&lt;=i;j++){                System.out.print(\" * \");            }            System.out.println();        }    }}for문의 선언된 변수 이름으로 반복문을 부름i Loop, j Loop 이런식import java.util.Scanner;public class StringCompare {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.println(\"Hello를 입력하세요. : &gt;\");        String input = s.nextLine();        if(input.equalsIgnoreCase(\"Hello\")) System.out.println(\"안녕하세요.\");        else System.out.println(\"안녕히가세요.\");        //equalsIgnoreCase : 대소문자 무시비교        s.close();    }}equalsIgnoreCase : 대소문자 무시비교import java.util.Scanner;public class ConditionCheck {    public static void main(String[] args) {        final int MAX_VALUE = 255;        Scanner s = new Scanner(System.in);        System.out.println(\"값을 입력하세요(최대 0 ~ 255) : &gt; \");        int input =s.nextInt();        // if(input &gt; MAX_VALUE) System.out.println(\"입력값은 최대 값을 넘습니다.\");        // // if(input &lt;=MAX_VALUE) System.out.println(\"입력한 값 : \"+input);        // else if(input&lt;0) System.out.println(\"입력값은 최소 값 미만입니다.\");        // else System.out.println(\"입력한 값 : \"+input);                if(input &gt;MAX_VALUE || input &lt; 0 ) System.out.println(\"입력값이 범위를 넘어섭니다. (범위 0 ~ 255)\");        else System.out.println(\"입력한 값 : \"+input);         s.close();    }}import java.util.Scanner;public class ConditionCheck2 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"선택(1~4) : &gt; \");        int input = s.nextInt();        if(input == 1 )      System.out.println(\"1번을 선택하셨습니다.\");        else if(input == 2 ) System.out.println(\"2번을 선택하셨습니다.\");        else if(input == 3 ) System.out.println(\"3번을 선택하셨습니다.\");        else if(input == 4 ) System.out.println(\"4번을 선택하셨습니다.\");        else                 System.out.println(\"잘못된 번호 선택입니다.\");                switch(input){            case   1: System.out.println(\"1번 기능\"); break;            case   2: System.out.println(\"2번 기능\"); break;            case   3: System.out.println(\"3번 기능\"); break;            case   4: System.out.println(\"4번 기능\"); break;            default : System.out.println(\"잘못된 번호 선택입니다.\");        }        s.close();    }}public class NameGenerate {    public static void main(String[] args) {        String name_first[] = {\"김\",\"이\",\"박\",\"최\",\"정\",\"강\",\"조\",\"윤\",\"장\",\"임\"};        String name_mid[] = {\"민\",\"서\",\"도\",\"예\",\"시\",\"하\",\"주\",\"준\",\"윤\",\"예\"};        String name_last[] = {\"준\",\"윤\",\"우\",\"원\",\"현\",\"은\",\"빈\",\"연\",\"진\",\"하\"};        for(int i=0;i&lt;10;i++){            int r1 = (int)(Math.random()*name_first.length);            int r2 = (int)(Math.random()*name_mid.length);            int r3 = (int)(Math.random()*name_last.length);            System.out.println(name_first[r1]+name_mid[r2]+name_last[r3]);        }    }}public class RandomEx2 {    public static void main(String[] args) {        System.out.println((int)(Math.random()*10)); //0~9        System.out.println((int)(Math.random()*100)); //0~99        System.out.println((int)(Math.random()*100)+1); //1~100        double d1 = 1.23;        double d2 = 1.88;        double d3 = 1.67;        System.out.println(Math.round(d3));        System.out.println(Math.ceil(d1)); //올림        System.out.println(Math.floor(d2)); //내림        int arr [] = {1,2,3,4,5};        System.out.println(arr[(int)(Math.random()*arr.length)]);    }}public class LoopEx3 {    public static void main(String[] args) {        for(int i=0;i&lt;3;i++){            System.out.println(\"Hello\");        }        int i=0;        while(i&lt;3){            System.out.println(\"Hello\");            i++;        }        for(i=0;i&lt;3;i++){            System.out.println(\"Hello\");        }        int value = 10;        for(i=0;i&lt;3;i++){            // int value =10;            System.out.println(\"Hello\");            value++;            System.out.println(value);        }        System.out.println(value);        int sum = 0;        int j=0;        while(sum&lt;=100){            System.out.println(\"sum : \"+sum);            // sum +=++j;            j++;            sum+=j;                    }    }}import java.util.Scanner;public class NestedLoop2 {    public static void main(String[] args) {        for(int i=0;i&lt;3;i++){            for(int j=0;j&lt;2;j++){                System.out.println(\"i : \"+ i+\" / j : \"+j);            }        }        Scanner s = new Scanner(System.in);        System.out.print(\"시작단을 입력하세요 : &gt; \");        int begin = s.nextInt();        System.out.print(\"끝단을 입력하세요 : &gt; \");        int end = s.nextInt();        if(begin&lt;=end){            for(int i=begin;i&lt;=end;i++){                System.out.println(i+\"단==========\");                for(int j=1;j&lt;=9;j++){                    System.out.println(i+\" X \"+ j+\" = \"+i*j);                }            }        }else {            System.out.println(\"시작 단은 끝 단 보다 클 수 없습니다.\");            return;        }    }}public class LoopEx4 {    public static void main(String[] args) {        for(int i=0;i&lt;10;i++){            System.out.println(\"반복합니다.\");            // break;            if(i==5) break;        }        int i=0;        int sum=0;        // while(sum&lt;1000){        // while(true){        //     sum = sum+i;        //     i++;        //     if(sum&gt;=1000) break;        // }        for(;;){            sum = sum+i;            i++;            if(sum&gt;=1000) break;        }        System.out.println(\"누적 횟수 : \"+i+\", 총 합 : \"+sum);    }}import java.util.Scanner;public class InfiniteLoop {    public static void main(String[] args) {        Scanner s= new Scanner(System.in);        while(true){            int sel = 0;            System.out.println(\"===============\");            System.out.println(\"1. 회원추가\");            System.out.println(\"2. 회원조회\");            System.out.println(\"3. 회원수정\");            System.out.println(\"4. 회원삭제\");            System.out.println(\"0. 종료\");            System.out.print(\"선택 : &gt; \");            sel = s.nextInt();            if(sel ==0) break;            else if(sel ==1) System.out.println(\"회원추가 기능 실행\");            else if(sel ==2) System.out.println(\"회원조회 기능 실행\");            else if(sel ==3) System.out.println(\"회원수정 기능 실행\");            else if(sel ==4) System.out.println(\"회원삭제 기능 실행\");            else System.out.println(\"잘못된 기능번호 입니다. 다시 선택해주세요\");         }        s.close();    }}public class LoopEx5 {    public static void main(String[] args) {        for(int i=0;i&lt;10;i++){            System.out.println(\"반복합니다\"+i);            if(i%3==0) continue; //필터링 역할            System.out.println(\"continue 다음 출력\");        }    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 연산자(Operator)",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EC%97%B0%EC%82%B0%EC%9E%90(Operator)/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 연산자",
    "date": "2022-10-18 00:00:00 +0900",
    





    
    "snippet": "비교연산자는 우선순위가 거의 비슷해서 적은 순서대로 처리됨비트연산자는 거의 안씀. (», «) - low level에서 사용low level : 컴퓨터 기계쪽에 가까움(서버)high level : 사용자쪽에 가까움(프론트)middle level : 백엔드=가 제일 후순위임import java.io.BufferedReader;import java.io....",
    "content": "비교연산자는 우선순위가 거의 비슷해서 적은 순서대로 처리됨비트연산자는 거의 안씀. (», «) - low level에서 사용low level : 컴퓨터 기계쪽에 가까움(서버)high level : 사용자쪽에 가까움(프론트)middle level : 백엔드=가 제일 후순위임import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Calendar;public class InputEx {    public static void main(String[] args) throws IOException {        //표준입력을 대상으로 하는 스캐너 생성        // Scanner s = new Scanner(System.in);        // int input = s.nextInt(); //int형태의 값 하나 입력받기        // s.close(); //Scanner 사용 종료        Calendar c = Calendar.getInstance();        final int CURRENT_YEAR=c.get(Calendar.YEAR);        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        while(true){            System.out.println(\"출생년도를 입력하세요. 종료하려면 0을 입력하세요\");            int birthyear = Integer.parseInt(br.readLine());            if(birthyear==0) break;            else if(birthyear&gt;2022 || birthyear&lt;0){                System.out.println(\"입력값이 잘못되었습니다.\");                return;            }            System.out.println(\"입력한 값 : \"+birthyear);            // System.out.println((CURRENT_YEAR-birthyear+1)+\"세 입니다\");            int age=CURRENT_YEAR-birthyear;            System.out.println(age+\"세 입니다\");            if(age&gt;=18) System.out.println(\"성인입니다.\");            System.out.println(\"=================\");        }              br.close();    }}심심해서 만들어봄클래스에 final이 붙어있으면 하위 클래스를 만들지 말라는뜻임import java.util.Scanner;public class ConditionCheck {    public static void main(String[] args) {        //비교연산자        //대소비교(이상, 이하, 초과, 미만)        //동일비교(같다, 다르다)        // int x =10;        // System.out.println(x&gt;=10);//이상        // System.out.println(x&lt;=10);//이하        // System.out.println(x&gt;10);//초과        // System.out.println(x&gt;10);//미만        // System.out.println(x==10); //동일        // System.out.println(x!=10); //다른값?                //동일비교        // int sel = s.nextInt();        // System.out.println(\"1번 선택 : \"+(sel == 1));        // System.out.println(\"2번 선택 : \"+(sel == 2));        // System.out.println(\"3번 선택 : \"+(sel == 3));        // System.out.println(\"4번 선택 : \"+(sel == 4));        // if(sel == 1) System.out.println(\"1번을 선택함\");        // if(sel == 2) System.out.println(\"2번을 선택함\");        // if(sel == 3) System.out.println(\"3번을 선택함\");        // if(sel == 4) System.out.println(\"4번을 선택함\");                Scanner s = new Scanner(System.in);        String input = s.nextLine();        if(input.equals(\"hello\")) System.out.println(\"Hello World!!\");        if(input.equals(\"bye\")) System.out.println(\"Exit Program\");                s.close(); //단순프로그램에선 안써도 문제없지만 복잡해지면 안썻을때 문제생길수도        // System.out.println(\"출생 연도를 입력하세요\");        // int birthYear=s.nextInt();        // int age = 2022-birthYear;        // String msg= age&gt;=18 ? \"성인입니다.\" :\"미성년입니다.\";        // System.out.println(msg);        // s.close();        // int totalCount =123;        // final int POST_PER_PAGE=10;        // //totalcount를 POST_PER_PAGE로 나눈 나머지 값이 0을 초과한다면 additionalPage를 1. 아니면 0        // int additionalPage = totalCount % POST_PER_PAGE &gt; 0 ? 1 : 0;        // int totalPage = totalCount / POST_PER_PAGE + additionalPage;        // System.out.println(\"총 페이지 수 : \"+totalPage);     }}            x             y = 논리합 (true[1]+false[0] → true)      x&amp;&amp;y = 논리곱 (true*false → false)이산수학 비둘기집원리printf보다 println이 좀더 범용적임import java.util.Scanner;public class ScannerExercise {    public static void main(String[] args) {        System.out.println(\"=====회원등록=====\");        Scanner s = new Scanner(System.in);        System.out.print(\"아이디 : &gt;\");        String user_id = s.nextLine();        System.out.print(\"비밀번호 : &gt;\");        String user_pwd = s.nextLine();        System.out.print(\"이름 : &gt;\");        String user_name = s.nextLine();        System.out.print(\"이메일 : &gt;\");        String user_email = s.nextLine();        System.out.print(\"생년월일(8자리로 입력하세요.) : &gt;\");        String user_birth = s.nextLine();        if(user_birth.length()!=8){            System.out.println(\"입력값이 잘못되었습니다.\");            s.close();            return;        }                // String user_gen = \"\";        System.out.print(\"성별을 입력하세요. 0-선택안함. 1-남자, 2-여자 : &gt;\");        int n = s.nextInt();                // if(n==0) user_gen=\"선택안함\";        // else if(n==1) user_gen=\"남\";        // else if(n==2) user_gen=\"여\";        // else{         //     System.out.println(\"입력값이 잘못되었습니다.\");        //     s.close();        //     return;        // }        String user_gen = n==0?\"선택안함\":n==1?\"남\":\"여\";        s.close();        System.out.println(\"=====회원등록정보=====\");        System.out.println(\"아이디 : \"+user_id);        System.out.println(\"비밀번호 : \"+user_pwd);        System.out.println(\"이름 : \"+user_name);        System.out.println(\"이메일 : \"+user_email);        System.out.println(\"생년월일 (8자리) : \"+user_birth);        System.out.println(\"성별 : \"+user_gen);        System.out.println(\"====가입정보====\");        System.out.print(\"아이디 : \"+user_id +\" / 비밀번호 : \");        for(int i=0;i&lt;user_pwd.length();i++){            System.out.print(\"*\");        }        System.out.println();        System.out.println(\"이름 : \"+user_name +\" / 생년월일 : \"+user_birth+\" / 성별 : \"+user_gen);        System.out.println(\"이메일 : \"+user_email);    }    }Scanner의 문제점import java.util.Scanner;public class ScannerProblem {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"숫자 입력 &gt; \");        int number =s.nextInt();        System.out.print(\"문자열 입력 &gt; \");        // String str =s.nextLine();         //문자열을 입력받기 전에 종료해버림.        //number값을 받은 후 입력한 enter를 str값으로 인식한것임        s.nextLine();        String str =s.nextLine();         //number뒤에 온 enter를 따로 처리해줌    }}import java.util.Scanner;public class ScannerEx2 {    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.print(\"정수값을 입력해주세요 &gt; \");        int input_value=s.nextInt();        final int MAX_VALUE = 255;        // System.out.println(\"입력 값이 최대 값을 초과하는가? \"+(input_value&gt;MAX_VALUE));        // System.out.println(\"입력 값이 최대 값을 이하인가? \"+(input_value&lt;=MAX_VALUE));        String msg = input_value&gt;MAX_VALUE?\"최대 초과\":\"최대 이하\";        System.out.println(msg);        s.close();    }}"
  },
  
  {
    "title": "[국비교육학원-수업내용정리] 변수(Variable)",
    "url": "/posts/%EA%B7%B8%EB%A6%B0_%EB%B3%80%EC%88%98(Variable)/",
    "categories": "JAVA",
    "tags": "java, 국비교육, 변수",
    "date": "2022-10-17 00:00:00 +0900",
    





    
    "snippet": "  단축키          ctrl + alt + 방향키 - 멀티라인 셀렉트. 동시수정 단축키      주석처리 ctrl + /      int와 double이 처리속도가 가장 빠름shift + home - 커서부터 줄의 맨 앞쪽까지 선택public class VariablesEx {    public static void main(String[] a...",
    "content": "  단축키          ctrl + alt + 방향키 - 멀티라인 셀렉트. 동시수정 단축키      주석처리 ctrl + /      int와 double이 처리속도가 가장 빠름shift + home - 커서부터 줄의 맨 앞쪽까지 선택public class VariablesEx {    public static void main(String[] args) {        //주석기호(메모공간)        //타입 변수명(식별자) = 값;        //정수, 실수, 논리, 레퍼런스 타입(String)        //정수 byte, shor, int, long        byte value1 = 10; //-127~128까지 표현 가능        short value2=100; //-32236~32235        int value3=10000; //-21억~+21억        long value4 = 1000000000000000000L;         System.out.println(value1);        System.out.println(value2);        System.out.println(value3);        System.out.println(value4);        System.out.println();        //실수 float, double        float f =100000.11f; //정밀도가 떨어짐        double d = 1000000.2222;         System.out.println(f);        System.out.println(d);        System.out.println();        //논리 boolean        boolean t=true;        System.out.println(t);        System.out.println();        //레퍼런스 타입 String        String str = \"abc\";        System.out.println(str);    }}양수만 표현 - unsugned (ex.조회수) - 정수형, 실수형에 쓰임(char제외) - c언어 문법이라고 함. java에서는 못씀public class VariablesEx {    public static void main(String[] args) {        // int i=100;        // System.out.println(i);        // i=200;        // System.out.println(i);        // i=300;        // System.out.println(i);        // i=400;        // System.out.println(i);        // i=500;        // System.out.println(i);        long lnum =123456789012L;        int num=22234;        int num2=55;        double d= 12.34;        double d2=12.3333222;        String str = \"Hello World\";        char c= '$';        System.out.println(lnum);        System.out.println(num);        System.out.println(num2);        System.out.println(d);        System.out.println(d2);        System.out.println(str);        System.out.println(c);       }}camel case, snake case 이름 파악해 둘 것리터럴 : 그 자체로 값이 인정됨 (int a= ==10==; 에서 10이 리터럴)정수 리터럴 - int(10) / long(10L)실수 리터럴 -double(10.23) / float(10.23f)상수 : 변하지 않는 값 (최초에 지정한 값에서 변경 불가능). 모두 대문자로 쓰는것이 좋음. finalpublic class Naming {    public static void main(String[] args) {        // int int =10; //오류남        int Int=10; //되는데 권장 안함        int numberofstudents =29; //되는데 권장 안함. 그냥 가독성 문제임        int numberOfStudents=29;//camel case 이걸 더 많이 씀 둘중 하나로 통일 추천        int number_of_Students=29;//snake case                // int @#$#^^=10; //오류남        int $$$=1;        int $_$$$$ =1; //되는데 욕먹음                int 숫자 =1; //가능한데 추천 안함. 한영키누르면 속도 느려짐        // int a b c =1; //오류 띄어쓰기 안됨                // int number_of_Students=29;//같은이름 두번 써서 오류        //상수        final int MAX_COUNT=255;        // MAX_COUNT=200; //오류남 MAX_count는 final이 붙어서 수정 불가능함        final double PI = 3.141592653589793; //대표적인 final예시        //지수표현        System.out.println(10e+10); //10의 10제곱 1.0E11출력        System.out.println(10e-10); //10의 -10제곱  1.0E-9출력.        byte b= (byte)250;        System.out.println(b); //-6출력됨. 오버플로우    }}            자료형      초기값                  boolean      false              char      ‘/u0000’              byte      0              short      0              int      0              long      0L              double      0.0d 또는 0.0              String      null      String =”” - 0임String = null - null값임형변환(Type Casting)public class TypeCasting {    public static void main(String[] args) {        //묵시적 형변환        byte a = 10; //10은 int형인데 자동으로 byte형 변환해줌        System.out.println(a);        int b=a;        System.out.println(b); //10 출력됨. byte를 int로 자동 형변환한것        // short c=b; //에러남. short가 int보다 작기때문에 데이터유실이 일어날 수도 있음.         //형변환을 사용하려면 명시적 형변환을 사용해야함        //명시적 형변환        short c = (short)b;//데이터 유실 위험있음        System.out.println(c); //10출력        double d1 = 10.99;        System.out.println(d1);        int i1 = (int)d1;         System.out.println(i1); //10출력. 소수점 버림        i1=(int)(d1*10);        d1=i1/10.0;        System.out.println(d1); //강제로 잘랐기때문에 값이 비정확할수도있음        //long -&gt; int 형변환에서 가낭 오버플로우가 많이일어남        int i2 = (int)1000000000000000L;        System.out.println(i2); //-1530494976출력됨        char ch ='A';        int i3 = ch;        System.out.println(i3);    }}가능하면 명시적으로 해주는 것이 가독성이 좋음public static void main(String[] args)에서 args가 파라미터 java -version에서 -version에 해당함class Review{    public static void main(String[] args){        System.out.println(\"한 줄 출력하기\");        //주석 ctrl + /        // System.out.print(\"그냥 출력1\");        // System.out.print(\"그냥 출력2\");        //변수        //타입이름 변수이름; - 생성        //변수이름 = 값; - 초기화        //타입이름 변수이름 = 값;        //변수의 데이터타입 : 정수형, 실수형, 논리형, 문자형, 참조형        //정수형 - byte, shortm int long (default type = int)        //1Byte, 2Byte, 4Byte, 8Byte        byte bt1 = 10; //byte타입의 변수 bt1을 선언(정의)하고, 변수를 10으로 초기화        System.out.println(bt1);        bt1=20;        System.out.println(bt1);        // byte bt1 = 100; //에러, 변수 명 중복                //실수형(float, double)        double d1=10.23;        System.out.println(d1);        //문자형(char)        char ch ='A';        System.out.println(ch);        //논리형        boolean b1 = true;        System.out.println(b1);        b1 = false;        System.out.println(b1);        //참조형(reference Type)        String str = new String(\"Hello\");        System.out.println(str);        String str2=null;        System.out.println(str2); //null출력. 문자열null이 출력된게 아니고 빈공간이라는 뜻임        int a,b,c;        a=b=c=100; //한번에 같은값 변수 3개에 넣기. 잘안씀        System.out.println(a);        System.out.println(b);        System.out.println(c);                    }}char 잘 안씀. String으로 거의 다 처리가능메모리를 절약해야 트래픽 소모가 줄어서 비용이 덜 듬int - boolean은 상호호환이 됨식별자 : 임의로 이름을 지을 수 있는 모든 것"
  },
  
  {
    "title": "자바의 정석 연습문제 8장 - 예외",
    "url": "/posts/8%EC%9E%A5/",
    "categories": "",
    "tags": "java, 자바의정석, 연습문제, 예외",
    "date": "2022-10-16 00:00:00 +0900",
    





    
    "snippet": "[8-1] 예외처리의 정의와 목적정의 : 발생할 수 있는 예외(에러아님)를 미리 대비해놓는 것목적 : 이미 일어날 것을 예상한 예외를 무시하고 정삭적인 실행상태를 유지시키기위해 사용[8-2] 실행도중 예외가 발생하여 화면에 출력된 내용. 옳지않은것은?  [!important]java.lang.ArithmeticException : / by zero a...",
    "content": "[8-1] 예외처리의 정의와 목적정의 : 발생할 수 있는 예외(에러아님)를 미리 대비해놓는 것목적 : 이미 일어날 것을 예상한 예외를 무시하고 정삭적인 실행상태를 유지시키기위해 사용[8-2] 실행도중 예외가 발생하여 화면에 출력된 내용. 옳지않은것은?  [!important]java.lang.ArithmeticException : / by zero at ExceptionEx18.method2 (ExceptionEx18.java:12) at ExceptionEx18.method1 (ExceptionEx18.java:8) at ExceptionEx18.main (ExceptionEx18.java:4)  위의 내용으로 예외 발생 시 호출스택에 존재했던 메소드를 알 수 있음  예외가 발생한 위치는 method2 메소드이며 ExceptionEx18.java파일의 12번째 줄이다  발생한 예외는 AirthmeticException이며, 0으로 나누어서 예외가 발생했다  method2메소드가 method1메소드를 호출했고 그 위치는 ExceptionEx18.java파일의 8번째 줄이다. → main메소드가 method1을 호출했고 다음에 method2가 호출되었음public class test {\t\tstatic void method1(){\t\tmethod2();\t}\tstatic void method2(){\t\tmethod3();\t}\tstatic void method3(){\t\tSystem.out.println(\"hello\");\t\tSystem.out.println(1/0);\t}\tpublic static void main(String[] args) {\t\tmethod1();\t}}위의 예시를 실행시키면Exception in thread \"main\" java.lang.ArithmeticException: / by zero\tat test.method3(test.java:29)\tat test.method2(test.java:25)\tat test.method1(test.java:22)\tat test.main(test.java:35)라는 메세지가 뜬다.실제 method3에서 발생했지만 method3를 호출한 method2도 예외가 발생했다고 처리하고 method2를 호출한 method1과 method1을 호출한 main메소드도 호출한 라인에 예외가 발생한것으로 처리하기떄문임.[8-3] 오버라이딩이 잘못 된 것을 모두 고르시오void add(int a, int b) throws InvalidNumberException, NotANumberException {}class NumberException extends Exception{}class InvalidNumberException extends Exception{}class NotANumberException extends Exception{}  void add(int a, int b) throws InvalidNumberException, NotAnumberException {}  void add(int a, int b) throws InvalidNumberException {}  void add(int a, int b) throws NotAnumberException {}  void add(int a, int b) throws Exception {}  void add(int a, int b) throws NumberException {}오버라이딩시 조상보다 더 많은 예외를 선언할 수 없음. 더 높은 조상을 예외선언해도 마찬가지임. Exception은 모든 예외의 최고조상임.[8-4]다음 중 예외를 잘못 처리한 것은?void method() throws InvalidNumberException, NotANumberException {}\tclass NumberException extends RuntimeException{}class InvalidNumberException extends NumberException{}class NotANumberException extends NumberException {}  try {method();} catch(Exception e){}  try {method();} catch(NumberException e) {} catch(Exception e) {}  try {method();} catch(Exception e) {} catch(NumberException e) {}  try {method();} catch(InvalidNumberException e) {} catch(NotANumberException e) {}  try {method();} catch(NumberException e) {}  try {method();} catch(RuntimeException e) {}Exception은 모든 예외의 최고조상이라서 맨 마지막 catch문에 넣어야함. 첫번째 catch문에서 모든 예외를 처리했으니 다음 catch문에서 처리할 예외가 올 수가 없음[8-5] 실행결과를 적으시오package _2javajungsuktestEx8;public class ex8_5 {\tstatic void method(boolean b) {\t\ttry {\t\t\tSystem.out.println(1);\t\t\tif(b) throw new ArithmeticException();\t\t\tSystem.out.println(2);\t\t}catch(RuntimeException r) {\t\t\tSystem.out.println(3);\t\t\treturn;\t\t}catch(Exception e) {\t\t\tSystem.out.println(4);\t\t\treturn;\t\t}finally {\t\t\tSystem.out.println(5);\t\t}\t\tSystem.out.println(6);\t}\t\tpublic static void main(String[] args) {\t\tmethod(true);\t\tmethod(false);\t}}method(true)호출 →1 출력 → 매개변수 b가 true라서 ArithmeticException발생 → ArithmeticException이 RuntimeExcpetion의 자손이라서 첫번째 catch블럭으로 감 → 3 출력 → 예외가 처리 됐으니 finally블럭으로 감 → 5출력 → method(false) 호출 → 1출력 → 매개변수 b가 false니까 예외가 발생하지 않음 → 2출력 → 5 출력 → 6 출력최종적으로 1 3 5 1 2 5 6이 출력된다[8-6] 실행결과를 적으시오class Exercise8_6 {public static void main(String[] args) {\ttry {\t\tmethod1();\t} catch(Exception e) {\t\tSystem.out.println(5);\t}}static void method1() {\ttry {\t\tmethod2();\t\tSystem.out.println(1);\t} catch(ArithmeticException e) {\t\tSystem.out.println(2);\t} finally {\t\tSystem.out.println(3);\t}\tSystem.out.println(4);} // method1()static void method2() {\tthrow new NullPointerException();}mothod1 → mothod2에서 NullPointerException발생 → 다시 method1으로 돌아가서 발생한 NullPointerException때문에 finally블럭으로 이동 → 3 출력 → method1의 try-catch문 종료 → 발생한 NullPointerException이 해결되지못해서 4가 출력되지못하고 method1 종료 → 다시 method1으로 해결못한 NullPointerException이 main의 try-catch문을 만나(Exception이 최고조상이라 모든 Exception을 처리가능) 5출력최종적으로 3 5 출력됨[8-7] 실행결과를 적으세요class Exercise8_7 {\tstatic void method(boolean b) {\t\ttry {\t\t\tSystem.out.println(1);\t\t\tif(b) System.exit(0);\t\t\tSystem.out.println(2);\t\t} catch(RuntimeException r) {\t\t\tSystem.out.println(3);\t\t\treturn;\t\t} catch(Exception e) {\t\t\tSystem.out.println(4);\t\t\treturn;\t\t} finally {\t\t\tSystem.out.println(5);\t\t}\t\tSystem.out.println(6);\t}\tpublic static void main(String[] args) {\t\tmethod(true);\t\tmethod(false);\t} // main}main에서 매개변수에 true가 들어간 생태로 method실행 → try-catch문으로 들어가 1 출력 → if(b)가 true니까 프로그램이 종료최종적으로 1 만 출력되고 종료됨package Ex8;import java.util.InputMismatchException;import java.util.Scanner;import javax.swing.plaf.synth.SynthSeparatorUI;public class Ex8_8{    public static void main(String[] args) {        //1~100사이의 임의의 값을 얻어서 answer에 저장한다        int answer = (int)(Math.random()*100)+1;        int input=0;        int count=0;        do{            Scanner s = new Scanner(System.in);            try{                System.out.println(\"1과 100사이의 값을 입력하세요 : &gt;\");                input = s.nextInt();            } catch(InputMismatchException e){                System.out.println(\"유효하지 않은 값입니다. 다시 값을 입력해주세요.\");                continue;            }            count++;                if(answer&gt;input) System.out.println(\"더 큰수를 입력하세요.\");            else if(answer &lt;input) System.out.println(\"더 작은 수를 입력하세요.\");            else {                System.out.println(\"맞췄습니다.\");                System.out.println(\"시도횟수는 \"+count+\"번 입니다.\");                s.close();                break;            }        }while(true);    }}input을 받는 부분을 try-catch문에 넣어서 오류가 발생했을시 에러메세지를 출력하고 다시 try문으로 돌아가도록 continue;를 넣어주었다. catch에 들어갈 Exception은 예제에 적힌Exception in thread “main” java.util.InputMismatchExceptionat java.util.Scanner.throwFor(Scanner.java:819)at java.util.Scanner.next(Scanner.java:1431)at java.util.Scanner.nextInt(Scanner.java:2040)at java.util.Scanner.nextInt(Scanner.java:2000)at Exercise8_8.main(Exercise8_8.java:16)을 보고 그대로 사용하였다. 그냥 Exception을 써도 될 것같다.[8-9] 다음과 같은 조건의 예외클래스를 작성하시오package Ex8;class UnsupportedFunctionException extends RuntimeException {    final private int ERR_CODE;    UnsupportedFunctionException(String msg, int errCode){        super(msg); //조상의 생성자 RuntimeException(String msg)호출        ERR_CODE=errCode;    }    UnsupportedFunctionException(String msg){        this(msg,100);    }    public int getErrorCode(){        return ERR_CODE;    }    public String getMessage(){ //Exception의 getMessage를 오버라이딩        return \"[\" + getErrorCode()+\"]\"+super.getMessage();     }}public class Ex8_9 {    public static void main(String[] args) {        throw new UnsupportedFunctionException(\"지원하지 않는 기능입니다.\",100);    }    }상속이 좀 헷갈리는데 강의를 다시 들어야할거같다[8-10] 실행순서를 적으시오class Exercise8_10 {\tpublic static void main(String[] args) {\t\ttry {\t\t\tmethod1();\t\t\tSystem.out.println(6);\t\t} catch(Exception e) {\t\t\tSystem.out.println(7);\t\t\t}\t\t}\tstatic void method1() throws Exception {\t\ttry {\t\t\tmethod2();\t\t\tSystem.out.println(1);\t\t} catch(NullPointerException e) {\t\t\tSystem.out.println(2);\t\t\tthrow e;\t\t} catch(Exception e) {\t\t\tSystem.out.println(3);\t\t} finally {\t\t\tSystem.out.println(4);\t\t}\t\t\tSystem.out.println(5);\t\t} // method1()\tstatic void method2() {\t\tthrow new NullPointerException();\t}}main → method1 → method2 → NullPointerException발생, method2종료 후 method1으로 돌아감 → method1의 try-catch문의 첫번째 catch문으로 이동, 2출력 + Exception발생. → Exception이 해결하지못한채로 finally로 이동, 4출력 → Exception이 해결되지못해서 5가 출력되지못하고 method1종료 → main의 try-catch문으로 이동 → Exception으로 인해 6이 출력되지못하고 Exception catch문으로 이동 → 7 출력4 2 7 출력됨"
  },
  
  {
    "title": "자바의 정석 연습문자 7장 - 상속 2",
    "url": "/posts/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D_%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C_7%EC%9E%A5_%EC%83%81%EC%86%8D_2/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 상속",
    "date": "2022-10-10 00:00:00 +0900",
    





    
    "snippet": "[7-17] 예제코드의 세 클래스에서 공통부분을 뽑아 Unit 클래스를 만들고 이 클래스를 상속받도록 코드를 변경  예제    class Marine{  int x,y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Tank{  int x, y;  void move(int x...",
    "content": "[7-17] 예제코드의 세 클래스에서 공통부분을 뽑아 Unit 클래스를 만들고 이 클래스를 상속받도록 코드를 변경  예제    class Marine{  int x,y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Tank{  int x, y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Dropship{  int x,y;  void move(int x, int y){}  void stop(){}  void load(){}  void unload(){}}        변경 코드package _2javajungsuktestEx7;class Unit{\tint x, y;\tvoid move(int x, int y) {}\tvoid stop() {}}class Marine extends Unit {\tvoid stimPack() {}}class Tank extends Unit {\tvoid changeMode() {}}class Droppship extends Unit{\tvoid load(){}\tvoid unload() {}}public class ex7_17 {\tpublic static void main(String[] args) {\t}}공통적으로 등장하는 부분만 Unit으로 묶어서 만들어준후 상속처리 해줬음  답지package _2javajungsuktestEx7;class Unit{\tint x, y;\tabstract void move(int x, int y) {}\tvoid stop() {}}class Marine extends Unit {\tvoid stimPack() {}}class Tank extends Unit {\tvoid changeMode() {}}class Droppship extends Unit{\tvoid load(){}\tvoid unload() {}}public class ex7_17 {\tpublic static void main(String[] args) {\t}}Unit클래스의 move메소드에 abstract를 붙여 추상메소드 처리를 해주었음. 각 클래스마다 이동방법이 다르기때문..[7-18] action메소드를 실행하면 매개변수에 해당하는 클래스의 메소드를 실행하도록 만드는 문제package _2javajungsuktestEx7;class Robot{}class DanceRobot extends Robot{\tvoid dance(){\t\tSystem.out.println(\"춤\");\t}}class SingRobot extends Robot{\tvoid sing(){\t\tSystem.out.println(\"노래\");\t}}class DrawRobot extends Robot{\tvoid draw(){\t\tSystem.out.println(\"그림\");\t}}public class ex7_18 {\t\tstatic void action(Robot r) {\t\tif(r instanceof DanceRobot) \t\t\t((DanceRobot) r).dance();\t\telse if(r instanceof SingRobot) \t\t\t((SingRobot) r).sing();\t\telse if(r instanceof DrawRobot) \t\t\t((DrawRobot) r).draw();\t}\tpublic static void main(String[] args) {\t\tRobot arr[] = {new DanceRobot(), new SingRobot(), new DrawRobot()};\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\taction(arr[i]);\t\t}\t}}Robot타입의 배열을 생성해서 서로 상속관계인 DrawRobot, SingRobot, DanceRobot을 배열에 넣어줬음. 다음에 배열의 i값이 특정 클래스와 상속관계라면 특정클래스의 메소드를 실행하도록 코드를 짰음.  답지package _2javajungsuktestEx7;class Robot{}class DanceRobot extends Robot{\tvoid dance() {\t\tSystem.out.println(\"춤을 춥니다.\");\t}}class SingRobot extends Robot{\tvoid sing() {\t\tSystem.out.println(\"노래를 합니다.\");\t\t}}class DrawRobot extends Robot{\tvoid draw() {\t\tSystem.out.println(\"그림을 그립니다.\");\t}}public class ex7_18 {\tstatic void action(Robot r) {\t\tif(r instanceof DanceRobot) {\t\t\tDanceRobot dr = (DanceRobot)r;\t\t\tdr.dance();\t\t}else if(r instanceof SingRobot) {\t\t\tSingRobot SR = (SingRobot)r;\t\t\tSR.sing();\t\t}else if(r instanceof DrawRobot) {\t\t\tDrawRobot Draw = (DrawRobot)r;\t\t\tDraw.draw();\t\t}\t}\t\tpublic static void main(String[] args) {\t\tRobot arr[] = {new DanceRobot(), new SingRobot(), new DrawRobot()};\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\taction(arr[i]);\t\t}\t}}if문에서 객체를 생성해서 메소드를 실행함.[7-19] Buyer 클래스의 제품구입 기능, 장바구니 추가기능, 구입물건 목록 조회기능, 남은 금액 출력 기능 구현package _2javajungsuktestEx7;class Buyer{\tint money =1000;\tProduct cart[] = new Product[3];\tint i=0;\t\tvoid buy(Product p) {\t\tif(money &lt; p.price) {\t\t\tSystem.out.println(p+\"를 구매할 돈이 부족합니다.\");\t\t\treturn;\t\t}else {\t\t\tmoney-=p.price;\t\t\tadd(p);\t\t}\t}\tvoid add(Product p) {\t\tif(i&gt;=cart.length) {\t\t\tProduct[] cart2 = new Product[cart.length*2];\t\t\tSystem.arraycopy(cart, 0, cart2, 0, cart.length);\t\t\tcart = cart2;\t\t}\t\tcart[i++] = p;\t}\tvoid summary() {\t\tint sum = 0;\t\tfor(int i=0;i&lt;cart.length;i++) {\t\t\tSystem.out.print(cart[i]+\", \");\t\t\tsum += cart[i].price;\t\t}\t\tSystem.out.println();\t\tSystem.out.println(\"쓴 돈 : \" + sum);\t\tSystem.out.println(\"남은 돈 : \"+  money);\t}}class Product{\tint price;\t\tProduct(int price){\t\tthis.price=price;\t}}class Tv2 extends Product{\tTv2(){super(100);}\tpublic String toString () {return \"Tv\";}}class Computer extends Product{\tComputer(){super(200);}\tpublic String toString () {return \"Computer\";}}class Audio extends Product{\tAudio(){super(50);}\tpublic String toString () {return \"Audio\";}}public class ex7_19 {\tpublic static void main(String[] args) {\t\tBuyer b = new Buyer();\t\tb.buy(new Tv2());\t\tb.buy(new Computer());\t\tb.buy(new Tv2());\t\tb.buy(new Audio());\t\tb.buy(new Computer());\t\tb.buy(new Computer());\t\tb.buy(new Computer());\t\t\t\tb.summary();\t\t\t}}일단 책에 적혀진 가이드대로 따라 만들어보았는데 가이드없이도 만들 줄 알아야할 것같다..컬렉션프레임워크의 List를 이용package Ex7;public class Product{  public int price;  public Product(int price){    this.price = price;  }}package Ex7;public class Tv extends Product{  public Tv(){    super(100);  }  public String toString(){    return \"Tv\";  }}package Ex7;public class Computer extends Product{  public Computer(){    super(200);  }  public String toString(){    return \"Computer\";  }}package Ex7;public class Audio extends Product{  public Audio(){    super(50);  }  public String toString(){    return \"Audio\";  }}package Ex7;import java.util.ArrayList;import java.util.List;public class Buyer {  int money = 1000;  List&lt;Product&gt; cart = new ArrayList&lt;Product&gt;();  void buy(Product p){    if(money&lt;p.price){      System.out.println(\"돈이 부족해서\"+p+\"을(를) 구매할 수 없습니다.\");      return;    }    money -= p.price;    add(p);    System.out.println(p+\"을(를) 구매했습니다.\");  }  void add(Product p){    cart.add(p);  }  void summary(){    System.out.print(\"구입한 물건 : \");    int sum=0;    for(Product p : cart){      System.out.print(p+\", \");      sum+=p.price;    }    System.out.println();    System.out.println(\"사용한 금액 : \"+sum);    System.out.println(\"남은 금액 : \"+money);  }  }package Ex7;public class ProductMain {  public static void main(String[] args) {    Buyer b = new Buyer();    b.buy(new Tv());    b.buy(new Computer());    b.buy(new Tv());    b.buy(new Audio());    b.buy(new Computer());    b.buy(new Computer());    b.buy(new Computer());        b.summary();  }}훨신 더 간단해졌다[7-20] 아래 코드의 실행결과는?class Parent{\tint x=100;\tvoid method() {\t\tSystem.out.println(\"Parent Method\");\t}}class Child extends Parent{\tint x=200;\tvoid method() {\t\tSystem.out.println(\"Child Method\");\t}}public class ex7_20 {\tpublic static void main(String[] args) {\t\tParent p = new Parent();\t\tChild c = new Child();\t\t\t\tSystem.out.println(\"p.x : \"+p.x);\t\tp.method();\t\tSystem.out.println(\"c.x : \"+c.x);\t\tc.method();\t}}순서대로p.x : 100Parent Methodc.x : 200Child Method가 출력됨.[7-21] attack메소드의 매개변수로 가능한 것 두가지는?interface Moveable{\tvoid move(int x, int y);}void attack(Moveable f){\t//내용 생략}null과 Moveable 인터페이스를 구현한 클래스나 그 자손의 인스턴스[7-22] Shape클래스를 조상으로 하는 Circle클래스와 Rectangle클래스를 작성하시오. 생성자도 각 클래스에 맞게 적절히 추가하시오package _3javajungsuktestEx7_3;abstract class Shape{\tPoint p;\t\tShape(){\t\tthis(new Point(0,0));\t}\tShape(Point p){\t\tthis.p=p;\t}\t\tabstract double calcArea(); //도형 면적 계산 후 반환\t\tPoint getPosition() {\t\treturn p;\t}\tvoid setPosition(Point p) {\t\tthis.p=p;\t}\t}class Point{\tint x, y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tpublic String toString() {\t\treturn \"[\" + x+\", \"+y+\"]\";\t}}class Circle extends Shape{\tdouble r; //반지름\t\tCircle(double r){\t\tthis(new Point(0,0),r);\t}\tCircle(Point p, double r){\t\tsuper(p); //조상의 멤버는 조상의 생성자가 초기화하도록 함\t\tthis.r=r;\t}\t\tdouble calcArea() {\t\treturn Math.PI*r*r;\t}}class Rectangle extends Shape{\tdouble width, height;\t\tRectangle(double width, double height){\t\tthis(new Point(0,0),width, height);\t}\tRectangle(Point p, double width, double height){\t\tsuper(p); //조상의 멤버는 조상의 생성자가 초기화하도록 함\t\tthis.height=height;\t\tthis.width=width;\t}\t\tdouble calcArea() {\t\treturn width *height;\t}\tboolean isSquare(){\t\tif(width == height) return true;\t\telse return false;\t}}public class ex7_22 {\t\tpublic static void main(String[] args) {\t}}[7-23] 면적을 구하는 sumArea 메소드를 작성하고 테스트package _3javajungsuktestEx7_3;abstract class Shape{\tPoint p;\t\tShape(){\t\tthis(new Point(0,0));\t}\tShape(Point p){\t\tthis.p=p;\t}\t\tabstract double calcArea(); //도형 면적 계산 후 반환\t\tPoint getPosition() {\t\treturn p;\t}\tvoid setPosition(Point p) {\t\tthis.p=p;\t}\t}class Point{\tint x, y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tpublic String toString() {\t\treturn \"[\" + x+\", \"+y+\"]\";\t}}class Circle extends Shape{\tdouble r; //반지름\t\tCircle(double r){\t\tthis(new Point(0,0),r);\t}\tCircle(Point p, double r){\t\tsuper(p);\t\tthis.r=r;\t}\t\tdouble calcArea() {\t\treturn Math.PI*r*r;\t}}class Rectangle extends Shape{\tdouble width, height;\t\tRectangle(double width, double height){\t\tthis(new Point(0,0),width, height);\t}\tRectangle(Point p, double width, double height){\t\tsuper(p);\t\tthis.height=height;\t\tthis.width=width;\t}\t\tdouble calcArea() {\t\treturn width *height;\t}\tboolean isSquare(){\t\tif(width == height) return true;\t\telse return false;\t}}public class ex7_22 {\tstatic double sumArea(Shape arr[]) {\t\tdouble sum=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tsum+=arr[i].calcArea();\t\t}\t\t\t\treturn sum;\t}\t\tpublic static void main(String[] args) {\t\tShape arr[] = {new Circle(5.0), new Rectangle(3,4), new Circle(1)};\t\tSystem.out.println(\"면적의 합 : \"+sumArea(arr));\t}}[7-24] 인터페이스의 장점이 아닌 것?  표준화를 가능하게 해줌  서로 관계없는 클래스들에게 관계를 맺어 줄 수 있음  독립적인 프로그래밍이 가능  다중상속을 가능하게 해줌  패키지간의 연결을 도와줌외에 개발시간 단축한다는 장점이 있음(동시에 여럿이서 개발 가능)"
  },
  
  {
    "title": "자바의 정석 연습문자 7장 - 상속 1",
    "url": "/posts/7%EC%9E%A5_%EC%83%81%EC%86%8D_1/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 상속",
    "date": "2022-10-07 00:00:00 +0900",
    





    
    "snippet": "[7-1] SutdaCard 배열을 초기화하는 문제. 숫자가 1,3,8인경우 isKwang이 true여야함.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int...",
    "content": "[7-1] SutdaCard 배열을 초기화하는 문제. 숫자가 1,3,8인경우 isKwang이 true여야함.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int i=0;i&lt;CARD_NUM;i++) {\t\t\tint num = i%10+1;\t\t\tboolean isKwang = i&lt;10&amp;&amp; (num==1 || num==3 || num==8);\t\t\t\t\t\tcards[i] = new SutdaCard(num, isKwang);\t\t}\t\t// for(int i=0;i&lt;10;i++){    //   isKwang = i==0 || i==2 || i==7;    //   cards[i] = new SutdaCard(i+1, isKwang);    //   cards[i+10] = new SutdaCard(i+1, false);    // } //이렇게해도됨\t\t//for(int i=0;i&lt;CARD_NUM;i++){    //   num = i+1;    //   isKwang = false;    //   if(i&gt;=10) num=i-9;    //   else if(i==0 || i==2 ||i==7) isKwang=true;    //   cards[i] = new SutdaCard(num, isKwang);    // } //이것도 됨\t}\t}class SutdaCard{\tint num;\tboolean isKwang;\t\tSutdaCard() {\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_1 {\tpublic static void main(String[] args) {\t\tSutdaDeck deck = new SutdaDeck();\t\t\t\tfor(int i=0;i&lt;deck.cards.length;i++) {\t\t\tSystem.out.print(deck.cards[i]+\" \");\t\t}\t}}[7-2] 클래스 SutdaDeck에 shuffle, pick메소드를 추가하는문제. pick은 매개변수가 있는것과 없는 것 둘다 만들 것.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int i=0;i&lt;CARD_NUM;i++) {\t\t\tint num = i%10+1;\t\t\tboolean isKwang = i&lt;10&amp;&amp; (num==1 || num==3 || num==8);\t\t\t\t\t\tcards[i] = new SutdaCard(num, isKwang);\t\t}\t}\t\tvoid shuffle() {\t\tSutdaCard tmp;\t\tfor(int i=0;i&lt;cards.length*2;i++) {\t\t\tint n = (int)(Math.random()*CARD_NUM);\t\t\tint n2 = (int)(Math.random()*CARD_NUM);\t\t\ttmp = cards[n];\t\t\tcards[n] = cards[n2];\t\t\tcards[n2]=tmp;\t\t}\t}\tSutdaCard pick(int index){\t\treturn cards[index];\t}\tSutdaCard pick() {\t\tint n = (int)(Math.random()*CARD_NUM);\t\treturn cards[n];\t}\t}class SutdaCard{\tint num;\tboolean isKwang;\t\tSutdaCard() {\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_1 {\tpublic static void main(String[] args) {\t\tSutdaDeck deck = new SutdaDeck();\t\t\t\tSystem.out.println(deck.pick(0));\t\tSystem.out.println(deck.pick());\t\tdeck.shuffle();\t\tfor(int i=0;i&lt;deck.cards.length;i++) {\t\t\tSystem.out.print(deck.cards[i]+\" \");\t\t}\t\tSystem.out.println();\t\tSystem.out.println(deck.pick(0));\t\t\t}}처음 shuffle메소드를 만들때void shuffle() {  \tSutdaCard tmp;  \tfor(int i=0;i&lt;cards.length;i++) {  \t\tint n = (int)(Math.random()*CARD_NUM);  \t\ttmp = cards[i];  \t\tcards[i] = cards[n];  \t\tcards[n]=tmp;  }  으로 만들었는데 cards.length가 배열을 충분히 섞기에 부족하다는 생각이 들어서 int n2을 추가로 만들어줬음.List로 변환public class SutdaCard {  int num;  boolean iskwang;  public SutdaCard(){    this(1,true);  }   public SutdaCard(int num, boolean isKwang){    this.num = num;    this.iskwang = isKwang;  }   String info(){    return num+(iskwang?\"K\":\"\");  }  @Override  public String toString(){    return num+(iskwang?\"K\":\"\");  }}import java.util.ArrayList;import java.util.List;public class SutdaDeck{  final int CARD_NUM = 20;  // SutdaCard[] cards = new SutdaCard[CARD_NUM];  List&lt;SutdaCard&gt; cards = new ArrayList&lt;SutdaCard&gt;();  public SutdaDeck(){    for(int i=0;i&lt;CARD_NUM;i++){      int num = i%10+1;      boolean isKwang = (i==1 || i==3 || i==8);      cards.add(new SutdaCard(num, isKwang));    }  }  SutdaCard pick(int index){    return cards.get(index);  }  SutdaCard pick(){    int r = (int)(Math.random()*CARD_NUM);        return cards.get(r);  }  void shuffle(){    List&lt;SutdaCard&gt; temp = new ArrayList&lt;SutdaCard&gt;();    while(cards.size()!=0){        int r = (int)(Math.random()*cards.size());        temp.add(cards.remove(r)); //temp에 저장 후 cards에서 삭제    }    cards = temp;  }}public class SutdaCardMain {  public static void main(String[] args) {    // SutdaCard card1 = new SutdaCard(3, false);    // SutdaCard card2 = new SutdaCard();    // System.out.println(card1.info());    // System.out.println(card2.info());    SutdaDeck deck = new SutdaDeck();        for(int i=0;i&lt;deck.cards.size();i++){      System.out.print(deck.cards.get(i)+\", \");    }    System.out.println();    System.out.println(deck.pick());    System.out.println(deck.pick(3));        deck.shuffle();    for(int i=0;i&lt;deck.cards.size();i++){      System.out.print(deck.cards.get(i)+\", \");    }  }}[7-3] 오버라이딩의 정의와 필요성 :조상클래스에게 상속받은 메소드를 수정할 수 있음. 자손클래스에서 그대로 사용할 수 없는 경우가 많아서 오버리이딩이 필요함.[7-4] 오버라이딩의 조건으로 옳지않은 것을 모두 고르시오  조상의 메소드와 이름이 같아야한다.  매개변수의 수와 타입이 모두 값아야한다.  리턴타입이 같아야한다.  접근 제어자는 조상의 메소드보다 좁은 범위로만 변경할 수 있다. - 조상 클래스의 메소드보다 좁은범위로 변경 불가  조상의 메소드보다 더 많은 예외를 선언할 수 있다. - 조상 클래스의 메소드보다 더 많은 예외 선언 불가오버로딩 : 이미 있는 이름의 메소드를 매개변수의 갯수나 타입을 다르게해서 새로 정의하는 것. 오버라이딩이랑은 관련 없음!!![7-5] 코드에서 오류가 나는 부분을 고치고 오류의 이유를 서술하시오package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}}class Tv extends Product{\tTv(){} //에러\tpublic String toStirng() {\t\treturn \"Tv\";\t}\t}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}class Tv extends Product{Tv(){}Tv(){}부분에서 오류가 난다 안에 super(매개변수); 를 넣어주면 해결된다.Product 클래스 안에 기본생성자가 없어서 발생하는 오류인데, Product클래스안에 기본생성자를 추가해주면 super()를 사용해주지않아도 된다.package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}\tProduct(){\t\tthis(100);\t}}class Tv extends Product{\tTv(){}\tpublic String toStirng() {\t\treturn \"Tv\";\t}}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}}class Tv extends Product{\tTv(){\t\tsuper(100);\t\t}\tpublic String toStirng() {\t\treturn \"Tv\";\t}\t}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}이런 식이다.[7-6] 자손 클래스의 생성자에서 조상 클래스의 생성자를 호출해야하는 이유는?조상 클래스에 정의된 인스턴스 변수들을 초기화해주어야함.직접 초기화해도 되지만 조상의 생성자를 호출하는 것이 더 효율적임.[7-7] 호출되는 생성자의 순서와 실행결과를 적으시오package _2javajungsuktestEx7;class Parent{\tint x=100;\t\tParent(){\t\tthis(200);\t}\tParent(int x){\t\tthis.x=x;\t}\tint getx() {\t\treturn x;\t}}class Child extends Parent{\tint x=3000;\tChild(){\t\tthis(1000);\t}\tChild(int x){\t\tthis.x=x;\t}}public class ex7_7 {\tpublic static void main(String[] args) {\t\tChild c = new Child();\t\t\t\tSystem.out.println(c.getx());\t}}main → child() → child(int x) → parent() → parent(int x) → Object()child(int x)와 Parent(int x)에는 생략되어있지만 super()이 존재함.x값은 200. child에 getx()가 없기때문에 Parent 클래스 내에서 구해야하는데 매개변수가 없으니 Parent()의 x값인 200이 나옴[7-8] 접근범위가 넚은 것에서 좁은 순으로 나열하시오public → protected → (default) → private[7-9] 다음 중 제어자 final을 붙일 수 있는 대상과 붙였을 때 그 의미를 적은 것 중 옳지 않은 것은?  지역변수 - 값 변경 불가능  클래스 - 상속을 통해 클래스에 새로운 멤버를 추가할 수 없음  메소드 - 오버로딩을 할 수 없음 - 오버라이딩을 할 수 없음  멤버변수 - 값 변경 불가[7-10] isPowerOn, channel, volume을 클래스 외부에서 접근 못하도록 제어자를 붙이고 이 멤버변수들의 값을 어디서나 읽고 변경할 수 있는 getter와 setter메소드를 추가하라package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}void setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t\t\tt.setVolume(20);\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t}}❗매개변수가 있는 메소드는 반드시 유효성검사를 해줘야함!![7-11] 이전채널로 이동하는 메소드를 추가package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\tprivate int prev;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tprev = this.channel;\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}\tvoid setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\tvoid gotoPrevChannel(){\t\tint tmp;\t\ttmp = channel;\t\tchannel = prev;\t\tprev = tmp;\t}\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t//\t\tt.setVolume(20);//\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t\t\t\tt.setChannel(20);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t}}int prev를 만들어준 뒤 getChannel에서 channel을 바꾸기 전에 prev에 저장해준 후gotoPrevChannel에서 channel과 prev의 값을 바꿔주게 만들었다.  답지package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\tprivate int prev;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tprev = this.channel;\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}\tvoid setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\tvoid gotoPrevChannel(){\t\tsetChannel(prev);\t}\t\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t//\t\tt.setVolume(20);//\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t\t\t\tt.setChannel(20);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t}}왜 있는 메소드를 활용할 생각을 못했을까ㅜ[7-12] 다음 중 접근제어자에 대한 설명으로 옳지 않은 것을 모두 고르시오  public은 접근 제한이 전혀 없는 접근 제어자이다  (default)가 붙으면, 같은 패키지 내에서만 접근 가능함  지역변수에도 접근 제어자를 사용할 수 있음  protected가 붙으면, 같은 패키지 내에서 접근 가능  protected가 붙으면, 다른 패키지의 자손 클래스에서 접근 가능[7-13] Math클래스의 생성자의 접근 제어자가 private인 이유?Math클래스의 모든 메소드가 static메소드이고 인스턴스 변수가 존재하지 않기 떄문에 객체를 생성할 필요가 없음.[7-14] 섯다 카드의 숫자와 종류를 변경할 수 없도록 코드를 수정하는 문제package _2javajungsuktestEx7;class SutdaCard{\t//인스턴스 변수라서 생성자에서 초기화해줘도 됨\tfinal int num;\tfinal boolean isKwang;\t\tSutdaCard(){\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_14 {\tpublic static void main(String[] args) {\t\tSutdaCard card = new SutdaCard();\t\tSystem.out.println(card.toString());\t}}[7-15] 형변환이 올바르지 않은 것은?class Unit() {}class AirUnit() extends Unit{}class GroundUnit() extends Unit{}class Tank extends GroundUnit{}class AirCraft extends AirUnit() {}Unit u = new GroundUnit();Tank t = new Tank();AirCraft ac = new AirCraft();  u = (Unit)ac;  u = ac;  GrountUnit gu = (GroundUnit)u;  u가 생성될때 GroundUnit을 참고하도록 설정해놨음 가능  AirUnit au = ac;  t = (Tank)u; 조상타입 인스턴스 → 자손타입 불가능  GroundUnit gu = t;[7-16] 다음 중 연산결과가 true가 아닌 것을 모두 골라라class Car{}class FireEngine extends Car implements Movable{}class Ambulance extends Car{}FireEngine fe = new FIreEngine();  fe instanceof FireEngine  fe instanceof Movable  fe instanceof Obeject  fe instanceof Car  fe instanceof Ambulanceinstanceof : 조상이나 구현한 인터페이스관계일경우 true를 반환함."
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 3",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_3/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-06 00:00:00 +0900",
    





    
    "snippet": "[6-20] 메소드 shuffle을 정의해 배열을 섞기package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_20 {\tstatic int[] shuffle(int arr[]) {\t\tif(arr==null || arr.length==0) return arr;\t\tint tmp=0;\t\tf...",
    "content": "[6-20] 메소드 shuffle을 정의해 배열을 섞기package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_20 {\tstatic int[] shuffle(int arr[]) {\t\tif(arr==null || arr.length==0) return arr;\t\tint tmp=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tint x = (int)(Math.random()*arr.length);\t\t\ttmp=arr[i];\t\t\tarr[i] = arr[x];\t\t\tarr[x] = tmp;\t\t}\t\treturn arr;\t}\t\tpublic static void main(String[] args) {\t\tint original[]= {1,2,3,4,5,6,7,8,9};\t\tSystem.out.println(Arrays.toString(original));\t\t\t\tint result[] = shuffle(original);\t\tSystem.out.println(Arrays.toString(result));\t}}배열을 몇번 섞을지 애매해서 일단 배열값만큼 섞어주었다. 더 크게 지정하면 또 Math.random으로 새 변수를 지정해줘야하기도해서..[6-21] MyTv클래스 완성하기package _2javajungsuktestEx6;class MyTv{\tboolean isPowerOn;\tint channel;\tint volume;\t\tfinal int MAX_VOLUME = 100;\tfinal int MIN_VOLUME = 0;\tfinal int MAX_CHANNEL = 100;\tfinal int MIN_CHANNEL = 1;\t\tvoid turnOnOff() {\t\tisPowerOn = !isPowerOn;\t}\tvoid volumeUp() {\t\tif(volume &lt; MAX_VOLUME) \t\tvolume++;\t}\tvoid volumeDown() {\t\tif(volume &gt; MIN_VOLUME) \t\tvolume--;\t}\tvoid channelUp() {\t\tif(channel == MAX_CHANNEL) \t\t\tchannel = MIN_CHANNEL;\t\telse channel++;\t}\tvoid channelDown() {\t\tif(channel == MIN_CHANNEL) { \t\t\tchannel = MAX_CHANNEL;\t\t} else {\t\t\tchannel--;\t\t}\t}}public class ex6_21 {\tpublic static void main(String[] args) {\t\tMyTv t = new MyTv();\t\t\t\tt.channel=100;\t\tt.volume=0;\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t\t\t\tt.channelDown();\t\tt.volumeDown();\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t\t\t\tt.volume=100;\t\tt.channelUp();\t\tt.volumeUp();\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t}}[6-22] 문자열 str이 숫자로만 이루어졌는지 확인하는 메소드를 작성하는 문제package _2javajungsuktestEx6;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex6_22 {\t\tstatic boolean isNumber(String str) {\t\tif(str.equals(\"\") || str == null) return false;\t\tfor(int i=0;i&lt;str.length();i++) {\t\t\tchar ch = str.charAt(i);\t\t\tif(!(ch&gt;='0' &amp;&amp; ch&lt;= '9')) return false;\t\t}\t\treturn true;\t}\tpublic static void main(String[] args) throws IOException {//\t\tString str = \"123\";//\t\tSystem.out.println(str +\"는 숫자입니까?\" + isNumber(str));////\t\tString str2 = \"123o\";//\t\tSystem.out.println(str2 +\"는 숫자입니까?\" + isNumber(str2));\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString str = br.readLine();\t\tSystem.out.println(str +\"는 숫자입니까?\" + isNumber(str));\t\t\t}}[6-23] 배열에서 가장 큰 값을 구하는 메소드를 작성package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_23 {\t\tstatic int max(int arr[]) {\t\tif(arr == null || arr.length==0) return -999999;\t\t\t\tint max=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tif(arr[i]&gt;=max) {\t\t\t\tmax=arr[i];\t\t\t}\t\t}\t\treturn max;\t}\tpublic static void main(String[] args) {\t\tint data[] = {3,2,9,4,7};\t\t\t\tSystem.out.println(Arrays.toString(data));\t\tSystem.out.println(\"최대값 : \"+max(data));\t\tSystem.out.println(\"최대값 : \"+max(null));\t\tSystem.out.println(\"최대값 : \"+max(new int[] {})); //크기가 0인 배열\t}}[6-24] 절대값을 구하는 메소드를 정의package _2javajungsuktestEx6;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex6_24 {\t\tstatic int abs(int value) {\t\treturn Math.abs(value);\t}\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\twhile(true) {\t\t\tSystem.out.println(\"절대값을 구할 수를 입력하세요. 종료하려면 0를 입력하세요. \");\t\t\tint value = Integer.parseInt(br.readLine());\t\t\tif(value == 0) {\t\t\t\tSystem.out.println(\"프로그램을 종료합니다.\");\t\t\t\tbreak;\t\t\t}\t\tSystem.out.println(value +\"의 절대값 : \"+abs(value));\t\t\t\t}\t}}간단하게 계속 반복하도록 만들어봤음 0을 입력하면 종료되게했음"
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 2",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_2/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-06 00:00:00 +0900",
    





    
    "snippet": "[6-8] 다음 코드에 정의된 변수들을 종류별로 구분해서 적기class PlayingCard{\tint kind;\tint num;\tstatic int width;\tstatic int height;\tPlayingCard(int k, int n){\t\tkind = k;\t\tnum = n;\t}\tpublic static void main(String[] args)...",
    "content": "[6-8] 다음 코드에 정의된 변수들을 종류별로 구분해서 적기class PlayingCard{\tint kind;\tint num;\tstatic int width;\tstatic int height;\tPlayingCard(int k, int n){\t\tkind = k;\t\tnum = n;\t}\tpublic static void main(String[] args){\t\tPlayingCard card= new PlayingCard(1,1);}  클래스변수 (static변수) : width, height  인스턴스변수 : kind, num  지역변수: k, n, card[6-9] static이 붙어야하는 것과 그 이유는?(모든 병사의 공격력과 방어력은 같아야함)class Marine{\tint x=0, y=0; //위치\tint hp = 60; //체력\tint weapon = 6; //공격력\tint armor = 0; //방어력\tvoid weaponUp(){\t\tweapon++;\t}\tvoid armorUp(){\t\tweapon++;\t}\tvoid move(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}}weapon과 armor. 메소드 weaponUP()과 armorUp()도 static이 붙어야함인스턴스 변수는 객체 생성해서 값을 수정하면 원본 값은 변하지 않음. 모든 병사의 공격력이 같아야하는데 공격력과 방어력이 인스턴스변수라면 각 병사마다 다른 공격력과 방어력을 가지는 일이 발생할 수도 있음.그래서 모든 병사의 공격력과 방어력을 관리하기위해서는 static변수로 관리해줘야함.체력은 각 병사마다 공격받은정도가 다르니까, 위치는 당연히 병사별로 달라야함. → 인스턴스변수 사용[6-10] 다음 중 생성자에 대한 설명으로 옳지 않은 것을 모두 고르시오  모든 생성자의 이름은 클래스의 이름과 동일해야한다  생성자는 객체를 생성하기 위한 것이다 - 객체 초기화 목적임. 객체를 생성하는 건 new 연산자임  클래스에는 생성자가 반드시 하나 이상 있어야 한다  생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다  생성자는 오버로딩 할 수 없다 - 가능함.[6-11] 다음 중this에 대한 설명으로 맞지 않은 것을 모두 고르시오  객체 자신을 가리키는 참조변수이다  클래스 내에서라면 어디서든 사용할 수 있다 - static이 붙은 변수나 메소드(클래스 멤버)에서는 사용 불가  지역변수와 인스턴스변수를 구별할 때 사용한다  클래스 메서드 내에서는 사용할 수 없다[6-12] 다음 중 오버로딩이 성립하기 위한 조건이 아닌 것을 모두 고르시오  메서드의 이름이 같아야 한다  매개변수의 개수나 타입이 달라야 한다  리턴타입이 달라야 한다 - 상관 없음  매개변수의 이름이 달라야 한다 - 상관없음[6-13] add 메소드를 올바르게 오버로딩한것은?                               long add(int a, int b) {return a+b;}        long add(int x, int y} {return x+y}  long add(long a, long b) {return a+b;} - 이름 같고, 매개변수의 타입이 달라 가능  int add(byte a, byte b) {return a+b;} - 이름 같고, 매개변수의 타입이 달라 가능  int add(long a, int b) {return (int)a+b;} - 이름 같고, 매개변수의 타입이 달라 가능[6-14] 다음 중 초기화에 대한 설명으로 옳지 않은 것을 모두 고르시오  멤버 변수는 자동 초기화되므로 초기화하지 않고도 값을 참조할 수 있다  지역변수는 사용하기 전에 반드시 초기화해야 한다  초기화 블럭보다 생성자가 먼저 수행된다 - 초기화 블럭이 먼저 수행됨  명시적 초기화를 제일 우선적으로 고려해야 한다  클래스변수보다 인스턴스변수가 먼저 초기화된다 - 클래스 변수가 먼저 초기화됨클래스 변수는 클래스가 처음 메모리에 로딩될 때, 자동 초기화 됨. → 인스턴스변수보다 먼저 초기화 됨. 그리고 초기화 블럭이 수행된 다음 생성자가 수행됨.==[6-15] 다음중 인스턴스변수의 초기화 순서가 올바른 것은?  기본값 - 명시적초기화 - 초기화블럭 - 생성자  기본값 - 명시적초기화 - 생성자 - 초기화블럭  기본값 - 초기화블럭 - 명시적초기화 - 생성자  기본값 - 초기화블럭 - 생성자 - 명시적초기화클래스 변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화가 이루어진다.클래스 변수의 초기화 순서 : 기본값 → 명시적 초기화 → 클래스 초기화 블럭인스턴스 변수의 초기화 순서 : 시본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자[6-16] 다음 중 지역변수에 대한 설명으로 옳지 않은 것을 모두 고르시오  자동 초기화되므로 별도의 초기화가 필요없다 - 자동초기화 안됨. 초기화 필수  지역변수가 선언된 메서드가 종료되면 지역변수도 함께 소멸된다  매서드의 매개변수로 선언된 변수도 지역변수이다  클래스변수나 인스턴스변수보다 메모리 부담이 적다  힙(heap) 영역에 생성되며 가비지 컬렉터에 의해 소멸된다 - 힙(heap)은 인스턴스가 생성되는 영역. 지역변수는 호출스택(call stack)에서 생성됨.[6-17] 호출스택이 다음과 같은 상황일 때 옳지 않은 설명을 모두 고르시오                                              println              method1              method2              main        제일 먼저 호출스택에 저장된 것은 main 메서드이다  println메서드를 제외한 나머지 메서드들은 모두 종료된 상태이다 - 종료된건 아니고 대기중인 상태  method2메서드를 호출한 것은 main메서드이다  println메서드가 종료되면 method1메서드가 수행을 재개한다  main-method2-method1-println의 순서로 호출되었다  현재 실행중인 메소드는 println뿐이다.[6-18] 컴파일 에러가 발생하는 라인과 이유를 설명class MemberCall{\tint iv=10;\tstatic int cv = 20;\t\tint iv2=cv;\tstatic int cv2= iv;    //라인 A\tstatic void staticMethod1(){\t\tSystem.out.println(cv);\t\tSystem.out.println(iv); //라인 b\t}\tvoid instanceMethod1(){\t\tSystem.out.println(cv);\t\tSystem.out.println(iv); //라인 c\t}\tstatic void staticMethod2(){\t\tstaticMethod1():\t\tinstanceMethod1(); //라인 d\t}\tvoid instanceMethod2(){\t\tstaticMethod1(); //라인 e\t\tinstanceMethod1();\t}}라인 a,b,d 오류.static변수 초기화시에 instance변수를 사용할 수 없으며, static메소드 안에서는 instance변수를 사용할 수 없음.instance메소드 안에서는 static변수를 사용 가능함.[6-19] 실행결과 예상하기class ex{\tpublic static void change(String str){\t\tstr+=\"456\";\t}\tpublic static void main(String[] args){\t\tString str = \"ABC123\";\t\tchange(str);\t\tSystem.out.println(\"After change : \"+str);\t}}결과 : ABC123오른쪽 그림 참고. 참조형 매개변수라서 x값도 같이 변경될 것 같지만 String객체는 수정이 불가능함.그래서 change에서 str+=”456”을 하려면 새로운 String객체를 하나 더 생성해야 함. 생성된 change()의 str객체는 change()가 종료될 때 함께 종료됨. 최종적으로 남은 str은 main메소드의 ABC123뿐이라서 출력은 ABC123이됨. change메소드에서 생성된 String객체 “ABC123456”은 나중에 가비지컬렉터가 제거해줌"
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 1",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_1/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-05 00:00:00 +0900",
    





    
    "snippet": "[6-1~6-2] SutdaCard클래스를 정의하고 두개의 생성자와 info()를 추가package _2javajungsuktestEx6;class SutdaCard{\tint num=3 ;\tboolean isKwang=true;\t\tSutdaCard(){\t\tthis(1,true);\t}\t\tSutdaCard(int num, boolean isKwang){\t...",
    "content": "[6-1~6-2] SutdaCard클래스를 정의하고 두개의 생성자와 info()를 추가package _2javajungsuktestEx6;class SutdaCard{\tint num=3 ;\tboolean isKwang=true;\t\tSutdaCard(){\t\tthis(1,true);\t}\t\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tString info() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex6_1 {\t\tpublic static void main(String[] args) {\t\tSutdaCard card1 = new SutdaCard(3,false);\t\tSutdaCard card2 = new SutdaCard();\t\t\t\tSystem.out.println(card1.info());\t\tSystem.out.println(card2.info());\t}}[6-3~6-4] Student클래스를 정의해서 안에 메소드 getTotal()과 getAverage()를 추가해서 총점과 평균을 구하는 문제package _2javajungsuktestEx6;class Student{\tString name;\tint ban;\tint no;\tint kor;\tint eng;\tint math;\t\tint getTotal(){\t\treturn kor+eng+math;\t}\tfloat getAverage() {\t\treturn Math.round(getTotal()*10/ 3f)/10f;\t}}public class ex6_3 {\tpublic static void main(String[] args) {\t\tStudent s = new Student();\t\ts.name = \"홍길동\";\t\ts.ban=1;\t\ts.no=1;\t\ts.kor=100;\t\ts.eng=60;\t\ts.math=76;\t\t\t\tSystem.out.println(\"이름 : \"+s.name);\t\tSystem.out.println(\"총점 : \"+s.getTotal());\t\tSystem.out.println(\"평균 : \"+s.getAverage());\t}}[6-5] 6-3~6-4에 생성자와 info추가package _2javajungsuktestEx6;class Student{\tString name;\tint ban;\tint no;\tint kor;\tint eng;\tint math;\t\tint getTotal(){\t\treturn kor+eng+math;\t}\tfloat getAverage() {\t\treturn Math.round(getTotal()*10/ 3f)/10f;\t}\tStudent(){\t\t\t}\tStudent(String name, int ban, int no, int kor, int eng, int math){\t\tthis.name=name;\t\tthis.ban=ban;\t\tthis.no=no;\t\tthis.kor = kor;\t\tthis.eng=eng;\t\tthis.math=math;\t}\tvoid info(){\t\tSystem.out.println(name+\", \"+ban+\", \"+no+\", \"+kor+\", \"+eng+\", \"+math);\t}}public class ex6_3 {\tpublic static void main(String[] args) {\t\tStudent s = new Student();\t\ts.name = \"홍길동\";\t\ts.ban=1;\t\ts.no=1;\t\ts.kor=100;\t\ts.eng=60;\t\ts.math=76;\t\t\t\tSystem.out.println(\"이름 : \"+s.name);\t\tSystem.out.println(\"총점 : \"+s.getTotal());\t\tSystem.out.println(\"평균 : \"+s.getAverage());\t\tSystem.out.println();\t\tStudent s2 = new Student(\"김길동\",1,1,95,80,63);\t\ts2.info();\t\tSystem.out.println(\"이름 : \"+s2.name);\t\tSystem.out.println(\"총점 : \"+s2.getTotal());\t\tSystem.out.println(\"평균 : \"+s2.getAverage());\t\t\t}}[6-6] 메소드 getDisrance()로 두 점 사이 거리 계산package _2javajungsuktestEx6;public class ex6_6 {\tstatic double getDistance(int x, int y, int x1, int y1) {\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}\t\tpublic static void main(String[] args) {\t\tSystem.out.println(getDistance(1,1,2,2));\t}}[6-7] MyPoint 클래스에 getDistance()를 인스턴스 메소드로 정의package _2javajungsuktestEx6;class MyPoint{\tint x;\tint y;\t\tMyPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tdouble getDistance(int x1, int y1){\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}}public class ex6_6 {\tstatic double getDistance(int x, int y, int x1, int y1) {\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}\t\tpublic static void main(String[] args) {\t\tSystem.out.println(getDistance(1,1,2,2));\t\t\t\tMyPoint p = new MyPoint(1,1);\t\tSystem.out.println(p.getDistance(2, 2));\t}}"
  },
  
  {
    "title": "자바의 정석 연습문제 5장 - 배열",
    "url": "/posts/5%EC%9E%A5_%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 배열",
    "date": "2022-10-03 00:00:00 +0900",
    





    
    "snippet": "[5-1] 잘못된것을 고르시오a. int[] arr[];b. int[] arr = {1,2,3,};c. int[] arr = new int[5];d. int[] arr = new int[5]{1,2,3,4,5}; - new int[5]나 {1,2,3,4,5} 둘중 하나를 지워야 함.e. int arr[5]; 선언하면서 크기지정 불가f. int[] ar...",
    "content": "[5-1] 잘못된것을 고르시오a. int[] arr[];b. int[] arr = {1,2,3,};c. int[] arr = new int[5];d. int[] arr = new int[5]{1,2,3,4,5}; - new int[5]나 {1,2,3,4,5} 둘중 하나를 지워야 함.e. int arr[5]; 선언하면서 크기지정 불가f. int[] arr[] = new int[3][];[5-2] arr[3].length의 값은?int [][] arr = {\t\t\t\t\t\t{5,5,5,5,5},\t\t\t\t\t\t{10,10,10},\t\t\t\t\t\t{20,20,20,20},\t\t\t\t\t\t{30,30}};arr[3]은 {30,30}를 뜻함. arr[3]은 값이 2개니까 length는 2.순서대로 5,3,4,2순임[5-3] 배열 arr에 담긴 모든 값의 합을 구하는 문제package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class ex5_3 {\tpublic static void main(String[] args) throws IOException {//\t\tint arr[] = {10,20,30,40,50};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint n= Integer.parseInt(br.readLine());\t\tint arr[] = new int[n];\t\tfor(int i=0;i&lt;n;i++) {\t\t\tarr[i]=Integer.parseInt(br.readLine());\t\t}\t\tint sum = 0;\t\t\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tsum+=arr[i];\t\t}\t\t\t\tSystem.out.println(\"sum = \"+sum);\t}}int arr[]을 입력값 n을 받아 크기를 결정하고, arr[]의 크기만큼 값을 입력받아 배열 arr[]을 만드는 방식으로 수정해서 풀어보았음[5-4] 2차원 배열 arr의 모든 값의 합과 평균package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_4 {\tpublic static void main(String[] args) throws IOException {//\t\tint arr[][] = {//\t\t\t\t{5,5,5,5,5},//\t\t\t\t{10,10,10,10,10},//\t\t\t\t{20,20,20,20,20},//\t\t\t\t{30,30,30,30,30}//\t\t\t\t};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint n= Integer.parseInt(br.readLine());\t\tint n2 = Integer.parseInt(br.readLine());\t\tint arr[][] = new int[n][n2];\t\tfor(int i=0;i&lt;n;i++) {\t\t\tfor(int j=0;j&lt;n2;j++) {\t\t\t\tarr[i][j]+=Integer.parseInt(br.readLine());\t\t\t}\t\t}\t\tint total = 0;\t\tfloat average=0;\t\t\t\tint count=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tfor(int j=0;j&lt;arr[i].length;j++) {\t\t\t\ttotal += arr[i][j];\t\t\t\tcount++;\t\t\t\t}\t\t\taverage = (float)total / count;\t\t}\t\tSystem.out.println(\"total = \"+total);\t\tSystem.out.println(\"average = \"+average);\t}}average를 구할때 나눌 수를 구하기가 애매해서 count를 새로 지정해줬음답지보니까 arr.length * arr[0].length를 해줬구나.. arr[i]를 넣었다가 그럼 for문 안에 넣어야해서 count를 만든건데 0을하면 되는구나!이후에 BufferedReader를 사용해서 arr값도 새로 입력값을 받아서 계산도 해봤음[5-5] 중복되지 않는 3가지 숫자 뽑아내는 문제package _2javajungsuktestEx5;import java.util.Arrays;public class ex5_5 {\tpublic static void main(String[] args) {\t\tint ballArr[] = {1,2,3,4,5,6,7,8,9};\t\tint ball3[] = new int[3];\t\t\t\tfor(int x=0;x&lt;20;x++) {\t\t\tint i=(int)(Math.random()*ballArr.length);\t\t\tint j=(int)(Math.random()*ballArr.length);\t\t\tint tmp=0;\t\t\t\t\t\ttmp=ballArr[i];\t\t\tballArr[i]=ballArr[j];\t\t\tballArr[j]=tmp;\t\t}\t\t\t\tSystem.arraycopy(ballArr,0,ball3,0,3);\t\tfor(int i=0;i&lt;ball3.length;i++) {\t\t\tSystem.out.print(ball3[i]);\t\t}\t}}[5-6] 필요한 동전 수를 구하는 문제package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_6 {\tpublic static void main(String[] args) throws IOException {\t\tint coinUnit[]= {500,100,50,10};//\t\tint money=2680;\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint money = Integer.parseInt(br.readLine());\t\tSystem.out.println(\"money = \"+money);\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint count = money/coinUnit[i];\t\t\tmoney %= coinUnit[i];\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+count);\t\t\t\t\t}\t}}/와 %를 이용하여 구했음[5-7] 필요한 동전의 수와 남은 동전의 수를 구하는 문제. 돈이 부족하다면 부족하다고 출력됨package _2javajungsuktestEx5;public class ex5_7 {\tpublic static void main(String[] args) {\t\tif(args.length!=1) {\t\t\tSystem.out.println(\"USAGE : java Exercise5_7 3120\");\t\t\tSystem.exit(0);\t\t}\t\tint money = Integer.parseInt(args[0]);\t\tSystem.out.println(\"money = \"+money);\t\t\t\tint coinUnit[] = {500,100,50,10};\t\tint coin[] = {5,5,5,5};\t\t\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint coinNum = 0;\t\t\tcoinNum = money/coinUnit[i];\t\t\tmoney %= coinUnit[i];\t\t\tif(coinNum&gt;coin[i]) {\t\t\t\tmoney+= (coinNum-coin[i])*coinUnit[i];\t\t\t\tcoinNum = coin[i];\t\t\t}\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coinNum);\t\t\tcoin[i]-=coinNum;\t\t}\t\tif(money&gt;0) {\t\t\tSystem.out.println(\"거스름돈이 부족합니다.\");\t\t\tSystem.exit(0);\t\t}\t\tSystem.out.println(\"=====남은 동전 개수=====\");\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coin[i]);\t\t}\t}}5-6과 비슷하게 했는데 만약 필요한 코인수가 소유 코인수보다 많다면 if문을 사용해서 money를 부족한 코인수만큼 채워주고 coinNum을 coin[i]로 맞춰주었음  답지package _2javajungsuktestEx5;public class ex5_7 {\tpublic static void main(String[] args) {\t\tif(args.length!=1) {\t\t\tSystem.out.println(\"USAGE : java Exercise5_7 3120\");\t\t\tSystem.exit(0);\t\t}\t\tint money = Integer.parseInt(args[0]);\t\tSystem.out.println(\"money = \"+money);\t\t\t\tint coinUnit[] = {500,100,50,10};\t\tint coin[] = {5,5,5,5};\t\t\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint coinNum =0;\t\t\tcoinNum = money/coinUnit[i];\t\t\tif(coin[i]&gt;=coinNum) {\t\t\t\tcoin[i]-=coinNum;\t\t\t}else {\t\t\t\tcoinNum = coin[i];\t\t\t\tcoin[i]=0;\t\t\t}\t\t\tmoney -= coinNum*coinNum;\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coinNum);\t\t}\t\tif(money&gt;0) {\t\t\tSystem.out.println(\"거스름돈이 부족합니다.\");\t\t\tSystem.exit(0);\t\t}\t\tSystem.out.println(\"=====남은 동전 개수=====\");\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coin[i]);\t\t}\t}}난 money를 먼저 구한 후에 돈이 부족하면 모자란 돈만큼 money를 수정해주고 coinNum을 보유동전수만큼 맞춰주었는데 답지의 코드는 coinNum을 먼저 맞춰주고 money를 구해줬구나이게 더 효율적이기는 한듯[5-8] 배열 answer에서 각 숫자의 개수를 세어 개수만큼 * 을 출력package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_8 {\tpublic static void main(String[] args) throws IOException {//\t\tint answer[] = {1,4,4,3,1,4,4,2,1,3,2};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint answer[] = new int[11];\t\tString str[] = br.readLine().split(\" \");\t\tfor(int i=0;i&lt;str.length;i++) {\t\t\tanswer[i] = Integer.parseInt(str[i]);\t\t}\t\tint counter[] = new int[4];\t\t\t\tfor(int i=0;i&lt;answer.length;i++) {\t\t\tint arr[] = {1,2,3,4};\t\t\tfor(int j=0;j&lt;arr.length;j++) {\t\t\t\tif(answer[i]==arr[j])\t\t\t\t\tcounter[arr[j]-1]+=1;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;counter.length;i++) {\t\t\tSystem.out.print(counter[i]);\t\t\tfor(int j=0;j&lt;counter[i];j++) {\t\t\t\tSystem.out.print(\"*\");\t\t\t}\t\t\t\t\t\tSystem.out.println();\t\t}\t}}생각해보니까 BufferedReader로 String형 배열을 입력받는 법은 알고 String을 int로 변환하는 법도 아는데 int형 배열을 입력받는법을 몰라서 한번 써봤음String형 배열을 먼저 받은 다음에 for문을 써서 int형 배열에 넣는 방법밖에 없는거같다.  답지package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_8 {\tpublic static void main(String[] args) throws IOException {//\t\tint answer[] = {1,4,4,3,1,4,4,2,1,3,2};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint answer[] = new int[11];\t\tString str[] = br.readLine().split(\" \");\t\tfor(int i=0;i&lt;str.length;i++) {\t\t\tanswer[i] = Integer.parseInt(str[i]);\t\t}\t\tint counter[] = new int[4];\t\t\t\tfor(int i=0;i&lt;answer.length;i++) {\t\t\tcounter[answer[i]-1]++;\t\t}\t\tfor(int i=0;i&lt;counter.length;i++) {\t\t\tSystem.out.print(counter[i]);\t\t\tfor(int j=0;j&lt;counter[i];j++) {\t\t\t\tSystem.out.print(\"*\");\t\t\t}\t\t\t\t\t\tSystem.out.println();\t\t}\t}}counter[answer[i]-1] 를 생각못해서 배열하나 더 만들었네..[5-9] 배열을 시계방향으로 90도 회전원본 배열이**  **  ***** ***** 인데 이걸****  ****  **  **  ** 이렇게 바꾸면됨  자리값으로 찍어보면00 0110 1120 21 22 23 2430 31 32 33 34 이걸30 20 10 0031 21 11 0132 2233 2334 24 이렇게 다.표현은 안해줬지만 공백값도 있어서 02 03 04도 다 있는 상태임.00→30, 01→20, 02→10, 03→0010→31, 11→21 .. 뭐 이런식. star의 x값과 result의 y값이 같은 상태라 x값만 구하면됨  1차시도(실패)package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tresult[j][i]=star[star.length-1][i];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}뭔가 잘못됐다.result[5][4]고 star[4][5]니까.. 아 star에 y값을 j로 해야하는구나 j가 범위를 5까지 잡아놨으니까star에 x값은 어떻게 하지? 지금 문제에 적힌 코드대로 하다보니까 x를 값을 먼저 바꿔가면서 구한다음에 y값을 바꾸면서 구하는게 돼버려서 좀 햇갈린다;;그니까 지금 x값이0→3 0→2 0→1 0→01→3 1→2 1→1 1→0+3 +2 +1 0+2 +1 0 -1이꼴인데.. 지금 y값이 고정인채로 x값이 바뀌는 상태니까0→3 1→3 2→3 3→30→2 1→2 2→2 3→20→1 1→1 2→1 3→1 이렇게 되는거잖아.. star.length가 4니까 -1에서 y값을 추가로 빼주면 되는거 아닌가?  2차시도(성공)package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tresult[j][i]=star[star.length-1-i][j];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}됐당!!package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star[0].length;i++) {\t\t\tfor(int j=0;j&lt;star.length;j++) {\t\t\t\tresult[i][j] = star[star.length-1-j][i];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}for문 순서때문에 약간 헷갈려서 순서바꿔서 한번 해봤당[5-10] 문자열 암호화package _2javajungsuktestEx5;public class ex5_10 {\tpublic static void main(String[] args) {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse result+=abcCode[ch-'a'];\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_10 {\tpublic static void main(String[] args) throws IOException {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString scr = br.readLine();//\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse if(ch&gt;='a' &amp;&amp; ch&lt;='z')\t\t\t\tresult+=abcCode[ch-'a'];\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}위 코드대로 했다가 BufferedReader를 통해 입력받았을때 대문자가 들어오니까 에러가 나길래 else if를 추가해줬음. 대문자가 들어오니까 공백으로 처리하고 남은것만 암호화하더라package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_10 {\tpublic static void main(String[] args) throws IOException {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString scr = br.readLine();//\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse if(ch&gt;='a' &amp;&amp; ch&lt;='z')\t\t\t\tresult+=abcCode[ch-'a'];\t\t\telse {\t\t\t\tSystem.out.println(\"입력값이 잘못됐습니다.\");\t\t\t\tSystem.exit(0);\t\t\t}\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}지정된 문자 말고 다른게 들어오면 경고문구띄우면서 종료되게 바꿔봄[5-11] 2차원 배열 score보다 가로, 세로로 한칸씩 더 큰 배열을 반들어 마지막에 각 열과 행의 합을 구하는 문제  1차시도 (실패)package _2javajungsuktestEx5;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tint sum=0;\t\t\tint sum2=0;\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tsum+=score[i][j];\t\t\t\tsum2+=score[i][j];\t\t\t\tresult[i][score[i].length] = sum;\t\t\t\tresult[score.length][j]=sum2;\t\t\t\tresult[score.length][score[i].length] += sum;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}일단 저 sum을 쓴거자체가 잘못된듯. 아니면 sum2를 for문 안으로 넣어서 계속 초기화를 시켜줘서 result[score].length +=sum2를 하거나.. 5,3값에도 +=sum2를 하면 될거같기는 한데 일단 아래처럼 수정해봄  2차시도(개선필요)package _2javajungsuktestEx5;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tint sum=0;\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tint sum2=0;\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tsum+=score[i][j];\t\t\t\tsum2+=score[i][j];\t\t\t\tresult[i][score[i].length] = sum;\t\t\t\tresult[score.length][j]+=sum2;\t\t\t\tresult[score.length][score[i].length] += sum2;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}이렇게 할거면 너무 비효율적이라서 굳이 sum, sum2를 고집할 필요가 없을듯..  3차시도 - 성공(sum,sum2 안씀)package _2javajungsuktestEx5;import java.util.Arrays;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tresult[i][score[i].length] += result[i][j];\t\t\t\tresult[score.length][j]+=result[i][j];\t\t\t\tresult[score.length][score[i].length] += result[i][j];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}더 쉽게하려고 변수 sum을 선언해줬는데 더 어렵게돼서 당황스럽다😭너무 꼬아서 생각하지말고 단순하게 생각도 해봐야겠음"
  },
  
  {
    "title": "자바의 정석 연습문제 4장 - 조건문, 반복문",
    "url": "/posts/4%EC%9E%A5_%EC%A1%B0%EA%B1%B4%EB%AC%B8_%EB%B0%98%EB%B3%B5%EB%AC%B8/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 조건문, 반복문",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "[4-1] 다음의 문장들을 조건식으로 표현하라.package _2javajungsuktestEx4;public class ex4_1 {\tpublic static void main(String[] args) {//\t\t1. int형 변수 x가 10보다 크고 20 보다 작을 때 true인 조건식\t\tint x=10;\t\tSystem.out.println(x&g...",
    "content": "[4-1] 다음의 문장들을 조건식으로 표현하라.package _2javajungsuktestEx4;public class ex4_1 {\tpublic static void main(String[] args) {//\t\t1. int형 변수 x가 10보다 크고 20 보다 작을 때 true인 조건식\t\tint x=10;\t\tSystem.out.println(x&gt;=10 &amp;&amp; x&lt;=20);//\t\t2. char형 변수 ch가 공백이나 탭이 아닐 때 true인 조건식\t\tchar ch = 'a';\t\tSystem.out.println(!(ch==' ' || ch=='\\t'));//\t\t3. char형 변수 ch가 ‘x'또는 ’X' 일 때 true인 조건식\t\tchar ch2 = 'x';\t\tSystem.out.println(ch2 =='x' || ch2 =='X');//\t\t4. char형 변수 ch가 숫자(‘0’~‘9’)일 때 true인 조건식\t\tchar ch3 = '9';\t\tSystem.out.println(ch3 &gt;='0' &amp;&amp; ch3 &lt;='9');//\t\t5. char형 변수 ch가 영문자(대문자 또는 소문자) 일 때 true인 조건식\t\tchar ch4= 'a';\t\tSystem.out.println((ch4&gt;='A' &amp;&amp; ch4&lt;='Z') || (ch4&gt;='a' &amp;&amp; ch4&lt;='z'));//\t\t6. int형 변수 year가 400으로 나눠떨어지거나 또는 4로 나눠떨어지고 100으로 나눠떨어지지않을 때 true인 조건식\t\tint year = 124;\t\tSystem.out.println(year%400==0 ||year%4==0 &amp;&amp; year%100!=0);//\t\t7. boolean형 변수가 powerOn false 일 때 true인 조건식\t\tboolean powerOn = false;\t\tSystem.out.println(!powerOn);//\t\t8. 문자열 참조변수 str이 “yes” 일 때 true인 조건식\t\tString str = \"yes\";\t\tSystem.out.println(str.equals(\"yes\"));\t\t\t}}[4-2] 1~20중 2또는 3의 배수가 아닌 수의 합package _2javajungsuktestEx4;public class ex4_2 {\tpublic static void main(String[] args) {\t\tint sum=0;\t\tfor(int i=1;i&lt;=20;i++) {\t\t\tif(!(i%2==0 || i%3==0))\t\t\t\tsum+=i;\t\t}\t\tSystem.out.println(sum);\t\tsum=0;    for(int i=1;i&lt;=20;i++){      if(i%2==0 || i%3==0) continue;      sum+=i;      }      System.out.println(sum);\t}}[4-3] 1+(1+2)+(1+2+3)+…(1+2+3+4+…+10)은?package _2javajungsuktestEx4;public class ex4_3 {\tpublic static void main(String[] args) {\t\tint sum=0;\t\tint result=0;\t\tfor(int i=1;i&lt;=10;i++) {\t\t\tsum+=i;\t\t\tresult+=sum;\t\t}\t\tSystem.out.println(result);\t}}답:220[4-4] 1+-2+3+-4+5+-6…일때 합이 100이상이 되려면 몇번 더해야하는가?package _2javajungsuktestEx4;public class ex4_4 {\tpublic static void main(String[] args) {\t\tint sum = 0;\t\tfor(int i=0;true;i++) {\t\t\tif(i%2==0) sum-=i;\t\t\telse sum+=i;\t\t\t\t\t\tif(sum&gt;=100) {\t\t\t\tSystem.out.println(i);\t\t\t\tbreak;\t\t\t}\t\t}\t}}음수값이 2의 배수이길래 if문을 써서 2의 배수면 -i를 하게 만들었음package _2javajungsuktestEx4;public class ex4_4 {\tpublic static void main(String[] args) {\t\tint sum=0,n=1;\t\tfor(int i=1;true;i++,n*=-1) {\t\t\tsum += i*n;\t\t\tif(sum&gt;=100) {\t\t\t\tSystem.out.println(i);\t\t\t\tbreak;\t\t\t}\t\t}\t}}이번엔 n값을 추가해서 n*=-1로 sum을 i값을 양수와 음수를 번갈아가게 나타나게 만들어봤음public class jungsukEx4_2 {    public static void main(String[] args) {        int sum=0;        int count = 0;        for(int i=1;true;i++){            if(i%2==0) i*=-1;            sum+=i;\t\t        count++;            if(sum&gt;=100) break;            i=Math.abs(i);        }        System.out.println(count);    }}i값을 마지막에 절대값처리해서 초기화도 시켜줘봄public class jungsukEx4_2 {    public static void main(String[] args) { \t\t\t\tsum=0;        int count = 0;        for(int i=1;true;i++){            if(i%2==0) i*=-1;            sum+=i;            if(sum&gt;=100) break;            count++;            i=Math.abs(i);        }\t}}while문 사용  답지 코드```javapackage _2javajungsuktestEx4;public class ex4_4 {public static void main(String[] args) {\tint sum=0,n=1,num=0;\tfor(int i=1;true;i++,n=-n) {\t\tnum=n*i;\t\tsum+=num;\t\tif(sum&gt;=100) break;\t}\tSystem.out.println(num);}}---### [4-5]```javapackage _2javajungsuktestEx4;public class ex4_5 {\tpublic static void main(String[] args) {\t\tfor(int i=0; i&lt;=10; i++) {\t\t\tfor(int j=0; j&lt;=i; j++)\t\t\tSystem.out.print(\"*\");\t\t\tSystem.out.println();\t\t}\t}}위 별찍기 for문을 while문으로 변환package _2javajungsuktestEx4;public class ex4_5 {\tpublic static void main(String[] args) {\t\tint i=0;\t\twhile(i&lt;=10) {\t\t\tint j=0;\t\t\twhile(j&lt;=i) {\t\t\t\tSystem.out.print(\"*\");\t\t\t\tj++;\t\t\t}\t\t\tSystem.out.println();\t\t\ti++;\t\t}\t\t\t}}처음에 int i와 j를 같이 선언해줬다가 이상하게 나와서 뭐지?했는데 while문안에 int j=0을 넣어서 매번 값을 초기화해줘야하는 걸 잊었다;; 일단 해결[4-6] 주사위 두개를 굴려 두 수의 합이 6이 나오는 모든 경우의 수package _2javajungsuktestEx4;public class ex4_6 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=6;i++) {\t\t\tfor(int j=1;j&lt;=6;j++) {\t\t\t\tif(i+j==6) System.out.println(i+\" + \"+j+\" = \"+(i+j));\t\t\t}\t\t}\t}}답 :1 + 5 = 62 + 4 = 63 + 3 = 64 + 2 = 65 + 1 = 6[4-7] value에 1~6까지의 랜덤 값을 Math.random()을 이용하여 받는 문제package _2javajungsuktestEx4;public class ex4_7 {\tpublic static void main(String[] args) {\t\tint value = (int) ((Math.random()*6))+1;\t\tSystem.out.println(value);\t}}Math.random()은 double형 결과값을 출력해서 소수점 까지 다 나오니까 원하는 값을 얻으려면 int형으로 변환해주어야함. 1.xxx값에 6을 곱한 후 int형으로 변환해 소수점을 버리면 0~5값이 나오기 때문에 +1까지 해주어야 한다.[4-8] 2x +4y =10인 모든 경우의 수 출력package _2javajungsuktestEx4;public class ex4_8 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;=10;i++) {\t\t\tfor(int j=0;j&lt;=10;j++) {\t\t\t\tif(i*2+4*j==10) System.out.println(\"x = \"+i+\", y = \"+j);\t\t\t}\t\t}\t}}[4-9] 문자열 str의 각 자리수의 합을 구하는 문제package _2javajungsuktestEx4;public class ex4_9 {\tpublic static void main(String[] args) {\t\tString str = \"12345\";\t\tint sum=0;\t\t\t\tfor(int i=0;i&lt;str.length();i++) {\t\t\tsum+= str.charAt(i)-'0';\t\t}\t\tSystem.out.println(\"sum=\"+sum);\t}}[4-10] 숫자 num의 각 자리수의 합을 구하는 문제package _2javajungsuktestEx4;public class ex4_10 {\tpublic static void main(String[] args) {\t\tint num=12345;\t\tint sum=0;\t\t\t\twhile(num&gt;0) {\t\t\tsum+=num%10;\t\t\tnum/=10;\t\t}\t\t\t\tSystem.out.println(\"sum=\"+sum);\t}}처음에 당당하게 num.length()쓰다가 자동완성이 안떠서 length()가 String클래스의 메소드인걸 생각해냄ㅋㅋ…그래서 for문을 쓰기엔 i값 범위 지정하기가 애매해서 그냥 while문을 사용하기로 결정함[4-11] 피보나치수열, 맨 앞 두 수가 1,1일때 10번째 값을 구하는 문제package _2javajungsuktestEx4;public class ex4_11 {\tpublic static void main(String[] args) {\t\tint num1= 1;\t\tint num2=1;\t\tint num3=0;\t\tSystem.out.print(num1+\",\"+num2);\t\tfor(int i=0;i&lt;8;i++) {\t\t\tnum3=num1+num2;\t\t\tSystem.out.print(\",\"+num3);\t\t\tnum1=num2;\t\t\tnum2=num3;\t\t}\t}}[4-12] 구구단 출력 문제이 형태임package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=2;i&lt;=9;i++) {\t\t\tfor(int j=1;j&lt;=3;j++) {\t\t\t\tSystem.out.println(i+\" * \"+j+\" = \"+i*j);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}모양이 복잡해 보여서 일단 찍어봄.2 * 1 = 22 * 2 = 42 * 3 = 63 * 1 = 33 * 2 = 63 * 3 = 94 * 1 = 44 * 2 = 84 * 3 = 125 * 1 = 55 * 2 = 105 * 3 = 156 * 1 = 66 * 2 = 126 * 3 = 187 * 1 = 77 * 2 = 147 * 3 = 218 * 1 = 88 * 2 = 168 * 3 = 249 * 1 = 99 * 2 = 189 * 3 = 27첫번째 for문의 System.out.println()을 print(”\\t”)으로 바꿔보면 진전이있을거같아서 해봤는데 3 * 1=3 4 * 1=4같이 첫 시작만 탭이 먹힘. 생각을 잘못한거같은게.. 저렇게 출력이되려면 맨 첫줄만 생각했을때 i값은 2~4가 계속 반복되고 j값은 1~3이 계속 반복됨. 일단 2~4단만 먼저 찍어보는게 나을것같음package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=3;i++) {\t\t\tfor(int j=2;j&lt;=4;j++) {\t\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\t\tSystem.out.print(\"\\t\");\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}추가로 i와 j값의 위치를 바꿔줌2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 12으로 2~4단은 잘 출력됨. 이제 다음걸 출력하려면.. j%3 == 2일때 println을 사용해본다면?package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=3;i++) {\t\t\tfor(int j=2;j&lt;=9;j++) {\t\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\t\tSystem.out.println();\t\t\t\t}\t\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\t\tSystem.out.print(\"\\t\");\t\t\t}\t\t}\t}}출력: 2 * 1 = 2 3 * 1 = 3 4 * 1 = 45 * 1 = 5 6 * 1 = 6 7 * 1 = 78 * 1 = 8 9 * 1 = 9 2 * 2 = 4 3 * 2 = 6 4 * 2 = 85 * 2 = 10 6 * 2 = 12 7 * 2 = 148 * 2 = 16 9 * 2 = 18 2 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 3 = 24 9 * 3 = 27예 이꼴났어요곱하는 수도 1~3이 계속 반복되어야하고 단도 3번은 반복되어야하는데.. if문안에 j-3값을 넣어봐야겠음..package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1,j=2;i&lt;=3&amp;&amp;j&lt;=9;j++) {\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\tSystem.out.println();\t\t\t\tj-=3;\t\t\t\ti++;\t\t\t\tif(i&gt;3) {\t\t\t\t\tSystem.out.println();\t\t\t\t\ti-=3;\t\t\t\t\tj+=3;\t\t\t\t}\t\t\t}\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\tSystem.out.print(\"\\t\");\t\t}\t}}출력2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 9좀만 더하면 될거같은데ㅜpackage _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1,j=2;i&lt;=3&amp;&amp;j&lt;=11;j++) {\t\t\tif(j==10&amp;&amp;i==3) break;\t\t\tif(j%10==0 &amp;&amp; i&lt;=3) continue;\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\tSystem.out.println();\t\t\t\tj-=3;\t\t\t\ti++;\t\t\t\tif(i&gt;3) {\t\t\t\t\tSystem.out.println();\t\t\t\t\ti-=3;\t\t\t\t\tj+=3;\t\t\t\t}\t\t\t}\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\tSystem.out.print(\"\\t\");\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 9 10 * 1 = 108 * 2 = 16 9 * 2 = 18 10 * 2 = 208 * 3 = 24 9 * 3 = 27일단 되긴 됐는데 이게 좋은 코드같지가않다…..ㅋㅋ내일 좀 더 생각해봐야겠음..for문을 한번 더 써보는게 나을 듯..package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;3;i++) {\t\t\tfor(int y=1;y&lt;=3;y++) {\t\t\t\tfor(int x=2;x&lt;=9;x++) {\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y);\t\t\t\t\tSystem.out.print(\"\\t\");\t\t\t\t\t}\t\t\t\tSystem.out.println();\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 272 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 272 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 27음…일단 x값을 ≤4로 해봐야겠음x값을 x≤4로한 다음에 i값이랑 x값이랑 같게해서 i를 +3씩 한다면.. 괜찮지않을까?package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=2;i&lt;9;i+=3) {\t\t\tfor(int y=1;y&lt;=3;y++) {\t\t\t\tfor(int x=i;x&lt;=i+2&amp;&amp;x&lt;=9;x++) {\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y);\t\t\t\t\tSystem.out.print(\"\\t\");\t\t\t\t\t}\t\t\t\tSystem.out.println();\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 98 * 2 = 16 9 * 2 = 188 * 3 = 24 9 * 3 = 27됐다!!!!!!!!!!!!!!!!!!!!!!!!11  답지\tpackage _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=9;i++) {\t\t\tfor(int j=1;j&lt;=3;j++) {\t\t\t//i가 3이상이 되면 x에 i-1값을 더해서 반복되는 단을 변경해줌(2~4-&gt;5~7-&gt;8~9)\t\t\t\tint x=j+1+ (i-1)/3*3;\t\t\t\tint y=i%3==0?3:i%3;  \t\t\t\t\t\t\t\tif(x&gt;9) break;\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y+\"\\t\");\t\t\t}\t\t\tSystem.out.println();\t\t\tif(i%3==0) System.out.println();\t\t}\t}}음.. 근데 int x구하는 식에서 굳이 +1을 해줘야 하나? for문쓸때 2~4로 해주면 되는거 아닌감..코드 이해는 했는데..ㅜㅜ어렵구만  for문을 한번만 쓰라는 조건이 없어서 for문을 3번적는 방법도 있다    public class Gugu {  public static void main(String[] args) {      for(int i=1;i&lt;=3;i++){          for(int j=2;j&lt;=4;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }      System.out.println();      for(int i=1;i&lt;=3;i++){          for(int j=5;j&lt;=7;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }      System.out.println();      for(int i=1;i&lt;=3;i++){          for(int j=8;j&lt;=9;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }  }}      [4-13] 문자열이 숫자로만 이루어졌는지 판단하는 문제package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_13 {\tpublic static void main(String[] args) throws IOException{\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString value = br.readLine();\t\tchar ch = ' ';\t\tboolean isNumber = true;\t\t\t\tfor(int i=0;i&lt;value.length();i++) {\t\t\tch=value.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') {\t\t\t\tisNumber=true;\t\t\t\t}\t\t\telse {\t\t\t\tisNumber = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif(isNumber) System.out.println(value+\"는 숫자입니다\");\t\telse System.out.println(value+\"는 숫자가 아닙니다.\");\t}}문자열은 BufferedReader를 통해 입력받아보았다.[4-14] 숫자맞추기 문제package _2javajungsuktestEx4;import java.util.Scanner;public class ex4_14 {\tpublic static void main(String[] args) {\t\tint answer = (int)(Math.random()*100)+1;\t\tint input=0;\t\tint count=0;\t\t\t\tScanner s = new Scanner(System.in);\t\t\t\tdo {\t\t\tcount++;\t\t\tSystem.out.println(\"1~100사이의 값을 입력하세요 : \");\t\t\tinput= s.nextInt();\t\t\t\t\t\tif(input&gt;answer) System.out.println(\"더 작은 수를 입력하세요.\");\t\t\telse if(input&lt;answer) System.out.println(\"더 큰 수를 입략하세요.\");\t\t\telse {\t\t\t\tSystem.out.println(\"정답입니다. 시도횟수는 \"+count+\"번 입니다.\");\t\t\t\tbreak;\t\t\t}\t\t}while(true);\t}}package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_14 {\tpublic static void main(String[] args) throws IOException {\t\tint answer = (int)(Math.random()*100)+1;\t\tint input=0;\t\tint count=0;\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\t\t\tdo {\t\t\tcount++;\t\t\tSystem.out.println(\"1~100사이의 값을 입력하세요 : \");\t\t\tinput= Integer.parseInt(br.readLine());\t\t\t\t\t\tif(input&gt;answer) System.out.println(\"더 작은 수를 입력하세요.\");\t\t\telse if(input&lt;answer) System.out.println(\"더 큰 수를 입략하세요.\");\t\t\telse {\t\t\t\tSystem.out.println(\"정답입니다. 시도횟수는 \"+count+\"번 입니다.\");\t\t\t\tbreak;\t\t\t}\t\t}while(true);\t}}Scanner대신 BufferedReader를 사용했다.import java.util.Scanner;public class UpAndDown {    public static void main(String[] args) {        int answer = (int)(Math.random()*100)+1 ;        int input = 0; // 사용자입력을 저장할 공간        int count = 0; // 시도횟수를 세기위한 변수        // Scanner 화면으로 부터 사용자입력을 받기 위해서 클래스 사용        Scanner s = new Scanner(System.in);        while (true) {            count++;            System.out.print(\"1과 100사이의 값을 입력하세요 :\");            input = s.nextInt(); // input . 입력받은 값을 변수 에 저장한다            if(input &lt; answer) System.out.println(\"입력한 값이 정답보다 큽니다.\");            else if(input &gt; answer) System.out.println(\"입력한 값이 정답보다 작습니다.\");            else {                 System.out.println(\"정답입니다.\");                System.out.println(\"시도횟수는 \"+count+\"번 입니다.\");                break;            }        }    }}그냥 while문 사용함[4-15] 회문수(앞뒤가 같은 수)를 구하는 문제package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_15 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint number = Integer.parseInt(br.readLine());\t\tint tmp=number;\t\t\t\tint result =0;\t\t\t\twhile(tmp!=0) {\t\t\tresult = tmp%10+result*10;\t\t\ttmp/=10;\t\t}\t\tif(number == result) System.out.println(number+\"는 회문수입니다.\");\t\telse System.out.println(number+\"는 회문수가 아닙니다.\");\t}}이것도 입력값 받는 문제로 바꿔서 풀었다"
  },
  
  {
    "title": "자바의 정석 연습문제 3장 - 연산자",
    "url": "/posts/3%EC%9E%A5_%EC%97%B0%EC%82%B0%EC%9E%90/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 연산자",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "3-1 출력값을 적어라class Exercise3_1 {public static void main(String[] args) {int x = 2;int y = 5;char c = 'A'; // 'A' 65 의 문자코드는System.out.println(1 + x &lt;&lt; 33);System.out.println(y &gt;= 5 || x &lt...",
    "content": "3-1 출력값을 적어라class Exercise3_1 {public static void main(String[] args) {int x = 2;int y = 5;char c = 'A'; // 'A' 65 의 문자코드는System.out.println(1 + x &lt;&lt; 33);System.out.println(y &gt;= 5 || x &lt; 0 &amp;&amp; x &gt; 2);System.out.println(y += 10 - x++);System.out.println(x+=2);System.out.println( !('A' &lt;= c &amp;&amp; c &lt;='Z') );System.out.println('C'-c);System.out.println('5'-'0');System.out.println(c+1);System.out.println(++c);System.out.println(c++);System.out.println(c);순서대로6true135false2566BBC이 출력됨.      System.out.println(1 + x &lt;&lt; 33);  +가 우선순위라 1+x부터 계산됨. 33은 int라서 int는 32bit니까 1만 계산하면 됨. 최종적으로 3«1        « : 비트이동 연산자. 왼쪽으로 이동 ⇒ 3을 왼쪽으로 1 이동  3«1 = 3*2 =6        System.out.println(y &gt;= 5 || x &lt; 0 &amp;&amp; x &gt; 2); | |보다 &amp;&amp;이 우선순위가 높음. 그럼 x&lt;0 &amp;&amp; x&gt;2는 false&amp;&amp;false임. y≥5는 true니까 최종 코드가 true | | false 로 true가 반환됨.        System.out.println(y += 10 - x++);  y=y+(10-x);    x++은 계산 후 1을 더해줌. 그럼 5+8로 13        System.out.println(x+=2);    위 식에서 x=3이됨. 5출력        System.out.println( !('A' &lt;= c &amp;&amp; c &lt;='Z') );    c가 A보다 크고 Z보다 작지 않을때 = c가 대문자가 아니면 true. c는 ‘A’니까 false        System.out.println('C'-c);    ‘C’ - ‘A’. C=67, A=65  2출력        System.out.println('5'-'0');    ‘5’-’0’ 53-48=5  5출력        System.out.println(c+1);    65(’A’) + 1 = ‘B’  c값의 변동은 없음        System.out.println(++c);    ++c는 먼저 값을 바꾸고 출력됨  B출력. c의 값이 B로 바뀜        System.out.println(c++);    c++은 출력 후 값이 바뀜. c=’B’니까 B 출력  출력후 c=’C’로 값 변동        System.out.println(c);  c=’C’니까 C출력  3-2 사과 박스의 \b갯수는?package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_2 {\tpublic static void main(String[] args) throws IOException {//\t\tint numOfApples = 123;\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint numOfApples = Integer.parseInt(br.readLine());\t\tint sizeOfBucket = 10;\t\tint numOfBucket = numOfApples/sizeOfBucket + (numOfApples%sizeOfBucket&gt;0?1:0);\t\tSystem.out.println(\"필요한 바구니의 수 : \"+numOfBucket);\t}}예제랑 다르게 bufferedReader를 사용해 입력값을 받아보았다3-3 삼항연산자를 2번 사용해서 num이 양수, 음수, 0중 어디에 해당하는가?package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_3 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num&gt;0?\"양수\":num&lt;0?\"음수\":0);\t\t\t}}삼항연산자 - 조건식?(true일때)값:(false일때)값3-4 백의자리 이하를 버려라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_4 {\tpublic static void main(String[] args) throws IOException{\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num/100*100);\t}}int는 소수점을 자동으로 버리기 때문에(반올림xxx) num을 100으로 나눈 후 100을 곱해줬음3-5 1의 자리를 1로 바꿔라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_5 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num/10*10+1);\t}}3-4처럼 일의자리를 버린 후 1을 더해줬다3-6 %연산자를 사용하여 크면서도 가까운 10의 배수에서 num값을 뺀 나머지를 구하라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_6 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(+num+\"의 크면서도 가까운 10의 배수 : \"+(10-num%10+num));\t\tSystem.out.println(\"나머지 수 : \"+(10-num%10));\t}}3-7 화씨를 섭씨로 변환  변환 공식 - 5/9 * (f-32)public class ex3_7 {\tpublic static void main(String[] args) {\t\tint fahrenheit = 100;\t\tfloat celcius = (int)(5/9f * (fahrenheit-32)*100+0.5)/100f;\t\tSystem.out.println(\"Fahrenheit : \"+fahrenheit);\t\tSystem.out.println(\"celcius : \"+celcius);\t}}섭씨로 바꾸는 공식을 사용하여 100을 곱하고 반올림을 위해 0.5를 더한다.+0.5를 했을때 일의 자리 수 값이 변한다면 어차피 반올림해도 변함 - 여기까지 int형으로 계산해서 3번째 자리수부터 버림그 후 다시 100f로 나눠 소수점을 만들어 준다3-8 정해진 값을 출력하라차례로c = 30ch = Cf = 1.5l = 1230196224result = true을 출력하는 문제package _2javajungsuktestEx3;public class ex3_8 {\tpublic static void main(String[] args) {\t\tbyte a=10;\t\tbyte b=20;\t\tbyte c =(byte) (a+b);\t\t\t\tchar ch ='A';\t\tch = (char)(ch+2);\t\tfloat f = 3/2f;\t\tlong l = 3000*3000*3000L;\t\t\t\tfloat f2 = 0.1f;\t\tdouble d = 0.1;\t\t\t\tboolean result = (float)d==f2;\t\t\t\tSystem.out.println(\"c = \"+c);\t\tSystem.out.println(\"ch = \"+ch);\t\tSystem.out.println(\"f = \" +f);\t\tSystem.out.println(\"l = \"+l);\t\tSystem.out.println(\"result = \"+result);\t\t\t}}byte c = a+b같은 경우에는 a+b가 int로 자동 형변환 되기때문에 앞에 (byte)를 붙여서 다시 byte로 형변환을 해주었다.ch =ch+2도 마찬가지로 앞에 (char)을 붙여서 형변환을 해주었다float f=3/2는 int/int라 2에 f를 붙여 float로 변환해주었다. long l = 300030003000도 뒤에 L이 빠져있었다. 3000중에 하나는 long타입이어야 오버플로우가 나타나지 않는다boolean result = d == f2는 d와 f2의 형식이 달라 false가 출력된다. float를 double로 형변환했을 때 오차가 발생할 수 있어서 d를 float으로 변환해주었다3-9 ch가 영어(대문자,소문자 둘다)거나 숫자일경우 true를 출력package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class cx3_9 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\tchar ch = br.readLine().charAt(0);\t\tboolean b= (ch&gt;='A'&amp;&amp; ch&lt;='z') || (ch&gt;='a' &amp;&amp; ch&lt;='z') || (ch&gt;='0' &amp;&amp; ch&lt;='9');\t\t\t\tSystem.out.println(b);\t}\t}char ch를 BufferedReader를 통해 입력받아보았다. char형을 입력받는 것은 처음이라 charAt()을 써보면 될거같아 시도해보았더니 성공했다!3-10 대문자를 소문자로 변환package _2javajungsuktestEx3;public class ex3_10 {\tpublic static void main(String[] args) {\t\tchar ch = 'A';\t\t\t\tchar lowerCase = (char) ((ch&gt;=65 &amp;&amp; ch&lt;97)?ch+32:ch);\t\t\t\tSystem.out.println(\"ch:\"+ch);\t\tSystem.out.println(\"ch to lowerCase : \"+lowerCase);\t}}"
  },
  
  {
    "title": "자바의 정석 연습문제 2장 - 변수",
    "url": "/posts/2%EC%9E%A5_%EB%B3%80%EC%88%98/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 변수",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "[2-1] 기본형 8개를 알맞은 자리에 적으시요            종류/크기      1byte      2byte      4byte      8byte                  논리형      boolean                                   문자형             char                     ...",
    "content": "[2-1] 기본형 8개를 알맞은 자리에 적으시요            종류/크기      1byte      2byte      4byte      8byte                  논리형      boolean                                   문자형             char                            정수형      byte      short      int      long              실수형                    float      double      [2-2] 주민등록번호를 초기화하는 코드 적기long regNo = 9701012222222L;int의 범위를 넘어서는 값이라 long을 사용함→ 원래는 이렇게 하면 됐는데 20000년생 부터는 long이 아닌 String으로 사용해야 온전한 값이 나옴[2-3] 리터럴, 변수, 상수, 키워드 구분하기int i = 100;long l =100L;final float PI = 3.14f;  리터럴 : 100,100L, 3.14f  변수 : i, l  키워드(=예약어) : int, long, final, float  상수 : PIPI는 final때문에 변경 불가능함[2-4] 기본형이 아닌 것.  int  ==Byte== - 기본형은 byte임.  double  boolean[2-5] 출력결과 적기System.out.println(“1” + “2”) → 12System.out.println(true + “”) → trueSystem.out.println(‘A’ + ‘B’) → 131 (A-65, b-66)System.out.println(‘1’ + 2) → 51 (’1’=49)System.out.println(‘1’ + ‘2’) → 99 (’1’=49, ‘2’=50)System.out.println(‘J’ + “ava”) → JavaSystem.out.println(true + null) → 오류![2-6] 키워드가 아닌 것  if  ==True== - true는 키워드임  ==NULL==  ==Class==  ==System== - 클래스명임키워드 :abstract, do, if, package, synchronized, boolean, double, implements, private, this, break, else, import, protected, throw, byte, enum, instanceof, public, throws, case, extends, int, return, transient, catch, false, interface, short, true, char, final, long, static, try, class, finally, native, strictfp, void, continue, float, new, super, volatile, default, for, null, switch, while[2-7] 변수이름으로 사용가능 한 것.==a. $ystem==b. channel==#==5 - # 불가c.==7==eleven - 숫자로 시작 불가==d. If====e. 자바==f.==new== - 예약어라 불가능==g. $MAX_NUM==h. hello==@==com - @불가[2-8] 참조형변수(reference type)과 같은 크기의 기본형(primitive type)  ==int== - 4byte  long - 8byte  short - 2byte  ==float== - 4byte  double - 8byte참조형 변수는 4byte임[2-9] 형변환 생략 가능한 것byte b=10;char ch = ‘A’;int i =100;long l = 1000L;  b = (byte) i; int(4byte) &gt; byte(1byte) 불가능  ch = (char)b; byte(1byte) &lt; char(2byte). 범위가 달라서 해줘야함  short s = (short) ch; char(2byte) = short(2byte). 범위가 달라서 해줘야함  float f = (float)l; long(8byte) &gt; float(4byte). 그러나 범위가 float이 더 커서 생략가능  i = (int)ch; char(2byte) &lt; int(4byte) 생략가능선생님은 정답 없다고하심[2-10] char타입에 저장될 수 있는 정수 값의 범위(10진수로)0~65535[2-11] 변수를 잘못 초기화 한것은?  ==byte b = 256;== byte의 범위값을 넘음  ==char c = ‘’;== 띄어쓰기 해야함 ‘ ‘  ==char answer = ‘no’;== 두글자 안됨  ==float f = 3.14== f 빠짐  double d = 1.4e3f;[2-12] main메소드의 선언부로 알맞은것은?  ==public static void main(String[] args)==  ==public static void main(String args[])==  ==public static void main(String[] arv)==  public void static main(String[] args) void는 main앞에 와야함  static public void main(String[] args)[2-13] 타입과 기본형의 연결이 잘못된 것  boolean = false  char = ‘\\u0000’  ==float - 0.0== f빠짐  int = 0  ==long = 0== L빠짐  ==String = “”== String의 기본형은 null임"
  },
  
  {
    "title": "자바의 정석 강의 - 람다와 스트림(Lambda & Stream)",
    "url": "/posts/%EB%9E%8C%EB%8B%A4%EC%99%80-%EC%8A%A4%ED%8A%B8%EB%A6%BC(Lambda&Stream)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-09-02 00:00:00 +0900",
    





    
    "snippet": "람다식(Lambda Experssion): 함수(메소드)를 간단한 식으로 표현하는 법 (ex. (a, b) → a &gt; b ? a : b )  익명함수(이름이 없는 함수, anonymous function) : 반환타입, 이름을 지우고 사이에 →를 붙인다  함수와 메소드는 근본적으로 동일하나 함수는 일반적 용어, 메소드는 객체지향개념 용어. 함수는...",
    "content": "람다식(Lambda Experssion): 함수(메소드)를 간단한 식으로 표현하는 법 (ex. (a, b) → a &gt; b ? a : b )  익명함수(이름이 없는 함수, anonymous function) : 반환타입, 이름을 지우고 사이에 →를 붙인다  함수와 메소드는 근본적으로 동일하나 함수는 일반적 용어, 메소드는 객체지향개념 용어. 함수는 클래스에 독립적(클래스 바깥에 있는것. 자바에서는 불가능), 메소드는 클래스에 종속적(클래스안에 있음)  작성 법                  메소드의 이름과 반환타입 제거 후 ‘ →’를 블럭{}앞에 추가 ( ex. (int a, int b) → return a&gt;b? a:b;)                    반환값이 있는 경우, 식이나 값만 적고 return문 생략 가능. 끝에 ; 안붙임 (ex. (int a, int b) → a&gt;b? a:b)                    매개변수의 타입이 추론 가능하면, 생략 가능(대부분의 경우 생략가능) (ex. (a, b) → a&gt;b?a:b              주의사항                  매개변수가 하나인 경우, 괄호() 생략가능(타입이 없을 때만)  (a) → aa ⇒ a → aa 가능, (int a) → aa ⇒ int a → aa 불가능.                    블록안의 문장이 하나일 겅우 {}생략가능. 끝에 ; 안붙음. (return문은 생략안됨)  (int i) → { System.out.println(i);} ⇒ (int i) → System.out.println(i) 가능            — 예시      int max(int a, int b){ retrun a&gt;b?a:b;} ⇒ (a, b) → a&gt;b? a:b;        int printVar(String name, int i){System.out.println(name+”=”+i);} ⇒ (name, i) → System.out.println(name+”=”+i)        int square(int x){return x * x; } ⇒ x→ x*x        int roll(){return (int)(Math.random()6); ⇒ () → (int)(Math.random()6)        익명 함수가 아니고 익명 객체임  new Object(){ int max(int a, int b){ return a&gt;b? a:b;} 를 (a, b) → a&gt;b? a:b;으로 쓴거라 객체임.        람다식(익명 객체)를 다루기 위해 참조변수가 필요함.  class  Main{\tpublic static void main(String[] args) throws Exception {//\tObject obj = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체 에러남\t\tObject obj = new Object() {\t\t\tint max(int a, int b) {\t\t\t\treturn a&gt;b? a:b;\t\t\t}\t\t};//\t\tint value = obj.max(3,5); //에러, Object리모컨인 obj는 max를 호출할 수 없음\t\t//=&gt; 함수형 인터페이스가 필요\t}}함수형 인터페이스: 단 하나의 추상 메소드만 선언된 인터페이스@FunctionalInterface //붙이는게 좋음interface MyFunction{ \tpublic abstract int max(int a, int b);}class  Main{\tpublic static void main(String[] args) throws Exception {\t\tMyFunction f= new MyFunction(){\t\t\tpublic int max(int a, int b){ \t\t\t\treturn a&gt;b? a:b; \t\t\t}\t\t};\t\tint value = f.max(3, 5);//가능. MyFunction에 max()가 있음\t\tSystem.out.println(value);  \t}}  함수형 인터페이스 타입의 참조변수로 람다식을 참고 가능 (단, 함수형 인터페이스의 메소드와 람다식의 매개변수 개수와 반환타입이 일치해야 함)  Myfunction f = (a,b) →a&gt;b?a:b;  int value = f.max(3,5);class  Main{\tpublic static void main(String[] args) throws Exception {//\tObject obj = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체 에러남//\t\tMyfunction f = new Myfunction() {//\t\t\tpublic int max(int a, int b) { //오버라이딩 규칙, 접근제어자는 좁게 못바꿈//\t\t\t\treturn a&gt;b? a:b;//\t\t\t}//\t\t};\t\t//람다식을 다루기 위한 참조변수의 타입은 함수형 인터페이스로 한다\t\tMyfunction f = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체\t\t//람다식을 사용하려면 이름이 있어야해서 이름을 붙여준거임(추상메소드와 연결)\t\tint value = f.max(3, 5);\t\tSystem.out.println(\"value : \"+value);\t}}@FunctionalInterface //함수형 인터페이스는 단 하나의 추상메소드만 가질 수 있다.interface Myfunction{//\tpublic abstract int max(int a, int b);\t\t\t\t\tint max(int a, int b); //public abstract 생략가능}— 예시      익명 객체를 람다식으로 대체      import java.util.*;      class  Main{  \tpublic static void main(String[] args)  {  \t\tList&lt;String&gt; list = Arrays.asList(\"abc\",\"aaa\",\"bbb\",\"ddd\",\"aaa\");    \t\t  //\t\tCollections.sort(list, new Comparator&lt;String&gt;() {  //\t\t\tpublic int compare(String s1, String s2) {  //\t\t\t\treturn s2.compareTo(s1);  //\t\t\t}  //\t\t});    \t\t  \t\tCollections.sort(list, (s1,s2)-&gt;s2.compareTo(s1));  \t\tSystem.out.println(list);  \t}  }  @FunctionalInterface  interface Comparator&lt;T&gt;{  \tint compare(T o1, T o2);  }        함수형 인터페이스타입의 매개변수, 반환타입                  함수형 인터페이스타입의 매개변수        @FunctionalInterface  interface MyFunction{  void myMethod(); }  void aMethod(MyFuction f) {  f.myMethod(); //람다식 호출  }  aMethod(()→System.out.println(”myMethod()”));                  함수형 인터페이스 타입의 반환타입    MyFunction myMethod(){ //람다식 반환  return ()→{}; }      import java.util.*;  @FunctionalInterface  interface MyFunction{  \tvoid run();  }      class  Main{  \tstatic void execute(MyFunction f) {//매개변수 타입이 MyFunction인 메소드  \t\tf.run();  \t}  \tstatic MyFunction getMyFunction() { //반환타입이 MyFunction인 메소드  //\t\tMyFunction f = () -&gt; System.out.println(\"f3.run()\");  //\t\treturn f;  \t\treturn ()-&gt;System.out.println(\"f3.run()\");  \t}  \tpublic static void main(String[] args)  {  \t\t//람다식으로 MyFunction의 run()을 구현  \t\tMyFunction f1 = ()-&gt;System.out.println(\"f1.run()\");    \t\t  \t\tMyFunction f2 = new MyFunction() {  \t\t\tpublic void run() {  \t\t\t\tSystem.out.println(\"f2.run()\");  \t\t\t}  \t\t};  \t\tMyFunction f3 = getMyFunction();    \t\t  \t\tf1.run();  \t\tf2.run();  \t\tf3.run();    \t\t  \t\texecute(f1);  \t\texecute(()-&gt;System.out.println(\"run()\"));  \t}  }      java.util.function패키지      자주 사용되는 다양한 함수형 인테페이스를 제공.        Predicate isEmptyStr = s→ s.length() == 0;    String s=””;    if(isEmptyStr.test(s) //if(s.length()==0)    Sysout(”This is an empty String”)  ![[assets/images/java/2022-09-02-람다와 스트림(Lambda&amp;Stream) 1/IMG-20240902151633.png]]  — 예시Supplier f = ()→(int)(Math.random()*100)+1; (공급자)Consumer f = i→ System.out.print(i+””);Predicate f = i→ i%2==0;Function f = i→ i/10*10; //25를 넣으면 20으로 반환  매개변수가 두개인 함수형 인터페이스Bi가 2개를 의미      매개변수가 3개인경우엔 만들어서 쓸것.  @FunctionalInterface  interface TriFunction&lt;T,U,V,R&gt;{  R apply(T t, U u, V v); //매개변수 3개  }        매개변수의 타입과 반환타입이 일치하는 함수형 인터페이스  UnaryOperator : 단항 연산자BinaryOperator : 이항 연산자@FunctionalInterfacepublic interface UnaryOperator extends Function&lt;T,T&gt;{  static UnaryOperrator  identity(){  return t→ t;} //입출력 타입 일치@FunctionalInterfacepublic interface Function&lt;T,R&gt;{R apply(T t);}import java.util.ArrayList;import java.util.List;import java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\t\tSupplier&lt;Integer&gt; s = () -&gt;(int)(Math.random()*100)+1; //1~100사이 양수\t\tConsumer&lt;Integer&gt; c = i-&gt;System.out.print(i+\", \");\t\tPredicate&lt;Integer&gt; p = i-&gt;i%2==0; //짝수인지 검사\t\tFunction&lt;Integer, Integer&gt; f = i-&gt;i/10*10; //i의 일의 자리수 버림\t\t\t\tList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\t\tmakeRandomList(s, list); //s에서 값(랜덤값)을 꺼내 list를 채운다\t\tSystem.out.println(list);\t\tprintEvenNum(p,c,list); //짝수 출력\t\tList&lt;Integer&gt; newList = doSomething(f,list); //새로운 list를 생성\t\tSystem.out.println(newList);\t}\t\tstatic&lt;T&gt; List&lt;T&gt; doSomething(Function&lt;T,T&gt; f, List&lt;T&gt; list){\t\tList&lt;T&gt; newList = new ArrayList&lt;T&gt;(list.size());\t\t\t\tfor(T i : list) {\t\t\tnewList.add(f.apply(i)); //list안의 값에서 1의 자리수를 버려 newlist 생성\t\t}\t\treturn newList;\t}\tstatic&lt;T&gt; void printEvenNum(Predicate&lt;T&gt; p, Consumer&lt;T&gt; c, List&lt;T&gt; list) {\t\tSystem.out.print(\"[\");\t\tfor(T i:list) {\t\t\tif(p.test(i)) //짝수인지 검사\t\t\t\tc.accept(i); //짝수면,System.out.print(i+\", \");로 화면에 i 출력\t\t}\t\tSystem.out.println(\"]\");\t}\tstatic&lt;T&gt; void makeRandomList(Supplier&lt;T&gt; s, List&lt;T&gt; list) {\t\tfor(int i=0;i&lt;10;i++) {\t\t\tlist.add(s.get()); //Supplier로 부터 1~100까지의 난수를 받아서 list에 10번 추가\t\t}\t}}Predicate의 결합      and(), or(), negate()로 두 Predicate를 하나로 결합(default메소드)    Predicate p = i → i&lt;100;    Predicate q = i → i&lt;200;    Predicate r = i → i%2 ==0;    Predicate notP = p.negate(); //i≥100    Predicate all = notP.and(q).or(r); //100≤i &amp;&amp; i&lt;200 || i%2==0    Predicate all2 = notP.and(q.or(r))//100≤i &amp;&amp; (i&lt;200 || i%2==0 )    System.out.println(all.test(2)); //true  System.out.println(all2.test(2)); //false        등가비교를 위한 predicate의 작성에는 isEqual()를 사용(static메소드)  Predicate [ =Predicate.isEqual(str1); //isEquals()은 static메소드    Boolean result = p.test(str2); //str1과 str2가 같은지 비교한 결과를 반환    ⇒ Boolean result = Predicate.isEqual(str1).test(str2);  import java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\tFunction&lt;String, Integer&gt; f = (s)-&gt;Integer.parseInt(s,16); //문자열을 16진수로\tFunction&lt;Integer, String&gt; g = (i)-&gt;Integer.toBinaryString(i); //2진수로\t\t//andThen : 두 function을 하나로 연결\t//f가 String입력, Integer출력. 출력된 Integer를 g에 입력, String출력하는 함수 h를 생성함\tFunction&lt;String, String&gt; h = f.andThen(g); //f적용하고 g를 적용. String입력, String출력\t//compose : f가 뒤에오고 g가 앞에옴\tFunction&lt;Integer, Integer&gt; h2 = f.compose(g); //Integer입력, Integer출력\t\tSystem.out.println(h.apply(\"FF\")); //\"FF\" -&gt; 255 -&gt; \"11111111\"\tSystem.out.println(h2.apply(2)); //2 -&gt; \"10\" -&gt; 16\t\tFunction&lt;String, String&gt; f2 = x-&gt;x; //항등함수(identity function)\tSystem.out.println(f2.apply(\"AAA\")); //AAA가 그대로 출력됨\t\tPredicate&lt;Integer&gt; p = i -&gt; i&lt;100;\tPredicate&lt;Integer&gt; q = i -&gt; i&lt;200;\tPredicate&lt;Integer&gt; r = i -&gt; i%2==0;\tPredicate&lt;Integer&gt; notP = p.negate(); //i&gt;=100\t\tPredicate&lt;Integer&gt; all = notP.and(q.or(r)); //i&gt;=100 &amp;&amp; (i&lt;200 || i%2==0)\tSystem.out.println(all.test(150)); //true\tSystem.out.println(all.test(149)); //true\tSystem.out.println(all.test(300)); //true\tSystem.out.println(all.test(10)); //false\t\tString str1 = \"abc\";\tString str2 = \"abc\";\t\t//str1과 str2가 같은지 비교\tPredicate&lt;String&gt; p2 = Predicate.isEqual(str1);\tboolean result = p2.test(str2);\tSystem.out.println(result); //true\t\tString str3 = new String(\"abc\");\t\t//str1과 str2가 같은지 비교//\tPredicate&lt;String&gt; p3 = Predicate.isEqual(str2);//\tboolean result2 = str1.equals(str2);\tboolean result2 = Predicate.isEqual(str2).test(str3);\tSystem.out.println(result2); //true\t}}컬렉션 프레임웍과 함수형 인터페이스  함수형 인터페이스를 사용하는 컬렉션 프레임웍의 메소드(와일드카드 생략)forEach는 consumer임(입력값만 있음)import java.util.*;class  Main{\tpublic static void main(String[] args)  {\t\tArrayList&lt;Integer&gt; list = new ArrayList();\t\tfor(int i=0;i&lt;10;i++) {\t\t\tlist.add(i);\t\t}\t\t\t\t//list의 모든 요소 출력\t\t//\t\tIterator it = list.iterator();//\t\twhile(it.hasNext()) {//\t\t\tSystem.out.print(it.next()+\",\");//\t\t}//\t\tSystem.out.println();\t\t//아래 한문장으로\t\tlist.forEach(i-&gt; System.out.print(i+\", \"));\t\tSystem.out.println();\t\tSystem.out.println(list); //이것도 되긴함\t\t\t\t\t\t//list에서 2또는 3의 배수를 제거\t\tlist.removeIf(x-&gt;x%2==0 || x%3==0); \t\tSystem.out.println(list);\t\t\t\tlist.replaceAll(i-&gt;i*10);\t\tSystem.out.println(list);\t\t\t\tMap&lt;String, String&gt; map = new HashMap();\t\tmap.put(\"1\", \"1\");\t\tmap.put(\"2\", \"2\");\t\tmap.put(\"3\", \"3\");\t\tmap.put(\"4\", \"4\");\t\t\t\t//map의 모든 요소를 {k,v}형식으로 출력//\t\tIterator it2 = map.entrySet().iterator();//\t\twhile(it2.hasNext()) {//\t\t\tSystem.out.print(\"{\"+it2.next()+\"}\");//\t\t}//\t\tSystem.out.println();\t\t//위에꺼 한문장으로\t\tmap.forEach((k,v)-&gt;System.out.print(\"{\"+k+\", \"+v+\"}\"));\t\tSystem.out.println();\t}}메소드 참조(method reference)  클래스이름 :: 메소드이름: 하나의 메소드만 호출하는 람다식을 ‘메소드 참조’로 더 간단히 할 수 있다            종류      람다      메소드 참조                  static메소드 참조      (x) → ClassName.method(x)      ClassName::method              인스턴스 메소드 참조      (obj,x) → obj.method(x)      ClassName::method              특정 객체 인스턴스 메소드 참조      (x)→ obj.method(x)      obj::method      import java.util.function.Function;class  Main{\tpublic static void main(String[] args)  {//\t\tFunction&lt;String, Integer&gt; f = (String s) -&gt; Integer.parseInt(s);\t\tFunction&lt;String, Integer&gt; f = Integer::parseInt; //메소드 참조. 위랑 같음\t\t\t\tSystem.out.println(f.apply(\"100\")+200); //f.apply(\"100\")이 숫자로 바뀜\t}}  생성자의 메소드 참조 - 클래스이름::new  배열과 메소드 참조 - 타입[]::newimport java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\t\t//매개변수 없는 경우//\t\tSupplier&lt;MyClass&gt; s = ()-&gt;new MyClass(); //입력x, 출력o\t\tSupplier&lt;MyClass&gt; s = MyClass::new;\t\t\t\tMyClass mc = s.get(); //객체 값 반환\t\tSystem.out.println(mc); \t\tSystem.out.println(s.get()); //위랑 다른 새로운 객체 생성\t\t\t\t//매개변수 있는 경우//\t\tFunction &lt;Integer, MyClass2&gt; f = (i)-&gt;new MyClass2(i); //입력o, 출력o\t\tFunction &lt;Integer, MyClass2&gt; f = MyClass2::new;\t\t\t\tMyClass2 mc2 = f.apply(100);\t\tSystem.out.println(mc2.iv); \t\tSystem.out.println(f.apply(100).iv); \t\t//\t\tFunction&lt;Integer, int[]&gt; f2 = (i)-&gt;new int[i];\t\tFunction&lt;Integer, int[]&gt; f2 = int[]::new;\t\tint[] arr = f2.apply(500);\t\tSystem.out.println(arr.length); //길이가 500인 배열\t}}class MyClass{}class MyClass2{\tint iv;\tMyClass2(int iv){\t\tthis.iv=iv;\t}}스트림(Stream): 다양한 데이터 소스를 표준화한 방법으로 다루기 위한 것  스트림이 제공하는 기능 - 중간 연산과 최종 연산— 스트림 만들기 3단계      스트림만들기                  컬렉션 - Collection인터페이스의 stream()으로 컬렉션을 스트림으로 변환  Stream stream() //Collection인터페이스의 메소드            배열                              객체 배열로부터 스트림 생성하기  Stream Stream.of(가변인자) or Stream Arrays.stream(T[])                                기본형 배열로부터 스트림 생성하기(Stream이 아니라 IntStream)  IntStream IntStream.of(int….value) or IntStream Arrays.Stream(int[])                                      임의의 수(난수)를 요소로 갖는 스트림 생성          import java.util.Random;  import java.util.stream.IntStream;          class  Main{  \tpublic static void main(String[] args)  {        \t\t  \t\tIntStream intStream = new Random().ints();   \t\tintStream.limit(5).forEach(System.out::println);  \t\tSystem.out.println();  \t\tIntStream intStream2 = new Random().ints(5);   \t\tintStream2.forEach(System.out::println);  \t\tSystem.out.println();  \t\tIntStream intStream3 = new Random().ints(10,5,10);   \t\tintStream3.forEach(System.out::println);  \t}  }                            특정범위의 정수를 요소로 갖는 스트림 생성하기(IntStream, LongStream)  IntSream IntStream.range(int begin, int end)                    람다식으로 스트림만들기  static  Stream iterate(T seed, UnaryOperator f) //이전요소에 종속적    static  Stream generate(Supplier s) //이전요소에 독립적                              iterate() : 이전요소를 seed로 해서 다음 요소를 계산  Stream evenStream = Stream.iterate(0, n→n+2); //0,2,4,6,..                                generate() : seed를 사용하지 않음  Stream randomStream = Stream.generate(Math::random);    Stream oneStream = Stream.generate(()→1); //1,1,1,1,…..                            import java.util.Random;  import java.util.stream.IntStream;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\t//iterate(T seed, UnaryOperator f)  단항연산자  \t\tStream&lt;Integer&gt; intStream = Stream.iterate(0, n-&gt;n+2);  \t\tintStream.limit(10).forEach(System.out::println);  \t\tSystem.out.println();  \t\tStream&lt;Integer&gt; intStream2 = Stream.iterate(1, n-&gt;n+2);  \t\tintStream2.limit(10).forEach(System.out::println);  \t\tSystem.out.println();  \t\t//generate(Supplier s)  입력x, 출력o  \t\tStream&lt;Integer&gt; oneStream = Stream.generate(()-&gt;1);  \t\toneStream.limit(5).forEach(System.out::println);  \t}  }                            파일을 소스로 하는 스트림생성  Stream Files.list(Path dir); //Path는 파일 또는 디렉토리    Stream Files.lines(Path path)    Stream Files.lines(Path path, Charset cs)    Stream lines() //BufferedReader클래스의 메소드            비어있는 스트림 생성하기  Stream emptyStream = Stream.empty(); //empty()는 빈 스트림을 생성해서 반환  long count = emptyStream.count(); //count의 값은 0         List&lt;Integer&gt; list =Arrays.asList(1,2,3,4,5); \t\tStream&lt;Integer&gt; intStream = list.stream(); //컬렉션 \t\tStream&lt;String&gt; strStream = Stream.of(new String[] {\"a\",\"b\",\"c\"}); //배열 \t\tStream&lt;Integer&gt; evenStream = Stream.iterate(0,n-&gt;n+2); //0,2,4,6... \t\tStream&lt;Double&gt; randomStream = Stream.generate(Math::random);//람다식 \t\tIntStream intStream2 = new Random().ints(5); //난수 스트림. 크기가 5     //컬렉션으로 스트림 생성 \t\tintStream.forEach(System.out::print); //최종연산 //\tintStream.forEach(System.out::print); //최종연산을 해서 Stream이 닫힘    \t\t \t\tintStream=list.stream(); \t\tintStream.forEach(System.out::print); //최종연산         import java.util.Arrays; import java.util.stream.IntStream; import java.util.stream.Stream;     class  Main{ \tpublic static void main(String[] args)  { //\t\tList&lt;Integer&gt; list =Arrays.asList(1,2,3,4,5); //\t\tStream&lt;Integer&gt; intStream = list.stream(); //list를 Stream으로 변환 //\t\tintStream.forEach(System.out::print); //최종연산 ////\t\tintStream.forEach(System.out::print); //최종연산을 해서 Stream이 닫힘 //\t\t //\t\tintStream=list.stream(); //\t\tintStream.forEach(System.out::print); //최종연산    \t\t \t\tStream&lt;String&gt; strstream = Stream.of(new String[] {\"a\",\"b\",\"c\",\"d\"}); \t\tstrstream.forEach(System.out::println);    \t\t \t\t//기본형 \t\tint[] intArr = {1,2,3,4,5}; \t\tIntStream intStream = Arrays.stream(intArr); //\t\tintStream.forEach(System.out::println); //\t\tSystem.out.println(\"count = \"+intStream.count()); //최종연산 //\t\tSystem.out.println(\"sum = \"+intStream.sum()); //최종연산 \t\tSystem.out.println(\"avg = \"+intStream.average()); //최종연산    \t\t \t\t//참조형 //\t\tInteger[] intArr = {1,2,3,4,5}; //\t\tStream&lt;Integer&gt; intStream = Arrays.stream(intArr); //\t\tintStream.forEach(System.out::println); //\t\tSystem.out.println(\"count = \"+intStream.count()); //count말고 다른건 안됨(sum, avg 등) \t\t//Stream&lt;T&gt;는 숫자 외에도 여러타입의 스트림이 가능해서 숫자 스트림에서만 사용할 수 있는 sum(), average()는 뺌 \t} }        중간연산(0~n번) : 연산결과가 스트림인 연산. 반복적으로 적용가능          스트림 자르기 - skip(long n)[앞에서부터 n개 건너뛰기), limit()[잘라내기]      스트림의 요소 걸러내기- filter()[조건에 맞는요소만 남김], distinct()[중복제거]              스트림 정렬 - sorted()[정렬기준안주면 스트림요소의 기본정렬]                                      Comparator의 comparing()으로 정렬기준을 제공  comparing(Function&lt;T,U&gt; keyExteactor)  comparing(Function&lt;T,U&gt; keyExteactor, Comparator, keyComparetor)                                추가정렬기준을 제공할 때는 thenComparing()사용  thenComparing(Function&lt;T,U&gt; keyExteactor)  thenComparing(Function&lt;T,U&gt; keyExteactor, Comparator, keyComparetor)              import java.util.Comparator;  import java.util.stream.Stream;              class  Main{  \tpublic static void main(String[] args)  {  \t\tStream&lt;Student&gt; studentStream = Stream.of(  \t\t\t\tnew Student(\"이자바\",3,300),  \t\t\t\tnew Student(\"김자바\",1,200),  \t\t\t\tnew Student(\"안자바\",2,100),  \t\t\t\tnew Student(\"박자바\",2,150),  \t\t\t\tnew Student(\"소자바\",1,200),  \t\t\t\tnew Student(\"나자바\",3,290),  \t\t\t\tnew Student(\"감자바\",3,180));            \t\t  \t\tstudentStream.sorted(Comparator.comparing(Student::getBan) //반별정렬  \t\t\t\t.thenComparing(Comparator.naturalOrder()))//기본정렬  \t\t\t\t.forEach(System.out::println);  \t}  }              class Student implements Comparable&lt;Student&gt;{  \tString name;  \tint ban;  \tint totalScore;            \t  \tStudent(String name, int ban, int totalScore){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.totalScore=totalScore;  \t}  \tpublic String toString() {  \t\treturn String.format(\"[%s, %d, %d]\",name,ban,totalScore);  \t}            \t  \tString getName() {return name;}  \tint getBan() {return ban;}  \tint getTotalScore() {return totalScore;}            \t  \t//총점 내림차순을 기본정렬로 한다  \tpublic int compareTo(Student s) {  \t\treturn s.totalScore - this.totalScore;  \t}  }                                          스트림의 요소 변환 - map()              forEach(의 중간연산버전(스트림소비x : 반환타입 void) - peek() : 중간점검          import java.io.File;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\tFile fileArr[] = { new File(\"Ex1.java\"), new File(\"Ex1.bak\"), new File(\"ex2.java\"), new File(\"java\"), new File(\"Ex1.txt\")};  \t\tStream&lt;File&gt; fileStream = Stream.of(fileArr);  \t\t//map()으로 Stream&lt;File&gt;을 Stream&lt;String&gt;으로 변환  \t\tStream&lt;String&gt; filenameStream = fileStream.map(File::getName);  \t\tfilenameStream.forEach(System.out::println); //모든 파일이름 출력        \t\t  \t\tfileStream = Stream.of(fileArr); //스트림 재생성  \t\tfileStream.map(File::getName)  \t\t\t.filter(s-&gt;s.indexOf('.')!=-1)///확장자가 없는 것 제외  \t\t\t.peek(s-&gt;System.out.printf(\"filename=%s%n\",s))  \t\t\t.map(s-&gt;s.substring((s.indexOf('.')+1))) //확장자만 추출  \t\t\t.peek(s-&gt;System.out.printf(\"extension=%s%n\",s))  \t\t\t.map(String::toUpperCase) //모두 대문자로 변환  \t\t\t.distinct() //중복제거  \t\t\t.forEach(System.out::print); //JAVABAKTXT        \t\t  \t\tSystem.out.println();        \t\t  \t}  }                            스트림의 스트림을 스트림으로 변환 : 여러 스트림 배열을 하나의 스트림배열로 변환 - flatmap()          import java.io.File;  import java.util.Arrays;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\tStream&lt;String[]&gt; strArrStrm = Stream.of(  \t\t\t\tnew String[] {\"abc\",\"def\",\"jkl\"},  \t\t\t\tnew String[] {\"ABC\",\"GHI\",\"JKL\"}  \t\t\t\t);        \t\t  //\t\tStream&lt;Stream&lt;String&gt;&gt; strStrmStrm = strArrStrm.map(Arrays::stream);  //\t\tstrStrmStrm.forEach(System.out::println);  //\t\tSystem.out.println();  \t\t//두 스트림배열을 하나의 스트림배열로 합침  \t\tStream&lt;String&gt; strStrm = strArrStrm.flatMap(Arrays::stream);        \t\t  \t\tstrStrm.map(String::toLowerCase) //대문자-&gt;소문자  \t\t.distinct()  \t\t.sorted()  \t\t.forEach(System.out::println);  \t\tSystem.out.println();        \t\t  \t\tString lineArr[] = {  \t\t\t\t\"Believe or not It is true\",  \t\t\t\t\"Do or not There is no try\"  \t\t};        \t\t  \t\tStream&lt;String&gt; lineStream = Arrays.stream(lineArr);  \t\tlineStream.flatMap(line -&gt; Stream.of(line.split(\" +\")))  \t\t.map(String::toLowerCase)  \t\t.distinct()  \t\t.sorted()  \t\t.forEach(System.out::println);  \t}  }                          최종연산(1번) : 연산결과가 스트림이 아닌 연산. 단 한번만 적용가능(스트림의 요소를 소모)          스트림의 모든 요소에 지정된 작업을 수행 - forEach(), forEachOrdered()                  sequential() : 직렬스트림(생략가능)          parallel() : 병렬 스트림 (순서보장x) - forEachOrdered를 써야 순서유지가 됨                    조건검사                  allMatch() : 모든 요소가 조건을 만족시키면 true          anyMatch() : 한 요소라도 조건을 만족시키면 true          noneMatch() : 모든 요소가 조건을 만족시키지 않으면 true          findFirst() : 첫번째 요소를 반환, 순차 스트림에 사용(결과가 null일수도 있어 Optional사용)          findAny() : 아무거나 하나를 반환, 병렬 스트림에 이용(결과가 null일수도 있어 Optional사용)                    reduce() : 스트림의 요소를 하나씩 줄여가며 누적연산 수행 (count, max, min, sum, collect는 reduce를 바탕으로 만든것). 전체 리듀싱                  identity : 초기값(대부분 0)          accumulator : 이전연산결과와 스트림의 요소에 수행할 연산                       import java.util.Optional; import java.util.OptionalInt; import java.util.stream.IntStream; import java.util.stream.Stream;     class  Main{ \tpublic static void main(String[] args)  { \t\tString strArr[] = { \t\t\t\t\"Ingeritance\",\"Java\",\"Lambda\",\"stream\",\"OptionalDouble\", \t\t\t\t\"IntStream\",\"count\",\"sum\", \t\t\t\t}; \t\tStream.of(strArr) \t\t.parallel() //병렬정렬 \t\t.forEachOrdered(System.out::println); //순서유지 \t\tSystem.out.println(\"---------------------------\");    \t\t \t\tboolean noEmptyStr = Stream.of(strArr).noneMatch(s-&gt;s.length()==0); //문자열길이가 0인게 없으면 true //\t\tOptional&lt;String&gt; sWord = Stream.of(strArr).parallel().filter(s-&gt;s.charAt(0)=='s').findAny(); //시작이 's'인 것 중 아무거나 가져옴 - 실행할때마다 값이 다름 \t\tOptional&lt;String&gt; sWord = Stream.of(strArr).filter(s-&gt;s.charAt(0)=='s').findFirst(); //시작이 's'인 것 중 첫번째 거만 가져옴    \t\t \t\tSystem.out.println(\"noEmptyStr=\"+noEmptyStr); \t\tSystem.out.println(\"-----------------\"); \t\tSystem.out.println(\"sWord=\"+sWord.get()); \t\tSystem.out.println(\"---------------------------\");    \t\t \t\t//Stream&lt;String&gt;을 String&lt;Integer&gt;로 변환 //\t\tStream&lt;Integer&gt; intStream = Stream.of(strArr).map(String::length);    \t\t \t\t//Stream&lt;String[]&gt;을 IntStream으로 변환. 성능이 더 놓음 \t\tIntStream intStream1 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream2 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream3 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream4 = Stream.of(strArr).mapToInt(String::length);    \t    \t\t \t\tint count = intStream1.reduce(0,(a,b)-&gt;a+1); \t\tint sum = intStream2.reduce(0,(a,b)-&gt;a+b); //단어길이 모두 더하기    \t\t \t\tOptionalInt max = intStream3.reduce(Integer::max); //가장긴거 \t\tOptionalInt min = intStream4.reduce(Integer::min); //가장 짧은거 \t\tOptionalInt max2 = IntStream.empty().reduce(Integer::max); //가장긴거 \t\tSystem.out.println(\"count = \"+count); \t\tSystem.out.println(\"sum = \"+sum); \t\tSystem.out.println(\"max = \"+max.getAsInt()); \t\tSystem.out.println(\"min = \"+min.getAsInt()); \t\tSystem.out.println(\"max2 = \"+max2.orElse(0)); //결과가 없으면 0을 반환 \t\tSystem.out.println(\"max2 = \"+max2.orElseGet(()-&gt;0)); //결과가 없으면 0을 반환 \t} }                      collect() : Collector(interface)를 매개변수로 하는 스트림의 최종 연산. 그룹별 리듀싱이 가능함                  Collector : 수집(collect)에 필요한 메소드를 정의해 놓은 인터페이스, Collectors클래스에서 구현해놔서 다 할 필요 없음                  interface Collector&lt;T, A, R&gt;{//T(요소)를 A에 누적한 다음, 결과를 R로 변환해서 반환  \tSupplier&lt;A&gt;\t\t\t\tsupplier(); //StringBuilder::new  누적할 곳 - A  \tBiConsumer&lt;A, T&gt;\t\taccumulator();//(sb, s)-&gt;sb.appens(s) 누적방법  \tBinaryOperator&lt;A&gt;\t\tcombiner();//(sb1,sb2)-&gt;sb1.append(sb2) 결합방법(병렬)  \tFunction&lt;A, R&gt; \t\t\tfinisher();//sb-&gt;ab.toString() 최종변환  \tSet&lt;Characteristics&gt; \tcharacteristics();//컬렉터의 특성이 담긴 set을 반환 - R  }                                      Collectors : 클래스. 다양한 기능의 컬렉터(Collector를 구현한 클래스)를 제공                          변환 - mapping(), toList(), toSet(), toCollection() 등              통계 - counting(), summingInt(), averagingInt(), maxBy(), minBy(), summarizingInt() 등              문자열 결합 - joining()              리듀싱 - reducing() : 그룹별 리듀싱 가능              그룹화와 분할 - groupingBy(), partitioningBy(), collectingAndThen()                        — 스트림을 컬렉션으로 변환 - toList(), toSet(), toMap(), toCollection()            Collectors.toList() 이렇게 사용함            — 스트림을 배열로 변환 - toArray()                              ex) stream.distinct().limit(5).sorted().forEach(System.out::println)Stream&lt;String&gt; stream = Stream.of(strArr); //문자열배열이 소스인 스트림생성\t\tStream&lt;String&gt; filteredStream = stream.filter(); //걸러내기(중간연산)\t\tStream&lt;String&gt; distinctedStream = stream.distinct(); //중복 제거(중간연산)\t\tStream&lt;String&gt; sortedStream = stream.sorted();//정렬(중간연산)\t\tStream&lt;String&gt; limitedStream = stream.limit(5);//스트림자르기(중간연산);\t\tint total = stream.count(); //요소 개수 세기(최종연산)  스트림의 특징          데이터소스로부터 데이터를 읽기만 할 뿐, 변경하지 않음(원본을 건들지 않음. read only)      Iterator처럼 일회용이다(필요하면 다시 스트림을 생성해야함) : 최종연산 후 스트림이 닫혀 사용할 수 없음      최종연산 전까지 중간연산이 수행되지 않는다. - 지연된 연산      작업을 내부 반복으로 처리한다.      작업을 병렬로 처리 - stream.parallel() : 병렬스트림으로 전환(속성만 변경)      기본형 스트림 - IntStream, LongStream, DoubleStream                  오토박싱&amp;언박싱의 비효율이 제거(Stream대신 IntStream사용) - 데이터소스가 기본형일때 사용가능          숫자와 관련된 유용한 메소드를 Stream보다 더 많이 제공                          스트림의 그룹화와 분할                  partitioningBy()는 스트림을 2분할함(다중분할 가능)          import java.util.*;  import java.util.function.*;  import java.util.stream.*;  import static java.util.stream.Collectors.*;  import static java.util.Comparator.*;          class Student{  \tString name;  \tboolean isMale; // 성별  \tint hak;        // 학년  \tint ban;        // 반  \tint score;          \tStudent(String name, boolean isMale, int hak, int ban, int score) {   \t\tthis.name\t= name;  \t\tthis.isMale\t= isMale;  \t\tthis.hak\t= hak;  \t\tthis.ban\t= ban;  \t\tthis.score  = score;  \t}  \tString\tgetName()    { return name;\t}  \tboolean  isMale()     { return isMale;\t}  \tint      getHak()     { return hak;\t}  \tint      getBan()     { return ban;\t}  \tint      getScore()   { return score;}        \t  \tpublic String toString() {  \t\treturn String.format(\"[%s, %s, %d학년 %d반, %3d점]\",name, isMale ? \"남\":\"여\", hak, ban, score);   \t}        \t  \t   // groupingBy()에서 사용  \t\tenum Level { HIGH, MID, LOW }  // 성적을 상, 중, 하 세 단계로 분류  }  class  Main{  \tpublic static void main(String[] args)  {  \t\tStudent[] stuArr = {  \t\t\t\tnew Student(\"나자바\", true,  1, 1, 300),\t  \t\t\t\tnew Student(\"김지미\", false, 1, 1, 250),\t  \t\t\t\tnew Student(\"김자바\", true,  1, 1, 200),\t  \t\t\t\tnew Student(\"이지미\", false, 1, 2, 150),\t  \t\t\t\tnew Student(\"남자바\", true,  1, 2, 100),\t  \t\t\t\tnew Student(\"안지미\", false, 1, 2,  50),\t  \t\t\t\tnew Student(\"황지미\", false, 1, 3, 100),\t  \t\t\t\tnew Student(\"강지미\", false, 1, 3, 150),\t  \t\t\t\tnew Student(\"이자바\", true,  1, 3, 200),\t  \t\t\t\tnew Student(\"나자바\", true,  2, 1, 300),\t  \t\t\t\tnew Student(\"김지미\", false, 2, 1, 250),\t  \t\t\t\tnew Student(\"김자바\", true,  2, 1, 200),\t  \t\t\t\tnew Student(\"이지미\", false, 2, 2, 150),\t  \t\t\t\tnew Student(\"남자바\", true,  2, 2, 100),\t  \t\t\t\tnew Student(\"안지미\", false, 2, 2,  50),\t  \t\t\t\tnew Student(\"황지미\", false, 2, 3, 100),\t  \t\t\t\tnew Student(\"강지미\", false, 2, 3, 150),\t  \t\t\t\tnew Student(\"이자바\", true,  2, 3, 200)\t  \t\t\t};  \t\tSystem.out.printf(\"1. 단순분할(성별로 분할)%n\");  \t\tMap&lt;Boolean, List&lt;Student&gt;&gt; stuBySex =  Stream.of(stuArr).collect(partitioningBy(Student::isMale));        \t\t  \t\tList&lt;Student&gt; maleStudent   = stuBySex.get(true);  \t\tList&lt;Student&gt; femaleStudent = stuBySex.get(false);        \t\t  \t\tfor(Student s : maleStudent)   System.out.println(s);  \t\tfor(Student s : femaleStudent) System.out.println(s);        \t\t  \t\tSystem.out.printf(\"%n2. 단순분할 + 통계(성별 학생수)%n\");  \t\tMap&lt;Boolean, Long&gt; stuNumBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale, counting()));\t          \t\tSystem.out.println(\"남학생 수 :\"+ stuNumBySex.get(true));  \t\tSystem.out.println(\"여학생 수 :\"+ stuNumBySex.get(false));        \t\t  \t\tSystem.out.printf(\"%n3. 단순분할 + 통계(성별 1등)%n\");  \t\tMap&lt;Boolean, Optional&lt;Student&gt;&gt; topScoreBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale, maxBy(comparingInt(Student::getScore))));  \t\tSystem.out.println(\"남학생 1등 :\"+ topScoreBySex.get(true));  \t\tSystem.out.println(\"여학생 1등 :\"+ topScoreBySex.get(false));        \t  \t\tMap&lt;Boolean, Student&gt; topScoreBySex2 = Stream.of(stuArr).collect(partitioningBy(Student::isMale,collectingAndThen(maxBy(comparingInt(Student::getScore)), Optional::get)));  \t\tSystem.out.println(\"남학생 1등:\"+topScoreBySex.get(true));  \t\tSystem.out.println(\"여학생 1등:\"+topScoreBySex.get(false));        \t\t  \t\tSystem.out.printf(\"%n4.다중분할(성적 불합격자, 100점 이하)%n\");        \t\t  \t\tMap&lt;Boolean, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; failedstuBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale,partitioningBy(s-&gt;s.getScore()&lt;=100)));        \t\t  \t\tList&lt;Student&gt; failedMaleStu   = failedstuBySex.get(true).get(true);  \t\tList&lt;Student&gt; failedFemaleStu = failedstuBySex.get(false).get(true);        \t\t  \t\tfor(Student s : failedMaleStu)   System.out.println(s);  \t\tfor(Student s : failedFemaleStu) System.out.println(s);        \t  \t}  }                            groupingBy()는 스트림을 n분할함                import java.util.*;  import java.util.function.*;  import java.util.stream.*;  import static java.util.stream.Collectors.*;  import static java.util.Comparator.*;      class Student3 {  \tString name;  \tboolean isMale; // 성별  \tint hak;        // 학년  \tint ban;        // 반  \tint score;      \tStudent3(String name, boolean isMale, int hak, int ban, int score) {   \t\tthis.name\t= name;  \t\tthis.isMale\t= isMale;  \t\tthis.hak   \t= hak;  \t\tthis.ban\t= ban;  \t\tthis.score \t= score;  \t}      \tString\tgetName() \t { return name;    }  \tboolean isMale()  \t { return isMale;  }  \tint\t\tgetHak()   \t { return hak;\t   }  \tint\t\tgetBan()  \t { return ban;\t   }  \tint\t\tgetScore()\t { return score;   }      \tpublic String toString() {  \t\treturn String.format(\"[%s, %s, %d학년 %d반, %3d점]\", name, isMale ? \"남\" : \"여\", hak, ban, score);  \t}      \tenum Level {  \t\tHIGH, MID, LOW  \t}  }      class Main {  \tpublic static void main(String[] args) {  \t\tStudent3[] stuArr = {  \t\t\tnew Student3(\"나자바\", true,  1, 1, 300),\t  \t\t\tnew Student3(\"김지미\", false, 1, 1, 250),\t  \t\t\tnew Student3(\"김자바\", true,  1, 1, 200),\t  \t\t\tnew Student3(\"이지미\", false, 1, 2, 150),\t  \t\t\tnew Student3(\"남자바\", true,  1, 2, 100),\t  \t\t\tnew Student3(\"안지미\", false, 1, 2,  50),\t  \t\t\tnew Student3(\"황지미\", false, 1, 3, 100),\t  \t\t\tnew Student3(\"강지미\", false, 1, 3, 150),\t  \t\t\tnew Student3(\"이자바\", true,  1, 3, 200),\t  \t\t\tnew Student3(\"나자바\", true,  2, 1, 300),\t  \t\t\tnew Student3(\"김지미\", false, 2, 1, 250),\t  \t\t\tnew Student3(\"김자바\", true,  2, 1, 200),\t  \t\t\tnew Student3(\"이지미\", false, 2, 2, 150),\t  \t\t\tnew Student3(\"남자바\", true,  2, 2, 100),\t  \t\t\tnew Student3(\"안지미\", false, 2, 2,  50),\t  \t\t\tnew Student3(\"황지미\", false, 2, 3, 100),\t  \t\t\tnew Student3(\"강지미\", false, 2, 3, 150),\t  \t\t\tnew Student3(\"이자바\", true,  2, 3, 200)\t  \t\t};      \t\tSystem.out.printf(\"1. 단순그룹화(반별로 그룹화)%n\");  \t\tMap&lt;Integer, List&lt;Student3&gt;&gt; stuByBan = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getBan));      \t\tfor(List&lt;Student3&gt; ban : stuByBan.values()) {  \t\t\tfor(Student3 s : ban) {  \t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}      \t\tSystem.out.printf(\"%n2. 단순그룹화(성적별로 그룹화)%n\");  \t\tMap&lt;Student3.Level, List&lt;Student3&gt;&gt; stuByLevel = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(s-&gt; {  \t\t\t\t\t\t if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\telse                         return Student3.Level.LOW;  \t\t\t\t}));      \t\tTreeSet&lt;Student3.Level&gt; keySet = new TreeSet&lt;&gt;(stuByLevel.keySet());      \t\tfor(Student3.Level key : keySet) {  \t\t\tSystem.out.println(\"[\"+key+\"]\");      \t\t\tfor(Student3 s : stuByLevel.get(key))  \t\t\t\tSystem.out.println(s);  \t\t\tSystem.out.println();  \t\t}      \t\tSystem.out.printf(\"%n3. 단순그룹화 + 통계(성적별 학생수)%n\");  \t\tMap&lt;Student3.Level, Long&gt; stuCntByLevel = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(s-&gt; {  \t\t\t\t\t     if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\telse                         return Student3.Level.LOW;  \t\t\t\t}, counting()));  \t\tfor(Student3.Level key : stuCntByLevel.keySet())  \t\t\tSystem.out.printf(\"[%s] - %d명, \", key, stuCntByLevel.get(key));  \t\tSystem.out.println();  /*  \t\tfor(List&lt;Student3&gt; level : stuByLevel.values()) {  \t\t\tSystem.out.println();  \t\t\tfor(Student3 s : level) {  \t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}  */  \t\tSystem.out.printf(\"%n4. 다중그룹화(학년별, 반별)\");  \t\tMap&lt;Integer, Map&lt;Integer, List&lt;Student3&gt;&gt;&gt; stuByHakAndBan =            Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getHak,  \t\t\t\t\t\t groupingBy(Student3::getBan)  \t\t\t\t));      \t\tfor(Map&lt;Integer, List&lt;Student3&gt;&gt; hak : stuByHakAndBan.values()) {  \t\t\tfor(List&lt;Student3&gt; ban : hak.values()) {  \t\t\t\tSystem.out.println();  \t\t\t\tfor(Student3 s : ban)  \t\t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}      \t\tSystem.out.printf(\"%n5. 다중그룹화 + 통계(학년별, 반별 1등)%n\");  \t\tMap&lt;Integer, Map&lt;Integer, Student3&gt;&gt; topStuByHakAndBan =            Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getHak,  \t\t\t\t\t\t groupingBy(Student3::getBan,  \t\t\t\t\t\t     collectingAndThen(  \t\t\t\t\t\t         maxBy(comparingInt(Student3::getScore))  \t\t\t\t\t\t         , Optional::get  \t\t\t\t\t\t     )  \t\t\t\t\t\t )  \t\t\t\t));      \t\tfor(Map&lt;Integer, Student3&gt; ban : topStuByHakAndBan.values())  \t\t\tfor(Student3 s : ban.values())  \t\t\t\tSystem.out.println(s);      \t\tSystem.out.printf(\"%n6. 다중그룹화 + 통계(학년별, 반별 성적그룹)%n\");  \t\tMap&lt;String, Set&lt;Student3.Level&gt;&gt; stuByScoreGroup = Stream.of(stuArr)  \t\t\t.collect(groupingBy(s-&gt; s.getHak() + \"-\" + s.getBan(),  \t\t\t\t\tmapping(s-&gt; {  \t\t\t\t\t\t if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\t\t else                    return Student3.Level.LOW;  \t\t\t\t\t} , toSet())  \t\t\t));      \t\tSet&lt;String&gt; keySet2 = stuByScoreGroup.keySet();      \t\tfor(String key : keySet2) {  \t\t\tSystem.out.println(\"[\"+key+\"]\" + stuByScoreGroup.get(key));  \t\t}  \t}    }      Optional: T타입 객체의 래퍼클래스. null을 간접적으로 사용하기 위해 씀null을 Optional객체 안에 넣어서 사용. null값이 필요할떄 빈Optional객체의 주소값을 받음  Optional객체의 값 가지고 오기 - get(), orElse(), orElseGet(), orElseThrow()  isPresent() : Optional객체의 값이 null이면 false, 아니면 true - null이 아닐때만 작업 수행— 사용이유  null을 직접 다루는 것은 위험 - nullPointException 위험 → 간접적으로 null을 사용하기 위해 사용  null체크는 if문 필수 : 코드가 지저분해짐 → 코드를 깔끔히 하기위해 사용import java.util.Optional;class  Main{\tpublic static void main(String[] args)  {//\t\tint arr[] = null; //nullpointException발생\t\tint arr[] = new int[0];\t\tSystem.out.println(\"arr.length = \"+arr.length);\t\t//\t\tOptional&lt;String&gt; opt = null; //가능한데 바람직하지않음\t\tOptional&lt;String&gt; opt = Optional.empty();//\t\tOptional&lt;String&gt; opt = Optional.of(\"abc\");\t\tSystem.out.println(\"opt=\"+opt);//\t\tSystem.out.println(\"opt.get()=\"+opt.get()); //에러. 값이없어서. 이래서 잘 안씀//\t\tString str = \"\";//\t\ttry {//\t\t\tstr = opt.get(); //\t\t} catch (Exception e) {//\t\t\tstr = \"\"; //예외 발생시 빈문자열(\"\")로 초기화//\t\t}//\t\tSystem.out.println();\t\t\t\t//Optional에 저장된 값이 null이면 \"\"반환//\t\tString str = opt.orElse(\"\");//\t\tString str = opt.orElseGet(()-&gt;new String());\t\tString str = opt.orElseGet(String::new);\t\tSystem.out.println(\"str=\"+str);\t}}      기본형을 감싸는 래퍼클래스 - OptionalInt, OptionalLong, OptionalDouble - Optional를 써도 되지만 성능이 떨어짐                            Optional클래스          값을 반환하는 메소드                                      Optional          T get()                          OptionalInt          int gerAsInt()                          OptionalLong          long gerAsLong()                          OptionalDouble          double getAsDouble()                            빈 Optional객체와의 비교 - OptionalInt.of(0)과 OptionalInt.empty() 구별에 isPresent()를 사용  OptionalInt.of(0)은 true, OptionalInt.empty()는 false. 두개 equals해도 false나옴          import java.util.Optional;  import java.util.OptionalInt;      class  Main{  \tpublic static void main(String[] args)  {  \t\tOptional&lt;String&gt; optStr = Optional.of(\"abcde\");  \t\tOptional&lt;Integer&gt; optInt = optStr.map(String::length);  \t\tSystem.out.println(\"optStr=\"+optStr.get());  \t\tSystem.out.println(\"optInt=\"+optInt.get());    \t\t  \t\tint result1 = Optional.of(\"123\")  \t\t\t\t.filter(x-&gt;x.length() &gt;0)  \t\t\t\t.map(Integer::parseInt).get();    \t\t  \t\tint result2 = Optional.of(\"\")  \t\t\t\t.filter(x-&gt;x.length() &gt;0) //false  \t\t\t\t.map(Integer::parseInt).orElse(-1); //값이 없으면 -1 반환    \t\t  \t\tSystem.out.println(\"result1 = \"+result1);  \t\tSystem.out.println(\"result2 = \"+result2);    \t\t  \t\tOptional.of(\"456\").map(Integer::parseInt)  \t\t.ifPresent(x-&gt;System.out.printf(\"result3 = %d%n\",x)); //ifPresent : 값이 있으면    \t\t  \t\tOptionalInt optInt1 = OptionalInt.of(0); //0을 저장  \t\tOptionalInt optInt2 = OptionalInt.empty(); //빈 객체 생성    \t\t  \t\tSystem.out.println(optInt1.isPresent()); //true  \t\tSystem.out.println(optInt2.isPresent()); //false  \t\tSystem.out.println(\"optInt1=\"+optInt1);  \t\tSystem.out.println(\"optInt2=\"+optInt2);  \t\tSystem.out.println(\"opt1.equals(optInt2)?\"+optInt1.equals(optInt2));//false  \t}  }      "
  },
  
  {
    "title": "자바의 정석 강의 - 쓰레드(thread)",
    "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C(thread)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 쓰레드",
    "date": "2022-08-28 00:00:00 +0900",
    





    
    "snippet": "프로세스와 쓰레드(process &amp; thread)  프로세스 : 실행중인 프로그램. 자원(resources)과 쓰레드로 구성 (공장)  쓰레드 : 프로세스 내에서 실제 작업을 수행. 모든 프로세서는 최소 하나의 쓰레드를 가지고 있다. (일꾼)      싱글 쓰레드 프로세스 = 자원 + 쓰레드      public class  Main {    ...",
    "content": "프로세스와 쓰레드(process &amp; thread)  프로세스 : 실행중인 프로그램. 자원(resources)과 쓰레드로 구성 (공장)  쓰레드 : 프로세스 내에서 실제 작업을 수행. 모든 프로세서는 최소 하나의 쓰레드를 가지고 있다. (일꾼)      싱글 쓰레드 프로세스 = 자원 + 쓰레드      public class  Main {      \tpublic static void main(String[] args) {  \t\tlong startTime = System.currentTimeMillis();    \t\t  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.printf(\"%s\", new String(\"-\"));  \t\t}    \t\t  \t\tSystem.out.println(\"소요시간 1 : \"+(System.currentTimeMillis()-startTime));    \t\t  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.printf(\"%s\", new String(\"|\"));  \t\t}  \t\tSystem.out.println(\"소요시간 2 : \"+(System.currentTimeMillis()-startTime));  \t} // 싱글쓰레드라 작업이 겹치지 않음  }        멀티 쓰레드 프로세스 = 자원 + 쓰레드 + 쓰레드…+쓰레드 (대부분이 멀티쓰레드)          장점                  시스템 자원을 보다 효율적으로 사용가능          사용자에 대한 응답성(responsencess)이 향상된다.          작업이 분리되어 코드가 간결해짐                            단점 : 고려할 사항이 많음                  동기화(synchronization)에 주의          교착상태(dead-lock)가 발생하지 않도록 주의          각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야함          context switching(쓰레드 전환)으로 시간이 좀 더 걸림                  public class  Main {          \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tThread2 t2 = new Thread2();  \t\tt1.start();  \t\tt2.start();  \t}   }          class Thread1 extends Thread{  \tpublic void run () {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t}  }  class Thread2 extends Thread{  \tpublic void run () {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(\"|\");  \t\t}  \t}  }  //멀티쓰레드라 번갈아가면서 실행됨                  public class  Main {  \tstatic long startTime = 0;          \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tt1.start();   \t\tstartTime = System.currentTimeMillis();        \t\t  \t\tfor(int i=0; i&lt;300; i++)   \t\t\tSystem.out.printf(\"%s\",new String(\"-\"));        \t\t  \t\tSystem.out.println(\"소요시간1 : \"+(System.currentTimeMillis() - startTime));  \t}  }          class Thread1 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++)   \t\t\tSystem.out.printf(\"%s\", new String(\"|\"));        \t\t  \t\tSystem.out.println(\"소요시간2 : \"+(System.currentTimeMillis() - Main.startTime));  \t}  }  // 멀티쓰레드라 번갈아가면서 실행됨                      쓰레드 구현과 실행                  Thread클래스를 상속(자바는 단일상속만 허용해서 쓰레드를 상속받으면 다른 것은 상속받을수 없음  class MyThread wxtends Thread { public void run(){ /Thread클래스의 run()을 오버라이딩/ }}  MyThread t = new MyThread(); //쓰레드 생성  t1.start(); //쓰레드의 실행                    Runnable인터페이스를 구현        class TyThread implements Runnable { public void run() { /Runnable인터페이스의 추상메소드 run()을 구현/}}  Runnable r = new MyThread();  Thread t = new Thread(r); //Thread(Runnable r)  //Thread t = new Thread(new MyThread()); //위에꺼 한줄로 줄임  t.start();                  쓰레드의 실행 - start() : 쓰레드를 생성한 후에 start를 호출해야 쓰레드가 작업을 시작함    — 각각의 쓰레드가 각각의 호출 스택을 가지고 있어 서로 독립적으로 작업을 수행함      public class  Main {  \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();    \t\t  \t\tRunnable r = new Thread2();  \t\tThread t2 = new Thread(r);  //생성자 Thread(Runnable target)    \t\t  \t\tt1.start(); //start했다고 바로 실행 안됨  \t\tt2.start(); //OS의 스케줄러가 실행순서를 결정. t1이 먼저 실행될 확률이 높기는 하나 100프로는 아님  \t}  }      class Thread1 extends Thread { //쓰레드 클래스를 상속해서 구현  \tpublic void run() { //쓰레드가 수행할 작업을 작성  \t\tfor(int i=0; i&lt;500; i++) {  \t\t\tSystem.out.print(getName()); //조상인 Thread의 getName()을 호출  \t\t}  \t}  }      class Thread2 implements Runnable{ //Runnable인터페이스를 구현해서 쓰레드를 구현  \tpublic void run() { ////쓰레드가 수행할 작업을 작성  \t\tfor(int  i=0;i&lt;500;i++) {  \t\t\t//Thread.currentThread() - 현재 실행중인 Thread를 반환  \t\t\tSystem.out.print(Thread.currentThread().getName());  \t\t}  \t}  }  //순서대로 실행되는게 아니라 번갈아서 실행됨        start()와 run()      main쓰레드 : main메소드의 코드를 수행하는 쓰레드.      public class  Main {  \tstatic long startTime = 0;      \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tThread2 t2 = new Thread2();  \t\tt1.start();   \t\tt2.start();   \t\tstartTime = System.currentTimeMillis();    \t\t  \t\ttry {  \t\t\tt1.join(); //main쓰레드가 th1의 작업이 끝날 떄까지 기다린다.  \t\t\tt2.join(); //main쓰레드가 th2의 작업이 끝날 때까지 기다린다.  \t\t}catch(InterruptedException e) {}    \t\t  \t\tSystem.out.println(\"소요시간 : \"+(System.currentTimeMillis() - startTime));  \t}  }      class Thread1 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t}  }  class Thread2 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"|\");   \t\t}  \t}  }              사용자 쓰레드                  메인쓰레드.          실행중인 사용자쓰레드가 하나도 없을때, 프로그램 종료                            데몬 쓰레드(daemon Thread)                  일반 쓰레드(non-daemon thread)의 작업을 돕는 보조적인 역할을 수행          일반쓰레드가 모두 종료되면 자동적으로 종료된다          가비지 컬렉터(쓰지않는 메모리 정리), 자동저장, 화면 자동갱신 등에 사용됨          무한루프와 조건문(while(true) 등)을 이용해서 실행 후 대기하다가 특정조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다.                  boolean inDaemon() //쓰레드가 데몬 쓰레드인지 확인. 데몬쓰레드이면 true반환  void setDaemon(boolean on) //쓰레드를 데몬쓰레드로 또는 사용자 쓰레드로 변경. 매개변수 on을 true로 지정하면 데몬쓰레드가 된다.                  public class  Main implements Runnable {  \tstatic boolean autoSave = false;          \tpublic static void main(String[] args) {  \t\tThread t = new Thread(new Main()); //Thread(Runnable r)  \t\tt.setDaemon(true); //이부분이 없이면 종료되지 않음  \t\tt.start();        \t\t  \t\tfor(int i=1;i&lt;=10;i++) {  \t\t\ttry {  \t\t\t\tThread.sleep(1000);  \t\t\t}catch (InterruptedException e) {}  \t\t\tSystem.out.println(i);        \t\t\t  \t\t\tif(i==5) autoSave = true;  \t\t}  \t\tSystem.out.println(\"프로그램을 종료합니다.\");  \t}  \tpublic void run() {  \t\twhile(true) { //무한루프지만 메인쓰레드가 종료되면(일반쓰레드가 하나도 없으면) 같이 종료될 예정임(데몬쓰레드라서)  \t\t\ttry {  \t\t\t\tThread.sleep(3*1000);//3초마다  \t\t\t}catch(InterruptedException e) {}        \t\t\t  \t\t\tif(autoSave) autoSave();  \t\t}  \t}  \tprivate void autoSave() {  \t\tSystem.out.println(\"파일이 자동저장되었습니다\");  \t}\t  }                          쓰레드의 I/O블락킹(blocking) : 사용자가 입력할때까지 아무것도 하지않고 멈춤(멀티쓰레드는 이때에 다른 쓰레드가 일하면 됨)  ⇒ 멀티쓰레드일때 더 빠름          싱글쓰레드          import javax.swing.JOptionPane;      public class  Main {      \tpublic static void main(String[] args) {  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은 \" +input+\"입니다.\");    \t\t  \t\tfor(int i=10; i&gt;0; i--) {  \t\t\tSystem.out.println(i);  \t\t\ttry {  \t\t\t\tThread.sleep(100); //1초간 정지  \t\t\t}catch (Exception e) {}  }  \t}  }              멀티쓰레드          import javax.swing.JOptionPane;      public class  Main {      \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tth1.start();    \t\t  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은 \" +input+\"입니다.\");    \t\t  \t\t}\t  \t}      class Thread1 extends Thread{  \tpublic void run() {  \t\tfor(int i=10; i&gt;0; i--) {  \t\t\tSystem.out.println(i);  \t\t\ttry {  \t\t\t\tThread.sleep(100); //1초간 정지  \t\t\t}catch (Exception e) {}  \t\t}  \t}  }  //입력을 안해도 카운트다운이 진행됨. -&gt; 프로그램 먼저 종료            쓰레드의 우선순위(priority of thread) : 작업의 중요도에 따라 쓰레드의 우선순위를 다르게 하여 특정 쓰레드가 더 많은 작업시간을 갖게 할 수 있다. (1~10까지 부여. 10이 최대 우선순위, 5가 보통 우선순위, 1이 최소 우선순위)      void setPriority(int new Priority); //쓰레드의 우선순위를 지정한 값으로 변경  int getPriority();      public static final int MAX_PRIORITY = 10; //최대 우선순위  public static final int MIN_PRIORITY = 1; //최소 우선순위  public static final int NORM_PRIORITY = 5; //보통 우선순위            쓰레드 그룹          서로 관련된 쓰레드를 그룹으로 묶어서 다루기위한 것      모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함되어 있어야한다.      쓰레드 그룹을 지정하지 않으면 생성한 쓰레드는 ‘main쓰레드 그룹’에 속한다      자신을 생성한 쓰레드(부모 쓰레드)의 그룹과 우선순위를 상속받는다.          Thread(ThreadGroup group, String name)  Thread(ThreadGroup group, Runnable target)  Thread(ThreadGroup group, Runnable target, String name)  Thread(ThreadGroup group, Runnable target, String name, long stackSize)      ThreadGroup getThreadGroup() //자신이 속한 쓰레드 그룹을 반환한다.  void uncaughtException(Thread t, Throwable e) //처리되지 않은 예외에 의해 쓰렏  //그룹에 의해 쓰레드가 실행종료되었을 때, JVM에 의해 매소드가 자동적으로 호출된가.                                ![[IMG-20240902151251.png          IMG-20240902151251.png]]                          쓰레드의 상태                            상태          설명                                      NEW          쓰레드가 _생성_되고 아직 start가 호출되지 않은 상태                          RUNNABLE          실행 중 또는 실행 가능한 상태(대기열에 대기중)                          BLOCKED          동기화 블럭에 의해 _일시정지_된 상태(lock이 풀릴 때 까지 기다리는 상태)                          WAITING TIMED_WAITING          쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnalble) 일시정지상태, TIMED_WAITING은 _일시정지시간_이 지정된 경우를 의미                          TERMINATED          쓰레드의 작업이 _종료_된 상태                          쓰레드의 실행제어          쓰레드의 실행을 제어할 수 있는 메소드가 제공된다.                                ![[IMG-20240902151251-1.png          IMG-20240902151251-1.png]]                      static붙은건 자기 자신에게만 적용됨                  sleep() : 현재 스레드를 지정된 시간동안 멈추게 한다.  static void sleep(long millis) //천분의 1초 단위  static void sleep(long millis, int nanos) //천분의 일초 + 나노초                              예외처리를 해줘야 한다. 예외 필수처리(InterruptedException이 발생하면 깨어남)            try { Thread.sleep(1,500000); //쓰레드를 0.0015초동안 멈추게한다  } catch (InterruptedException e){} //누가 깨운 상태                                특정 쓰레드를 지정해서 멈추게 하는 것은 불가능하다.(th1.sleep()으로 쓰면 가능은 하지만 오해의 여지가 있어서 Thread.sleep()으로 써야함)                            class  Main{  \tstatic void delay(long millis) {  \t\ttry {  //\t\t\tth1.sleep(2000); //th1을 2초 잠자게가 아니고 main쓰레드가 잠이드는데, 이렇게 쓰면 헷갈림  \t\t\tThread.sleep(millis);  \t\t}catch (InterruptedException e){}  \t}  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tThread2 th2 = new Thread2();  \t\tth1.start();  \t\tth2.start();        \t\t  \t\tdelay(2*1000);        \t\t  \t\tSystem.out.println(\"&lt;&lt;main 종료&gt;&gt;\");  \t}  }  class Thread1 extends Thread {  \tpublic void run(){  \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t\tSystem.out.println(\"&lt;&lt;th1 종료&gt;&gt;\");  \t}  }  class Thread2 extends Thread {  \tpublic void run(){  \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"|\");  \t\t}  \t\tSystem.out.println(\"&lt;&lt;th2 종료&gt;&gt;\");  \t}  }                            interrupt()                  대기상태(WAITING)의 쓰레드를 실행대기 상태(RUNNABLE) 로 만든다                  import javax.swing.JOptionPane;          class  Main{  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tth1.start();        \t\t  \t\tSystem.out.println(\"interrupted() : \"+th1.isInterrupted()); //true반환  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은\"+input+\"입니다\");  \t\tth1.interrupt();  \t\tSystem.out.println(\"isInterrupted() : \"+th1.isInterrupted()); //true반환  \t\tSystem.out.println(\"isInterrupted() : \"+th1.isInterrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+th1.interrupted()); //false반환. static메소드임. main쓰레드의 Interrupt되었는지 확인  \t\t//카운트 세는 도중, 입력값을 주면 카운트 종료  \t\t//게임에서 계속하시겠습니까?하고 카운트세다가 y/n선택하면 카운트 종료되는거 이거임  \t}  }  class Thread1 extends Thread{  \tpublic void run() {  \t\tint i=10;        \t\t  \t\twhile (i!=0 &amp;&amp; !isInterrupted()) {  \t\t\tSystem.out.println(i--);  \t\t\tfor(long x=0;x&lt;2500000000L;x++); //시간지연  \t\t}  \t\tSystem.out.println(\"isInterrupted() : \"+this.isInterrupted()); //true반환  \t\tSystem.out.println(\"isInterrupted() : \"+this.isInterrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+this.interrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+this.interrupted()); //false 위에서 확인 후 초기화 됨.  \t\t//isInterrupted()와 달리 interrupted는 interrupted라는 상태변수를 false로 초기화  \t\tSystem.out.println(\"카운트가 종료되었습니다.\");  \t}  }                      — 아래 3개 모두 deprecated되었음. 사용 권장안함. dead-lock가능성이 있음          suspend() : 쓰레드 일시정지      resume() : suspend()에 의해 일시정지 된 쓰레드를 실행대기상태로 만든다. (재개)      stop() : 완전 정지. 즉시종료          class  Main{  \tpublic static void main(String[] args) {  \t\tMyThread th1 = new MyThread(\"*\");  \t\tMyThread th2 = new MyThread(\"**\");  \t\tMyThread th3 = new MyThread(\"***\");    \t\t  \t\tth1.start();  \t\tth2.start();  \t\tth3.start();    \t\t  \t\ttry {  \t\t\tThread.sleep(2000);  \t\t\tth1.suspend(); //쓰레드 th1을 잠시 중단  \t\t\tThread.sleep(2000);  \t\t\tth2.suspend();   \t\t\tThread.sleep(3000);  \t\t\tth1.resume(); //쓰레드 th1 재 동작  \t\t\tThread.sleep(3000);  \t\t\tth1.stop();  \t\t\tth2.stop();  \t\t\tThread.sleep(2000);  \t\t\tth3.stop();  \t\t} catch (InterruptedException e) {}  \t}  }      class MyThread implements Runnable{  \tvolatile boolean suspended = false;   \t//volatile : 쉽게 바뀌는 변수(cpu의 코어는 복사본을 가지고 있는데(가끔 원본의 값이 변경됐을때 복사본의 값은 안바뀌는 경우 발생), volatile을 사용하면 원본을 바로 사용함  \t//자주 바뀌는 값이니까 복사본말고 원본 쓰라는 의미  \tvolatile boolean stopped = false;     \t  \tThread th;    \t  \tMyThread(String name){  \t\tth = new Thread(this,name);  \t}  \tvoid start() {  \t\tth.start();  \t}    \t  \tvoid stop() {  \t\tstopped = true;  \t}    \t  \tvoid suspend() { //일시정지  \t\tsuspended = true;  \t}    \t  \tvoid resume() { //재실행  \t\tsuspended = false;  \t}  \tpublic void run() {  \t\twhile(!stopped) {  \t\t\tif(!suspended) {  \t\t\tSystem.out.println(Thread.currentThread().getName());  \t\t\ttry {  \t\t\t\tThread.sleep(1000); //1초마다 쓰레드 이름찍기  \t\t\t} catch(InterruptedException e) {}  \t\t\t}  \t\t}  \t}  }              join() : 지정된 시간동안 특정 쓰레드가 작업하는 것을 기다린다. 예외처리 필수 (InterruptedException이 발생하면 작업 재개)          class  Main{  \tstatic long starttime = 0;  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tThread2 th2 = new Thread2();  \t\tth1.start();  \t\tth2.start();  \t\tstarttime = System.currentTimeMillis();    \t\t  \t\ttry {  \t\t\tth1.join(); //main쓰레드가 th1의 작업이 끝날때까지 기다린다.  \t\t\tth2.join(); //main쓰레드가 th2의 작업이 끝날때까지 기다린다.  \t\t}catch(InterruptedException e) {}  \t\t//이거 안해주면 main쓰레드가 먼저 끝나서 소요시간이 제대로 안나옴. 덜끝났는데 시간을 계산해버림    \t\t  \t\tSystem.out.println(\"소요시간 : \"+(System.currentTimeMillis()-starttime));    \t\t  \t}  }  class Thread1 extends Thread{  \tpublic void run() {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(new String(\"-\"));  \t\t}  \t}  }  class Thread2 extends Thread{  \tpublic void run() {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(new String(\"|\"));  \t\t}  \t}  }          public void run() {  \twhile(true) {  \t\ttry {  \t\tThread.sleep(10*1000); //10초 기다림  \t\t}catch(InterruptedException e) {}  \t\tSystem.out.println(\"Awaken by interrupt().\");  \t}  \tgc(); //garbage collection을 수행 : 사용하지 않는 객체 제거  \tSystem.out.println(\"Garbage Collection. Free Memory : \"+freeMemory());  }      for(int i=0;i&lt;20;i++) {  \trequiredMemory = (int)(Math.random()*10)*20; //requiredMemory 필요한 메모리  \t//필요한 메모리가 사용할 수 있는 양보다 적거나 전체 메모리의 60%이상 사용했을 경우 gc를 깨운다  \tif(gc.freeMemry()&lt; requireMemory || gc.freeMemory()&lt;gc.totalMemory()*0.4) { //메모리 부족한 경우  \t\tgc.interrupt(); //잠자고있는 쓰레드 gc를 깨운다  \t\ttry {  \t\t\tgc.join(100); //gc가 작업(메모리정리)할 시간을 줌. 0.1초  \t\t}catch(InterruptedException e) {}  \t}  \tgc.usedMemory += requiredMemory; //메모리 사용  \tSystem.out.println(\"usedMemory : \"+gc.usedMemory);  }              yield() : 남은 시간을 다음 쓰레드에게 양보하고, 자신(현재 쓰레드)은 실행대기한다. yield()와 interrupt()를 적절히 사용하면, 응답성과 효율을 높일 수 있다.          class  Main{  \tpublic static void main(String[] args) {  \t\tMyThread th1 = new MyThread(\"*\");  \t\tMyThread th2 = new MyThread(\"**\");  \t\tMyThread th3 = new MyThread(\"***\");    \t\t  \t\tth1.start();  \t\tth2.start();  \t\tth3.start();    \t\t  \t\ttry {  \t\t\tThread.sleep(2000);  \t\t\tth1.suspend(); //쓰레드 th1을 잠시 중단  \t\t\tThread.sleep(2000);  \t\t\tth2.suspend();   \t\t\tThread.sleep(3000);  \t\t\tth1.resume(); //쓰레드 th1 재 동작  \t\t\tThread.sleep(3000);  \t\t\tth1.stop();  \t\t\tth2.stop();  \t\t\tThread.sleep(2000);  \t\t\tth3.stop();  \t\t} catch (InterruptedException e) {}  \t}  }      class MyThread implements Runnable{  \tvolatile boolean suspended = false;   \t//volatile : 쉽게 바뀌는 변수(cpu의 코어는 복사본을 가지고 있는데(가끔 원본의 값이 변경됐을때 복사본의 값은 안바뀌는 경우 발생), volatile을 사용하면 원본을 바로 사용함  \t//자주 바뀌는 값이니까 복사본말고 원본 쓰라는 의미  \tvolatile boolean stopped = false;     \t  \tThread th;    \t  \tMyThread(String name){  \t\tth = new Thread(this,name);  \t}  \tvoid start() {  \t\tth.start();  \t}    \t  \tvoid stop() {  \t\tstopped = true;  \t\tth.interrupt(); //쓰레드가 자고있을 확률이 있어서 깨워줌  \t}    \t  \tvoid suspend() { //일시정지  \t\tsuspended = true;  \t\tth.interrupt(); //쓰레드가 자고있을 확률이 있어서 깨워줌  \t}    \t  \tvoid resume() { //재실행  \t\tsuspended = false;  \t}  \tpublic void run() {  \t\twhile(!stopped) {  \t\t\tif(!suspended) {  \t\t\tSystem.out.println(Thread.currentThread().getName());  \t\t\ttry {  \t\t\t\tThread.sleep(1000); //1초마다 쓰레드 이름찍기  \t\t\t} catch(InterruptedException e) {}  \t\t\t}else {  \t\t\t\tThread.yield(); //쓰레드가 일시정지 상태이면, 다른 쓰레드에게 순서를 양보함. os에게 통보는 하지만 반드시 작동한다는 보장은 없음.(써도 큰 차이는 없음..^^  \t\t\t}  \t\t}  \t}  }        쓰레드의 동기화(synchronization)          멀티 쓰레드 프로세스에서는 다른 쓰레드의 작업에 영향을 미칠 수 있다.      진행중인 작업이 다른 쓰레드에게 간섭받지 않게 하려면 ‘동기화’가 필요      쓰레드 동기화 : 한 스레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는것      동기화 하려면 간섭받지 않아야 하는 문장들을 ‘임계 영역(critical section)’으로 설정      임계영역은 락(lock)을 얻은 단 하나의 쓰레드만 출입가능(객체 1개에 락 1개)            synchronized를 이용한 동기화          synchronized로 임계영역(lock이 걸리는 영역)을 설정하는 방법 2가지                      메소드 전체를 임계 영역으로 지정(많을수록 성능이 떨어져서 최소한으로 좁은 영역에 쓰는 것이 좋음. 메소드 전체를 임계영역으로 지정하는 것은 비효율적)        Public synchronized void calcSum(){ /**/ }                    특정한 영역을 임계 영역으로 지정 synchronized(객체의 참조변수){ /**/ }                class Account{  \t//계좌에 1000있음  \tprivate int balance = 1000; //private로 해야 동기화가 의미있음    \t  \tpublic int getBalance() {  \t\treturn balance;  \t}  \t//출금 메소드. 잔고뺄떄 쓰레드 여러개가 들어오면 마이너스잔고가 뜰수도 잇음. 임계영역 지정  \tpublic synchronized void withdraw(int money) { //synchronized로 메소드를 동기화  \t\tif(balance&gt;=money) { //잔고보다 출금하려는 돈이 많아야 출금 가능  \t\t\ttry{Thread.sleep(1000); //별 의미없는 코드  \t\t\t} catch(InterruptedException e) {}  \t\t\tbalance -= money;  \t\t}//임계영역  \t}  }      class RunnableEx1 implements Runnable {  \tAccount acc = new Account();      \tpublic void run() {  \t\twhile(acc.getBalance()&gt;0) {  \t\t\t//100,200,300 중 한 값을 임으로 선택해서 출금(withdraw)  \t\t\tint money = (int)(Math.random()*3+1)*100;  \t\t\tacc.withdraw(money);  \t\t\tSystem.out.println(\"balance : \"+acc.getBalance());  \t\t}  \t}   }  class  Main{  \tpublic static void main(String[] args) {  \t\tRunnableEx1 r = new RunnableEx1();  \t\tnew Thread(r).start(); //ThreadGroup에 의해 참조되므로 gc대상이 아니다  \t\tnew Thread(r).start(); //ThreadGroup에 의해 참조되므로 gc대상이 아니다    \t\t  \t}  }            wait(), notify()          동기화의 효율을 높이기 위해 사용      Object클래스에 정의되어 있으며, 동기화 블록 내에서만 사용할 수 있다.      wait() : 객체의 lock을 풀고 쓰레드를 해당 객체의 waiting pool에 넣는다      notify() : waiting pool에서 대기중인 쓰레드 중의 하나를 깨운다.      notifyAll() : waiting pool에서 대기중인 모든 쓰레드를 깨운다.          class Account{  \t//계좌에 1000있음  \tprivate int balance = 1000; //private로 해야 동기화가 의미있음    \t  \tpublic synchronized void withdraw(int money) { //synchronized로 메소드를 동기화  \t\tif(balance &lt;money) {  \t\t\ttry{  \t\t\t\twait(); //대기, 락을 풀고 기다린다. 통지를 받으면 락을 재획득  \t\t\t} catch(InterruptedException e) {}  \t\t\tbalance -= money;  \t\t}//임계영역  \t}    \t  \tpublic synchronized void deposit(int money) {  \t\tbalance += money;  \t\tnotify(); //통지. 대기중인 쓰레드 중 하나에게 알림  \t}  }      class  Main{  \tpublic static void main(String[] args) {  \t}  }          import java.util.ArrayList;;      class Customer implements Runnable{  \tprivate Table table;  \tprivate String food;    \t  \tCustomer(Table table, String food){  \t\tthis.table = table;  \t\tthis.food = food;  \t}    \t  \tpublic void run() {  \t\twhile(true) {  \t\t\ttry { Thread.sleep(0);} catch(InterruptedException e) {}  \t\t\tString name = Thread.currentThread().getName();    \t\t\t  \t\t\ttable.remove(food);  \t\t\tSystem.out.println(name + \" ate a \"+food);  \t\t}  \t}  }    \t  class Cook implements Runnable{  \tprivate Table table;    \t  \tCook(Table  table){ this.table = table;}    \t  \tpublic void run() {  \t\twhile(true) {  \t\t\tint idx = (int)(Math.random()*table.dishNum());  \t\t\ttable.add(table.dishNames[idx]);  \t\t\ttry {Thread.sleep(10);} catch(InterruptedException e) {}  \t\t}  \t}  }  class Table {  \tString [] dishNames = {\"donut\",\"donut\", \"burger\"}; //donut의 확률을 높인다  \tfinal int MAX_FOOD = 6;  \tprivate ArrayList&lt;String&gt; dishes = new ArrayList&lt;&gt;();    \t  \tpublic synchronized void add(String dish) {  \t\twhile(dishes.size()&gt;=MAX_FOOD) {  \t\t\tString name = Thread.currentThread().getName();  \t\t\tSystem.out.println(name+\" is waiting.\");  \t\t\ttry {  \t\t\t\twait(); //COOK쓰레드(요리사)를 기다린다.  \t\t\t\tThread.sleep(500);  \t\t\t}catch(InterruptedException e) {}  \t\t}  \t\tdishes.add(dish);  \t\tnotify(); //기다리고 있는 CUST를 깨우기 위함.  \t\tSystem.out.println(\"Dishes : \"+dishes.toString());  \t}  \tpublic void remove(String dishName) {  \t\tsynchronized(this) {  \t\t\tString name = Thread.currentThread().getName();    \t\t\t  \t\t\twhile(dishes.size()==0) {  \t\t\t\tSystem.out.println(name + \" is waiting. \");  \t\t\t\ttry {  \t\t\t\t\twait();  \t\t\t\t\tThread.sleep(500);  \t\t\t\t}catch(InterruptedException e) {}  \t\t\t}  \t\t\twhile(true) {  \t\t\t\tfor(int i =0; i&lt;dishes.size();i++) {  \t\t\t\t\tif(dishName.equals(dishes.get(i))) {  \t\t\t\t\tdishes.remove(i);  \t\t\t\t\tnotify(); //자고있는 COOK을 깨우기 위함  \t\t\t\t\treturn;  \t\t\t\t\t}  \t\t\t\t}  \t\t\t\ttry {  \t\t\t\t\tSystem.out.println(name+\" is waiting.\");  \t\t\t\t\twait();  \t\t\t\t\tThread.sleep(500);  \t\t\t\t}catch(InterruptedException e) {}  \t\t\t}  \t\t}  \t}  \tpublic int dishNum() {return dishNames.length;}  }  class  Main{  \tpublic static void main(String[] args) throws Exception {  \t\tTable table = new Table();    \t\t  \t\tnew Thread(new Cook(table), \"COOK\").start();  \t\tnew Thread(new Customer(table, \"donut\"), \"CUST1\").start();  \t\tnew Thread(new Customer(table, \"burger\"), \"CUST2\").start();  \t\tThread.sleep(2000);  \t\tSystem.exit(0);    \t\t  \t}  }      "
  },
  
  {
    "title": "자바의 정석 강의 - 지네릭스, 열거형, 애너테이션",
    "url": "/posts/%EC%A7%80%EB%84%A4%EB%A6%AD%EC%8A%A4_%EC%97%B4%EA%B1%B0%ED%98%95_%EC%95%A0%EB%84%88%ED%85%8C%EC%9D%B4%EC%85%98/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-26 00:00:00 +0900",
    





    
    "snippet": "지네릭스(Generics): 컴파일시 타입을 체크해주는 기능(compile-time type check) - JDK1.5객체의 타입 안정성을 높이고 형변환의 번거로움을 줄임.⇒ 코드가 간결해짐, ClassCastException(형변환 에러) 방지import java.util.ArrayList;public class  Main {\t\tpublic sta...",
    "content": "지네릭스(Generics): 컴파일시 타입을 체크해주는 기능(compile-time type check) - JDK1.5객체의 타입 안정성을 높이고 형변환의 번거로움을 줄임.⇒ 코드가 간결해짐, ClassCastException(형변환 에러) 방지import java.util.ArrayList;public class  Main {\t\tpublic static void main(String[] args) {//\t\tArrayList list = new ArrayList(); //JDK1.5이전, 지네릭스 도입이전에는 이렇게 썻음//\t\tlist.add(10);//\t\tlist.add(20);//\t\tlist.add(\"30\");  //String//\t\t//\t\tInteger i = (int)list.get(2);  //[10, 20, 30]중 30을 꺼냄. 30이 String임//\t\t// =&gt; Object를 int로 형변환 해서 컴파일은 ok 에러없음//\t\t//그러나 실행하면 에러남. java.lang.ClassCastException 형변환 에러//\t\t//컴파일러의 한계. 30이 String인걸 체크 못함.//\t\t//\t\tSystem.out.println(list);\t\t\t\t//위 같은 사항을 방지하기 위해 지네릭스 등장\t\t\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\t\tlist.add(10);\t\tlist.add(20);//\t\tlist.add(\"30\");  //String이라 에러남. 위에서 &lt;Integer&gt;로 지정해줘서 잘못된 타입인걸 컴파일러가 잡아줌\t\tlist.add(30);\t\t\t\tInteger i = list.get(2);  //[10, 20, 30]중 30을 꺼냄. 어차피 Integet만 올 수 있어서 형변환 안해줘도 됨\t\t\t\tSystem.out.println(list);\t\tSystem.out.println(i);\t\t\t\tArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;(); //모든 타입 저장가능 JKD1.5이후부터 이렇게 씀\t\tlist2.add(10);\t\tlist2.add(20);\t\tlist2.add(\"30\");  //String\t\t\t\tString i2= (String)list2.get(2);\t\tSystem.out.println(list2);\t\tSystem.out.println(i2);\t\tObject i3 = list2.get(1);\t\tObject i4 = list2.get(2);\t\tSystem.out.println(i3);\t\tSystem.out.println(i4);\t}}      타입변수          클래스 작성 시, Object타입 대신 타입 변수(T or E)를 선언해서 사용      객체 생성 시, 타입변수 대신 실제타입을 지정(대입)  ⇒ 형변환 생략가능.          //public class ArrayList extends AbstractList{   //\tprivate transient Object[] elementData;  //\tpublic boolean add(Object o) {/*생략*/}  //\tpublic Object get(int inex); {/*생략*/}  //}  //   ↓ JDK1.5부터 아래코드로 변경  public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;{   \tprivate transient E[] elementData;  \tpublic boolean add(E o) {/*생략*/}  \tpublic E get(int inex); {/*생략*/}  }  class Main{  public static void main(String[] args){  \t\t//타입변수 대신 실제 타입을 대입시킴. 참조변수와 생성자에 지정  \t\t//생상자의 실제타입과 참조변수의 실제타입이 일치해야함  \t\t//Tv가 E에 대입됨  \t\tArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();  \t\ttvList.add(new Tv());  //\tTv v = (Tv)tvList.get(0); //반환타입이 Object가 아닌 Tv라 형변환 필요없음. 주석처리  \t\tTv v = tvList.get(0);  \t}  }          import java.util.*;      class Tv{}  class Audio{}      public class  Main {    \t  \tpublic static void main(String[] args) {  //\t\tArrayList List = new ArrayList();  //\t\tList.add(new Tv());  //\t\tList.add(new Audio());    \t\t  \t\tArrayList list2 = new ArrayList();  \t\tTv v2 = (Tv)list2.get(0); //list2의 첫번째 요소를 꺼냄 Tv로 형변환 필수    \t\t  \t\tArrayList&lt;Tv&gt; list = new ArrayList&lt;Tv&gt;();  \t\tlist.add(new Tv());  //\t\tlist.add(new Audio()); //위와 다르게 Tv객체만 저장하게 지정돼서 에러남.  \t\tTv v = list.get(0); //형변환 불필요. 어차피 Tv객체만 저장하게 돼있음  \t}  }        지네릭스 용어          Box : 지네릭 클래스. ‘T의 Box’ or ‘T Box’라고 읽는다.      T : 타입변수 or 타입 매개변수(T는 타입문자)      Box : 원시타입(raw type). 일반클래스가 지네릭클래스로 바뀌어서 원 Box클래스를 원시타입이라 부름      대입된 타입(매개변수화된 타입, parameterized) : Box b = new Box();에서 String. 객체를 만들때마다 변경가능.            지네릭 타입과 다형성          참조변수와 생성자의 대입된 타입은 일치해야 한다.(조상과 자손관계여도 안됨)      지네릭클래스간의 타형성 성립은 성립.(여전히 대입된 타입은 일치해야함)      매개변수 다형성도 성립됨.          import java.util.*;      class Product{}  class Tv extends Product{}  class Audio extends Product{}      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tArrayList&lt;Product&gt; productList = new ArrayList&lt;Product&gt;();  \t\tArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();  //\t\tArrayList&lt;Product&gt; tvList1 = new ArrayList&lt;Tv&gt;(); //에러. 조상자손관계여도 안됨  \t\tList&lt;Tv&gt; tvList2 = new ArrayList&lt;Tv&gt;(); //가능. 다형성이지만 대입된 타입이 일치함    \t\t   \t\tproductList.add(new Tv()); //다형성. public boolean add(Product e)라서 Product의 자손인 Tv도 가능  \t\tproductList.add(new Audio());    \t\t  \t\ttvList.add(new Tv()); //public boolean add(Tv e)  //\t\ttvList.add(new Audio()); //Tv와 Audio는 공통 조상을 가진것이지 상속관계는 아니라 에러      \t\tprintAll(productList);  \t\t//printAll(tvList) //컴파일 에러. printAll은 Product타입임.   \t}      \tpublic static void printAll(ArrayList&lt;Product&gt; list){  \t\tfor(Product p : list) {  \t\t\tSystem.out.println(p);  \t\t}  \t}  }            Iterator          클래스를 작성할 때, Object타입 대신 T와 같은 타입 변수를 사용          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();  \t\tlist.add(new Student(\"자바왕\",1,1));  \t\tlist.add(new Student(\"자바짱\",1,2));  \t\tlist.add(new Student(\"홍길동\",2,1));    \t\t  \t\tIterator&lt;Student&gt; it =list.iterator();  \t\twhile(it.hasNext()) {  //\t\t\tStudent s = (Student)it.next(); //지네릭스를 사용해서 형변환 필요없음. Iterator it =list.iterator(); 였다면 형변환 해줘야함  //\t\t\tStudent s = it.next();  //\t\t\tSystem.out.println(s.name); //밑의 한줄로 줄임  //\t\t\tSystem.out.println(((Student)it.next()).name); //형변환 필요없음.  \t\t\tSystem.out.println(it.next().name);  \t\t}  \t}  }  class Student{  \tString name = \"\";  \tint ban; //반  \tint no; //번호    \t  \tStudent(String name, int ban, int no){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.no = no;  \t}  }            HashMap&lt;K,V&gt;          여러 개의 타입 변수가 필요한 경우, 콤마(,)를 구분자로 선언          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tHashMap&lt;String, Student&gt; map = new HashMap&lt;&gt;(); //JDK1.7부터 생성자의 타입지정 생략가능  \t\tmap.put(\"자바왕\", new Student(\"자바왕\",1,1,100,100,100));  \t\tmap.put(\"자바짱\", new Student(\"자바짱\",1,2,100,100,100));  \t\tmap.put(\"홍길동\", new Student(\"홍길동\",2,1,100,100,100));    \t\t  \t\t//public Student get(Object Key){}  \t\tStudent s = map.get(\"자바왕\"); //형변환 생략    \t\t  \t\tSystem.out.println(map.get(\"자바왕\").name);  \t}  }  class Student{  \tString name = \"\";  \tint ban; //반  \tint no; //번호  \tint kor;  \tint eng;  \tint math;    \t  \tStudent(String name, int ban, int no, int kor, int eng, int math){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.no = no;  \t\tthis.kor=kor;  \t\tthis.eng=eng;  \t\tthis.math=math;  \t}  }            제한된 지네릭 클래스          extends로 대입할 수 있는 타입을 제한 - class avg                  Student의 자손만 타입으로 지정가능.                    인터페이스인 경우에도 extends를 사용(implement안씀)          import java.util.*;      interface Eatable{};      class Fruit implements Eatable{  \tpublic String toString() {return \"fruit\";}  }      class Apple extends Fruit{public String toString() {return \"Apple\";} }  class Grape extends Fruit{public String toString() {return \"Grape\";} }  class Toy {public String toString() {return \"Toy\";} }  public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; fruitBox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; appleBox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Grape&gt;();  //\t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Apple&gt;(); //에러. 타입 불일치  //\t\tFruitBox&lt;Toy&gt; toyBox = new FruitBox&lt;Toy&gt;(); //에러. Toy클래스는 Fruit의 자손이 아님  \t\tBox&lt;Toy&gt; toyBox = new Box&lt;Toy&gt;();     \t\t  \t\tfruitBox.add(new Fruit());                     \t\tfruitBox.add(new Apple());                     \t\tfruitBox.add(new Grape());                     \t\tappleBox.add(new Apple());                     //\t\tappleBox.add(new Grape()); //Grape는 Apple의 자손이 아님              \t\tgrapeBox.add(new Grape());            \t\t  \t\tSystem.out.println(\"fruitBox - \"+fruitBox);  \t\tSystem.out.println(\"appleBox - \"+appleBox);  \t\tSystem.out.println(\"grapeBox - \"+grapeBox);  \t}  }  class FruitBox&lt;T extends Fruit &amp; Eatable&gt; extends Box&lt;T&gt;{}       class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); //아이템을 저장할 list  \tvoid add(T item)\t\t{list.add(item);} //박스에 추가  \tT get(int i) \t\t\t{return list.get(i);} //박스에서 아이템 꺼냄  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  \t}        지네릭스의 제약                  타입변수에 대입은 인스턴스 별로 다르게 가능        ⇒ static멤버에 타입 변수 사용불가.(모든 인스턴스에 공통이기 때문)        class BOX{    static T item; //에러    static int compare(T t1, T t2); //에러 }                    배열 생성할 떄 타입 변수 사용 불가. 타입 변수로 배열 선언은 가능        class Box{    T[] itemArr; //Ok, T타입의 배열을 위한 참조변수    T[] toArray() {    T[] tmpArr = new T[itemArr.length]; //에러. 지네릭 배열 생성불가 } }                  와일드 카드 &lt;?&gt; : 하나의 참조변수로 대입된 타입이 다른 객체를 참조 가능          &lt;? extends T&gt; : 와일드 카드의 상한 제한. T와 그의 자손들만 가능      &lt;? super T&gt; : 와일드 카드의 하한 제한. T와 그의 조상들만 가능      &lt;?&gt; == &lt;? extends Object&gt; : 제한없음. 모든 타입이 가능.        — 메소드의 매개변수에 와일드카드를 사용    static Juice makeJuice(FruitBox&lt;? extends Fruit&gt; box) {  String tmp = “”;  for(Fruit f : box.getList()) tmp += f +””;  return new Juice(tmp); }      import java.util.*;      class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }      class Juice{  \tString name;    \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }      class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";    \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; fruitBox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; appleBox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Grape&gt;();    \t\t  \t\t//appleBox에 Fruit와 그 자손(Apple, Grape)들 사용 가능  //\t\tFruitBox&lt;? extends Fruit&gt; appleBox = new FruitBox&lt;Apple&gt;();  //\t\tappleBox = new FruitBox&lt;Fruit&gt;();  //\t\tappleBox = new FruitBox&lt;Apple&gt;();  //\t\tappleBox = new FruitBox&lt;Grape&gt;();  //일단 주석처리해놓음 전부 에러안뜨고 잘 됨    \t\t   \t\tfruitBox.add(new Apple());  \t\tfruitBox.add(new Grape());  \t\tappleBox.add(new Apple());  \t\tgrapeBox.add(new Grape());     \t\t  \t\tSystem.out.println(Juicer.makeJuice(fruitBox));  \t\tSystem.out.println(Juicer.makeJuice(appleBox));  \t\tSystem.out.println(Juicer.makeJuice(grapeBox));  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}      class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }        지네릭 메소드                  지네릭 타입이 선언된 메소드(타입 변수는 메소드 내에서만 유효)  static  void sort(List list, Comparator&lt;? super T&gt; c)                    클래스의 타입 매개변수 와 메소드의 타입 매개변수 는 별개    class FruitBox{ /….    static  void sort(List list, Comparator&lt;? super T&gt; c){/*..*/} }        → class와 메소드의 타입변수가 다를수도 있음. 가까운 쪽의 것을 따름                    메소드를 호출할 때마다 타입을 대입해야함(대부분 생략가능)        FruitBox fruitBox = new FruitBox();    FruitBox appleBox = new FruitBox();    System.out.println(Juicer.makeJuice(fruitBox)); //생략 가능    System.out.println(Juicer.makeJuice(appleBox)); //생략가능                    메소드를 호출할 때 타입을 생략하지 않았을 때는 클래스 이름 생략 불가(아주 드뭄)  System.out.println(makeJuice(fruitBox));//에러. 클래스 생략 불가    System.out.println(this.makeJuice(fruitBox));    System.out.println(Juicer.makeJuice(fruitBox));            — 와일드카드메소드는 하나의 참조변수로 대입된 타입이 다른 여러 지네릭 객체를 다루기위해서 사용, 지네릭 메소드는 호출할때마다 다른 타입을 대입할 수 있음. 용도가 다름. (보통 와일드카드 못쓸때 지네릭 씀)  지네릭형 변환          지네릭 타입과 원시타입간의 형변환은 바람직하지 않음(경고발생, 가능은 함) 원시 타입을 사용하는 것부터 비효율적.              와일드 카드가 사용된 지네릭타입으로는 형변환 가능          import java.util.*;          class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }          class Juice{  \tString name;        \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }          class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";        \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tBox b = null;  \t\tBox&lt;String&gt; bstr = null;        \t\t  \t\tb = (Box)bstr;  //Box&lt;String&gt;-&gt;Box 가능은 하나 경고. 바람직하지않음  \t\tbstr = (Box&lt;String&gt;)b; //Box -&gt; Box&lt;String&gt;  가능은 하나 경고. 바람직하지않음        \t\t  \t\tBox b2 = new Box&lt;String&gt;();//가능 원래는 Box&lt;String&gt; b2 = new Box&lt;String&gt;();로 사용햐여함  \t\tb2.add(100);  \t\tb2.add(200);  \t\tSystem.out.println(b2);        \t\t  \t\tBox&lt;String&gt; b3 = new Box&lt;String&gt;();//가능 원래는 Box&lt;String&gt; b2 = new Box&lt;String&gt;();로 사용햐여함  //\t\tb3.add(100);  //\t\tb3.add(200);  //에러. b3는 &lt;String&gt;으로 타입을 지정해놔서 에러뜸  \t\t//어지간하면 섞어쓰지말고 꼭 지네릭으로 써줄 것.        \t\t  \t\tBox&lt;Object&gt; objBox = null;  //\t\tobjBox = (Box&lt;Object&gt;)bstr; //Box&lt;String&gt; -&gt; Box&lt;Objecte&gt; 불가능  //\t\tbstr = (Box&lt;String&gt;)objstr; //Box&lt;Object&gt; -&gt; Box&lt;String&gt; 불가능  //\t\tBox&lt;Sting&gt; b4 = new Box&lt;Object&gt;(); //불가능. 타입안맞음        \t\t  \t\tBox&lt;? extends Object&gt; wBox = (Box&lt;? extends Object&gt;)new Box&lt;String&gt;(); //가능  \t\tBox&lt;? extends Object&gt; wBox2 = new Box&lt;String&gt;(); //위 문장과 동일. 형변환 생략됨.        \t\t  \t\tFruitBox&lt;? extends Fruit&gt; Fbox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;? extends Fruit&gt; Fbox2 = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;? extends Fruit&gt; Fbox3 = new FruitBox&lt;Grape&gt;();        \t\t  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}          class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }                  import java.util.*;          class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }          class Juice{  \tString name;        \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }          class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";        \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; box = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; abox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; gbox = new FruitBox&lt;Grape&gt;();        \t\t  \t\tFruitBox&lt;? extends Fruit&gt; box2 = new FruitBox&lt;Fruit&gt;();  \t\t//FruitBox&lt;Apple&gt; -&gt; FruitBox&lt;? extends Fruit&gt;  \t\tFruitBox&lt;? extends Fruit&gt; abox2 = new FruitBox&lt;Apple&gt;();  \t\t//FruitBox&lt;Grape&gt; -&gt; FruitBox&lt;? extends Fruit&gt;  \t\tFruitBox&lt;? extends Fruit&gt; gbox2 = new FruitBox&lt;Grape&gt;();        \t\t  \t\t//FruitBox&lt;? extends Fruit&gt; -&gt; FruitBox&lt;Apple&gt;   \t\tFruitBox&lt;Apple&gt; abox3 = (FruitBox&lt;Apple&gt;)abox2; //가능. 경고발생  \t\t//FruitBox&lt;? extends Fruit&gt; -&gt; FruitBox&lt;Grape&gt;   \t\tFruitBox&lt;Grape&gt; gbox3 = (FruitBox&lt;Grape&gt;)gbox2;  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}          class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }                      지네릭타입의 제거          컴파일러는 지네릭타입을 제거하고, 필요한 곳에 형변환을 넣는다.                              지네릭 타입의 경계(bound)를 제거( → Object) - 하위호환성때문에 타입을 제거하기로 결정 ⇒ 안정성 증가            class box{void att(T t) } → class box{void add(Fruit t)} 으로 변경                                지네릭 타입 제거 후에 타입이 불일치하면, 형변환을 추가 T get(int i){return list.get(i);} → Fruit get(int i){return (Fruit)list.get(i);}                                와일드 카드가 포함된 경우, 적절한 타입으로 형변환 추가                                    열거형(enum) : 관련된 상수들을 같이 묶어놓은 것. java는 타입에 안전한 열거형을 제공. ==연산자 사용시 값과 타입 둘다 체크함          정의 방법 - enum 열거형 이름{ 상수명1, 상수명2, 상수명3 ,…}      열거형 타입의 변수를 선언, 사용          enum Direction { EAST, SOUTH, WEST, NORTH}      class Unit {  \tint x, y; //유닛의 위치  \tDirection dir; //열거형 인스턴스 변수를 선언    \t  \tvoid init() {  \t\tdir = Direction.EAST; //유닛의 방향을 EAST로 초기화\t\t  \t}  }              열서형 상수의 비교에 ==와 compareTo() 사용가능          void init() {  \t\tdir = Direction.EAST; //유닛의 방향을 EAST로 초기화\t\t  \t\tif(dir == Direction.EAST) {  \t\t\tx++; }  //\t\telse if(dir &gt; Direction.WEST) { //에러, 열거형 상수에 비교 연산자 사용 불가능  \t\telse if(dir.compareTo(Direction.WEST)&gt;0) {  /*compare은 사용 가능*/}  \t}                      열거형의 조상 - java.lang.Enum                  모든 열거형은 Enum의 자손이며, 아래의 메소드를 상속받는다.                                                    메소드              설명                                                          Class getDeclaringClass()              열거형의 Class객체를 반환                                      String name()              열거형 상수의 이름을 문자열로 반환                                      int ordinal()              열거형 상수가 정의된 순서를 반환(0부터 시작)                                      T valueOf(Class enumType, String name)              지정된 열거형에서 name과 일치하는 열거형 상수를 반환                                                values(), valueOf()는 컴파일러가 자동으로 추가                  static E[] values()  \t\tstatic E valueOf(String name)        \t\t  \t\tDirection [] dArr = Direction.values();        \t\t  \t\tfor(Direction d : dArr) {  \t\t\tSystem.err.printf(\"%s = $d%n\",d.name(),d.ordinal());  \t\t}                  import java.util.*;          enum Direction { EAST, SOUTH, WEST, NORTH}          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tDirection d1 = Direction.EAST;  \t\tDirection d2 = Direction.valueOf(\"WEST\");  \t\tDirection d3 = Enum.valueOf(Direction.class, \"EAST\");        \t\t  \t\tSystem.out.println(\"d1 = \" + d1);  \t\tSystem.out.println(\"d2 = \" + d2);  \t\tSystem.out.println(\"d3 = \" + d3);        \t\t  \t\tSystem.out.println(\"d1==d2 ? \"+(d1==d2));  \t\tSystem.out.println(\"d1==d3 ? \"+(d1==d3));  \t\tSystem.out.println(\"d1.equals(d3) \"+(d1.equals(d3)));  //\t\tSystem.out.println(\"d2&gt;d3 ? \"+(d1&gt;d3)); //에러. 객체가 없어서 비교연산자 사용 불가  \t\tSystem.out.println(\"d1.compareTo(d3) ? \"+(d1.compareTo(d3)));  \t\tSystem.out.println(\"d1.compareTo(d2) ? \"+(d1.compareTo(d2))); //0-2 = -2 출력        \t\t  \t\tswitch(d1) {  \t\tcase EAST: //Direction.EAST라고 못씀  \t\t\tSystem.out.println(\"The direction is EAST. \"); break;  \t\tcase SOUTH:   \t\t\tSystem.out.println(\"The direction is SOUTH. \"); break;  \t\tcase WEST:   \t\t\tSystem.out.println(\"The direction is WEST. \"); break;  \t\tcase NORTH:   \t\t\tSystem.out.println(\"The direction is NORTH. \"); break;  \t\tdefault:  \t\t\tSystem.out.println(\"Invalid direction\"); break;  \t\t}  \t\tDirection[] dArr = Direction.values(); //열겨형의 모든 상수를 배열로 반환  \t\tfor(Direction d : dArr) { //for(Direction d : Direction.values()  \t\t\tSystem.out.printf(\"%s = %d%n\",d.name(),d.ordinal());  \t\t}  \t}  }                            열거형에 멤버 추가하기                  불연속적인 열거형 상수의 경우 원하는 값을 괄호()안에 넣는다. 여러개도 가능          괄호를 사용하려면, 인스턴스 변수와 생성자를 새로 추가해줘야 함                  import java.util.*;          enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10);  \tprivate final int value;// 정수를 저장할 필드(인스턴스변수)를 추가  \tDirection(int value) {this.value = value;} //생성자 추가, private 생략        \t  \tpublic int getValue() {return value;}          }          public class  Main {        \t  \tpublic static void main(String[] args) {  //\t\tDirection d = new Direction(1); //에러, 열거형의 생성자는 외부에서 호출불가(무조건 private라서)   \t}  }                  import java.util.*;          enum Direction { EAST(1,\"&gt;\"), SOUTH(2,\"V\"), WEST(3,\"&lt;\"), NORTH(4,\"^\");        \t  \tprivate static final Direction[] DIR_ARR = Direction.values();  \tprivate final int value;// 정수를 저장할 필드(인스턴스변수)를 추가  \tprivate final String symbol;        \t  \tDirection(int value, String symbol) {  \t\tthis.value = value;  \t\tthis.symbol=symbol;  \t} //생성자 추가, private 생략        \t  \tpublic int getValue() {return value;}  \tpublic String getSymbol() {return symbol;}        \t  \tpublic static Direction of(int dir) {  \t\tif(dir&lt;1 || dir&gt;4) //1~4이외의 값이면 x  \t\t\tthrow new IllegalArgumentException(\"Invalid value : \"+dir);  \t\treturn DIR_ARR[dir-1];   \t}  \t//방향 회전 메소드, num의 값만큼 90도씩 시계방향으로 회전  \tpublic Direction rotate(int num) {  \t\tnum = num%4;        \t\t  \t\tif(num&lt;0) num +=4;  //num이 음수일때는 시계 반대방형으로 회전        \t\t  \t\treturn DIR_ARR[(value-1+num)];  \t}        \t  \tpublic String toString() {  \t\treturn name()+getSymbol();  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tfor(Direction d : Direction.values()) {  \t\t\tSystem.out.printf(\"%s = %d%n\",d.name(),d.ordinal());  \t\t}  \t\tSystem.out.println();  \t\t\tDirection d1 = Direction.EAST;  \t\t\tDirection d2 = Direction.of(1); //DIR_ARR[0]반환        \t\t\t  \t\t\tSystem.out.printf(\"d1 = %s, %d%n\",d1.name(),d1.getValue());  \t\t\tSystem.out.printf(\"d2 = %s, %d%n\",d2.name(),d2.getValue());  \t\t\tSystem.out.println();  \t\t\tSystem.out.println(Direction.EAST.rotate(1)); //EAST에서 한번 회전  \t\t\tSystem.out.println(Direction.EAST.rotate(2));  \t\t\tSystem.out.println(Direction.EAST.rotate(-1));//EAST에서 시계반대방향으로 한번 회전  \t\t\tSystem.out.println(Direction.EAST.rotate(-2));  \t}  }                            애너테이션                  주석처럼 프로그래밍 언어에 영향을 미치지 않으며, (프로그램에게)유용한 정보를 제공          /*~~~/ : javadoc.exe주석          애너테이션 사용 예  @Text //이 메소드가 테스트 대상임을 테스트 프로그램에게 알림  public void method{}                                                    ![[IMG-20240902151155.png              IMG-20240902151155.png]]                                      메타애너테이션 : 애너테이션을 만들때 사용                  @Override : 오버라이딩을 올바르게 했는지 컴파일러가 체크. 메소드 이름 잘못적을때가 많음. 오버라이딩 하기전에 적어줄 것.                      @Deprecated : 앞으로 사용하지 않을 것을 권장하는 필드, 메소드에 붙임 (ex. Date클래스의 getDate())  ⇒ @Deprecate가 붙은 대상을 사용하면 에러는 안뜨나 경고메세지(이클립스에선 취소선)가뜸                    @FunctionalInterface : 함수형 인터페이스(14장)에 붙이면, 컴파일러가 올바르게 작성했는지 체크, 함수형 인터페이스는 하나의 추상 메소드만 가질수 있다는 제약이 있음                      @SuppressWarings                          컴파일러의 경고메세지가 나타나지않게 억제              ()안에 억제하고자 하는 경고의 종류를 문자열로 지정 (경고를 확인했다는 의미)              여러 경고를 동시에 억제 가능함.              ‘-Xlint’옵션으로 컴파일 하면, 경고메세지를 확인할 수 있음. []안이 경고의 종류.                          class Parent{  \tvoid parentMethod() {}  \tvoid parentMethod2() {}  }              class Child extends Parent{  \t@Override  \t@Deprecated  \tvoid parentMethod() {};  //\t@Override  //\tvoid parentmethod2() {}; //에러. 이름불일치로 오버라이딩이 안됨.(@Override가 없으면 에러 안뜸)\t  }              @FunctionalInterface  interface Testable{ //함수형 인터페이스는 하나의 추상메소드만 가질 수 있음  \tvoid test(); //추상메소드  //\tvoid check(); //추상메소드 //추상메소드가 두개라서 에러, @FunctionlInterface가 없으면 가능함  }  public class  Main {  @SuppressWarnings(\"deprecation\")//이클립스에서는 차이가 없으나 cmd에서 컴파일하면 경고가 안뜸.  \tpublic static void main(String[] args) {  \t\tChild c = new Child();  \t\tc.parentMethod();  \t}  }                                메타애너테이션 : 애너테이션을 위한 에터테이션. java.lang.annotation 패키지에 포함                                          @Target : 애너테이션 정의할 때, 적용대상 지정에 사용                                                                            ![[IMG-20240902151156.png                      IMG-20240902151156.png]]                                                                                  @Retention : 애너테이션이 유지(retrntion)되는 기간을 지정하는데 사용                                  SOURCE : 소스파일에만 존재. 클래스파일에는 없음. 컴파일러에 의해 사용되는 애너테이션의 유지정책                  ==CLASS : 클래스파일에 존재. 실행시 사용불가. 기본값==                  RUNTIME : 클래스파일에 존재. 실행시 사용가능                                            @Documented : javadoc으로 작성한 문서에 포함시킴              @Ingerited : 애너테이션을 자손 클래스에 상속시킴              @Repeatable : 반복해서 붙일 수 있는 애너테이션을 정의. @ToDo를 하나로 묶을 컨테이너 애너테이션도 정의해야함                                            애너테이션 타입 정의                          직접 만들 수 있음 : @Interface 애너테이션이름{}              애너테이션의 메소드는 추상 메소드이며, 애너테이션을 적용할 때 지정(순서x)              애너테이션의 요소                                  적용시 값을 지정하지 않으면, 사용될 수 있는 기본 값 지정가능(null제외)                  요소가 하나이고 이름이 value일때는 요소의 이름 생략 가능                  요소의 타입이 배열인경우, {}를 사용(값이 여러개일때만, 값이 없을땐 빈{}라도 반드시 적어줘야함)                                            모든 애너테이션의 조상 - java.lang.annotation.Annotation                                  Annotation은 모든 애너테이션의 조상이지만 상속 불가능.                  사실 Annotation은 인터페이스임                                            마커 애너테이션(Marker Annotation) : 요소가 하나도 정의되지 않은 애너테이션              애너테이션 요소의 규칙                                  요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용됨                  ()안에 매개변수 선언 불가                  예외 선언 불가                  요소를 타입 매개변수로 정의 불가                                                        import java.lang.annotation.*;              @Deprecated  @SuppressWarnings(\"1111\") //유효하지 않은 애너테이션은 무시  @TestInfo(testedBy =\"aaa\", testTools= {\"JUnit\",\"JUnit5\"}, testDate = @DateTime(yymmdd=\"160101\",hhmmss=\"235959\"))  public class  Main {  \tpublic static void main(String[] args) {  \t\tClass&lt;Main&gt; cls = Main.class;            \t\t  \t\tTestInfo anno = cls.getAnnotation(TestInfo.class);  \t\tSystem.out.println(\"anno.testedBy() = \"+anno.testedBy());  \t\tSystem.out.println(\"anno.testDate().yymmdd()=\" +anno.testDate().yymmdd());  \t\tSystem.out.println(\"anno.testDate().hhmmss()=\" +anno.testDate().hhmmss());            \t\t  \t\tfor(String str : anno.testTools())   \t\t\tSystem.out.println(\"testTools = \" +str);            \t\t  \t\tSystem.out.println();            \t\t  \t\t//Main에 적용된 모든 애너테이션을 가져온다.  \t\tAnnotation[] annoArr = cls.getAnnotations();            \t\t  \t\tfor(Annotation a : annoArr)  \t\t\tSystem.out.println(a);  \t}  }  @Retention(RetentionPolicy.RUNTIME) //실행시 사용 가능하도록 지정  @interface TestInfo{  \tint count() default 1;  \tString testedBy();  \tString[] testTools() default \"JUnit\";  \tTestType TestType() default TestType.FIRST;  \tDateTime testDate();  }              @Retention(RetentionPolicy.RUNTIME) //실행시 사용 가능하도록 지정  @interface DateTime{  \tString yymmdd();  \tString hhmmss();  }              enum TestType{FIRST, FINAL}                                          "
  },
  
  {
    "title": "자바의 정석 강의 - 컬렉션 프레임웍(collections framework)",
    "url": "/posts/%EC%BB%AC%EB%A0%89%EC%85%98_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8D(collections_framework)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, collection",
    "date": "2022-08-21 00:00:00 +0900",
    





    
    "snippet": "컬렉션 프레임웍(collections framework)      컬렉션(collection)    : 여러 객체(데이터)를 모아놓은 것        프레임웍(framework)    : 표준화, 정형화된 체계적인 프로그램 방식 (Spring)        컬렉션 프레임웍(collections framework)    : 컬렉션(다수의 객체)를 다루기...",
    "content": "컬렉션 프레임웍(collections framework)      컬렉션(collection)    : 여러 객체(데이터)를 모아놓은 것        프레임웍(framework)    : 표준화, 정형화된 체계적인 프로그램 방식 (Spring)        컬렉션 프레임웍(collections framework)    : 컬렉션(다수의 객체)를 다루기 위한 표준화된 프로그래밍 방식    컬랙션을 쉽고 편리하게 다룰 수 있는 다양한 클래스 제공(객체 저장, 삭제, 검색, 정렬 등)    java.util 패키지에 포함. JDK1.2부터 제공(그전엔 표준화가 안됨)        컬렉션 클래스(collections class)    : 다수의 데이터를 저장할 수 있는 클래스(ex. Vector, ArrayList, HashSet)  ❗❗컬렉션 크레임웍의 핵심 인터페이스Map구현 클래스 이름에 Map이 없는 것은 표준화되기 전 옛날에 생긴 것— List와 Set의 공통부분 만 모아서 Collection이라는 인터페이스를 정의함. Map은 성격이 달라서 공통부분이 없음  Collection인터페이스의 메소드 - 순서ox,중복ox(상관없음)      List인터페이스 - (저장)순서o, 중복o          ArrayList (배열기반):                              기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일  (Vector써도 되지만[동기화o] 가능하면 ArrayList[동기화x]쓸것.)                    List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용          데이터의 저장공간으로 배열을 사용(배열기반)                      ArrayList의 메소드                          생성자                                  ArrayList() - 기본생성자                  ArrayList(Collection) - 컬렉션들 끼리 변환할때 많이 씀                  ArrayList(int initialCapacity) - 배열의 길이를 지정해주어야함(원래 배열은 길이를 조절못해서. 만들때 넉넉하게 만드는게 좋음)                                            추가                                  boolean add(Object o) - 객체 추가. 성공하면 true, 실패하면 false                  void add(int index, Object element) - 저장위치 지정(안하면 맨 뒤에 저장됨)                  boolean addAll(Collection c) - 컬렉션이 가진 요소를 그대로 저장                  boolean addAll(int index, Collection c) - 컬렉션의 저장위치지정                                            삭제                                  boolean remove(Object o) - 삭제                  Object remove(int index) - 특정위치 객체 삭제                  boolean removeAll(Collection c) - 컬렉션에 있는 객체 삭제                  void clear() - Array의 모든 객체 삭제                                            검색                                  int indexOf(Object o) - 객체가 몇번째에 저장됐는지(못찾으면 -1)                  int lastIndexOf(Object o) - 끝에서 부터 객체를 찾음                  boolean contains(Object o) - 객체가 있는지(있으면 true, 없으면 false)                  Object get(int index) - 객체 읽기                  Object set(int index, Object element) - 특정 위치 객체를 다른 걸로 변경                                                            기타                                  List subList(int fromIndex, int toIndex) -from부터 to까지 객체를 뽑아서 새로운 List를 만듦                  Object[] toArray() - ArrayList의 객체배열을 반환                  Object[] toArray(Object[] a)                  boolean isEmpty() - ArrayList가 비어있는지 확인                  void trimToSize() - 빈공간 제거                  int size() - 저장된 객체의 갯수                                  import java.util.*;                  public class  Main {  \tpublic static void main(String[] args) {  \t\t//기본길이(용량, capacity)가 10인 ArrayList를 생성  \t\tArrayList list1 = new ArrayList(10);  //\t\tlist1.add(new Integer(5));  //\t\tlist1.add(new Integer(4));  //\t\tlist1.add(new Integer(2));  //\t\tlist1.add(new Integer(0));  //\t\tlist1.add(new Integer(1));  //\t\tlist1.add(new Integer(3));  \t\t//ArrayList는 객체만 저장되나 autoboxing에 의해 기본형이 참조형으로 자동변환되서 밑처럼 써도 됨  \t\tlist1.add(5);  \t\tlist1.add(4);  \t\tlist1.add(2);  \t\tlist1.add(0);  \t\tlist1.add(1);  \t\tlist1.add(3);                \t\t  \t\t//ArrayList(Collection c)  //\t\tList sub = list1.subList(1, 4);  //\t\tArrayList list2 = new ArrayList(sub);  \t\tArrayList list2 = new ArrayList(list1.subList(1, 4));                \t\t  \t\tprint(list1, list2);                \t\t  \t\t//Collection은 인터페이스, Collections는 유틸클래스  \t\tCollections.sort(list1); //list1과 list2를 정렬한다  \t\tCollections.sort(list2); //Collections.sort(list1)  \t\tprint(list1, list2);                \t\t  \t\t//list1이 list2의 모든 요소를 포함하고 있는가?  \t\tSystem.out.println(\"list1.conrainsAll(list2) : \"+list1.containsAll(list2));                \t\t  \t\tlist2.add(\"B\");  \t\tlist2.add(\"C\");  \t\tlist2.add(3,\"A\"); //기존 값은 삭제되니 신중히  \t\tprint(list1, list2);                \t\t  \t\tlist2.set(3, \"AA\");  \t\tprint(list1, list2);                \t\t  \t\tlist1.add(0,\"1\");  \t\t//list1에서 \"1\"이 어느 위치에 있는지 출력   \t\tSystem.out.println(\"\\\"1\\\"의 index = \"+list1.indexOf(\"1\")); //0  \t\tSystem.out.println(\"1의 index = \"+list1.indexOf(1)); //2  \t\tprint(list1,list2);  \t\tlist1.remove(0); //list1[0]자리의 값을 0으로(String이라)  \t\tprint(list1, list2);  \t\tlist1.remove(5); //list1[5]를 삭제  \t\tprint(list1, list2);                \t\t  \t\tlist1.remove(new Integer(1)); //값이 1인 것을 삭제  \t\tprint(list1, list2);                \t\t  \t\t// list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제  \t\tSystem.out.println(\"list1.retainAll(list2) : \"+list1.retainAll(list2));  \t\tprint(list1, list2);                \t\t  \t\t//list2에서 list1에 포함된 객체들을 삭제  \t\tfor(int i = list2.size()-1;i&gt;=0;i--) {  \t\t\tif(list1.contains(list2.get(i)))  \t\t\t\t\tlist2.remove(i);  \t\t}  \t\tprint(list1, list2);  \t}                  \tprivate static void print(ArrayList list1, ArrayList list2) {  \t\tSystem.out.println(\"list1:\"+list1);  \t\tSystem.out.println(\"list2:\"+list2);  \t\tSystem.out.println();  \t}  }                                                            ArrayList에 저장된 객체의 삭제 과정                                                      삭제할 데이터 아래의 데이터를 한 칸씩 위로 복사해서 삭제할 데이터 덮어쓰기(부담 많이감.) System.arraycopy(data, 3, data, 2, 2) data[3]에서 data[2]로 2개의 데이터를 복사함                                                        데이터가 모두 한 칸씩 이동했으므로 마지막 데이터는 null로 변경 data[size-1]=null;                                                        데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 감소시킨다 size–;                                                        마지막데이터를 삭제하는 경우 1번은 안해도됨.                                                  — for문으로 모든 객체 지우기                for(int i =list.size()-1;i&gt;=0;i–) { list.remove(i); }  이렇게안하면 배열이 자꾸 위로 올라가서 다 안지워짐                                                                LinkedList : 배열의 단점을 보완 (연결기반)                  배열의 장단점                          배열의 장점 : 구조가 간단, 데이터를 읽는데 걸리는 시간이(접근시간, access time) 짧음              배열의 단점                                  크기 변경x : 변경 시 새로운 배열을 생성한 후 데이터를 복사해야함. 미리 넉넉하게 배열크기를 지정하면 메모리가 낭비됨                                          더 큰 배열 생성                      복사                      참조 변경                                                        비순차적인 데이터의 추가, 삭제에 시간이 많이 걸림  → 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.  그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠름                                                              배열과 달리 LinkedList는 불연속적으로 존재하는 데이터를 연결          데이터의 삭제 : 단 한번의 참조 변경만으로 가능          데이터 추가 : 한번의 Node객체 생성과 두번의 참조 변경만으로 가능                      단점                          접근성이 나쁨. (불연속적이라서)  첫번째 배열에서 마지막 배열까지 가려면 모든 배열을 거쳐서 가야함                        ⇒ 서큘러 링크드 리스트(이중 원형리스트, doubly circular linked list)[첫번째애서 마지막으로 이동이 편리) , 이중연결리스트(doubly linked list)[앞뒤 이동만 편해짐]로 , 접근성 향상                                      [!important]ArrayList vs Linked List데이터를 순차적 추가/삭제 - ArrayList데이터를 비순차적으로 추가/삭제 - LinkedList접근시간(access time) - ArrayList⇒ 읽기는 ArrayList, 추가/삭제는 LinkedList가 빠르다      Collection인터페이스의 메소드는 제외됨(자손이라 쓸 수 있음)  Set인터페이스 - 순서x, 중복x (집합)                  HashSet : Set인터페이스를 구현한 대표적인 컬렉션 클래스. 순서를 유지하려면 LInkedHashSet을 사용 (중복 방지를 위해 객체 저장 전에 기존에 같은 객체가 있는지 확인함)                  생성자                          HashSet()              HashSet(Collection c) : 지정된 컬렉션에 모든 객체 저장              HashSet(int initialCapacity) : 초기용량 지정(보통 2배)              HashSet(int initialCapacity, float loadFactor) : 언제 용량을 늘릴건지(보통2배)                                추가/삭제                          boolean add(Object o) : 추가 - 중복 확인을 위해 저장할 객체의 equals()와 hashCode()를 호출, equals()와 hashCode()가 오버라이딩 되어있어야함(equals()만 해도되나 hashCode()까지 오버라이딩 해주는 것이 정석임)              boolean addAll(Collection c) : 추가(합집합)              boolean remove(Object o) : 삭제              boolean removeAll(Collection c) : 삭제 (교집합)              boolean retainAll(Collection c) : Collection에 있는거만 남기고 삭제(조건부삭제, 차집합)              void clear() : 모두 삭제                                포함                          boolean contains(Object o) : set이 객체를 포함했다면 true, 아니라면 false              boolean containsAll(Collection c) : Collection에 담긴 여러 객체가 모두 포함되어있는지              Iterator iterator() : 컬랙션의 요소를 읽어옴                                확인                          boolean isEmpty() : 비었는지              int size() : 저장된 객체의 갯수              Object[] toArray() : set에 저장된 객체를 객체배열로 반환              Object[] toArray(Object[] a)                                        import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tObject [] objarr = {\"1\", new Integer(1),\"2\",\"2\",\"3\",\"3\",\"4\",\"4\",\"4\"};  \t\tSet set = new HashSet();  \t\tfor(int i=0;i&lt;objarr.length;i++) {  \t\t\tSystem.out.println(objarr[i]+\"=\"+set.add(objarr[i])); //HashSet에 objarr의 모든 요소를 저장  \t\t}  \t\t//HashSet에 저장된 요소를 출력(set이라서 중복된 것 제외됨)  \t\tSystem.out.println();  \t\tSystem.out.println(set);        \t\t  \t\t//HashSet에 저장된 요소들을 출력(Iterator이용)  \t\tIterator it = set.iterator();        \t\t  \t\twhile(it.hasNext()) { //읽을 요소가 남아있는지 확인  \t\t\tSystem.out.println(it.next()); //요소 하나 꺼내오기  \t\t}// =&gt; 읽은 요소가 없을때까지 꺼내옴  \t}                }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tSet set = new HashSet();        \t\t  \t\t//set의 크기가 6보다 작은 동안 1~45사이의 난수를 저장  \t\tfor(int i=0; set.size()&lt;6 ;i++) {  \t\t\tint num = (int)(Math.random()*45+1);  \t\t\tset.add(num);  \t\t}  \t\tSystem.out.println(set);  \t\t//set은 정렬(순서유지) 안됨 -&gt; LinkedList사용   \t\tList list = new LinkedList(set); //LinkedList(Collection c)  \t\tCollections.sort(list);  //Collections.sort(List list)  \t\tSystem.out.println(list);  \t}                }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashSet set = new HashSet();        \t\t  \t\tset.add(\"abc\");  \t\tset.add(\"abc\");  \t\tset.add(new Person(\"Daivd\",10));  \t\tset.add(new Person(\"Daivd\",10));        \t\t  \t\tSystem.out.println(set);  \t}                }  //equals와 hashCode를 오버라이딩 안해주면 david,10이 두번 다 저장됨  class Person{  \tString name;  \tint age;        \t  \tPerson(String name, int age){  \t\tthis.name=name;  \t\tthis.age = age;  \t}        \t  \tpublic String toString() {  \t\treturn name+\" : \"+age;  \t}          \tpublic int hashCode() {  \t\t//int hash(Object... values);//가변인자  \t\treturn Objects.hash(name,age);  \t}          \tpublic boolean equals(Object obj) {  \t\tif(!(obj instanceof Person)) return false;        \t\t  \t\tPerson p =(Person)obj;  \t\t//나자신의 이름과 나이를 p와 비교  \t\treturn this.name.equals(p.name) &amp;&amp; this.age==p.age;  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashSet setA = new HashSet();  \t\tHashSet setB = new HashSet();  \t\tHashSet setHab = new HashSet();  \t\tHashSet setKyo = new HashSet();  \t\tHashSet setCha = new HashSet();        \t\t  \t\tsetA.add(\"1\"); setA.add(\"2\"); setA.add(\"3\"); setA.add(\"4\"); setA.add(\"5\");  \t\tSystem.out.println(\"A = \"+setA);        \t\t  \t\tsetB.add(\"4\"); setB.add(\"5\"); setB.add(\"6\"); setB.add(\"7\"); setB.add(\"8\");  \t\tSystem.out.println(\"B = \"+setB);        \t\t  \t\t//교집합  \t\tIterator it = setB.iterator();  \t\twhile(it.hasNext()) {  \t\t\tObject tmp = it.next();  \t\t\tif(setA.contains(tmp)) { //setB의 구성요소를 하나씩 빼서 setA에 있는지 확인  \t\t\t\tsetKyo.add(tmp);  \t\t\t}  \t\t}        \t\t  \t\t//차집합  \t\tit = setA.iterator();  \t\twhile(it.hasNext()) {  \t\t\tObject tmp = it.next();  \t\t\tif(!setB.contains(tmp)) {  \t\t\t\tsetCha.add(tmp);  \t\t\t}  \t\t}        \t\t  \t\t//합집합  \t\tit = setA.iterator();  \t\twhile(it.hasNext()) {  \t\t\tsetHab.add(it.next());  \t\t}  \t\tit = setB.iterator();  \t\twhile(it.hasNext()) {  \t\t\tsetHab.add(it.next());  \t\t} //어차피 set은 중복 제거 돼서 중복제거안해줘도됨        \t\t  \t\tSystem.out.println(\"A ∩ B = \"+setKyo);  \t\tSystem.out.println(\"A ∪ B = \"+setHab);  \t\tSystem.out.println(\"A - B = \"+setCha);        \t\t  \t\t//교집합(위에거 간단히)  //\t\tsetA.retainAll(setB);  //\t\tSystem.out.println(\"A ∩ B = \"+setA);  \t\t//합집합  //\t\tsetA.addAll(setB);  //\t\tSystem.out.println(\"A ∪ B = \"+setA);  \t\t//차집합  //\t\tsetA.removeAll(setB);  //\t\tSystem.out.println(\"A - B = \"+setA);  \t}  }                            TreeSet : 범위 검색과 정렬에 유리한 컬렉션 클래스. HashSet보다 데이터 추가, 삭제에 시간이 더 걸림. 이진 탐색 트리(binary search tree)로 구현.                  이진트리는 모든 노드(요소)가 최대 2개의 하위노드(요소)를 갖음. 각 요소가 나무 형태로 연결(LinkedList의 변형)          이진 탐색 트리(binary search tree) : 부모보다 작은 값은 왼쪽에, 큰 값은 오른쪽에 저장(이진트리는 값의 크기랑은 상관없음). 데이터가 많이질 수록 추가, 삭제에 시간이 더 걸림(비교횟수 추가)          데이터 저장 과정 : boolean add(Object o) - 중복이면 false반환, 저장안됨                        Comparator : 비교기준            import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tSet set = new TreeSet();        \t\t  //\t\tfor(int i =0; set.size()&lt;6;i++) {  //\t\t\tint num = (int)(Math.random()*45)+1;  //\t\t\tset.add(num); //set.add(new Integer(num));  //\t\t}  //\t\tSystem.out.println(set);  \t\t//TreeSet이라서 정렬안해도 해줌(Hashset은 정렬 필요)  //\t\tset.add(new Test());   //\t\tset.add(new Test());   //\t\tset.add(new Test());   \t\tset.add(new Test());   \t\tSystem.out.println(set); //[Test@77459877, Test@5b2133b1, Test@72ea2f77, Test@33c7353a]  \t}  }                  //class TestComp implements Comparator{  //  //\t@Override  //\tpublic int compare(Object o1, Object o2) {  //\t\treturn -1; //같은 객체가 아님을 지정  //\t}  //}  class Test implements Comparable{//비교기준이 없다면 에러.           \t@Override  \tpublic int compareTo(Object o) {  \t\treturn -1;  \t}         \t  }  //결론 : \tSet set = new TreeSet(new TestComp);, set.add(new Test()); 처럼 둘중에 하나는 비교기준을 지정해 줘야함                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tTreeSet set = new TreeSet(); //범위검색에 유리        \t\t  \t\tString from = \"b\";  \t\tString to = \"d\";        \t\t  \t\tset.add(\"abc\"); set.add(\"alien\"); set.add(\"bat\");  \t\tset.add(\"car\"); set.add(\"Car\"); set.add(\"disc\");  \t\tset.add(\"dance\"); set.add(\"dZZZZ\"); set.add(\"dzzzz\");  \t\tset.add(\"elephant\"); set.add(\"elevator\"); set.add(\"fan\");  \t\tset.add(\"flower\");        \t\t  \t\tSystem.out.println(set);  \t\tSystem.out.println(\"range search : from \"+from + \" to \"+to);  \t\tSystem.out.println(\"result1 : \"+set.subSet(from, to));  \t\tSystem.out.println(\"result2 : \"+set.subSet(from, to+\"zzz\")); //\"b\"~~~zzz으로 끝나는 부분까지 출력  \t\t/* result1 : [bat, car]  \t\tresult2 : [bat, car, dZZZZ, dance, disc] */  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tTreeSet set = new TreeSet();   \t\tint score[]= {80,95,50,35,45,65,10,100};        \t\t  \t\tfor(int i=0;i&lt;score.length;i++) {  \t\t\tset.add(new Integer(score[i]));  \t\t}        \t\t  \t\tSystem.out.println(\"50보다 작은 값 : \"+set.headSet(50));  \t\tSystem.out.println(\"50보다 큰 값 : \"+set.tailSet(50));  \t\tSystem.out.println(\"50보다 큰 값 : \"+set.subSet(40,80));  \t}  }                — 트리 순회(tree traversal) : 이진트리의 모든 노드를 한번 씩 읽는 것                  전위순회 : 부모 먼저 읽음          후위순위 : 자식 먼저 읽음                      중위순외 : (좌)자식-부모-(우)자식순으로 읽음 (오름차순 정렬됨)  ⇒ treeSet이 정렬에 유리한 이유                    레벨순회 : 순서대로 위에서부터 좌우로 읽음                    Set인터페이스의 메소드 == Collection인터페이스의 메소드              집합과 관련된 메소드(Collection에 변화가 있으면 true, 아니면 false                          Map인터페이스 - 순서x, 중복(키x,값o)                  HashMap(동기화x) : Map인터페이스를 구현한 대표적인 클래스, 데이터를 키와 값의 쌍으로 저장, Hashtable의 신버전. Hashtable은 동기화가 됨.  해싱(hashing)기법으로 데이터를 저장. 데이터가 많아도 검색이 빠름                  LinkedHashMap : 순서 필요할때 사용          해싱(hashing) : 해시함수를 이용해서 헤시테이블(hash table)에 데이터를 저장, 검색                          해시함수(hash function) : key를 넣으면 index를 반환 - 같은 키를 넣으면 항상 같은 값이 나옴              해시테이블(hash table) : 배열과 LikedList가 조합된 형태                              해시테이블에 저장된 데이터를 가져오는 과정                                  키로 해시함수를 호출, 해시코드를 얻는다.                  해시코드(해시함수의 반환값)에 대응하는 LikedList를 배열에서 찾는다.                  LikedList에서 키와 일치하는 데이터를 찾는다.                                — 해시함수는 같은 키에 대해 항상 같은 해시코드를 반환해야 한다. 서로 다른 키일지라도 같은 값의 해시코드를 반환할 수도 있다.                                              주요 메소드                          생성자                                  HashMap()                  HashMap(int initialCapacity) :                  HashMap(int initalCapacity, float loadFactor)                  HashMap(Map m) : 다른 Map을 HashMap으로 변경 가능                                            저장/삭제/수정                                  Object put(Object key, Object value) : 데이터 저장                  void putAll(Map m) : 지정된 Map을 모두 저장                  Object remove(Object key, Object value) : 삭제                  boolean replace(Object key, Object odlValue, Object newValue) : 기존 키를 새로운 키로 변경                                            읽기                                  Set entrySet() : 키과 값으로 이루어진 set을 얻을 수 있음                  Set keySet() : 키 값만 가져옴                  Collection values() : 값만 가져옴                                            기타                                  Object get(Object key) : 키를 넣으면 값이 반환됨                  Object getOr Default(Object key, Object defaultValue) : 저장된 키가 없다면 지정된 값을 반환                  boolean containsKey(Object key) : 지정된 키가 있는지. 있으면 t, 없으면 f                  boolean containsValue(Object value) : 지정된 값이 있는지 있으면 t, 없으면 f                                                                      import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashMap map = new HashMap();  \t\tmap.put(\"myId\",\"1234\");  \t\tmap.put(\"asdf\",\"1111\");   //\t\tSystem.out.println(map);  \t\tmap.put(\"asdf\",\"1234\");  //\t\tSystem.out.println(map);  //\t\t//마지막값으로 입력됨        \t\t  \t\tScanner s = new Scanner(System.in);        \t\t  \t\twhile(true) {  \t\t\tSystem.out.println(\"id와 password를 입력해주세요\");  \t\t\tSystem.out.println(\"id : \");  \t\t\tString id = s.nextLine().trim();        \t\t\t  \t\t\tSystem.out.println(\"password : \");  \t\t\tString password = s.nextLine().trim();  \t\t\tSystem.out.println();        \t\t\t  \t\t\tif(!map.containsKey(id)) {  \t\t\t\tSystem.out.println(\"입력하신 아이디는 존재하지 않습니다. 다시 시도해주세요\");  \t\t\t\tcontinue;  \t\t\t}  \t\t\tif(!(map.get(id).equals(password))) {  \t\t\t\tSystem.out.println(\"비밀번호가 일치하지 않습니다. 다시 시도해주세요\");  \t\t\t\tcontinue;  \t\t\t}else {  \t\t\t\tSystem.out.println(\"로그인 되었습니다!\");  \t\t\t\tbreak;  \t\t\t}  \t\t}  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashMap map = new HashMap();  \t\tmap.put(\"김자바\", new Integer(90));  \t\tmap.put(\"김자바\", new Integer(100));  \t\tmap.put(\"이자바\", new Integer(100));  \t\tmap.put(\"강자바\", new Integer(80));  \t\tmap.put(\"안자바\", new Integer(90));        \t\t  \t\t//entry는 map인터페이스의 내부 인터페이스  \t\tSet set = map.entrySet();  \t\tIterator it = set.iterator();        \t\t  \t\twhile(it.hasNext()) {  \t\t\tMap.Entry e = (Map.Entry)it.next();  \t\t\tSystem.out.println(\"이름 : \"+e.getKey() + \", 점수 : \"+e.getValue());  \t\t}  \t\tset = map.keySet();  \t\tSystem.out.println(\"참가자 명단 : \"+set);        \t\t  \t\tCollection values = map.values();  \t\tit = values.iterator();        \t\t  \t\tint total=0;        \t\t  \t\twhile(it.hasNext()) {  \t\t\tint i = (int)it.next();  \t\t\ttotal += i;  \t\t}  \t\tSystem.out.println(\"총점 : \"+total);  \t\tSystem.out.println(\"평균 : \"+(float)total/set.size());  \t\tSystem.out.println(\"최고 점수 : \"+Collections.max(values));  \t\tSystem.out.println(\"최저 점수 : \"+Collections.min(values));  \t}  }                            TreeMap : 이진탐색트리. 범위검색과 정렬에 유리하며, HashMap보다 데이터 추가, 삭제에 시간이 더 걸림                import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tString data[] = {\"A\",\"K\",\"A\",\"K\",\"D\",\"K\",\"A\",\"K\",\"k\",\"K\",\"Z\",\"D\"};  \t\tHashMap map = new HashMap();    \t\t  \t\tfor(int i=0;i&lt;data.length;i++) {  \t\t\tif(map.containsKey(data[i])) {  \t\t\t\tint value = (int)map.get(data[i]); //map.get() 키를 넣으면 값이 반환  \t\t\t\tmap.put(data[i], value+1);  \t\t\t} else {  \t\t\t\tmap.put(data[i], 1);  \t\t\t}  \t\t}  \t\tIterator it = map.entrySet().iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tMap.Entry entry = (Map.Entry)it.next();  \t\t\tint value = (int)entry.getValue();  \t\t\tSystem.out.println(entry.getKey()+\" : \"+printBar('*',value)+\" \"+value);  \t\t}  \t}  \tpublic static String printBar(char ch, int value) {  \t\tchar bar[] = new char[value];  \t\tfor(int i=0;i&lt;bar.length;i++) {  \t\t\tbar[i] = ch;  \t\t}  \t\treturn new String(bar);  \t}  }      스택과 큐(Stack &amp; Queue)import java.util.*;public class  Main {\tpublic static void main(String[] args) {\t\tStack st = new Stack();\t\tQueue q = new LinkedList(); //Queue인테페이스의 구현체인 LinkedList사용\t\t\t\tst.push(\"0\");\t\tst.push(\"1\");\t\tst.push(\"2\");\t\t            \t\tq.offer(\"0\");\t\tq.offer(\"1\");\t\tq.offer(\"2\");\t\t\t\tSystem.out.println(\"=====Stack=====\");\t\twhile(!st.empty()) {\t\t\tSystem.out.println(st.pop()); //스택요소 하나하나 꺼내기\t\t}\t\tSystem.out.println(\"=====Queue=====\");\t\twhile(!q.isEmpty()) {\t\t\tSystem.out.println(q.poll()); //스택요소 하나하나 꺼내기\t\t}\t}}      스택 : LIFO(Last In First Out, 후입선출)구조. 저장(push), 추출(pop) — 배열이 효율적(순차적이라서)          활용 예 : 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로          import java.util.*;      public class  Main {  \tpublic static void main(String[] args) {  \t\tif(args.length !=1) {  \t\t\tSystem.out.println(\"usage : java Ex11_3 \\\"EXPRESSIN\\\"\");  \t\t\tSystem.out.println(\"Example : java Ex11_3 \\\"((2+3)*1)3\\\"\");  \t\t\tSystem.exit(0);  \t\t}    \t\t  \t\tStack st = new Stack();  \t\tString expression = args[0];    \t\t  \t\tSystem.out.println(\"expression : \"+expression);    \t\t  \t\ttry {  \t\t\tfor(int i=0;i&lt;expression.length();i++) {  \t\t\t\t//입력된 수식에서 하나씩 꺼내기  \t\t\t\tchar ch = expression.charAt(i);     \t\t\t  \t\t\tif(ch=='(') {  \t\t\t\t//여는괄호라면, 스택에 집어넣고  \t\t\t\tst.push(ch+\"\");  \t\t\t\t//닫는 괄호라면, 스택에서 꺼냄  \t\t\t}else if(ch==')') {  \t\t\t\tst.pop();  \t\t\t}  \t\t}  \t\t\t//스택이 비었다면?  \t\t\tif(st.isEmpty()) {  \t\t\t\tSystem.out.println(\"괄호가 일치합니다\");  \t\t\t}else {  \t\t\t\tSystem.out.println(\"1.괄호가 일치하지 않습니다\");  \t\t\t}  \t\t}catch (EmptyStackException e) {  \t\t\t//(2+3)*1)))) 이런식으로 꺼낼 괄호가 없는데 자꾸 추출하려해서 에러날떄  \t\t\tSystem.out.println(\"2.괄호가 일치하지 않습니다\");  \t\t}  }      }            큐 : FIFO(First in First Out, 선입선출)구조, 저장(offer), 추출(poll) — 링크드리스트가 효율적(비순차적이라서) - 인터페이스라 객체생성안됨          활용 예 : 최근사용문서(Recent Files), 인쇄작업 대기목록, 버퍼(buffer)      Queue를 직접 구현                  Queue를 구현할 클래스를 사용(LinkeList 등 공식문서 참조)  ⇒ Queue q = new LinkedList();                        import java.util.*;      public class  Main {  \tstatic Queue q = new LinkedList();  \tstatic final int MAX_SIZE = 5; //Queue에 최대 5개까지 저장됨(최근 5개의 명령어를 저장)    \t  \tpublic static void main(String[] args) {  \t\tSystem.out.println(\"help를 입력하면 도움말을 볼 수 있습니다.\");    \t\t  \t\twhile(true) {  \t\t\tSystem.out.println(\"&gt;&gt;\");  \t\t\ttry {  \t\t\t\t//화면으로부터 라인단위로 입력받음  \t\t\t\tScanner s = new Scanner(System.in);  \t\t\t\tString input = s.nextLine().trim();    \t\t\t\t  \t\t\t\tif(\"\".equals(input)) continue;    \t\t\t\t  \t\t\t\tif(input.equalsIgnoreCase(\"q\")) {  \t\t\t\tSystem.out.println(\"프로그램 종료\");  \t\t\t\tSystem.exit(0);  \t\t\t\t}  \t\t\t\tif(input.equalsIgnoreCase(\"help\")) {  \t\t\t\t\tSystem.out.println(\"help - 도움말을 표시합니다\");  \t\t\t\t\tSystem.out.println(\"q 또는 Q - 프로그램을 종료합니다\");  \t\t\t\t\tSystem.out.println(\"history - 최근에 입력한 명령어를 \"+MAX_SIZE+\"개 보여줍니다\");  \t\t\t\t}else if(input.equalsIgnoreCase(\"history\")) {  \t\t\t\t\tsave(input); //입력한 명령어 저장    \t\t\t\t\t  \t\t\t\t\t//LinkedList의 내용 표시  \t\t\t\t\tLinkedList list = (LinkedList)q;    \t\t\t\t\t  \t\t\t\t\tfinal int size = list.size();  \t\t\t\t\tfor(int i = 0 ; i&lt;size;i++)  \t\t\t\t\t\tSystem.out.println((i+1)+\".\"+list.get(i));  \t\t\t\t}else {  \t\t\t\t\tsave(input);  \t\t\t\t\tSystem.out.println(input);  \t\t\t\t} //if(input.equalsIgnoreCase(\"q\"))  \t\t\t}catch(Exception e) {  \t\t\t\tSystem.out.println(\"입력오류입니다\");  \t\t\t}  \t\t}  \t}      \tprivate static void save(String input) {  \t\t//queue에 저장(빈문자열은 저장안함)  \t\tif(!\"\".equals(input)) {  \t\t\tq.offer(input);    \t\t\t  \t\t\t//queue의 최대크기를 넘으면 제일 처음 입력된 것을 삭제  \t\t\tif(q.size()&gt;MAX_SIZE) //size()는 Collection인터페이스에 정의  \t\t\t\tq.remove(); // == q.pool();  \t\t}  \t}      }      peek : 꺼내지 않고 맨 위에 있는 것을 보는 것밑에 세 개가 예외발생x, 중점으로 쓸것Iterator(새버전), ListIterator, Enumeration(구버전): 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스      Iterator : 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한 것.  컬렉션에 iterator()를 호출해서 Iterator를 구현한 객체를 얻어서 사용          boolean hasNext() : 읽어올 요소가 남아있는지 확인, 있으면 true, 없으면 false(확인)      Object next() : 다음 요소를 읽어온다. next()를 호출하기 전에 hasnext()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다.(읽기)      Map에는 iterator()가 없다. keySet(), entrySet(), values()를 호출해야함                  Map map = new HashMap(); Iterator it =  map.entrySet().iterator();                        import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tList list = new ArrayList(); //다른컬렉션으로 변경할때 이거만 수정하면 됨  \t\tIterator it =list.iterator();    \t\t  \t\twhile (it.hasNext()) { //boolean hasNext() 읽어올 요소가 있는지 확인  \t\t\tSystem.out.println(it.next()); //Object next() 다음요소 읽음  \t\t}  \t}  }          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\t//Set은 Collection의 자손  //\t\tCollection c = new HashSet(); //for문의 get이 오류남  \t\tArrayList list = new ArrayList();  \t\tlist.add(\"1\");  \t\tlist.add(\"2\");  \t\tlist.add(\"3\");  \t\tlist.add(\"4\");  \t\tlist.add(\"5\");    \t\t  \t\t//Iterator를 사용했다면 표준화되어있기때문에 List나 Set 둘다 작동함  \t\tIterator it = list.iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t}    \t\t  \t\twhile(it.hasNext()) { //이미 한번 실행됐기때문에 false반환, 실행 안됨  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t\t//즉,Iterator는 1회용 코드임  \t\t}  \t\tSystem.out.println();  \t\t//새로운 iterator객체 얻어옴  \t\tit = list.iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t}  \t\tSystem.out.println();  \t\tfor(int i=0;i&lt;list.size();i++) {  \t\t\tObject obj = list.get(i);  \t\t\tSystem.out.println(obj);  \t\t}  \t}  }        Enumeration          boolean hasMoreElements() : 읽어올 요소가 남아있는지 확인, 있으면 true, 없으면 false(확인)      Object nextElement() : 다음 요소를 읽어온다. nextElements()를 호출하기 전에 hasMoreElements()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다.(읽기)        Listiterator : Iterator의 접근성을 향상시킨 것. (단방향 → 양방향 : 이전요소도 읽어올 수 있음)Array: 배열을 다루기 편한 메소드(static)을 제공  배열의 출력 -toString()  배열의 복사 - copyOf(), copyOfRange()  배열 채우기 - fill(), setAll()  배열의 정렬과 검색 - sort(), binarySearch()          sort()로 배열 정렬      binarySearch()로 위치 찾기        다차원 배열의 출력 - deepToString()  다차원 배열의 비교 - deepEquals()  배열을 List로 변환 - asList(Object…a)  람다와 스트임(14장)관련 - parallelXXX(). spliterator(), stream()import java.util.*;public class  Main {\t\tpublic static void main(String[] args) {\t\tint arr[] = {0,1,2,3,4};\t\tint arr2D[][] = { {11,12,13},{21,22,23} };\t\t\t\tSystem.out.println(\"arr = \"+Arrays.toString(arr));\t\tSystem.out.println(\"arr2D = \"+Arrays.toString(arr2D)); //arr2D = [[I@6b884d57, [I@38af3868]\t\tSystem.out.println(\"arr2D = \"+Arrays.deepToString(arr2D));\t\t        \t\tint arr2[] = Arrays.copyOf(arr, arr.length); //arr을 똑같이 복사\t\tint arr3[] = Arrays.copyOf(arr, 3);\t\tint arr4[] = Arrays.copyOf(arr, 7); //남는 공간에 0 채워넣음\t\tint arr5[] = Arrays.copyOfRange(arr, 2,4);\t\tint arr6[] = Arrays.copyOfRange(arr, 0,7);\t\t\t\tSystem.out.println(\"arr2 = \"+Arrays.toString(arr2));\t\tSystem.out.println(\"arr3 = \"+Arrays.toString(arr3));\t\tSystem.out.println(\"arr4 = \"+Arrays.toString(arr4));\t\tSystem.out.println(\"arr5 = \"+Arrays.toString(arr5));\t\tSystem.out.println(\"arr6 = \"+Arrays.toString(arr6));\t\t\t\tint arr7[] = new int[5];\t\tArrays.fill(arr7,9); //arr7 전부를 9로 채움 \t\tSystem.out.println(\"arr7 = \"+Arrays.toString(arr7));\t\t\t\tArrays.setAll(arr7,  i-&gt;(int)(Math.random()*6)+1);\t\tSystem.out.println(\"arr7 = \"+Arrays.toString(arr7));\t\t\t\t//향상된 for문. arr7에서 한개씩 꺼내서 i에 집어넣음 \t\tfor(int i : arr7) {\t\t\tchar graph[] = new char[i];\t\t\tArrays.fill(graph, '*');\t\t\tSystem.out.println(new String(graph)+i);\t\t}\t\t\t\tString str2D[][] = new String[][] { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\",\"CCC\"} };\t\tString str2D2[][] = new String[][] { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\",\"CCC\"} };\t\t\t\tSystem.out.println(Arrays.equals(str2D, str2D2)); //false\t\tSystem.out.println(Arrays.deepEquals(str2D, str2D2));\t\t\t\tchar charr[] = {'A','D','C','B','E'};\t\t\t\tSystem.out.println(\"charr = \"+Arrays.toString(charr));\t\tSystem.out.println(\"index of B = \"+Arrays.binarySearch(charr, 'B')); //정렬 전이라 안나옴\t\tSystem.out.println(\"= After sorting = \");\t\tArrays.sort(charr);\t\tSystem.out.println(\"charr = \"+Arrays.toString(charr));\t\tSystem.out.println(\"index of B = \"+Arrays.binarySearch(charr, 'B'));\t}              }— 순차 검색(탐색)과 이진 검색(탐색)  순차 검색 - 순차적으로 찾음  이진 검색 - 정렬 후 반씩 잘라서 특정지점만 찾기Comparator와 Comparable: 객체 정렬에 필요한 메소드(정렬기준 제공)를 정의한 인터페이스  Comparator : 기본 정렬기준을 구현, 두 객체를 비교  Comparable : 기본 정렬기준 외에 다른 기준으로 정렬, 주어진 객체를 자신과 비교  Compare()과 CompareTo()는 두 객체의 비교결과를 반환하도록 작성. 같으면 0, 오른쪽이 크면 음수, 오른쪽이 작으면 양수import java.util.*;public class  Main {\t\tpublic static void main(String[] args) {\t\tString strArr[] = {\"dog\",\"cat\",\"Tiger\",\"lion\"};\t\tSystem.out.println(\"strArrArray = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr); //Comparable구현에 의해 정렬\t\t//원래 Arrays.sort(정렬대상, 정렬기준)인데 String자체에 기본정렬기준[사전순]이 있어[String 안에 comparable 구현돼있음]지정안해줌\t\tSystem.out.println(\"strArrArray = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr, String.CASE_INSENSITIVE_ORDER); //대소문자 구분x\t\tSystem.out.println(\"strArr = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr, new Descending());\t\tSystem.out.println(\"strArr = \"+Arrays.toString(strArr));\t}              }class Descending implements Comparator{\tpublic int compare(Object o1, Object o2) {\t\tif(o1 instanceof Comparable &amp;&amp; o2 instanceof Comparable) {\t\t\tComparable c1 = (Comparable)o1;\t\t\tComparable c2 = (Comparable)o2;\t\t\treturn c1.compareTo(c2)*-1;\t\t\t//-1을 곱해서 기본정렬방식의 역순으로 변경. \t\t}\t\treturn -1;\t}}      Integer와 Comparable          버블정렬(불변)          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t}                static void sort(int [] intarr) {  \tfor(int i=0;i&lt;intarr.length-1;i++) {  \t\tfor(int j=0;j&lt;intarr.length-1-i;i++) {  \t\t\tint tmp = 0;    \t\t\t  \t\t\tif(intarr[j] &gt; intarr[j+1]) {  \t\t\t\ttmp = intarr[j];  \t\t\t\tintarr[j] = intarr[j+1];  \t\t\t\tintarr[j+1]=tmp;  \t\t\t}  \t\t}  \t}  }  }      Collections: 컬렉션을 위한 메소드(static)을 제공  컬렉션 채우기, 복사, 정렬, 검색 - fill(), copy(), sort(), binarySearch() 등      컬렉션의 동기화 - synchronized-0~~~()  List syncList = Colloections.synchronizedList(new ArrayList(…));  ⇒ 동기화 안된 synchronizedList를 넣으면 동기화된 List(Vector와 똑같은 효과)인 syncList가 반환됨    변경불가(readOnly)컬렉션 만들기 - unmodifiable~~~()  싱글톤 컬렉션 만들기 - singleton~~~() : 객체 1개만 저장하는 컬렉션      한종류의 객체만 저장하는 컬력션 만들기 - checked~~~() : 한가지 타입의 객체만 저장가능    List list = new ArrayList();  List checkedList = checkedList(list, String.class); //String만 저장가능  checkedList.add(“abc”);  checkedList.add(3); //에러  import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import static java.util.Collections.*; //Collections를 생략 기능public class  Main {\t\tpublic static void main(String[] args) {\t\tList list = new ArrayList();\t\tSystem.out.println(list);\t\t\t\taddAll(list,1,2,3,4,5); //원래 Collections.addAll()로 써야함\t\tSystem.out.println(list);\t\t\t\trotate(list,2);//반시계방향으로두번회전\t\tSystem.out.println(list);\t\t\t\tswap(list,0,2); //첫번째와 세번쨰를 교환\t\tSystem.out.println(list);\t\t\t\tshuffle(list); //저장된요소의 위치를 임의로 변경\t\tSystem.out.println(list);\t\t\t\tsort(list,reverseOrder()); \t\tSystem.out.println(list);\t\t\t\tsort(list); \t\tSystem.out.println(list);\t\t\t\tint idx = binarySearch(list,3);\t\tSystem.out.println(\"index of 3 = \"+idx);\t\t\t\tSystem.out.println(\"max = \"+max(list));\t\tSystem.out.println(\"min = \"+min(list));\t\tSystem.out.println(\"min = \"+max(list,reverseOrder()));\t\t\t\tfill(list,9); //9로 채움\t\tSystem.out.println(list);\t\t\t\t//list와 같은 크기의 새로운 list생성, 2로 채움\t\tList newlist = nCopies(list.size(),2);\t\tSystem.out.println(\"newList=\"+newlist);\t\t\t\t//공통요소가 없으면 true\t\tSystem.out.println(disjoint(list, newlist));\t\t\t\tcopy(list, newlist);\t\tSystem.out.println(\"newlist=\"+newlist);\t\tSystem.out.println(\"list=\"+list);\t\t\t\t//2를 1로 변경\t\treplaceAll(list,2,1);\t\tSystem.out.println(\"list=\"+list);\t\t\t\tEnumeration e = enumeration(list);\t\tArrayList list2 = list(e);\t\t\t\tSystem.out.println(\"list2 = \"+list2);\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - 날짜와 시간 & 형식화",
    "url": "/posts/%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84-&-%ED%98%95%EC%8B%9D%ED%99%94/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-21 00:00:00 +0900",
    





    
    "snippet": "날짜와 시간      java.util.Date : 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)  date의 메소드는 거의 사용되지 않지만(deprecated), 여전히 쓰이고 잇다.    java.util.Calendar :Date클래스를 개선한 새로운 클래스(JDK1.1), 여전히 단점이 있다 (실무에는 아직 쓰이는 곳이 많음    ...",
    "content": "날짜와 시간      java.util.Date : 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)  date의 메소드는 거의 사용되지 않지만(deprecated), 여전히 쓰이고 잇다.    java.util.Calendar :Date클래스를 개선한 새로운 클래스(JDK1.1), 여전히 단점이 있다 (실무에는 아직 쓰이는 곳이 많음          날짜와 시간을 같이 다루는 것이 단점        java.time 패키지 : Date와 Calendar의 단점을 개선한 새로운 클래스들을 제공(JDK1.8=JDK8)          날짜와 시간의 클래스를 나누어 놓음(LocalDate, LocalTime, LocalDateTime)      Calender클래스추상클래스. getinstace()를 통해 구현된 객체를 얻어야 한다.Calendar cal = new Calendar.getInstance(); //사용자 시스템에 기반해서 서양력, 불교력, 일본력 중 하나를 가져온다. (달력을 지정하는것 보다 애매하게 쓰는게 나중에 달력변경 시 조금만 수정해도 사용할 수 있음 - 추상화 )  get()으로 날짜와 시간 가져오기 - int ger(int field)import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar cal = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tint thisYear = cal.get(Calendar.YEAR); //현재 몇년도인지\t\tint lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);//이달의 마지막 날\t\tSystem.out.println(lastDayOfMonth);\t\t}}            필드명      설명                  YEAR      년              MONTH      월(0부터 시작)              WEEK_OF_MONTH      그 달의 몇 번째 주              WEEK_OF_YEAR      그 해의 몇 번째 주              DATE      일              DAY_OF_MONTH      그 달의 몇 번째 일              DAY_OF_YEAR      그 해의 몇 번째 일              DAY_OF_WEEK      요일              DAY_OF_WEEK_IN_MONTH      그 달의 몇 번째 요일              HOUR      시간(0~11)              HOUR_OF_DAY      시간(0~23)              MINUTE      분              SECOND      초              MILLISECOND      천분의 1초              ZONE_OFFSET      GMT기준 시차(천분의 1초단위)  (한국은 GMT시간보다 9시간빨라서 9로 표시)              AM_PM      오전/오후      import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar cal = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tint thisYear = cal.get(Calendar.YEAR); //현재 몇년도인지\t\tint lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);//이달의 마지막 날\t\tSystem.out.println(lastDayOfMonth);\t\tSystem.out.println(cal.get(Calendar.DAY_OF_WEEK_IN_MONTH));\t\tSystem.out.println(cal.get(Calendar.MONTH)); //0부터시작해서 7나옴 8월임\t\tSystem.out.println(cal.get(Calendar.WEEK_OF_YEAR)); //0부터시작해서 7나옴 8월임\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar today = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tSystem.out.println(\"이 해의 연도 : \"+today.get(Calendar.YEAR));\t\tSystem.out.println(\"월(0~11, 0:1월) : \"+today.get(Calendar.MONTH));\t\tSystem.out.println(\"이 해의 몇 째 주 : \"+today.get(Calendar.WEEK_OF_YEAR));\t\tSystem.out.println(\"이 달의 몇 째 주 : \"+today.get(Calendar.WEEK_OF_MONTH));\t\t\t//DATE와 DAY_OF_MONTH는 같다\t\tSystem.out.println(\"이 달의 며칠 : \"+today.get(Calendar.DATE));\t\tSystem.out.println(\"이 달의 며칠 : \"+today.get(Calendar.DAY_OF_MONTH));\t\tSystem.out.println(\"이 해의 며칠 : \"+today.get(Calendar.DAY_OF_YEAR));\t\tSystem.out.println(\"요일(1~7, 1은 일요일) : \"+today.get(Calendar.DAY_OF_WEEK));\t\tSystem.out.println(\"이 달의 몇 째 요일 : \"+today.get(Calendar.DAY_OF_WEEK_IN_MONTH));\t\tSystem.out.println(\"오전/오후(0:오전,1:오후) : \"+today.get(Calendar.AM_PM));\t\tSystem.out.println(\"시간(0~11) : \"+today.get(Calendar.HOUR));\t\tSystem.out.println(\"시간(0~23) : \"+today.get(Calendar.HOUR_OF_DAY));\t\tSystem.out.println(\"분(0~59) : \"+today.get(Calendar.MINUTE));\t\tSystem.out.println(\"초(0~59) : \"+today.get(Calendar.SECOND));\t\tSystem.out.println(\"1000분의 1초(0~999) : \"+today.get(Calendar.MILLISECOND));\t\t//천분의 1초를 시간으로 표시하기 위해 360000으로 나눔(1시간 = 60*60초)\t\tSystem.out.println(\"TimeZone : \"+today.get(Calendar.ZONE_OFFSET/(60*60/1000)));\t\tSystem.out.println(\"이 달의 마지막 날 : \"+today.getActualMaximum(Calendar.DATE));\t}}  set()으로 날짜와 시간 지정하기datel = Calendar.getInstance();//\t\tdatel.set(Calendar.YEAR, 2022);//\t\tdatel.set(Calendar.MONTH, 10); //11월//\t\tdatel.set(Calendar.DATE, 20);\t\tdatel.set(2022,10,20); //2022년 11월 20일\t\t\t\tCalendar timel = Calendar.getInstance();//\t\tdatel.set(Calendar.HOUR_OF_DAY, 10); //10시//\t\tdatel.set(Calendar.MINUTE, 20); //20분 //\t\tdatel.set(Calendar.SECOND, 30); //30초\t\ttimel.set(10,20,30); //10시import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\t//요일 숫자-&gt;문자열로 바꾸어 표시\t\tfinal String[] DAY_OF_WEEK = {\"\",\"일\",\"월\",\"화\",\"수\",\"목\",\"금\",\"토\",\"일\"};\t\tCalendar date1 = Calendar.getInstance();\t\tCalendar date2 = Calendar.getInstance();\t\t\t\t//month의 경우 0부터 시작하기 때문에 4월인경우 3으로 지정\t\tdate1.set(2022, 3,29);//2022년 4월 29일\t\tSystem.out.println(\"date1은 \" +toString(date1)+DAY_OF_WEEK[date1.get(Calendar.DAY_OF_WEEK)]+\"요일이고, \");\t\tSystem.out.println(\"date2는 \" +toString(date2)+DAY_OF_WEEK[date2.get(Calendar.DAY_OF_WEEK)]+\"요일입니다.\");\t\t//두 날짜간의 차이를 얻으려면, gerTimeInMillis()-날짜,시간을 초단위로 바꿔줌[/1000해줘야함]- 천분의 일초단위로 변환\tlong difference = (date2.getTimeInMillis() - date1.getTimeInMillis())/1000;\tSystem.out.println(\"date1부터 date2까지 \"+difference+\"초가 지났습니다.\");\tSystem.out.println(\"일(day)로 계산하면 \"+difference/(24*60*60)+\"일입니다\");\t//1일 = 24*60*60\t}\tpublic static String toString(Calendar date) {\t\treturn date.get(Calendar.YEAR)+\"년 \"+(date.get(Calendar.MONTH)+1)+\"월 \"+date.get(Calendar.DATE)+\"일\";\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tfinal int[] TIME_UNIT = {3600,60,1};\t\tfinal String[] TIME_UNIT_NAME= {\"시간\",\"분\",\"초\"};\t\tCalendar time1 = Calendar.getInstance();\t\tCalendar time2 = Calendar.getInstance();\t\t\t\ttime1.set(Calendar.HOUR_OF_DAY,10);\t\ttime1.set(Calendar.MINUTE,20);\t\ttime1.set(Calendar.SECOND,30);\t\ttime2.set(Calendar.HOUR_OF_DAY,20);\t\ttime2.set(Calendar.MINUTE,30);\t\ttime2.set(Calendar.SECOND,10);\t\t\t\tSystem.out.println(\"time1 : \"+time1.get(Calendar.HOUR_OF_DAY)+\"시 \"+time1.get(Calendar.MINUTE)+\"분 \"+time1.get(Calendar.SECOND)+\"초\");\t\tSystem.out.println(\"time2 : \"+time2.get(Calendar.HOUR_OF_DAY)+\"시 \"+time2.get(Calendar.MINUTE)+\"분 \"+time2.get(Calendar.SECOND)+\"초\");\t\t\t\t//Math.abs:절대값\t\tlong different = Math.abs(time2.getTimeInMillis()-time1.getTimeInMillis())/1000;\t\tSystem.out.println(\"time1과 time2의 차이는 \"+different+\"초 입니다\");\t\t\t\tString tmp=\"\";\t\tfor(int i=0;i&lt;TIME_UNIT.length;i++) {\t\t\ttmp += different/TIME_UNIT[i]+TIME_UNIT_NAME[i];\t\t\tdifferent %= TIME_UNIT[i];\t\t}\t\tSystem.out.println(\"시분초로 변환하면 \"+tmp+\"입니다.\");\t}}  clear()는 Calendar객체의 모든 필드를 초기화 → 1970년 1월 1일 00:00:00으로 초기화  clear(int field)는 Calendar객체의 특정 필드를 초기화 → 0초 or 0분 or …import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tSystem.out.println(getDaydiff(\"20010103\",\"20010101\")); //2\t\tSystem.out.println(getDaydiff(\"20010103\",\"20010103\")); //0\t\tSystem.out.println(getDaydiff(\"20010103\",\"200103\")); //형식안맞음.\t}\tpublic static int getDaydiff(String yyyymmdd1, String yyyymmdd2) {\t\tint diff=0;\t\ttry{\t\tint year1 = Integer.parseInt(yyyymmdd1.substring(0,4));\t\tint month1 = Integer.parseInt(yyyymmdd1.substring(4,6));\t\tint day1 = Integer.parseInt(yyyymmdd1.substring(6,8));\t\tint year2 = Integer.parseInt(yyyymmdd2.substring(0,4));\t\tint month2 = Integer.parseInt(yyyymmdd2.substring(4,6));\t\tint day2 = Integer.parseInt(yyyymmdd2.substring(6,8));\t\t\t\tCalendar date1 = Calendar.getInstance();\t\tCalendar date2 = Calendar.getInstance();\t\t//date1, date2사이의 약간의(0.000...초 정도)차이 발생//\t\tSystem.out.println(\"date1 : \"+date1);//\t\tSystem.out.println(\"date2 : \"+date2);\t\t//time세팅을 clear해줘야함\t\tdate1.clear();\t\tdate2.clear();\t\tdate1.set(year1, month1,day1);\t\tdate2.set(year2, month2,day2);\t\tdiff=(int)((date1.getTimeInMillis()-date2.getTimeInMillis())/(24*60*60*1000));\t\t} catch(Exception e) {\t\t\tdiff = 0;//substring, parseInt에서 예외 발생시\t\t}\t\treturn diff;\t}}            add()는 특정 필드의 값을 증가 또는 감소(다른 필드에 영향o)      8월 31일에서 일에 +1하면 월도 +1됨                  roll()은 특정 필드의 값을 증가 또는 감소(다른 필드에 영향x)      8월 31일에서 일에 +1해도 월은 그대로임      import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar date = Calendar.getInstance();\t\tdate.set(2022, 7,31);\t\t\t\tSystem.out.println(toString(date)); //8/31\t\tSystem.out.println(\"1일 후\");\t\tdate.add(Calendar.DATE, 1);\t\tSystem.out.println(toString(date)); //9/1\t\tSystem.out.println();\t\tSystem.out.println(\"6달 전\");\t\tdate.add(Calendar.MONTH, -6);\t\tSystem.out.println(toString(date));//3/1\t\tSystem.out.println();\t\tSystem.out.println(\"31일 후(roll)\"); //다른필드(월)에 영향x\t\tdate.roll(Calendar.DATE,31);\t\tSystem.out.println(toString(date)); //3/1\t\tSystem.out.println();\t\tSystem.out.println(\"31일 후(add)\");\t\tdate.add(Calendar.DATE,31);\t\tSystem.out.println(toString(date)); //4/1\t}\tpublic static String toString(Calendar date) {\t\treturn date.get(Calendar.YEAR)+\"년 \"+(date.get(Calendar.MONTH)+1)+\"월 \"+date.get(Calendar.DATE)+\"일\";\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {//달력찍기\t\tif(args.length !=2) {\t\t\tSystem.out.println(\"usage : java Ex10\");\t\t\treturn;\t\t}\t\tint year = Integer.parseInt(args[0]);\t\tint month = Integer.parseInt(args[1]);\t\tint START_DAY_OF_WEEK = 0;\t\tint END_DAY_OF_WEEK = 0;\t\t\t\tCalendar sDay = Calendar.getInstance();//시작일\t\tCalendar eDay = Calendar.getInstance();//끝일\t\t\t\t//월의 경우 -1해줘야함 (0~11)\t\tsDay.set(year,month-1,1);\t\teDay.set(year,month,1);\t\t\t\t//다음 달 첫날에서 하루를 빼면 현재달의 마치막 날이 출력\t\teDay.add(Calendar.DATE, -1);\t\t\t\t//첫번째요일이 무슨 요일인지\t\tSTART_DAY_OF_WEEK = sDay.get(Calendar.DAY_OF_WEEK);\t\t\t\t//eDay의 지정된 날짜\t\tEND_DAY_OF_WEEK=eDay.get(Calendar.DATE);\t\t\t\tSystem.out.println(\"       \"+args[0]+\"년 \"+args[1]+\"일\");\t\tSystem.out.println(\" SU MO TU WE TH FR SA\");\t\t\t\t//해당 월의 1일이 어느 요일인지에 따라서 공백을 출력(일요일부터 시작)\t\tfor(int i=1;i&lt;START_DAY_OF_WEEK;i++) {\t\t\tSystem.out.print(\"   \");\t\t}\t\tfor(int i = 1, n=START_DAY_OF_WEEK;i&lt;=END_DAY_OF_WEEK;i++,n++) {\t\t\tSystem.out.print((i&lt;10)?\"  \"+i:\" \"+i);\t\t\tif(n%7==0) System.out.println();\t\t}\t}}      Date와 Calendar간의 변환          Date의 메소드는 대부분 deprecated되었지만 여전히 사용됨(하위호환성-옛날 기능도 계속 지원해주려고 신경씀)          import java.util.Calendar;      public class  Main {  \tpublic static void main(String[] args) {  \t\t//Calendar-&gt;Date  \t\tCalendar cal = Calendar.getInstance();  \t\tDate d = new Date(cal.getTimeInMillis()); //Date(long date)    \t\t  \t\t//Date -&gt; Calendar  \t\tDate d = new Date();  \t\tCalendar cal = Calendar.getInstance();  \t\tcal.setTime(d);  \t}  }      형식화클래스: java.text 패키지의 DecimalFormat(10진수숫자형식) SimpleDateFormat(날짜형식화)  숫자와 날짜를 원하는 형식으로 쉽게 출력 가능 (숫자, 날짜 → 형식문자열)import java.text.DecimalFormat;public class  Main {\tpublic static void main(String[] args) {\t\tdouble num = 1234567.89;\t\tDecimalFormat df = new DecimalFormat(\"#.\\#E0\"); //지수형식 \t\tSystem.out.println(df); //java.text.DecimalFormat@5c8\t\tString result = df.format(num);\t\tSystem.out.println(result); //1.2E6\t}}  형식 문자열에서 숫자와 날짜를 뽑아내는 기능(형식문자열→숫자, 날짜)import java.text.DecimalFormat;import java.text.ParseException;public class  Main {\tpublic static void main(String[] args) throws ParseException {\t\tDecimalFormat df = new DecimalFormat(\"#,###.##\"); //지수형식 \t\tNumber num = df.parse(\"1,234,567.89\");\t\tdouble d = num.doubleValue();\t\tSystem.out.println(d); //1234567.89\t}}      DecimalFormat                  숫자를 형식화 할때 사용(숫자 → 형식문자열)                            특정 형식의 문자열을 숫자로 변환할 때도 사용(형식 문자열→숫자)          import java.text.DecimalFormat;          public class  Main {  \tpublic static void main(String[] args) {  \t\tdouble num = 1234567.89;  \t\tString[] pattern = {  \t\t\t\t\"0\",  \t\t\t\t\"#\",  \t\t\t\t\"0.0\",  \t\t\t\t\"#.#\",  \t\t\t\t\"0000000000.0000\",  \t\t\t\t\"##########.####\",  \t\t\t\t\"#.\\#-\",  \t\t\t\t\"-#.#\",  \t\t\t\t\"#,###.##\",  \t\t\t\t\"#,####.##\",  \t\t\t\t\"\\#E0\",  \t\t\t\t\"0E0\",  \t\t\t\t\"#\\#E0\",  \t\t\t\t\"00E0\",  \t\t\t\t\"###\\#E0\",  \t\t\t\t\"0000E0\",  \t\t\t\t\"#.\\#E0\",  \t\t\t\t\"0.0E0\",  \t\t\t\t\"0.000000000E0\",  \t\t\t\t\"00.00000000E0\",  \t\t\t\t\"000.0000000E0\",  \t\t\t\t\"#.########\\#E0\",  \t\t\t\t\"##.#######\\#E0\",  \t\t\t\t\"###.######\\#E0\",  \t\t\t\t\"#,###.##+;\\#m###.#\\#-\",  \t\t\t\t\"#.#%\",  \t\t\t\t\"#,#\\u2030\",  \t\t\t\t\"\\u00A4 #,####\",  \t\t\t\t\"'#'#,###\",  \t\t\t\t\"''#,###\",  \t\t};  \t\tfor(int i=0;i&lt;pattern.length;i++) {  \t\t\tDecimalFormat df = new DecimalFormat(pattern[i]);  \t\t\tSystem.out.printf(\"%19s : %s\\n\",pattern[i],df.format(num));  \t\t}  \t}  }  /*  0 : 1234568  # : 1234568  0.0 : 1234567.9  #.# : 1234567.9  0000000000.0000 : 0001234567.8900  ##########.#### : 1234567.89  #.\\#- : 1234567.9-  -#.# : -1234567.9  #,###.## : 1,234,567.89  #,####.## : 123,4567.89  \\#E0 : .1E7  0E0 : 1E6  #\\#E0 : 1.2E6  00E0 : 12E5  ###\\#E0 : 123.5E4  0000E0 : 1235E3  #.\\#E0 : 1.2E6  0.0E0 : 1.2E6  0.000000000E0 : 1.234567890E6  00.00000000E0 : 12.34567890E5  000.0000000E0 : 123.4567890E4  #.########\\#E0 : 1.23456789E6  ##.#######\\#E0 : 1.23456789E6  ###.######\\#E0 : 1.23456789E6  #,###.##+;\\#m###.#\\#- : 1,234,567.89+  #.#% : 123456789%  #,#‰ : 1,2,3,4,5,6,7,8,9,0‰  ¤ #,#### : ? 123,4568  '#'#,### : \\#1,234,568  ''#,### : '1,234,568  */                      ⚠️ Integer,parseInt는 콤마(,)가 포함된 문자열을 숫자로 변환 못함      import java.text.DecimalFormat;      public class  Main {  \tpublic static void main(String[] args) {  \t\tDecimalFormat df = new DecimalFormat(\"#,###.#\");  \t\tDecimalFormat df2 = new DecimalFormat(\"#.##\\#E0\");    \t\t  \t\ttry {  //\t\t\tSystem.out.println(Double.parseDouble(\"1,234,567.89\")); //콤마때매 변환 불가로 에러  \t\t\tSystem.out.println(Double.parseDouble(\"1234567.89\"));   \t\t\tNumber num = df.parse(\"1,2 34,567.89\");  \t\t\tSystem.out.print(\"1,234,567.89\"+\" -&gt; \");    \t\t\t  \t\t\tdouble d = num.doubleValue();  \t\t\tSystem.out.print(d+\" -&gt; \"); //1234567.89    \t\t\t  \t\t\tSystem.out.println(df2.format(num)); //1.235E6  \t\t} catch(Exception e) {  \t\t}  \t}  }            SimpleDateFormat          날짜와 시간을 다양한 형식으로 출력할 수 있게 해줌          import java.text.SimpleDateFormat;  import java.util.Date;      public class  Main {  \tpublic static void main(String[] args) {  \t\tDate today = new Date();  \t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");//소문자 mm은 분이 출력    \t\t  \t\tString result = df.format(today);  \t\tSystem.out.println(result);  \t}  }              특정 형식으로 된 문자열에서 날짜와 시간 뽑아내기          import java.text.DateFormat;  import java.text.ParseException;  import java.text.SimpleDateFormat;  import java.util.Date;      public class  Main {  \tpublic static void main(String[] args) throws ParseException {  \t\tDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");  \t\tDateFormat df2 = new SimpleDateFormat(\"yyyy/MM/dd\");    \t\t  \t\tDate d = df.parse(\"2015년 11월 23일\"); //문자열에서 날짜 뽑기  \t\tString result = df2.format(d); //뽑은 날자 문자열로 바꾸기  \t\tSystem.out.println(result); //2015/11/23    \t\t  \t}  }      월은 MM으로import java.text.SimpleDateFormat;import java.util.Date;public class  Main {\tpublic static void main(String[] args) {\t\tDate today = new Date();\t\t\t\tSimpleDateFormat sdf1, sdf2,sdf3,sdf4;\t\tSimpleDateFormat sdf5, sdf6,sdf7,sdf8,sdf9;\t\t\t\tsdf1=new SimpleDateFormat(\"yyyy-MM-dd\");\t\tsdf2=new SimpleDateFormat(\"''yy년 MMM dd일 E요일\");\t\tsdf3=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\t\tsdf4=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss a\");\t\t\t\tsdf5=new SimpleDateFormat(\"오늘은 올 해의 D번째 날입니다\");\t\tsdf6=new SimpleDateFormat(\"오늘은 이 달의 d번째 날입니다\");\t\tsdf7=new SimpleDateFormat(\"오늘은 올 해의 w번째 주입니다\");\t\tsdf8=new SimpleDateFormat(\"오늘은 이 달의 W번째 날입니다\");\t\tsdf9=new SimpleDateFormat(\"오늘은 이 달의 F번째 E요일입니다\");\t\t\t\tSystem.out.println(sdf1.format(today));\t\tSystem.out.println(sdf2.format(today));\t\tSystem.out.println(sdf3.format(today));\t\tSystem.out.println(sdf4.format(today));\t\tSystem.out.println(sdf5.format(today));\t\tSystem.out.println(sdf6.format(today));\t\tSystem.out.println(sdf7.format(today));\t\tSystem.out.println(sdf8.format(today));\t\tSystem.out.println(sdf9.format(today));\t}}import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;public class  Main {\tpublic static void main(String[] args) {\t\tDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");\t\tDateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd\");\t\t\t\ttry {\t\t\tDate d = df.parse(\"2022년 9월 30일\");\t\t\tSystem.out.println(df2.format(d));\t\t}catch(Exception e) {}\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - java.lang 패키지와 유용한 클래스",
    "url": "/posts/java.lang%ED%8C%A8%ED%82%A4%EC%A7%80%EC%99%80_%EC%9C%A0%EC%9A%A9%ED%95%9C_%ED%81%B4%EB%9E%98%EC%8A%A4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-15 00:00:00 +0900",
    





    
    "snippet": "Object 클래스: 모든 클래스의 최고 조상. 오직 11개의 메소드만을 가지고 있다.nitity(), wait() 등은 쓰레드(13장)와 관련된 메소드이다            Object클래스의 메소드      설명                  protected Object clone()      객체 자신의 복사본을 반환              ...",
    "content": "Object 클래스: 모든 클래스의 최고 조상. 오직 11개의 메소드만을 가지고 있다.nitity(), wait() 등은 쓰레드(13장)와 관련된 메소드이다            Object클래스의 메소드      설명                  protected Object clone()      객체 자신의 복사본을 반환              public boolean equals(Object obj)      객체 자신과 객체 obj가 같은 객체인지 알려준다(같으면 true)              protected public void finalize()      객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출. 이 때 수행되어야하는 코드가 있을 때 오버라이딩(거의 사용안함)              public Class getClass()      객체 자신의 클래스 정보를 담고있는 Class 인스턴스를 반환              public int hashCode      객체 자신의 해시코드를 반환              public String toString()      객체 자신의 정보를 문자열로 반환              public void notify()      객체 자신을 사용하려고 기다리는 쓰레드 하나만 깨움              public void notifyAll()      객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨움              public void wait()  public void wait(long time out)  public void wait(long timeout, int nanos)      다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다. (timeout은 천분의 1초, nanos는 10의9제곱분의 1초)        [!important]Class처럼 앞글자가 대문자인 Class는 클래스 정보를 담기위한 클래스이다.자바 파일을 저장할때 class파일이 생성되고, class 객체가 생성됨. Class를 호출하면 이때 생성된 class객체를 가지고옴이것을 가지고 객체 생성도 하고 정보를 얻을 수 있게 하는 것이 ReflectionAPI라고 한다.equals(Object obj): 객체 자신(this)과 주어진 객체(obj)를 비교한다. 같으면 true, 다르면 falseObject클래스의 equal()는 객체의 주소를 비교(참조변수 값 비교)— == 는 각 객체의 주소가 같을 경우에만 true. 서로 다른 두 객체는 항상 주소가 다르다.//Object의 equals()를 오버라이딩 해서 주소가 아닌 value값을 비교하도록 함class Value{\tint value;\t\tValue(int value){\t\tthis.value = value;\t}\tpublic boolean equals(Object obj) { //오버라이딩\t\t//참조변수의 형변환 전에는 반드시 instaceof로 확인해야 함.\t\tif(!(obj instanceof Value)) return false;\t\tValue v = (Value)obj; //obj를 value로 형변환. obj안에 value라는 멤버가 없음\t\t//return this == obj; //주소비교. 서로 다른 객체는 항상 다른 주소를 가져서 거짓이 나옴\t\treturn this.value == v.value;\t}}public class  Main {\tpublic static void main(Strin] args) {\t\tValue v1 = new Value(10);\t\tValue v2 = new Value(10);\t\tSystem.out.println(v1.value);\t\tSystem.out.println(v2.value);\t\tSystem.out.println(v1);\t\tSystem.out.println(v2);\t\tSystem.out.println(\"=====================\");\t\tif(v1 == v2) \t\t\tSystem.out.println(\"v1과 v2의 값이 같습니다\");\t\t\t\telse \t\t\tSystem.out.println(\"v1과 v2의 값이 다릅니다\"); //출력됨\t\tSystem.out.println(\"=================\");\t\tif(v1.equals(v2)) \t\t\tSystem.out.println(\"v1과 v2의 값이 같습니다\"); //출력됨\t\t\t\telse \t\t\tSystem.out.println(\"v1과 v2의 값이 다릅니다\");\t\t\t}}  인스턴스 변수의 값을 비교하도록 equals()를 오버라이딩class person{\tlong id;\t\tpublic boolean equals(Object obj) {\t\tif(obj instanceof person) {\t\t\treturn id == ((person)obj).id; //obj가 Object타입 값이므로 id값을 참조하기 위해서 person타입으로 형변환 필요\t\t}\t\telse \t\t\treturn false; //타입이 person이 아니라면 값을 비교할 필요도 없다.\t}}class Person{\tlong id;\t\tpublic boolean equals(Object obj) {\t\tif(!(obj instanceof Person)) {\t\t\treturn false; //타입이 person이 아니라면 값을 비교할 필요도 없다.\t}//\t\treturn id == ((Person)obj).id;\t\tPerson p = (Person)obj;\t\treturn id == p.id;\t}\tPerson(long id){\t\tthis.id = id;\t}}public class  Main {\tpublic static void main(Strin] args) {\t\tPerson p1 = new Person(8011081111222L);\t\tPerson p2 = new Person(8011081111222L);\t\t\t\tif(p1.equals(p2))\t\t\tSystem.out.println(\"p1과 p2는 같은 사람입니다\"); //출력\t\telse\t\t\tSystem.out.println(\"p1과 p2는 다른 사람입니다.\");\t}}hashCode(): 객체의 해시코드(hash code)를 반환하는 메소드Object클래스의 hashCode()는 객체의 주소를 int로 변환해서 반환⇒ 객체의 지문이라고 부르기도 함.public class Object{\tpublic native int hashcode();}      equals()를 오버라이딩하면, hashCode()도 오버라이딩해야한다.    : 둘다 객체의 주소를 가지고 작업하기 때문에 둘다 주소를 iv를 사용하여 작업하도록 오버라이딩 해야함    equals()의 결과가 true인 두 객체의 해시코드는 같아야 하기 때문      public class  Main {      \tpublic static void main(Strin] args) {  \t\tString str1 = new String(\"abc\");  \t\tString str2 = new String(\"abc\");  \t\tSystem.out.println(str1.equals(str2)); //true  \t\tSystem.out.println(str1.hashCode()); //96354  \t\tSystem.out.println(str2.hashCode()); //96354  \t\t//equals값이 같으면 hashCode값도 같아야 함    \t\t  \t\t//System.identityHashCode(str1) == Object클래스의 hashCode  \t\tSystem.out.println(System.identityHashCode(str1));  \t\tSystem.out.println(System.identityHashCode(str2));  \t\t//오버라이딩 하기 전의 기능이 필요할 때 사용. 객체마다 다른 해시코드를 반환함.  \t}  }      toString(), toString()의 오버라이딩      toString() : 객체를 문자열(string)으로 반환하기 위한 메소드  -&gt; ‘객체 == iv집합’이므로 객체를 문자열로 변환한다는 것은 iv값을 문자열로 변환한다는 것과 같은 의미    public String toString() { //Object클래스의 toString()  return  getClass().getName()+”@”+Integer.toHexString(hashCode());  }      class Card{  \tpublic String toString() {    //Object클래스의 toString()  \t\treturn \"kind : \"+kind+\", number : \"+number;  \t} //toString 오버라이딩  \tString kind;  \tint number;    \t  \tCard(){  \t\tthis(\"SPADE\",1);  \t}    \t  \tCard(String kind, int number){  \t\tthis.kind = kind;  \t\tthis.number = number;  \t}  }  public class  Main {  \tpublic static void main(Strin] args) {  \t\tSystem.out.println(new Card().toString()); //Card@7a81197d, kind : SPADE, number : 1  \t\tSystem.out.println(new Card(\"HEART\",10).toString()); //Card@5ca881b5 , kind : HEART, number : 10  \t}  }          import java.util.Objects;      class Card{  \tString kind;  \tint number;    \t  \tCard(){  \t\tthis(\"SPADE\",1);  \t}    \t  \t//============================  \t////Source탭의 Generate hashCode()and equals()가 자동으로 해준 hashCode와 equals의 오버라이딩  //\t@Override  //\tpublic int hashCode() {  //\t\treturn Objects.hash(kind, number);  //\t}  //  //\t@Override  //\tpublic boolean equals(Object obj) {  //\t\tif (this == obj)  //\t\t\treturn true;  //\t\tif (obj == null)  //\t\t\treturn false;  //\t\tif (getClass() != obj.getClass())  //\t\t\treturn false;  //\t\tCard other = (Card) obj;  //\t\treturn Objects.equals(kind, other.kind) &amp;&amp; number == other.number;  //\t} //별로 안어려워서 직접 만드는게 더 직관적이고 좋을 확률이 큼!!  //================================================  \tpublic boolean equals(Object obj) {  \t\tif(!(obj instanceof Card))  \t\t\treturn false;    \t\t  \t\tCard c = (Card)obj;  \t\treturn this.kind.equals(c.kind) &amp;&amp; this.number==c.number;  \t\t//kind가 문자열이라서 equals 써줌  \t}  \tequals() 오버라이딩 해주면 hashCode도 오버라이딩 해줘야함  \tpublic int hashCode() {  \t\treturn Objects.hash(kind, number /*더 넣어도 됨*/);   \tint hash(Object... value){...} : 매개변수가 가변인자(Object...)라서 호출시 지정하는 값의 개수가 정해져 있지 않다.  \t}//iv가 같으면 같은 값이 나오게 됨    \t    \t  \tCard(String kind, int number){  \t\tthis.kind = kind;  \t\tthis.number = number;  \t}  \tpublic String toString() {    //Object클래스의 toString()  \t\treturn \"kind : \"+kind+\", number : \"+number;  \t} //toString 오버라이딩  }  public class  Main {  \tpublic static void main(Strin] args) {  \t\tCard c1 = new Card();  \t\tCard c2 = new Card();  \t\tSystem.out.println(c1.toString()); //Card@7a81197d, kind : SPADE, number : 1  \t\tSystem.out.println(c2.toString()); //Card@5ca881b5 , kind : HEART, number : 10  \t\tSystem.out.println(\"===================\");  \t\tSystem.out.println(c1.equals(c2));  \t\tSystem.out.println(c1.hashCode()); //-1842861219  \t\tSystem.out.println(c2.hashCode()); //-1842861219  \t\t//equals가 true면 hashCode가 똑같이 나와야 함  \t\tSystem.out.println(\"===================\");  \t\tCard c3 = new Card(\"HEART\",10);  \t\tCard c4 = new Card(\"DIAMON\",5);  \t\tSystem.out.println(c3.toString()); //kind : HEART, number : 10  \t\tSystem.out.println(c4.toString()); //kind : DIAMON, number : 5  \t\tSystem.out.println(c3.equals(c4)); //false  \t\tSystem.out.println(c3.hashCode()); //2127040613  \t\tSystem.out.println(c4.hashCode()); //-1921929034  \t\t//equals가 false라서 hashCode도 다른 값이 출력됨  \t}  }      String클래스: 문자열을 다루기 위한 클래스String클래스 = 데이터(char[]) + 메소드(문자열관련)내용을 변경할 수 없는 불변(immutable) 클래스String a = “a”; String b = “b”; a=a+b;일때 a의 “a”값이 사라지고 “ab”가 들어오는게 아니라 “ab”라는 객체가 새로 생성되어 a에 “ab”객체의 주소가 들어가고 “a” 객체는 사라지지않음.⇒ 덧셈 연산자를 이용한 문자열 결합은 성능이 떨어짐(매번 객체가 새로 생성됨)문자열의 변경이나 결합이 잦다면, 내용을 변경 가능한 StringBuffer(내용변경가능)를 사용      문자열 비교      public class  Main {  \tpublic static void main(Strin] args) {  \t\t//하나의 문자열을 여러 참조변수가 공유  \t\tString str1 = \"abc\"; //문자열 리터럴 \"abc\"의 주소가 str1에 저장됨  \t\tString str2 = \"abc\"; //문자열 리터럴 \"abc\"의 주소가 str1에 저장됨  \t\tSystem.out.println(str1 == str2); //true  \t\tSystem.out.println(\"equals 비교 : \"+str1.equals(str2)); //true    \t\t  \t\t//항상 새로운 객체 생성  \t\tString str3 = new String(\"abc\");//새로운 String인스턴스 생성  \t\tString str4 = new String(\"abc\");//새로운 String인스턴스 생성  \t\tSystem.out.println(str3 == str4); //false  \t\tSystem.out.println(\"equals 비교 : \"+str3.equals(str4)); //true  \t\t//String은 변경 불가라 굳이 이렇게 할 필요는 없음  \t}  }        문자열 리터럴 : 프로그램 실행시 자동으로 생성 (constant pool에 저장”          같은 내용의 문자열 리터럴은 하나만 만들어짐(불변이라)ㅈ            빈 문자열 (””, empty string)    : 내용이 없는 크기가 0인 char형 배열을 저장하는 문자열        크기가 0인 배열을 생성하는 것은 어느 타입이나 가능.      public class  Main {  \tpublic static void main(Strin] args) {  \t\tchar charr[] = new char[0]; //길이가 0인 배열 = 데이터 저장 불가  \t\tint iarr[] = {}; //길이가 0인 배열 = 데이터 저장 불가  \t\t//주로 숫자를 문자로 바꿀때나(\"\"+5=\"5\") 배열초기화시(null보다 빈문자열이 편리) 사용함  \t}  }      CharSequence : 인터페이스. CharBuffer, Segment, String, StringBuffer, StringBuilder 클래스들의 공통 조상이 없어서 CharSequence 인터페이스로 묶어준거임.regex : 정규식join()과 StringJoinner: 여러 문자열 사이에 구분자를 넣어서 결합한다. (static메소드)import java.util.Arrays;public class  Main {\tpublic static void main(Strin] args) {\t\tString animals = \"dog,cat,bear\";\t\tString arr[] = animals.split(\",\"); //위 문자열을 ,별로 나눠서 배열로 저장\t\tSystem.out.println(Arrays.toString(arr));/dog, cat, bear]\t\tString str = String.join(\"-\", arr); //배열의 문자열을 '-'로 구분해서 결합(배열x 문자열o)\t\tSystem.out.println(str); //dog-cat-bear\t}}문자열과 기본형 간의 변환      숫자를 문자열로 바꾸는 법      \t\tint i = 100;  \t\tString str1 = i+\"\";  \t\tString str2 = String.valueOf(i);            문자열을 숫자로 바꾸는 법      \t\tint i2 = Integer.parseInt(\"100\"); //옛날 방법  \t\tint i3 = Integer.valueOf(\"100\"); //새로운 방법. 위 방법이 종류가 많아져서 통합해버림  \t\tInteger i4 = Integer.valueOf(\"100\"); //반환타입이 Integer  \t\tint i5 = new Integer(100).intValue(); //밑에서 자세히              [!important]byte, short을 문자열로 변경할 때는 String valueOf(int)를 사용하면 됨      public class  Main {\tpublic static void main(Strin] args) {\t\tint iVal = 100;//\t\tString strVal = String.valueOf(iVal);\t\tString strVal = iVal+\"\";\t\t\t\tdouble dVal = 200.0;//\t\tString strVal2 = String.valueOf(dVal);\t\tString strVal2 = dVal + \"\";\t\t\t\tdouble sum = Integer.parseInt(\"+\"+strVal) //문자열-&gt;숫자\t\t\t\t\t\t\t\t+Double.parseDouble(strVal2);\t\tdouble sum2 = Integer.valueOf(strVal)+Double.valueOf(strVal2);\t\t\t\t\t\tSystem.out.println(String.join(\"\",strVal,\"+\",strVal2,\"=\")+sum);\t\tSystem.out.println(strVal+\"+\"+strVal2+\"=\"+sum2); //성능 떨어짐\t}}      n진법 문자열을 숫자로      public class  Main {  \tpublic static void main(Strin] args) {  //\t\tint i5 = Integer.parseInt(\"FF\"); //에러. NumberFormatException. 10진수에 ff가 없음  \t\tSystem.out.println(\"i = \" +Integer.parseInt(\"100\")); //100  \t\tSystem.out.println(\"i = \" +Integer.parseInt(\"100\",10)); //100 위랑 같은거임  \t\tSystem.out.println(\"i1 = \"+Integer.parseInt(\"100\",2)); //4  \t\tSystem.out.println(\"i2 = \"+Integer.parseInt(\"100\",8)); //64  \t\tSystem.out.println(\"i3 = \"+Integer.parseInt(\"100\",16)); //256  \t\tSystem.out.println(\"i4 = \"+Integer.parseInt(\"FF\",16)); //255  \t}  }      StringBuffer의 생성자와 메소드StringBuffer sb = new StringBuffer(”Hi”) 는 16+2(”h”, “i”로 총 2칸)=18문자를 저장할 수 있는 StringBuffer인스턴스를 생성버퍼크기 = char[] 크기⚠️ 자바에서는 범위가 주어졌을때 start ≤ x &lt;end 라 끝 값은 언제나 포함안됨import javax.xml.transform.Source;public class  Main {\tpublic static void main(Strin] args) {\t\tStringBuffer sb = new StringBuffer(\"01\");\t\tStringBuffer sb2 = sb.append(23);\t\tsb.append(\"4\").append(56); //56도 문자로 들어감\t\t\t\tStringBuffer sb3 = sb.append(78);\t\tsb3.append(9.0);\t\t\t\tSystem.out.println(\"sb = \"+sb); //0123456789.0\t\tSystem.out.println(\"sb2 = \"+sb2); //0123456789.0\t\tSystem.out.println(\"sb3 = \"+sb3); //0123456789.0\t\t\t\tSystem.out.println(\"sb = \"+sb.deleteCharAt(10)); //01234567890\t\tSystem.out.println(\"sb = \"+sb.delete(3, 6)); //01267890\t\tSystem.out.println(\"sb = \"+sb.insert(3, \"abc\")); //012abc67890\t\tSystem.out.println(\"sb = \"+sb.replace(6, sb.length(), \"END\")); //012abcEND\t\t\t\tSystem.out.println(\"capacity : \"+sb.capacity()); //18. 처음 sb객체 생성시 \"01\"로 생성해서 16+2\t\tSystem.out.println(\"length : \"+sb.length()); //9\t}}StringBuilder      StringBuffer : 동기화 돼있다. 멀티 쓰레드(13장)에 안전(thread-safe)  → 멀티 쓰레드 프로그램이 아닌경우, 동기화는 불필요한 성능저하를 불러옴        StringBuilder : 동기화 안되어있다. 싱글 쓰레드일때는 StringBuilder를 사용하면 성능이 향상됨  Math: 수학관련 static 메소드의 집합  E : 자연로그의 밑  PI : 원주율  round : 반올림  — double d = 90.7552; d = (Math.round(d*100))/100.0; ⇒ 90.76            ![image](/assets/images/java/2022-08-15-javalang/IMG-20240818214102-9.png      ]      public class  Main {\tpublic static void main(Strin] args) {\t\tdouble sum=0;\t\tdouble sum1=0;\t\tdouble sum2=0;\t\tfor(double d = 1.5; d&lt;=10.5; d++) {\t\t\tdouble d1= Math.round(d);\t\t\tdouble d2= Math.rint(d); //반올림하는데 .5는 짝수를 출력\t\t\t\t\t\tSystem.out.printf(\"%4.1f %4.1f, %4.1f%n\",d,d1,d2);\t\t\t\t\t\tsum+=d;\t\t\tsum1+=d1;\t\t\tsum2+=d2;\t\t\tSystem.out.println(\"====================\");\t\t\tSystem.out.printf(\"%4.1f %4.1f, %4.1f%n\",sum,sum1,sum2);\t\t\tSystem.out.println(\"******************\");\t\t/*\t\t 1.5  2.0,  2.0\t\t====================\t\t 1.5  2.0,  2.0\t\t******************\t\t 2.5  3.0,  2.0\t\t====================\t\t 4.0  5.0,  4.0\t\t******************\t\t 3.5  4.0,  4.0\t\t====================\t\t 7.5  9.0,  8.0\t\t******************\t\t 4.5  5.0,  4.0\t\t====================\t\t12.0 14.0, 12.0\t\t******************\t\t 5.5  6.0,  6.0\t\t====================\t\t17.5 20.0, 18.0\t\t******************\t\t 6.5  7.0,  6.0\t\t====================\t\t24.0 27.0, 24.0\t\t******************\t\t 7.5  8.0,  8.0\t\t====================\t\t31.5 35.0, 32.0\t\t******************\t\t 8.5  9.0,  8.0\t\t====================\t\t40.0 44.0, 40.0\t\t******************\t\t 9.5 10.0, 10.0\t\t====================\t\t49.5 54.0, 50.0\t\t******************\t\t10.5 11.0, 10.0\t\t====================\t\t60.0 65.0, 60.0\t\t******************\t\t\t *///rint가 최종 합산이 더 정확함. \t\t}\t}}래퍼(wrapper)클래스: 기본형 값을 감싸는 클래스. 8개의 기본형을 객체로 다뤄야할 때 사용.public class  Main {\tpublic static void main(Strin] args) {\t\tInteger i = new Integer(100);\t\tInteger i2 = new Integer(100);\t\t\t\tSystem.out.println(\"i==i2 ? \"+(i==i2)); //false\t\tSystem.out.println(\"i.equals(i2)? \"+i.equals(i2)); //true\t\tSystem.out.println(\"i.compareTo(i2) \"+i.compareTo(i2)); //0, 같으면 0, 오른쪽이 작으면 양수, 오른쪽이 크면 음수\t\tSystem.out.println(\"i.toString() = \"+i.toString()); //100(문자열)\t\t\t\tSystem.out.println(\"MAX_VALUE = \"+Integer.MAX_VALUE); //2147483647 . 최댓값 (+20억)\t\tSystem.out.println(\"MIN_VALUE = \"+Integer.MIN_VALUE); //-2147483648 . 최솟값(-20억)\t\tSystem.out.println(\"SIZE = \"+Integer.SIZE+\"bits\"); //32bits\t\tSystem.out.println(\"BYTES = \"+Integer.BYTES+\"BYTES\"); //4BYTES\t\tSystem.out.println(\"TYPE = \"+Integer.TYPE); //int\t}}  타입Value - 래퍼객체 → 기본형 (new Integer → int)  래퍼클래스 → 문자열 - toString() 사용Number클래스: 모든 숫자 래퍼 클래스의 조상— byte, short, integer, long, float, double, BigInteger, BigDecimal오토박싱 &amp; 언박싱오토박싱 : 기본형 → 객체 자동변환 (int → Integer)언박싱 : Integer → int  JDK1.5부터는 기본형과 참조형간의 연산이 가능해짐(컴파일러가 바꿔줌)int i = 5; Integer iobj = new Integer(7); int sum = i+iobg;⇒ int i = 5; Integer iobj = new Integer(7); int sum = i+ iobg.intValue();로 자동 컴파일됨import java.util.ArrayList;public class  Main {\tpublic static void main(Strin] args) {\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\t\tlist.add(10); //오토박싱. 10-&gt; new Integer(10);  \t\t//↑ 원래는 list.add(new Integer)처럼 객체를 넣어줘야 함.JDK1.5이후에만 가능.(컴파일러가 자동변환)\t\t\t\t//list에 저장된 객체를 꺼내기. //\t\tint value = list.get(0).intValue();// 원래는 이렇게 써줘야함. intValue()로 Integer를 int로 변환\t\tint value = list.get(0);  //언박싱. new Integer(10) -&gt; 10;\t}}import java.util.ArrayList;public class  Main {\tpublic static void main(Strin] args) {\t\tint i = 10;\t\t\t\t//기본형 -&gt; 참조형\t\t//Integer intg = Integer.Value(i);\t\tInteger intg = (Integer)i;  \t\t//Object obg = (Object)Integer.Value(i);\t\tObject obg = (Object)i;\t\t\t\t//Long lng = new Long(100L);\t\tLong lng = 100L; //원래는 객체를 생성해줘야 하나 기본형을 바로 저장하도록 컴파일러가 바꿔줌\t\t\t\tint i2 = intg + 10; //참조형+기본형 가능\t\tLong l = intg + lng; //참조형+참조형 가능. \t\t\t\tInteger intg2 = new Integer(20);\t\tint i3 = (int)intg2; //참조형 -&gt; 기본형 가능\t\t\t\t/*컴파일 전 코드 \t\t\t\t\t\t컴파일 후 코드\t\t * Integer intg = (Integer)i;\t\tInteger intg = Integer.Value(i);\t\t *Object obg = (Object)i;\t\t\tObject obg = (Object)Integer.Value(i);\t\t *Long lng = 100L;\t\t\t\t\tLong lng =  new Long(100L);\t\t */\t\t\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - 예외처리",
    "url": "/posts/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 예외",
    "date": "2022-08-14 00:00:00 +0900",
    





    
    "snippet": "프로그램 오류system.out.println(args[0]); //컴파일 에러System.out.println(args[0]); //런타임 에러 : 실행중 발생하는 에러. 매개변수로 받은 값이 없는데 실행해서 생김  논리적에러(logical error) : 작성 의도와 다르게 동작  컴파일러에러(compile-time error) : 컴파일 할 때 ...",
    "content": "프로그램 오류system.out.println(args[0]); //컴파일 에러System.out.println(args[0]); //런타임 에러 : 실행중 발생하는 에러. 매개변수로 받은 값이 없는데 실행해서 생김  논리적에러(logical error) : 작성 의도와 다르게 동작  컴파일러에러(compile-time error) : 컴파일 할 때 발생하는 에러번호          컴파일러                  구문체크          번역          최적화 (ex. int i = 3+5를 8로 변경)                      런타임에러(runtime error) : 실행할 때 발생하는 에러. 프로그램종료                  에러 (error) : 프로그램코드에 의해 수습될 수 없는 심각한 오류  ex)Out Of Memory Error - OOME : 메모리부족으로 일어나는 오류                    예외 (exception) : 프로그램코드에 의해 수습될 수 있는 다소 미약한 오류  ex)RuntimeException, IOException                              Excepton클래스들 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외            — checked예외 : 컴파일러가 예외처리 여부를 체크(예외처리 필수)                                RuntimeException 클래스들 : 프로그래머의 실수로 발생하는 예외            — unchecked예외 : 컴파일러가 예외처리 여부를 체크 안함.(예외처리 선택)              throw new Exception(\"고의로 발생\");  //try-catch문이 없어 컴파일 조차 안됨  \t\tthrow new RuntimeException(\"고의로 발생\");  //try-catch가 없어도 컴파일은 됐으나 실행중 에러. 비정상 종료                                            예외처리(exception handling) : 프로그램 실행시 발생할 수 있는 예외의 발생에 대비한 코드를 작성.  프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지  — try - catch문 사용 - {}생략불가.            try { /예외가 발생할 가능성이 있는 문장을 넣는다/  } catch (Exception1 e1) { /* Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣음/  } catch (Exception2 e2) { / Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 넣음/  catch (ExceptionN eN) { / ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 넣음*/                          try블럭에서 예외가 발생한 경우                                  발생한 예외와 일치하는 catch블럭이 있는지 확인                  일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.                                                            try블럭 내에서 예외가 발생하지 않은 경우                                  catch블럭을 거치지 않고 전체 try-catch문을 빠져나가 수행을 계속한다.                                  public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\ttry {  \t\t\tSystem.out.println(2);  \t\t\tSystem.out.println(3);  \t\t} catch (Exception e) {  \t\t\tSystem.out.println(4); //예외가 발생하지 않아서 출력안됨.   \t\t}//try-catch문의 끝  \t\tSystem.out.println(5);  //1 2 3 5 출력됨  \t\tSystem.out.println(\"=============\");  \t\tSystem.out.println(1);  \t\ttry {  \t\t\tSystem.out.println(0/0); //예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(2);  \t\t} catch (ArithmeticException e) {  \t\t\tSystem.out.println(3);  \t\t}//try-catch문의 끝  \t\tSystem.out.println(4);  //1 3 4 출력됨  \t}//main 메소드의 끝  }                                                              printStackTrace() : 예외발생 당시의 호출스택(Call strack)에 있었던 메소드의 정보와 예외 메시지를 화면에 출력한다.                      getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메세지를 얻을 수 있다.              public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\tSystem.out.println(2);  \t\ttry {  \t\t\tSystem.out.println(3);  \t\t\tSystem.out.println(0/0); //ArithmeticException예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(4); //실행안됨  \t\t} catch (ArithmeticException ae) {  \t\t\tae.printStackTrace();  \t\t\tSystem.out.println(\"예외 메세지 : \"+ae.getMessage());   \t\t} catch (Exception e) {  //Exception : 모든 예외의 최고조상, 모든 예외를 처리함(맨 마지막에 와야함)  \t\t\tSystem.out.println(\"Exception\"); //실행안됨  \t\t}//try-catch문의 끝  \t\tSystem.out.println(6);    \t\t//1 2 3   java.lang.ArithmeticException: / by   zero 예외 메세지 : / by zero   6 출력됨  \t}//main 메소드의 끝  }                                예외 발생시키기                                          연산자 new를 이용해 발생시키려는 예외 클래스의 객체를 만든다 Exception e = new Exception(”고의로 발생시켰음”);                                            키워드 throw를 이용해 예외 발생 throw e;                                              예외 처리방법                                          멀티 catch블럭(try - catch문) : 내용이 같은 catch블럭을 하나로 합친 것 (JDK1.7부터)  try { /…/ } catch (ExceptionA | ExceptionB) { e.printStackTrace (); }                멀티catch블록에 쓰는 두 클래스가 부모자식관계면 에러. 부모만써도 같은 의미라서 에러표시됨                  public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\tSystem.out.println(2);  \t\ttry {  \t\t\tSystem.out.println(3);  \t\t\tSystem.out.println(0/0); //ArithmeticException예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(4); //실행안됨  \t\t} catch (ExceptionA | ExceptionB e) {  //Exception : 모든 예외의 최고조상, 모든 예외를 처리함(맨 마지막에 와야함)  //\t\t\te.methodA(); //에러, e에 ExceptionA가 들어올지 ExceptionB가 들어올지 알수 없음. methodA는 ExceptionA의 멤버라서 에러  \t\t\t//ExceptionA,ExceptionB의 공통멤버는 사용 가능  \t\t\tif(e instanceof ExceptionA) {  \t\t\t\tExceptionA e1 = (ExceptionA)e;  \t\t\t\te1.methodA();  \t\t\t}  \t\t\telse {  \t\t\t\tExceptionB e2 = (ExceptionB)e;  \t\t\t\te2.methodB();  \t\t\t}  \t\t}//try-catch문의 끝  \t\tSystem.out.println(6);    \t}//main 메소드의 끝  }                                                            메소드에 예외 선언하기 : 빈catch블럭을 사용함                ❗예외를 발생시키는 키워드 throw와 메소드에 선언할 때 쓰이는 throws를 잘 구분 할 것.                  static void startInstall() throws SpaceException, MemoryException{  \tif(!enoughSpace()) //설치공간이 부족하다면  \t\tthrow new SpaceException(\"설치공간 부족\");  \tif(!enoughMemory()) //메모리가 부족하다면  \t\tthrow new MemoryException(\"메모리 부족\");  } //내가 처리할 수 없는 것들. 사용자에게 해결하고 오라고 떠넘김                                  public class ex {  \tpublic static void main(String[] args) throws Exception{  \tmethod1(); //같은 클래스 내의 static멤버이므로 객체생성없이 직접 호출 가능  \t}  \tstatic void method1()throws Exception {  \t\tmethod2();  \t}  \tstatic void method2() throws Exception{  \t\tthrow new Exception();  \t}  } //method2에서 발생한 Exception이 try-catch문을 만나지 못해 method1-main까지 올라갔다가 JVM까지 올라감 -&gt; 비정상종료  //try-catch문이 하나는 있어야 해결이됨.                                  import java.io.*;                  public class ex {  \tpublic static void main(String[] args) {  \t\t\tFile f = createFile(\"\");  \t\t\tSystem.out.println(f.getName()+\" 파일이 성공적으로 생성되었습니다\");  \t\t}                   static File createFile(String fileName){  \ttry {  \t\tif(fileName == null || fileName.equals(\"\"))  \t {  \t\t throw new Exception(\"파일 이름이 유효하지 않습니다.\");  \t }  \t} catch(Exception e) {  \t\t fileName = \"제목없음.txt\";  \t }  \t File f = new File(fileName); //File클래스의 객체 생성  \t try {  \t\tf.createNewFile();  \t} catch (IOException e) {  \t\te.printStackTrace();  \t}finally{  \t\t//예외 발생 여부와 상관없이 무조건 실행해야함. 코드 중복 박기 위해  \t}  \t return f;  \t}   }                                                            finally블럭 : 예외 발생 여부와 관계없이 수행되어야 하는 코드                ⚠️ try블럭안에 return문이 있어서 try블럭을 벗어나갈 때도 finally블럭이 실행 됨                                                          사용자정의 예외 만들기            : 우리가 직접 예외 클래스를 정의할 수 있다.            조상은 Exception과 RuntimeException중에 선택 (웬만하면 RuntimeException으로 할것. try-catch문 꼭 안써줘도 됨)              class MyException extends Exception{  \tMyException(String msg){ //문자열을 매개변수로 받는 생성자  \t\tsuper(msg); //조상인 Exception의 생성자를 호출  \t}  }                          class MyException extends Exception{  \t//에러코드 값을 저장하기 위한 필드 추가  \tprivate final int ERR_CODE;  \t MyException(String msg, int errCode){ //생성자  \t\t super(msg);  \t\t ERR_CODE = errCode;  \t }  \t MyException(String msg){ //생성자  \t\t this(msg, 100); //ERR_CODE를 100(기본값)으로 초기화  \t }  \t public int getErrCode() { //에러코드를 얻을 수 있는 메소드도 추가  \t\t return ERR_CODE; //주로 getMessage()와 함께 사용될 것.  \t }  \t}                                            예외 되던지기(exception re-throwing)            : 예외를 처리한 후에 다시 예외를 발생시킴              public class Main {  \tpublic static void main(String[] args) {  \t\ttry {  \t\t\tmethod1();  \t\t} catch (Exception e) {  \t\t\tSystem.out.println(\"main메소드에서 예외처리 되었습니다\");  \t\t} //예외 2번처리 = 예외 되던지기 = 예외 양쪽에서 처리  \t}  static void method1() throws Exception{  \t\ttry {  \t\t\tthrow new Exception();  \t\t}catch (Exception e) {  \t\t\tSystem.out.println(\"method1에서 예외가 처리되었습니다\");  \t\t\tthrow e;  \t\t}  \t}  }                                            연결된 예외(chained exception)            : 한 예외가 다른 예외를 발생시킬 수 있다.            예외 A가 예외 B를 발생시키면 A는 B의 원인예외(cause exception)            Throwable initCause(Throwable cause) : 지정된 예외를 원인 예외로 등록            Throwable getCause() : 원인 예외를 반환              public class Throwable implements Serializable{  \t//...  \tprivate Throwable cause = this; //객체 자신(this)을 원인 예외로 등록  \t//...  \tpublic synchronized Throwable initCause(Throwable cause) {  \t\t//...  \t\tthis.cause = cause; //cause를 원인 예외로 등록  \t\treturn this;  \t}  }                          void install() throws InstallException{ //실제로는 SpaceException이 발생했으나 InstallException안에 포함시켜서 예외 처리됨  \ttry {  \t\tstartInstall(); //SpaceException 발생, 저장공간 부족  \t\tcopyFiles();  \t} catch (SpaceException e) {  \t\tInstallException ie = new InstallException(\"설치 중 예외 발행\");  \t\tie.initCause(e); //ie(InstallException)의 원인 예외를 e(SpaceException)으로 지정  \t\tthrow ie; //InstallException 발생  \t}catch (MemoryException me) {  \t\t//......  \t}   }                        — 이유 1 : 여러 예외를 하나로 묶어서 다루기 위해              void install() throws InstallException{ //실제로는 SpaceException이 발생했으나 InstallException안에 포함시켜서 예외 처리됨  \ttry {  \t\tstartInstall(); //SpaceException 발생, 저장공간 부족  \t\tcopyFiles();  \t} catch (SpaceException e) {  \t\tInstallException ie = new InstallException(\"설치 중 예외 발행\");  \t\tie.initCause(e); //ie(InstallException)의 원인 예외를 e(SpaceException)으로 지정  \t\tthrow ie; //InstallException 발생  \t}catch (MemoryException me) {  \t\t//......  \t}   }  public class Main {              \tpublic static void main(String[] args) {  //\t\ttry {  //\t\t\tinstall();  //\t\t} catch (SpaceException e) {  //\t\t\te.printStackTrace();  //\t\t} catch (MemoryException e) {  //\t\t\te.printStackTrace();  //\t\t} catch (Exception e) {  //\t\t\te.printStackTrace();  \t\ttry {  \t\t\tinstall();  \t\t} catch (InstallException e) {  \t\t\te.printStackTrace();  \t\t} catch (Exception e) {  \t\t\te.printStackTrace();  \t\t}  \t}  }                        — 이유 2 : checked예외를 unchecked예외로 변경할때              static void startInstall() throws SpaceException, MemoryException{  \tif(!enoughSpace())  \t\tthrow new SpaceException(\"설치할 공간이 부족합니다.\");  \tif(!enoughMemory())  \t\tthrow new RuntimeException(new MemoryException(\"메모리가 부족합니다.\"));\t\t  }//MemoryException을 RuntimeException으로 위장해 try-catch문은 사용하지않아도됨  //class SpaceException extends Exception{  //\tSpaceException(String msg){  //\t\tsuper(msg);  \t}  }                                          "
  },
  
  {
    "title": "자바의 정석 강의 - 상속(Ingeritance)",
    "url": "/posts/%EC%83%81%EC%86%8D-(Ingeritance)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 상속",
    "date": "2022-08-05 00:00:00 +0900",
    





    
    "snippet": "상속~는 ~이다 (is - a) - ex.원(circle)은 점(point)다. (x)class 자식클래스 extends 부모클래스  기존의 클래스로 새로운 클래스를 작성(코드 재사용)  두 클래스를 부모와 자식 관계로 이어줌  자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화 블럭 제외 (자식클래스에 멤버가 안적혀있어도 있는거임)  자손의 멤버...",
    "content": "상속~는 ~이다 (is - a) - ex.원(circle)은 점(point)다. (x)class 자식클래스 extends 부모클래스  기존의 클래스로 새로운 클래스를 작성(코드 재사용)  두 클래스를 부모와 자식 관계로 이어줌  자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화 블럭 제외 (자식클래스에 멤버가 안적혀있어도 있는거임)  자손의 멤버 개수가 조상보다 적을 수는 없음.(같거나 많다.)  자손의 변경은 조상에게 영향을 미치지 않음.  부모 클래스의 변경은 자식 클래스에 영향을 미침.class point {\tint x, y;}class point3D extends point {\tint z;}  상속을 받지않고 중복으로 멤버들을 지정해줘도 결과는 똑같음.class Tvclass {\tboolean power;//전원상태(on/off)\tint channel;\t\tvoid power() {power = !power;}\t\tvoid channelUp() {++channel;}\t\tvoid channelDown() {--channel;}}\tclass SmartTv extends Tvclass{ //SmartTv는 Tv에 캡션(자막)을 보여주는 기능을 지원\tboolean caption; //캡션상태 (on/off)\tvoid displayCapion(String text) {\t\tif(caption) { \t\t\t//캡션의 상태가 on(true)일때만 text를 보여줌\t\t\tSystem.out.println(text);\t\t}\t}}public class Ex7_1 {\tpublic static void main(String[] args) {\t\tSmartTv stv = new SmartTv();\t\tstv.channel=10; //조상에게 상속받은 멤버\t\tstv.channelUp(); //조상에게 상속받은 멤버\t\tSystem.out.println(stv.channel);\t\tstv.displayCapion(\"ssssssssssss\"); //자막 off상태\t\tstv.caption = true;\t\tSystem.out.println(\"ssssssssssssssssssssssss\");\t\t\t\t\t}}포함(composite)~은 ~을 가지고 있다. (has - a) - ex. 원(circle)은 점(point)를 가지고 있다.(o)  — 90%가 포함이라고 보면 됨      클래스의 멤버로 참조변수를 선언함  class Point {\tint x; //원점의 x좌표\tint y; //원점의 y좌표}class circle {\tPoint c =new Point(); //c가 또 객체를 만들어서 Point를 가르킴\tint r; //반지름}//class circle { int x; int y; int r;}과 같은 거임.public class Ex7_1 {\tpublic static void main(String[] args) {\t\tcircle c = new circle();\t\tc.c.x = 5;\t\tc.c.y = 10;\t\tc.r = 15;\t\t//x,y는 circle c의 point c를 불러야 사용가능class Point{\tint x, y;}class Circle extends Point{\tint r;}class Circle2{\tPoint p = new Point();\tint r;}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\tc.x=1;\t\tc.y=2;\t\tc.r=3;\t\tSystem.out.println(\"c.x = \"+c.x);\t\tSystem.out.println(\"c.y = \"+c.y);\t\tSystem.out.println(\"c.r = \"+c.r);\t\t\t\tSystem.out.println();\t\t\t\tCircle2 c2 = new Circle2();\t\tc2.p.x = 10;\t\tc2.p.y = 15;\t\tc2.r=20;\t\tSystem.out.println(\"c2.p.x = \"+c2.p.x);\t\tSystem.out.println(\"c2.p.y = \"+c2.p.y);\t\tSystem.out.println(\"c2.p.r = \"+c2.r);\t\t\t}}단일상속(Single Inheritance)자바는 단일 상속만을 허용함. (c++은 다중상속 허용) → 인터페이스를 이용하면 비슷한 기능을 쓸 수 있음  비중이 높은 클래스 하나만 상속으로 나머지는 포함으로 작성 가능Object class - 모든 클래스의 조상  부모가 없는 클래스는 자동적으로 object 클래스를 상속받게 됨.      모든 클래스는 object클래스에 정의된 11개의 메소드를 상속받음  toString(), equals(Object obj), hashCode() ……..등등(9장)    상속계층도를 따라올라가면 맨 위에 Object가 있음class Point{\tint x, y;}class Circle extends Point{\tint r;}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\tSystem.out.println(c.toString()); //Circle@5ca881b5 클래스이름@객체주소값\t\tSystem.out.println(c); //Circle@5ca881b5 클래스이름@객체주소값\t\tCircle c2 = new Circle();\t\tSystem.out.println(c2.toString()); //Circle@24d46ca6 클래스이름@객체주소값\t\tSystem.out.println(c2); //Circle@24d46ca6 클래스이름@객체주소값\t}}println이 참조변수가 들어오면 내부적으로 toString을 호출오버라이딩 (overriding)상속받은 조상의 메소드를 자신에 맞게 변경하는 것.  조건          선언부가 조상클래스의 메소드와 일치해야함      접근 제어자(public, protect, defalt, private) 를 조상클래스의 메소드보다 좁은 범위로 변경불가      예외는 조성 클래스의 메소드보다 많이 선언할 수 없다. (8장)      class Point{\tint x, y;String getLocation(){\treturn \"x : \"+x+\", y : \"+y;\t}}class Point3D extends Point{\tint z;\tString getLocation() { //오버라이딩 (선언부 변경 불가 내용[ {} 구현부 ]만 변경가능)\t\treturn \"x : \"+x+\", y: \"+y+\", z : \"+z;\t\t}\t}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tPoint3D p = new Point3D();\t\tp.x = 3;\t\tp.y=5;\t\tp.z=7;\t\tSystem.out.println(p.getLocation()); //x : 3, y: 5, z : 7\t}}class Point{\tint x, y;\t\tPoint(int x, int y){\t\tthis.x= x;\t\tthis.y=y;\t}\t\t//object클래스의 toString()을 오버라이딩\tpublic String toString(){\treturn \"x : \"+x+\", y : \"+y;\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tPoint p = new Point(3,5);\t\tSystem.out.println(p.toString()); //x : 3, y : 5\t\tSystem.out.println(p); //x : 3, y : 5\t}}오버로딩 (overloading)기존에 없는 새로운 (이름이 같은)메소드를 정의하는 것. 오버라이딩이랑은 관계없음.class Parent{\tvoid parentMethod() {\t\t\t}\tclass child extends Parent{\t\tvoid parentMethod() {}\t\tvoid parentMethod(int i) {}\t\t\t\tvoid childMethod() {}\t\tvoid childMethod(int i) {}\t\tvoid childMethod() {}\t\t\t}}참조변수 superthis와 비슷함  객체 자신을 가르치는 참조변수. 인스턴스 메소드(생성자)내에서만 존재  조상의 멤버를 자신의 멤버와 구분할 떄 사용class Parent{\tint x=10;}class child extends Parent{ //구성멤버 3개\tint x = 20;\t\tvoid method() { \t\tSystem.out.println(\"x = \"+x);  //가까이있는 x(20)\t\tSystem.out.println(\"this.x = \"+this.x);//20\t\tSystem.out.println(\"super.x = \"+super.x); //부모클래스의 x (10)\t\t\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tchild c = new child();\t\tc.method();\t}}class Parent{\tint x=10;}class child extends Parent{ //구성멤버 2개\tvoid method() { \t\tSystem.out.println(\"x = \"+x);  //가까이있는 x\t\tSystem.out.println(\"this.x = \"+this.x);\t\tSystem.out.println(\"super.x = \"+super.x); //부모클래스의 x\t\t//중복이 없으면 !! 조상멤버기도하지만 내꺼기도해서 this, super 모두 같은 x를 가르킴\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tchild c = new child();\t\tc.method();\t}}super() - 조상의 생성자참조변수 super와 상관없음  조상의 생성자를 호출할 때  조상의 멤버는 조상의 생성자를 호출해서 초기화  생자와 초기화 블럭은 상속이 xclass Point {\tint x,y;\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y; //초기화\t}}class Point3D extends Point {\tint z;\t\tPoint3D(int x, int y, int z) {\t\tsuper(x, y); //조상class에서 초기화\t\tthis.z=z; //초기화\t}}  생성자의 첫 줄에는 반드시 생성자(super(); or this();)를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입함.class Point {\tint x,y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tsuper();  //object(); 안넣어주면 컴파일러가 자동으로 넣어줌\t\tthis.x=x;\t\tthis.y=y;에러 예시 중요!!class Point {\tint x, y;\tPoint(int x, int y){\t\tsuper(); //컴파일러 자동 추가\t\tthis.x=x;\t\tthis.y=y;\t}\tString getLocation() {\t\treturn \"x : \"+x+\", y : \"+y;\t}}class MyPoint3D extends Point{\tint z;\t//\tMyPoint3D(int x, int y, int z){//\tsuper();  //컴파일러 자동 추가 Point()를 호출 -&gt; Point에 Point();가 없어서 에러남//\tthis.x=x;//\tthis.y=y;//\tthis.z=z;//\t}\t\tMyPoint3D(int x, int y, int z){\t\tsuper(x,y);\t\tthis.z=z;  \t}  //에러 없애는 방법 다른방법은 Pointclass에 Point();추가하기\t\tString getLocation() { //오버라이딩\t\treturn \"x : \"+x+\", y : \"+y+\", z : \"+z;\t}\t}public class Ex_test {\tpublic static void main(String[] args) {\t\tMyPoint3D p3 = new MyPoint3D(1,2,3);\t\t\t}}패키지(package)  서로 연관된 class의 묶음  클래스는 클래스파일(*.class), 패키지는 폴더. 하위 패키지는 하위폴더      클래스의 실제 이름 (full name)은 패키지를 포함.(java.lang.String)    rt.jar는 클래스들을 압축한 파일.(JDK설치경로\\jre\\lib에 위치) - 자바9부터 rt.jar는 없어짐    패키지 선언          패키지는 소스파일의 첫 번째 문장으로 단 한번 선언      같은 소스파일의 클래스들은 모두 같은 패키지에 속하게 된다.      패키지 선언이 없으면 이름없는(unnamed)에 속하게 된다. - defaultpackage        클래스 패스(classpath)          클래스 파일(*.class)의 위치를 알려주는 경로(path)      환경변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용      classpath(환경변수)에 패키지의 루트를 등록해줘야 함      import문클래스를 사용할 때 패키지 이름을 생략할 수 있다.  컴파일러에게 클래스가 속한 패키지를 알려줌  ctrl + shift + o ⇒ 자동으로 import문을 추가해줌.(import java.lang.*[모든클래스];) -  java.lang 패키지(String, Object, System, Thread…)의 클래스는 import하지않고도 사용 가능함.  패키지문과 클래스선언 사이에 선언함.  이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.  static import문          static멤버를 사용할 떄 클래스 이름을 생략가능              import static java.lang.Math.random;  import static java.lang.System.  out;        ⇒ out.println(random()); 가능함.            코드가 길어져서 class이름도 거추장스러운순간이 옴. 코드를 짧게하려고 쓰는 방법. 꼭 필요할때만 사용할것. 헷갈릴수도      제어자(modifier)클래스와 클래스의 멤버(멤버 변수, 메소드)에 부가적인 의미 부여 - 형용사                                             접근 제어자      public, protecred, (default)[아무것도안붙임], private      1개만 사용가능              그외      static, final, abstract, transient, synchronized, volatile, strictfp               하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만). 순서는 상관없으나 보통 접근제어자를 맨 왼쪽에 씀      static - 클래스의, 공통적인                            대상          의미                                      멤버변수          모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다  클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.  클래스가 메모리에 로드될 때 생성된다.                          메소드          인스턴스를 생성하지 않고도 호출이 가능한 static메소드가 된다.  static메소드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다                      final - 마지막의, 변경될 수 없는                                      클래스      변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.  그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다              메소드      변경될 수 없는 메소드. final로 지정된 메소드는 오버라이딩을 통해 재정의 될 수 없다.              멤버변수  지역변수      변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.      final class Finaltest{ //조상이 될 수 없는 클래스\tfinal int MAX_SIZE=10; //값을 변경할 수 없는 멤버변수(상수)\t\tfinal void getMaxsize() {  //오버라이딩 할 수 없는 메소드(변경불가)\t\tfinal int LV = MAX_SIZE; //값을 변경할 수 없는 지역변수(상수)\t\treturn MAX_SIZE;\t}}  abstract - 추상의, 미완성의                                      클래스      클래스 내에서 추상 메소드가 선언되어 있음을 의미한다              메소드      선언부만 작성하고 구현부는 작성하지 않은 추상 메소드임을 알린다.      abstract class abstracttest{ //추상 클래스(추상 메소드를 포함한 클래스\tabstract void move(); //추상 메소드(구현부가 없는 메소드)}//미완성상태 - 미완성 설계도. 제품제작불가 = 인스턴스 생성 불가public class Ex_test {\tpublic static void main(String[] args) {\t\tabstracttest a = new abstracttest();  //에러. 추상클래스의 인스턴스 생성 불가\t}}추상 클래스를 상속받아서 완전한 클래스를 만든 후에 객체생성가능접근 제어자(access modifier) - 1개만 사용 가능  private : 같은 클래스 내에서만 접근이 가능하다.  (default) : 같은 패키지 내에서만 접근이 가능하다.  protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.  public : 접근 제한이 전혀 없다.            제어자      같은 클래스      같은 패키지      자손 클래스      전체                  public      o      o      o      o              protected      o      o      o                     (default)      o      o                            private      o                           ❗클래스 앞에는 public or (default)만 붙일 수 있다. (아무것도 안붙이면 default)클래스 멤버들에게는 4가지 모두 붙일 수 있다.package pkg1;class MyParent{\t\tprivate \tint prv; //같은 클래스\t\t\t\t\t\t\tint dft; //같은 패키지\tprotected \tint prt; //같은 패키지, 자손(다른패키지)\t\tpublic \t\tint pub; //접근제한 없음\t\tpublic void printMembers(){\t\tSystem.out.println(prv);\t\tSystem.out.println(dft);\t\tSystem.out.println(prt);\t\tSystem.out.println(pub);\t}}public class MyParentTest {\tpublic static void main(String[] args) {\t\t\tMyParent p = new MyParent();\t\t\tSystem.out.println(p.prv); //에러. 다른 클래스라서\t\t\tSystem.out.println(p.dft);\t\t\tSystem.out.println(p.prt);\t\t\tSystem.out.println(p.pub);\t}}package pkg1;public class MyParentTest{  //접근 제어자 public\t\tprivate \tint prv; //같은 클래스\t\t\t\t\t\t\tint dft; //같은 패키지\tprotected \tint prt; //같은 패키지, 자손(다른패키지)\t\tpublic \t\tint pub; //접근제한 없음\t\tpublic void printMembers(){\t\tSystem.out.println(prv);\t\tSystem.out.println(dft);\t\tSystem.out.println(prt);\t\tSystem.out.println(pub);\t}}class MyParent {  //접근 제어자 default\tpublic static void main(String[] args) {\t\t\tMyParentTest p = new MyParentTest();//\t\t\tSystem.out.println(p.prv); //에러. 다른 클래스라서\t\t\tSystem.out.println(p.dft);\t\t\tSystem.out.println(p.prt);\t\t\tSystem.out.println(p.pub);\t}}package pkg2;import pkg1.MyParentTest; //ctrl +shift + oclass MyChild extends MyParentTest{\tpublic void printMembers(){//\tSystem.out.println(prv); //에러. 다른 클래서//\tSystem.out.println(dft); //에러. 다른 패키지\t\tSystem.out.println(prt); //자손클래스라서 가능\t\tSystem.out.println(pub);\t}}public class MyParentTest2 {\tpublic static void main(String[] args) {\t\tMyParentTest p = new MyParentTest();//\tSystem.out.println(p.prv); //에러. 다른 클래스라서//\tSystem.out.println(p.dft); //에러. 다른 패키지//\tSystem.out.println(p.prt); //에러. 다른 패키지, 자손관계 없음\t\tSystem.out.println(p.pub);\t}}캡슐화와 접근 제어자  접근 제어자를 사용하는 이유                  외부로부터 데이터를 보호하기 위해(캡슐화)          public class Ex_test{  \tprivate int hour;  //접근 제어자를 private로 하여 외부에서 접근 못하도록 막음  \tprivate int minute;  \tprivate int second;        \t  \tpublic int gethour() {  \t\treturn hour;  \t}  \tpublic void sethour(int hour) {  \t\tif(hour&lt;0 || hour &gt;23) return;  \t\tthis.hour=hour;  //메소드를 통해서 지역변수에 간접접근하도록 만들어 놓음  \t}  }  class test {  \tpublic static void main(String[] args) {  \t\tEx_test T=new Ex_test();  \t\tT.sethour(25);  //조건에 안맞아서 값이 바뀌지 않음. = 값이 보호됨  \t\tT.sethour(21);  \t}  }                    다형성(polymorphism)여러가지 형태를 가질 수 있는 능력  조상 타입 참조변수로 자손 타입 객체를 다루는 것. - 타입 불일치.  Tv t = new SmartTv();                  객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?  조상클래스의 참조변수는 자식 클래스의 멤버를 사용할 수 없다.                    자손타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.        SmartTv s = new Tv 불가능 - 없는 멤버를 호출해서 에러날 가능성 있음              참조변수의 형변환                  사용할 수 있는 멤버의 갯수를 조절하는 것. 멤버 갯수 외 요소는 바뀌지 않음  기본형 형변환 - (double)3.5 → (int)3                    조상 자손 관계의 참조변수는 서로 형변환 가능          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFireEngine f = new FireEngine();  \t\tCar c = (Car)f; //조상인 Car타입으로 형변환  \t\tFireEngine f2 = (FireEngine)c; //자손인 FireEngine타입으로 형변환(생략불가)  \t//Ambulance a = (FireEngine)f; //에러. 상속관계가 아닌 클래스간의 형변환 불가  \t}  }                Car c= (Car)f;경우 자손 클래스의 멤버를 조상클래스의 멤버가 사용할 수 없으니 c는 FireEngine의 모든 멤버를 사용할 수 없음(예시의 경우 c.water사용 불가능)        FireEngine f2 = (FireEngine)c는 f→c→f로 변환되었으니 FireEngine의 모든 멤버를 사용할 수 있음.                  class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tCar car = null;  \t\tFireEngine fe = new FireEngine();  \t\tFireEngine fe2 = null;        \t\t  \t\tfe.water();  \t\tcar = fe; //car = (car)fe; 에서 형변환이 생략됨.  //\t\tcar.water(); //에러  \t\tfe2=(FireEngine)car;  //자손타입&lt;-조상타입. 생략불가  \t\tfe2.water();  \t}  }                ❗fe2=(FireEngine)car;의 경우 사용할 수 있는 멤버의 수가 증가해서 불안정함. 그래서 꼭! 형변환을 써줘야함. 생략불가능        ]          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tCar car = null;  \t\tFireEngine fe = new FireEngine();        \t\t  \t\tFireEngine fe2= (FireEngine)car; //조상 -&gt; 자손  \t\tCar car2 = (Car)fe2; // 자손 -&gt; 조상  \t\t//객체가 없어도 형변환에는 문제없음.  \t\t//car2.drive(); //에러  NullPointerException발생. 객체가 없다는 뜻  \t\t//실제 인스턴스가 뭔지가 중요함.        \t\t  \t\tCar c2 = new Car();  \t\tFireEngine fe3 = (FireEngine)c2; // 형변환 실행 에러. java.lang.ClassCastException  \t\tfe3.water(); //컴파일 ok. 리모컨에는 water가 있음.  \t\t//객체를 Car로 만들어서 객체안에 water자체가 없음!! 그래서 에러나는거임!!  \t}  }                      instanceof 연산자          참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환      형변환 전에 반드시 instanceof로 확인해야 함              인스턴스의 원래 기능을 모두 사용하려고 형변환을 함.          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFireEngine fe = new FireEngine();        \t\t  \t\tSystem.out.println(fe instanceof Object); //true. FireEngine의 조상  \t\tSystem.out.println(fe instanceof Car); //true. FireEngine의 조상  \t\tSystem.out.println(fe instanceof FireEngine); //true  \t\tObject obg = (Object)fe;  \t\tCar c2 = (Car)fe;  \t\tFireEngine fe2 = (FireEngine)fe;  \t\t}  \tCar c = new Car();  \tvoid doWork(Car c) {  \t\tif(c instanceof FireEngine) {//형변환이 가능한지 확인  \t\t\tFireEngine fe = (FireEngine)c; //형변환  \t\t\tfe.water();  \t\t}  \t\telse if (c instanceof Ambulance) {  \t\t\tAmbulance a = (Ambulance)c;  \t\t}  \t}        \t  }                      다형성의 장점                  다형적 매개변수 - 매개변수의 다형성                              참조형 매개변수는 메소드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.              class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  }  class Tvvv extends Product{}  class Computer extends Product{}  class Audio extends Product{}              class Buyer { //물건사는사람  \tint money = 10000; //소지금  \tint bonusPoint = 0; //누적 적립금            \t  //\tvoid buy(Tv t1) {  //\t\tmoney -= t1.price;  //\t\tbonusPoint += t1.bonusPoint;  //\t}  //\tvoid buy(Computer c) {  //\t\tmoney -= c.price;  //\t\tbonusPoint += c.bonusPoint;  //\t}  //\tvoid buy(Audio a) {  //\t\tmoney -= a.price;  //\t\tbonusPoint += a.bonusPoint;  //\t}  \tvoid buy(Product p){  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();            \t\t  //\t\tTvvv tv = new Tvvv();  //\t\ttv.price=5000;  //\t\ttv.bonusPoint= (int) (tv.price*0.01);  //\t\tb.buy(tv);  //\t\tComputer com = new Computer();  //\t\tcom.price=3000;  //\t\tcom.bonusPoint= (int) (com.price*0.01);  //\t\t  //\t\tb.buy(com);            \t\t  \t\tProduct p1= new Tvvv();  \t\tProduct p2= new Computer();  \t\tProduct p3= new Audio();  \t\tp1.price=5000;  \t\tp1.bonusPoint=(int) (5000*0.01);  \t\tb.buy(p1);  \t\tp2.price=3000;  \t\tp2.bonusPoint=(int)(p2.price*0.01);  \t\tb.buy(p2);  \t\tSystem.out.println(b.money);  \t\tSystem.out.println(b.bonusPoint);            \t\t  \t}            \t  }                          class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  \tProduct(int price){  \t\tthis.price=price;  \t\tbonusPoint = (int) (price/10.0);  \t}  }  class Tv extends Product{  \tTv() {  \t\t//조상 클래스의 product(int price)를 호출  \t\tsuper(100); //100만원  \t}  \t//Object 클래스의 toString()을 오버라이딩  \tpublic String toString() {return \"tv\";}  }  class Computer extends Product{              \tComputer() {  \t\tsuper(200);  \t}  \tpublic String toString() {return \"computer\";}  }  class Audio extends Product{              \tAudio() {  \t\tsuper(50);  \t}  \tpublic String toString() {return \"audio\";}  }              class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금            \t  \tvoid buy(Product p){   \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}            \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();            \t\t  \t\tb.buy(new Tv()); //Product tv1 = new Product; b.buy(tv1)  \t\t//짧게 쓸 수 있으나 참조변수가 없어서 리모컨을 사용할 수 없음. b.buy에서 임시로 쓰는 것.  \t\tb.buy(new Computer()); //Product com1 = new Product; b.buy(com1)            \t\t  \t\tSystem.out.println(\"현재 남은 돈은 \"+b.money+\"만원입니다\");  \t\tSystem.out.println(\"현재 보너스 점수는 \"+b.bonusPoint+\"점 입니다.\");  \t}  }                                      ⇒장점 1.하나의 메소드로 여러타입의 객체를 받을 수 있음                    하나의 배열로 여러 종류의 객체를 다루기        : 조상 타입의 배열에 자손들의 객체를 담을 수 있다. =        장점2. 하나의 배열에 여러종류의 객체를 저장할 수 있음          // product p1 = new tv();  // product p2 = new computer();  // product p3 = new audio();          Product p[] = new Product();  p[0] = new tv();  p[1] = new computer();  p[2] = new audio();                ]          class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금        \t  \tProduct cart[] = new Product[10]; //구매한 물건을 담을 배열 (장바구니)        \t  \tint i = 0;        \t  \tvoid buy(Product p){  \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}        \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tcart[i++] = p; //cart에 담고 배열+1해서 새 장바구니칸에 담고..  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  }                  public class Vector extends AbstractList //Vector = 가변배열기능. object배열을 멤버로 가지고 있음.  \t\timplements List, Cloneable, java.io.serializable{  \tprotected Object elementDate[];  }                  class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  \tProduct(int price){  \t\tthis.price=price;  \t\tbonusPoint = (int) (price/10.0);  \t}  }  class Tvvv extends Product{  \tTvvv() {  \t\tsuper(100); //100만원  \t}  \tpublic String toString() {return \"tv\";}  }  class Computer extends Product{          \tComputer() {  \t\tsuper(200);  \t}  \tpublic String toString() {return \"computer\";}  }  class Audio extends Product{          \tAudio() {  \t\tsuper(50);  \t}  \tpublic String toString() {return \"audio\";}  }          class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금        \t  \tProduct cart[] = new Product[10]; //구매한 물건을 담을 배열 (장바구니)        \t  \tint i = 0;        \t  \tvoid buy(Product p){  \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}        \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tcart[i++] = p; //cart에 담고 배열+1해서 새 장바구니칸에 담고..  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  \tvoid summary() { //구매 물품 정보 요약표시  \t\tint sum = 0; //구입한 물품의 가격 합계  \t\tString itemList = \"\"; //구입한 물품 목록        \t\t  \t\t//반복문을 사용해 구입한 물품의 총 가격과 목록을 만든다.  \t\tfor(int i=0; i&lt;cart.length;i++) {  \t\t\tif(cart[i]==null) break;  \t\t\tsum+=cart[i].price;  \t\t\titemList += cart[i]+\", \";  \t\t}  \t\tSystem.out.println(\"구입하신 물건의 총 금액은 \"+sum+\"만원입니다.\");  \t\tSystem.out.println(\"구입하신 제품은 \"+itemList+\"입니다.\");  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();        \t\t  \t\tb.buy(new Tvvv(  ));  \t\tb.buy(new Computer());  \t\tb.buy(new Audio());        \t\t  \t\tSystem.out.println(\"현재 남은 돈은 \"+b.money+\"만원입니다\");  \t\tSystem.out.println(\"현재 보너스 점수는 \"+b.bonusPoint+\"점 입니다.\");  \t\tb.summary();  \t}  }                    추상클래스(abstract calss): 미완성 설계도. 미완성 메소드 -구현부(몸통{})이 없는 메소드- 를 갖고 있는 클래스. 객체 생성 불가능. 일반클래스인데 미완성 메소드를 가지고 있는 것abstract 리턴타입 메소드 이름();abstract class Player { //추상클래스(미완성 클래스)\t\tabstract void play(int pos); //몸통{}이 없는 추상메소드\tabstract void stop(); //몸톰{}이 없는 추상메소드}\t//추상클래스가 다른 클래스를 작성하는데 도움이 됨.//추상클래스는 상속을 통해 완성해야 객체 생성가능class AudioPlayer extends Player{\tvoid play(int pos) {\t\tSystem.out.println(pos+\"위치부터 play합니다.\");\t\t}//추상메소드 구현 = 몸통만들어줌.\tvoid stop() {\t\tSystem.out.println(\"재생을 멈춥니다.\");\t}//추상메소드 구현=몸통 만들어줌}public class PlayerTest {\tpublic static void main(String[] args) {//\t\tPlayer p = new Player();  //에러. 추상클래스의 인스턴스화 불가\t\tAudioPlayer ap = new AudioPlayer(); //인스턴스 생성 가능.\t\tap.play(100);\t\tap.stop();\t\tPlayer p2 = new AudioPlayer(); //Player가 조상타입이라 가능함. 다형성\t\tp2.play(500);\t\tp2.stop();\t\t}\t}abstract class Player{\tboolean pause; //일시정지상태를 저장하기위한 변수\tint currentPos;//현재 play되고 있는 위치를 저장하기 위한 변수\t//플레이어의 종류마다 플레이 방식이나 멈추는 방식이 다르니 미리 만들어봤자 의미가 없음.\t//중요한건데 후에 상속을 만들 때 빠질까봐 강제하는 것임.\tPlayer(){  //추상클래스라도 생성자가 있어야함.\t\tpause = false;  \t\tcurrentPos = 0;\t}\t//지정된 위치(pos)에서 재생을 시작하는 기능이 수행하도록 작성되어야 한다.\tabstract void play(int pos); //추상메소드\t//재생을 즉시 멈추는 기능을 수행하도록 작성되어야한다.\tabstract void stop(); //추상메소드\t\tvoid play() { //인스턴스메소드\t\tplay(currentPos); //추상메소드를 사용할 수 있다.. 메소드는 선언부만 알면 호출가능하므로 추상메소드도 호출가능함.\t//상속을 통해 자손이 완성될 예정이라 사용할 수 있다. (지금 호출은 안됨. 상속을 통해 완성된 다음 호출 가능)\t}}public class ex {\tpublic static void main(String[] args) {\t\t}\t}  꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우      여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.      abstract class Unit{  \tint x,y;  \tabstract void move(int x, int y);  \tvoid stop() {  \t\t//현재 위치에 정지  \t\t};  \t}  class Marine extends Unit { //보병  \tvoid move(int x, int y) {  \t\t//지정된 위치로 이동  \t\tSystem.out.println(\"marine [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid stimPack() {  \t\t//스팀팩 사용  \t}  }  class Tank extends Unit{  \tvoid move(int x, int y) {  \tSystem.out.println(\"Tank [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid changeMode() {}; //공격모드로 변경  }  class Dropship extends Unit {  \tvoid move(int x, int y) {  \tSystem.out.println(\"Dropship [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid load() {}// 선택된 대상 태우기  \tvoid unload() {}//선택대상 내리기  }  public class ex {      \tpublic static void main(String[] args) {  //\t\tUnit[] group = new Unit[3];  //\t\tgroup[0]=new Marine();  //\t\tgroup[1]=new Tank();  //\t\tgroup[2]=new Dropship();  \t\tUnit group[] = {new Marine(), new Tank(), new Dropship()};    \t\t  \t\tfor(int i=0;i&lt;group.length;i++) {  \t\t\tgroup[i].move(100, 200);  \t\t\t//group의 타입은 Unit[], group[0], group[1], group[2]  \t\t}  \t\tObject group2[] = {new Marine(), new Tank(), new Dropship()};  \t\tfor(int i=0;i&lt;group2.length;i++) {  //\t\t\tgroup2[i].move(100, 200);  \t\t\t//Object는 최상위 객체라서 구현은 가능하나 move를 멤버로 가지고있지 않아서 에러남  \t\t}  \t}  }            추상화(불명확)←→구체화(명확)          추상화된 코드는 구체화된 코드보다 유연함. 변경에 유리  구체적인 코드 - GregorianCalendar cal = new GregorianCalendar();  추상적인 코드 = Calendar cal = Calendar.getInstance : Calendar 자손 객체를 반환해 cal에 대입. ⇒ Calendar객체가 무엇을 반환할 지 불명확함.          import java.util.Calendar;      private static Calendar createCalendar(TimeZone. Locale aLocale) {  \tif(caltype != null) {  \t\tswitch(caltype) {  \t\tcase \"buddhist\": //불교력  \t\t\tcal = new BuddhistCalendar(zone, aLocale);  \t\t\tbreak;  \t\tcase \"japanese\" : //일본력  \t\t\tcal = new JapanesImperialCalendar(zone, aLocale);  \t\t\tbreak;  \t\tcase \"gregory\" : //서양력  \t\t\tcal = new GregorianCalendar(zone, aLocale);  \t\t\tbreak;  \t\t}  \t}  }  public class ex {      \tpublic static void main(String[] args) {  //\t\tGregorianCalendar cal = new GregorianCalender(); 구체적  \t\tCalendar cal = Calendar.getInstance();//추상적  \t}  }      인터페이스(interface)추상메소드의 집합(프로그래밍관점)      구현된 것이 하나도 없는 설계도. 껍데기(모든 멤버가 public)    interface 인터페이스이름{    public static final 타입 상수이름 = 값;    public abstract 메소드이름(매개변수목록); }      interface PlayingCard{  \t//상수  \tpublic static final int SPADE =4;  \tfinal int DIAMOND = 3; //public static 생략됨  \tstatic int HAEART = 2; //public final 생략됨  \tint CLOVER = 1; //public static final      \t//추상메소드  \tpublic abstract String getCardNumber();  \tString getCaedKind(); //public abstract생략됨.  \t//public static final은 예외없이 모두 적용이기때문에 적지않아도 자동으로 붙여줌  \t}  public class ex {      \tpublic static void main(String[] args) {  \t}  }        [!important]추상클래스와 인터페이스의 차이점인터페이스는 인스턴스변수를 가질 수 없음!  인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상이 아님)  다중 상속 가능. (추상메소드는 구현부{}가 없어서 충돌해도 문제 없음) - 조상이 여러개여도 가능.  인터페이스는 지역변수를 가지지 못함(추상클래스는 가능)      인터페이스의 구현 : 인터페이스에 정의된 추상메소드를 완성하는 것.  class 클래스 이름 implements 인터페이스 이름{ 인터페이스에 정의된 모든 추상메소드를 구현해야 함. } - 일부만 구현하는 경우, 클래스앞에 abstract를 붙여야함.  = 추상클래스 완성과 동일      interface Fightable{ //인터페이스  \tvoid move(int x, int y);  \tvoid attack(Unit u);  }  class Fighter implements Fightable{ //인터페이스 구현  \tpublic void move(int x, int y) {  \t\tSystem.out.println(\"x = \"+x+\", y = \"+y);  \t}  \tpublic void\tattack(Unit u) {  \t\tSystem.out.println(\"Unit = \"+u);  \t}  }  abstract class Player{ //추상클래스  \tabstract void play(int pos);  \tabstract void stop();  }  class AudioPlayer extends Player{ //추상클래스 구현  \tvoid play(int pos) {  \t\tSystem.out.println(pos);  \t}  \tvoid stop() {  \t\t//내용  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {    \t\t  \t}  }            인터페이스를 이용한 다형성          인터페이스도 구현 클래스의 부모임      인터페이스 타입 매개변수는 인터페이스 구현한 클래스의 객체만 가능      인터페이스를 메소드의 리턴타입으로 지정가능.          import java.io.ObjectInputStream.GetField;      abstract class Unit{  \tint x,y;  \tabstract void move(int x, int y);  \tvoid stop() {  \t\tSystem.out.println(\"멈춤\");  \t};  }  interface Fightable{ //인터페이스  \tvoid move(int x, int y); //public abstract가 생략됨  \tvoid attack(Fightable f); //public abstract가 생략됨  }  class Fighter extends Unit implements Fightable {   \tpublic void move(int x, int y) { //오버라이딩 규칙: 조상(public)보다 접근제어자가 좁으면 안됨.  \t\tSystem.out.println(\"[\"+x+\", \"+y+\"]로 이동\");  \t}  \tpublic void attack(Fightable f) //매개변수 타입이 인터페이스.= 이 인스턴스를 구현한 class의 객체만 가능  \t//attack메소드는 매개변수로 Fightable인터페이스를 구현한 class의 객체만 받음  \t{   \t\tSystem.out.println(f+\"를 공격\");  \t}   \t//싸울 수 있는 상대 소환  \tFightable getFightable(){  \t\tFighter f = new Fighter();   \t\treturn f;  //Fighter가 Fightable을 상속받고있어서 형변환이 가능하기때문에 f는 Fighter지만 사용 가능  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFighter f = new Fighter();  \t\tFightable ff = f.getFightable();    \t\t  \t\tf.move(100, 200);  \t\tf.attack(new Fighter()); //toString이 나옴  \t\tf.stop();    \t\t  \t\tSystem.out.println(\"-----------------\");  \t\tUnit u = new Fighter();  \t\tu.move(100, 200);  \t\tu.stop();  //\t\tu.attack(new Fighter()); //에러, Unit에 attack이 없음    \t\t  \t\tSystem.out.println(\"-----------------\");  \t\tFightable f2 = new Fighter();  \t\tf2.move(100, 200);  \t\tf2.attack(new Fighter()); //toString이 나옴  //\t\tf2.stop(); //Fightable에 stop이 없음  \t}  }            장점          두 대상(객체)간의 ‘연결, 대화, 소통’을 돕는 ‘중간역할’을 한다      선언과 구현을 분리시킬수 있게됨.(변경에 유리)      개발시간 단축      변경에 유리한 설계      표준화 가능 (데이터베이스회사들이 JDBC에 맞춰 데이터베이스를 개발함. 자바개발자는 JDBC를 기준으로 개발 )      서로 관계없는 클래스들의 관계를 맺어줄 수 있다. : 내가 원하는 클래스만 모아서 인터페이스로 묶을 수 있음      인터페이스덕분에 한 클래스를 변경해도 다른 클래스는 안바꿔도 동작함(느슨한 결함)        직접적 관계      class A {  \tpublic void method(C c){  \t\tc.methodC();  \t}  }  class B {  \tpublic void methodB(){  \t\tSystem.out.println(\"methodB()\");  \t}  }  class C{  \tpublic void methodC(){  \t\tSystem.out.println(\"method() in C\");  \t}  }  public class InterfaceTest {      \tpublic static void main(String[] args) {  \t\tA a = new A();  \t\ta.method(new C()); //A가 B에 의존  \t}      }        간접적 관계      class A {  \tpublic void method(I i){  \t\ti.method();  \t}  }  interface I { void method();}       class B implements I{  \tpublic void method(){  \t\tSystem.out.println(\"methodB()\");  \t}  }  class C implements I{  \tpublic void method(){  \t\tSystem.out.println(\"method() in C\");  \t}  }  public class InterfaceTest {      \tpublic static void main(String[] args) {  \t\tA a = new A();  \t\ta.method(new B()); //A가 B에   \t}  }        디폴트 메소드                  인터페이스에 새로운 메소드(추상메소드)를 추가하기 어려움 - 한 인터페이스에 추상메소드가 추가되면 연관된 모든 클래스에 추가된 추상메소드 구현을 해주어야함 ⇒ 해결책:디폴트메소드(default method)        interface MyInterface {        void method();        default void newMethod();{ } }            디폴트메소드 = 인스턴스메소드 (인터페이스 원칙 위반 = 예외)      디폴트메소드가 기존의 메소드와 충돌할때?                              여러 인터페이스의 디폴트 메소드간의 충돌 — 인터페이스를 구현한 클래스에서 디폴트메소드를 오버라이딩한다                                디폴트메소드와 조상클래스의 메소드간의 충돌 — 조상클래스의 메소드가 우선되어 먼저 상속되고, 디폴트메소드는 무시된다.                                static 메소드      내부클래스(inner class) : 클래스 안에 클래스          객체생성없이도 상위클래스의 멤버에 접근가능      코드의 복잡성을 줄일 수 있음. (캡슐화)          class AAA{ //BBB의 외부클래스  \tint i=100;  \tBBB b = new BBB();  \tclass BBB{///AAA의 내부클래스  \t\tvoid method() {  //\t\t\tAAA a = new AAA();  //AAA의 내부클래스라 해줄필요없음  \t\t\tSystem.out.println(i); //객체생성없이 접근가능  \t\t}  \t}  }  class CCC{  }  public class ex {      \tpublic static void main(String[] args) {  \t\tAAA a = new AAA();  \t\ta.b.method();  \t}  }                      내부클래스의 종류와 유효범위(scope)는 변수와 동일                                            내부클래스              특징                                                          인스턴스 클래스  (instance class)              외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.                                      스태택 클래스  (static class)              외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메소드에서 사용될 목적으로 선언된다.                                      지역 클래스  (local class)              외부클래스의 메소드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.                                      익명 클래스  (anonymosus class)              클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)                                                내부클래스의 제어자는 public, private, (default), protected 4가지 사용가능.                  public class ex {          \tclass InterfaceInner{  \t\tint iv = 100;  //\t\tstatic int cv = 100; //에러, static변수 선언불가  \t\t//static은 객체없이 생성할 수 있어야하는데 인스턴스안에 들어가있어서 객체를 만들어야 사용할 수 있게됨. 모순이라 에러표시  \t\tfinal static int CONST = 100; //final static은 상수이므로 허용  \t}        \t  \tstatic class staticInner{  \t\tint iv = 200;  \t\tstatic int cv = 200; //static클래스만 static멤버를 정의할 수 있다.  \t}  \tvoid mymethod() {  \t\tclass LocalInner{  \t\t\tint iv = 300;  //\t\t\tstatic int cv = 300; //에러, static변수를 선언할 수 없다  \t\t\tfinal static int CONST = 300; //final static은 상수이므로 허용  \t\t\t//final뒤에 static이 오는 경우는 어떤 조건에서도 같은 값일 경우.   \t\t\t//객체마다 값이 다를수도 있으면 final만 쓰면됨(ex.카드의 숫자와 무늬)  \t\t}  \t\tint i = LocalInner.CONST; //지역내부클래스의 static상수는 메소드 내에서만 사용가능  \t}  \tpublic static void main(String[] args) {  \t\tSystem.out.println(InterfaceInner.CONST);  \t\tSystem.out.println(staticInner.cv);  //\t\tSystem.out.println(LocalInner.CONST); //지역내부클래스의 static상수는 메소드 외에서는 사용 불가능  \t}  }                  public class ex {          \tclass InstanceInner{}  \tstatic class StaticInner{}        \t  \tInstanceInner iv = new InstanceInner(); //인스턴스 멤버끼리는 직접 접근가능  \tstatic StaticInner cv = new StaticInner(); //static멤버끼리는 직접 접근가능  //\tstatic StaticInner cv2 = new InstanceInner(); //static멤버가 instance멤버 접근 불가능. 반대는 가능          \tstatic void staticmethod() { //static멤버는 인스턴스에 직접접근불가  //\tInstanceInner obj1 = new InstanceInner();  \t\tStaticInner obj2 = new StaticInner();        \t\t  \t\t//이렇게까지 쓰지는 않는데 일단 예시로  \t\tex outer = new ex(); //인스턴스 클래스는 외부클래스를 먼저 생성해야 생성가능  \t\tInstanceInner obj1 = outer.new InstanceInner();  \t}  \tvoid instanceMethod() {//인스턴스메소드에서는 인스턴스멤버와 static멤버 모두 접근가능  \t\tInstanceInner obj1 = new InstanceInner();  \t\tStaticInner obj2 = new StaticInner();  //\t\tLocalInner lv = new LocalInner(); //지역 내부클래스는 외부에서 접근 불가  \t}  \tvoid myMethod() {  \t\tclass LocalInner{}  \t\tLocalInner lv = new LocalInner();  \t}  \tpublic static void main(String[] args) {  \t}  }                  class Outer{  \tprivate int outerIv= 0;  \tprivate static \tint outerCv=0;        \t  \tclass InstanceInner{  \t\tint iiv = outerIv;//외부클래스의 private멤버도 접근가능  \t\tint iiv2 = outerCv;   \t}  \tstatic class StaticInner{  //\t\tint siv = outerIv; //static클래스는 외부클래스의 인스턴스멤버에 접근 불가  \t\tstatic int scv = outerCv;  \t}  \tvoid mymethod() {  \t\tint lv = 0;  \t\tfinal int LV = 0;  //final생략 가능        \t\t  //\t\tlv=3;//밑에 int liv3 = lv;에러내려고 적음. 값이 바뀌었으니 변수로 처리해서 에러남  \t\tclass LocalInner{ //지역내부클래스를 감싸고있는 메소드의 상수만 사용가능  \t\t\tint liv = outerIv;  \t\t\tint liv2 = outerCv;  \t\t\t//내부클래스의 객체가 지역변수보다 더 오래 존재가능   \t\t\t//외부클래스의 지역변수는 final이 붙은 변수(상수)만 접근 가능  \t\t\t//JDK1.8부터는 변수인데 값이 안바뀌는 것도 상수로 간주. (에러x)  \t\t\tint liv3 = lv;  \t\t\tint liv4 = LV;         \t\t\t  \t\t\tvoid method() {  \t\t\t\tSystem.out.println(lv);  \t\t\t}        \t\t\t  \t\t}  \t}  }  public class ex {  \tpublic static void main(String[] args) {  \t}  }                          인스턴스 내부클래스를 사용하려면 외부클래스의 객체를 먼저 만들고 인스턴스내부클래스의 객체를 만들어야 함      class Outer {  \tclass instanceInner {  \t\tint iv =100;  \t}  \tstatic class StaticInner {  \t\tint iv = 200;  \t\tstatic int cv = 300;  \t}  \tvoid myMethod() {  \t\tclass LocalInner{  \t\t\tint iv = 400;  \t\t}  \t}  }  public class ex {  \tpublic static void main(String[] args) {  \t\tOuter oc  = new Outer(); //외부클래스의 인스턴스를 먼저 생성해야 인스턴스클래스의  \t\tOuter.instanceInner ii = oc.new instanceInner(); //인스턴스를 생성가능    \t\t  \t\tSystem.out.println(\"ii.iv : \"+ii.iv);  \t\tSystem.out.println(\"Outer.StaticInner.cv : \"+Outer.StaticInner.cv);    \t\t  \t\t//스태틱 내부클래스의 인스턴스는 외부클래스를 먼저 생성하지않아도 된다  \t\tOuter.StaticInner si = new Outer.StaticInner();  \t\tSystem.out.println(\"ii.iv : \"+si.iv);    \t\t  \t}  }          class Outer {  \tint value = 10; //Outer.this.value 외부클래스의 iv    \t  \tclass Inner{  \t\tint value = 20; //this.value 내부클래스의 iv    \t\t  \t\tvoid method() {  \t\t\tint value = 30;  \t\t\tSystem.out.println(\"           value : \"+value);  \t\t\tSystem.out.println(\"      this.value : \"+this.value);  \t\t\tSystem.out.println(\"Outer.this.value : \"+Outer.this.value);    \t\t\t  \t\t}  \t}    \t  }  public class ex {  \tpublic static void main(String[] args) {  \t\tOuter outer = new Outer();  \t\tOuter.Inner inner = outer.new Inner();  \t\tinner.method();    \t\t  \t}  }            익명클래스(anonymous class)    : 이름이 없는 일회용 클래스. 정의와 생성을 동시에 함(조상이름을 대신 씀)  new 조상클래스 이름(){ 멤버선언 } / new 구현인터페이스이름() { 멤버선언 }      public class ex {  \tObject iv = new Object() {void method2(){}}; //익명클래스  \tstatic Object cv = new Object() {void method2(){}}; //익명클래스    \t  \tvoid Mymethod() {  \t\tObject lv = new Object() { void method2() {}}; //익명클래스  \t}      \tpublic static void main(String[] args) {  \t}  }          import java.awt.*;  import java.awt.event.*;  //awt : 자바의 윈도우 프로그래밍 도구.       public class ex {  \tpublic static void main(String[] args) {  \t\tButton b = new Button(\"start\");  //\t\tb.addActionListener(new EventHandler()); //객체생성  \t\tb.addActionListener(new AcionListener/*조상 OR 인스턴스 이름*/() { //클래스의 정의와 객체생성을 동시에  \t\t\tpublic void actionPerformed(ActionEvent e) {  \t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");  \t\t\t}  \t\t}); //객체생성    \t\t  \t\t//위랑 같아보이지만 다른 클래스임. 일회용클래스이기때문.  \t\tb.addActionListener(new AcionListener/*조상 OR 인스턴스 이름*/() { //클래스의 정의와 객체생성을 동시에  \t\t\tpublic void actionPerformed(ActionEvent e) {  \t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");  \t\t\t}  \t\t}); //객체생성    \t\t  \t\t}  \t}  //class EventHandler implements AcionListener{ //클래스 정의.   //\tpublic void actionPerformed(ActionEvent e) {  //\t\tSystem.out.println(\"ActionEvent occurred!!!\");  //\t}  //}      "
  },
  
  {
    "title": "자바의 정석 강의 - 객체지향(OOP)",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5(OOP)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 객체",
    "date": "2022-08-01 00:00:00 +0900",
    





    
    "snippet": "객체지향 언어 = 프로그래밍 언어 + 객체지향개점(규칙)  캡슐화  상속  추상화      다형성    class : 객체를 정의해 놓은 것, 객체를 생성하는데 사용함. (설계도)  = 데이터 + 함수(method) (서로 관련있는 것 끼리 묶음. 데이터만 묶으면  구조체)  기본적으로 하나의 소스파일에 하나의 class를 작성하는것이 바람직하나, 여...",
    "content": "객체지향 언어 = 프로그래밍 언어 + 객체지향개점(규칙)  캡슐화  상속  추상화      다형성    class : 객체를 정의해 놓은 것, 객체를 생성하는데 사용함. (설계도)  = 데이터 + 함수(method) (서로 관련있는 것 끼리 묶음. 데이터만 묶으면  구조체)  기본적으로 하나의 소스파일에 하나의 class를 작성하는것이 바람직하나, 여러 class를 작성할수도 있음.          public class가 있는 경우, 소스파일의 이름은 반드시 public class(한소스파일에서 한번만 사용 가능)의 이름과 일치해야함      public class가 없는 경우, 소스파일의 이름은 class 중 어느 것을 사용해도 무방함. (main method가 있는부분은 동일해야함. 아니면 수동으로 지정가능)            객체(인스턴스와 거의 같은 말임) : 실제로 존재하는 사물 또는 개념. 객체가 가진 기능과 속성에따라 용도가 다름. 모든 인스턴스를 대표하는 일반적 용어. 클래스를 인스턴스화하면 객체(인스턴스)가 됨.  (제품) - 속성(변수) + 기능(메소드)                  class 생성        class Tv { String color ………. (6개의 멤버 = 구성 6개) }                    객체 생성 : 변수명 = new 클래스명();        Tv t = new Tv();                    사용        t.channel1 = 7; t.channelDown(); sout(”현재 “+t.channel1+번입니다”)         class Tv { \t//tv의 속성 \tString color; \tboolean power; \tint channer1;        \t \t//tv의 기능 \tvoid power(){ \t\tpower !=power; //티비 온오프 \t} \tvoid channer1Up() { \t\t++channer1; \t} \tvoid channer1Down() { \t\t--channer1; \t} } public class Ex6_1 {         \tpublic static void main(String[] args) { \t\tTv t = new Tv(); \t\tt.channer1=7; \t\tt.channer1Down(); \t\tSystem.out.println(\"현재 \"+t.channer1+\"번 입니다.\");        \t\t //\t\tTv t2 = new Tv(); //\t\tSystem.out.println(\"현재 \"+t2.channer1+\"번 입니다.\"); //0번        \t\t \t\tTv t2 = t; \t\tSystem.out.println(\"현재 \"+t2.channer1+\"번 입니다.\"); //6번 \t}         }                                    객체 배열 == 참조변수 배열  tv tvarr[] = new tv[3]; == tv tvarr[] = {new tv(), new tv(), new tv()};        tvatrr[0] = new tv(); tvatrr[1] = new tv(); tvatrr[2] = new tv();              인스턴스(객체와 거의 같은 말임) : 특정 class로부터 생성된 객체      선언위치에 따른 변수의 종류      class variable {  \tint iv;  \tstatic int cv;      \tvoid method() {  \tint lv = 0;  \t}  } //이 전체가 class 영역                      변수                  클래스 영역(선언문만 가능, 순서 상관x)                          iv (intance variable), cv(static 있어서 class)                                메소드 영역 - lv(Local variable)                                                    변수의 종류              선언 위치              생성 시기                                                          class 변수              class 영역              클래스가 메모리에 올라갈 때(import할때)                                      instance 변수              class 영역              인스턴스가 생성되었을 때                                      지역변수              class영역 이외의 영역  (메소드, 생성자, 초기화 블럭 내부)              변수 선언문이 수행되었을 때                                      객체 - instance 변수를 묶어놓은 것.                  [!important]CPU ←RAM ←SSD or HDD - ssd, hdd에서 바로 cpu못가니까 ram을 둠. 파일을 읽는다고 하면(loading) 메모리(ram)에 얹는다고 표현함. = 작업을 하려면 class가 메모리에 올라간다고 표현함.ram은 컴퓨터를 끄면 데이터가 날아가니까 저장(save)하려면 다시 디스크로 옮겨야함즉, class변수는 아무때나 사용이 가능하고 instance는 객체생성을 해야 사용 가능함. 그래서!! class는 객체생성이 필요없고 instance는 객체생성이 필요함.                          class 변수 : 공통 속성(객체 모두 같은 값) ??변경하면 까다로워지니까          instance 변수 : 개별 속성(객체마다 다른 값도 가능) ??복사개념이라 수정쉬워서                  class Card{  \tString kind; //무늬  \tint number; //숫자          \tstatic int width = 100; //폭  \tstatic int height = 250;  }          public static main void(String[] args){  \tCard c = new Card();  \tc.kind = \"heart\";  \tc.number = 5;          \t// c.width = 200;  오류는 안나는데 이렇게하면 안됨!! 객체별로 값이 달라짐  \t// c.height = 300; 오류는 안나는데 이렇게하면 안됨!! 객체별로 값이 달라짐  \tCard.width = 200;  \tCard.height = 300; //class값이 전부 변경돼서 객체별로 값이 같아짐  }                  class Card{  \tString kind; //무늬  \tint number; //숫자          \tstatic int width = 100; //폭  \tstatic int height = 250;  }  public class Ex6_3 {          \tpublic static void main(String[] args) {  \t\tSystem.out.println(\"Card.width = \"+Card.width);  \t\tSystem.out.println(\"Card.height = \"+Card.height); //객체 생성없이 사용 가능        \t\t  \t\tCard c1 = new Card();  \t\tc1.kind = \"Heart\";  \t\tc1.number = 7;        \t\t  \t\tCard c2 = new Card();  \t\tc2.kind = \"Spade\";  \t\tc2.number = 4;        \t\t  \t\tSystem.out.println(\"c1은 \"+c1.kind+\", \"+c1.number+\"이며, 이 카드의 크기는 (\"+c1.width+\", \"+c1.height+\")\");  \t\tSystem.out.println(\"c2은 \"+c2.kind+\", \"+c2.number+\"이며, 이 카드의 크기는 (\"+c2.width+\", \"+c2.height+\")\");  \t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경합니다\");        \t\t  //\t\tc1.width=50;  //\t\tc1.height=80; //c1이 인스턴스지만 width와 height가 class기 때문에 모두 바뀜  \t\t//오해하기 쉬운 코드니까 권장하지 않는 코드임.        \t\t  \t\tCard.width=50;  \t\tCard.height=80;  \t\tSystem.out.println(\"c1은 \"+c1.kind+\", \"+c1.number+\"이며, 이 카드의 크기는 (\"+c1.width+\", \"+c1.height+\")\");  \t\tSystem.out.println(\"c2은 \"+c2.kind+\", \"+c2.number+\"이며, 이 카드의 크기는 (\"+c2.width+\", \"+c2.height+\")\");  \t}          }                                      메소드(=블랙박스) : 문장들을 묶어놓은 것. (class안에 있어야함)  선언부 { 구현부 }                                          값(입력)을 받아서 처리하고, 결과를 반환(출력) - 함수랑 똑같다고 보면됨(함수는 독립적이라 class안에 없어도됨.  int add(int x, int y){  int result = x+y;  return result; }                                                      반드시 return으로 마무리 지어야하는데 값이 void일경우 return 생략 가능                                                        메소드 = 블랙박스??                    별 이유없고 걍..별로 알고싶지않아서 println이 어떻게 동작하는지 궁금함? ㄴㄴㅋㅋ                                                              실행흐름                                  인스턴스 생성                  main메소드안에서 메소드 호출                  메소드 {}안의 문장 수행                  호출 메소드로 돌아와서 main메소드안의 메소드로 돌아와서 이후 문장 수행                                            하나의 메소드에 하나의 기능만 수행하도록 작성할 것.              장점                                  코드 중복 줄이기                  코드 관리 용이                  코드 재사용 용이                  코드가 간결해서 이해하기 쉬워진다                                            지역 변수 : 메소드 안에 선언된 변수 (매소드가 끝나면 없어지기때문에 다른 메소드에 이름을 같게해도 상관없음.)              메소드 호출 : 메소드 이름(값1,값2,…[값 안써도 됨]);  int result = add(3,5); ⇒ int add값을 저장할 공간이 필요해서 int result를 씀 (class영역에만 정의 가능)                          int add(int x, int y){  \tint result = x+y;  \treturn result;  }              public static void main(String [] args) {  \tint result = add(3,5);  }                        매개변수 : 메소드를 호출한쪽에서 준 값을 메소드에게 전달하는 역할              class MyMath {  \tlong add(long a, long b) {  \t\treturn a+b;  \t}  \tlong subtract(long a, long b) {  \t\treturn a-b;  \t}  \tlong multiply(long a, long b) {  \t\treturn a*b;  \t}  \tlong divide(long a, long b) {  \t\treturn a/b;  \t}            \t  \t// 두 값을 받아서 더 큰 값을 반환하는 메소드  \tlong max (long a, long b) {  //\t\treturn a&gt;b? a:b;  \t\tif(a&gt;b) return a;  \t\telse return b; //참, 거짓 둘다 return해줘야함  \t}  \tlong min (long l, long m) {  \t\treturn l&lt;m?l:m;  \t}            \t  \tvoid printgugudan(int dan) {  \t\tif(!(dan&gt;=2 &amp;&amp; dan&lt;=9)) {  \t\t\treturn;  \t\t}            \t\t  \t\tfor (int i=1;i&lt;=9;i++) {  \t\t\tSystem.out.printf(\"%d * %d = %d%n\",dan,i,dan*i);  \t\t}  \t}  }  public class Ex6_4 {              \tpublic static void main(String[] args) {  \t\tMyMath mm = new MyMath();            \t\t  \t\tlong result1 = mm.add(5L,3L);  \t\tlong result2 = mm.subtract(5L,3L);  \t\tlong result3 = mm.multiply(5L,3L);  \t\tlong result4 = mm.divide(5L,3L);            \t\t  \t\tSystem.out.println(\"add = \"+result1);  \t\tSystem.out.println(\"subtract = \"+result2);  \t\tSystem.out.println(\"multiply = \"+result3);  \t\tSystem.out.println(\"divide = \"+result4);            \t  \t\tSystem.out.println(mm.max(mm.add(5, 3),mm.add(4, 3)));  \t\tSystem.out.println(mm.max(5, 4));  \t\tSystem.out.println(mm.min(mm.add(5, 3),mm.add(4, 3)));  \t\tSystem.out.println(mm.min(5, 4));            \t\t  \t\tmm.printgugudan(5);  \t}              }                                      반환값 - return : 실행중인 메소드를 종료하고 호출한 곳으로 되돌아간다. (타입이 일치해야하나 자동형변환된는 것은 가능 ex. char → int                                            호출스택 (call srack) : 메소드 수행에 필요한 메모리가 제공되는 공간. 메소드가 호출되면 호출스택에 메모리 할당, 종료되면 해제          stack : 밑이 꽉막힌 상자. 위에 차곡차곡 쌓인다. - 후입선출      main 메소드가 println 메소드를 호출했으면 println 메소드가 실행되는동안 main 메소드는 대기상대임.println메소드가 종료되면 스택에서 사라지고 남은 main메소드가 작업을 계속함  = 맨 위에 있는 메소드 하나만 실행중, 나머지는 대기            기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.      class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tchange(d.x);     \t\t  \t\tSystem.out.println(\"After change(d.x)\");  \t\tSystem.out.println(\"main() : x = \"+d.x); //change의 int x와는 다른 주소를 가지고있기때문에 main안에서는 여전히 10의 값을 가짐  \t}  \tstatic void change(int x) { //int x로 새로운 저장공간은 만들었기때문에 class date의 int x와는 가른 주소를 가짐  \t\tx=1000;  \t\tSystem.out.println(\"chanhe() : x = \"+x);  \t}//change문이 끝났으니 change문 시작할때 새로 지정해준 int x의 값도 종료됨!  }            참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.      class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tchange(d);     \t\t  \t\tSystem.out.println(\"After change(d)\");  \t\tSystem.out.println(\"main() : x = \"+d.x); //1000  \t}  \tstatic void change(Date d) { //main에서도 공유중인 date의 d값을 복사해옴. = main의 x와 같은 동일한 공간을 가짐  \t\td.x=1000;  \t\tSystem.out.println(\"chanhe() : x = \"+d.x);  \t}  }          class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tDate d2 = copy(d);  \t\tSystem.out.println(\"d.x = \"+d.x);  \t\tSystem.out.println(\"dx.x = \"+d2.x);  \t}  \tstatic Date copy(Date d) {  \t\tDate tmp = new Date();    \t\t  \t\ttmp.x=d.x;    \t\t  \t\treturn tmp; //객체의 주소를 반환함    \t\t  \t}  }            일단 이렇게 이해함.            좀 더 확실히 이해하려고 다시 그려봄    static method(class method) - ex)Math.random();          객체생성 없이 ‘클래스이름.메소드이름()’으로 호출      인스턴스 멤버(iv, im)과 관련없는 작업을 하는 메소드      메소드 내에서 인스턴스 변수(iv), 인스턴스 메소드(im) 사용불가 (객체가 있다는 보장이 없음)            instance method          인스턴스 생성 후 ‘참조변수.메소드이름()’으로 호출      인스턴스 멤버와 관련된 작업(iv, im)을 하는 메소드      메소드 내에서 인스턴스 변수(iv) 사용가능      class 메소드 사용 가능함. (class는 언제나 사용가능함)          class MyMath3{  \tlong a,b;  //인스턴스 변수(iv)    \t  \tlong add() { //instance method  \t\treturn a+b; //인스턴스 변수  \t}  \tstatic long add(long a, long b )  { //class method. long a,b는 지역변수이자 매개변수(iv필요없음)  \t\treturn a+b; //지역변수  \t}  }  public class array {  \tpublic static void main(String[] args) {  \t\t\tSystem.out.println(MyMath3.add(200L,100L)); //class method 호출  \t\t\tMyMath3 mm = new MyMath3(); //객체 만들기  \t\t\tmm.a = 200L;  \t\t\tmm.b = 300L;  \t\t\tSystem.out.println(mm.add()); //instance method 호출  \t}  }        static은 iv를 사용하지않을때 붙일 것.    이걸 구분할줄알아야 코더가 아니고 프로그래머가된다…………………………………    그래도 한번더 정리하자면          static - 공통속성에 붙이는 것. (변하지 않는 값 - ex.카드 크기 등)        오버로딩(overloaing : 과적하다) : 한 class안에 같은 이름의 메소드 여러개를 정의하는 것. (대표적으로 println이 있다)                  성립조건                  메소드 이름이 같음          매개변수의 개수 또는 타입이 달라야함.                      반환 타입은 영향이 없음            ex )                        int add(int a, int b) {return a+b}            int add(int x, int y) {return a+b}            ⇒ 오버로딩 아님. 1번만 충족. 그냥 중복처리돼서 에러                        int add(int a, int b) {return a+b}            long add(int a, int b) {return (long)(a+b)}            ⇒ 1번 충족, 2번 불충족, 3번은 상관없음. 결론, 중복정의로 에러                        long add(int a, long b) {return a+b}            long add(long a, int b) {return a+b}            ⇒ 1번 2번 모두 충족, 오버로딩            💡 add(3,3);은 두 add 전부 해당돼서 명확하지않다고 에러남                            class MyMath3{  \tint add(int a, int b) {  \t\tSystem.out.println(\"int add (int a, int b) - \");  \t\treturn a+b;  \t}  \tlong add(long a, int b) {  \t\tSystem.out.println(\"long add (long a, int b) - \");  \t\treturn a+b;  \t}  \tlong add(int a, long b) {  \t\tSystem.out.println(\"long add (int a, long b) - \");  \t\treturn a+b;  \t}  \tlong add(long a, long b) {  \t\tSystem.out.println(\"long add (long a, long b) - \");  \t\treturn a+b;  \t}  \tint add(int[] a) { //배열의 모든 요소의 합을 결과로  \t\tSystem.out.print(\"int add(int[] a) - \");  \t\tint result = 0;  \t\tfor(int i=0; i &lt; a.length;i++)   \t\t\tresult += a[i];  \t\t\treturn result;  \t\t}  }          public class array {  \tpublic static void main(String[] args) {  \t\tMyMath3 mm = new MyMath3();  \t\tSystem.out.println(\"mm.add(3,3) 결과 : \"+mm.add(3,3));  \t\tSystem.out.println(\"mm.add(3L,3) 결과 : \"+mm.add(3L,3));  \t\tSystem.out.println(\"mm.add(3,3L) 결과 : \"+mm.add(3,3L));  \t\tSystem.out.println(\"mm.add(3L,3L) 결과 : \"+mm.add(3L,3L));        \t\t  \t\tint a[] = {100, 200,300};  \t\tSystem.out.println(\"mm.add(a) 결과 : \"+mm.add(a));        \t\t  \t}  }                      생성자(constructor) :                  인스턴스가 생성될 때마다 호출되는 ‘인스턴스 초기화 메소드’        Time t = new Time(); //객체생성  //인스턴스 초기화  t.hour = 12;  t.minute = 34;  t.second = 56;  == Time t = new  Time(12,34,56); //생성자            인스턴스 생성시 수행할 작업(iv 초기화)에 사용              class와 이름이 같아야 함. (구성다른 생성자를 여러개 쓰면 오버로딩임)        class Card {        Card() { //매개변수 없는 생성자        //인스턴스 초기화 작업        }        Card (String kind, int number) { //매개변수 있는 생성자        //인스턴스 초기화 작업        }        Card 클래스가 두개인건 생성자 오버로딩            리턴값이 없음 (void도 안붙임)      모든 class는 한개이상의 생성자가 있어야한다.            기본생성자 (default constructor) : 직접 작성해줘야하나 자동으로 생기는 생성자          매개변수가 없는 생성자              생성자가 하나도 없을 때만, 컴파일러가 자동 추가        Point() {} //Point 클래스의 기본 생성자                class Data_1 {  \tint value;  \t//Date_1(){} 가 자동으로 생김  }  class Data_2{  \tint value;  \t//Data_2() {} //기본생성자 (에러내려고 주석처리함)  \tData_2(int x){ //매개변수가있는 생산자  \t\tvalue = x;  \t}      }  public class array {  \tpublic static void main(String[] args) {  \t\tData_1 d1 = new Data_1(); //Date_1 클래스안에 생성자가 없어서(1개) 기본 생성자가 자동으로 생김  \t\tData_2 d2 = new Data_2(); //compile error 생성자를 호출했는데 Date_2안에 생성자가 없음  \t}  }        어지간하면 그냥 넣어줄것. 나중에가면 헷갈림          매개변수가 있는 생성자 : 생성자 호출할때 바로 값을 받음.          class Car {  \tString color; //색상  \tString gearType; //변속기 종류 - auto(자동), manual(수종)  \tint door; //문 개수    \t  \tCar(){}  \tCar(String c, String g, int d){  \t\tcolor = c;  \t\tgearType = g;  \t\tdoor = d;  \t}  }  public class array {   \tpublic static void main(String[] args) {  \t\tCar c = new Car(\"white\",\"auto\",4);   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t\tSystem.out.println();  \t\tCar c2 = new Car(\"red\",\"manual\",3);   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t}  }            생성자 this()          같은 클래스에서 다른 생성자를 호출할 때 사용      다른 생성자 호출시 첫 줄에서만 가능          class Car {  \tString color; //색상  \tString gearType; //변속기 종류 - auto(자동), manual(수종)  \tint door; //문 개수    \t  \tCar(){  \t\tthis(\"white\",\"auto\",4); // == Car{String color, String gearType, int door)  \t\t//color = \"white\";  \t\t//gearType = \"auto\"  \t\t//door = 4;   이거랑 같은거임. 코드 중복 줄이려고 한 문장으로 만든 것.  \t}  \tCar(String color) {  \t\tthis(color, \"manual\",3);  \t}  \tCar(String color, String gearType, int door){  \t\tthis.color = color;  \t\tthis.door = door;  \t\tthis.gearType= gearType;  \t}  }  public class array {   \tpublic static void main(String[] args) {  \t\tCar c = new Car();   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t\tSystem.out.println();  \t\tCar c2 = new Car(\"red\");   \t\tSystem.out.println(\"색 : \"+c2.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c2.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c2.door);  \t\tSystem.out.println();  \t\tCar c3 = new Car(\"blue\",\"auto\",5);   \t\tSystem.out.println(\"색 : \"+c3.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c3.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c3.door);  \t}  }        코드 중복을 제거하기 위해 생성자끼리 서로 호출하는 것  class Car {\tString color;\tString gearType; \tint door; }Car(){ //값이 주어지지않는다면 밑의 값으로 초기화\tcolor = \"white\";\tgearType = \"auto\";\tdoor = 4;} Car(String c, String g, int d){color = c;gearType = g;door = d;}↓class Car {\tString color;\tString gearType; \tint door; }Car(){\tthis(\"white\",\"auto\",4)}Car(String c, String g, int d){color = c;gearType = g;door = d;}  참조변수 this -괄호 없음 : 생성자 this랑 아예 관련없음. 연관짓지말것.          인스턴스 자신을 가리키는 참조변수 - 인스턴스 주소가 저장되어있다      인스턴스 메소드에서만 사용가능      모든 인스턴스 메소드에 지역변수로 숨겨진 채로 존재      지역변수와 인스턴스 변수를 구분할 때 사용      Car(String c, String g, int d){\t//color는 iv, c는 lv\tcolor = c;\tgearType = g;\tdoor = d;} //같은 클래스안에서는 생략이 가능하나 이름이 같으면 생략이 안됨//this가 자동으로 생략됨Car(String color, String gearType, int door){\t\tthis.color = color;\t\tthis.door = door;\t\tthis.gearType= gearType;} //this가 붙은건 iv, =뒤에있는건 lv//this가 없다면 iv처리가 됨//이름이 같아서 this 생략이 불가능왼쪽으로 많이 쓰는데, 정석은 오른쪽. 지역변수와 인스턴스 구분할때 정석으로 써주면됨class MyMath3{\tlong a,b;  //this a, this b iv의 진짜 이름\tMyMath(int a, int b){\t\tthis.a = a;\t\tthis.b = b;  //this 생락 불가능. 에러는 안나는데 지역변수가 됨\t}\tlong add(){ //인스턴스 메소드\t\treturn a+b; //return this.a + this.b    this는 생략 가능\t} \tstatic long add(long a, long b){ \t\treturn a+b;  //인스턴스 변수 사용 불가능. static이 있어서. 그래서 this. 사용불가\t}}this는 클래스 메소드나 인스턴스 매소드에서만 사용가능  변수의 초기화                  지역변수는 수동 초기화 해주어야함          class a{  \tint x;  \tint y = x;  //인스턴스 변수          \tvoid Method1(){ //메소드 안이니까 지역변수  \t\tint i;   \t\tint j = i; //에러남. i의 값이 없기때문. 지역변수는 자동으로 0으로 초기화해주지 않음.   \t}  \tvoid Method2(){  \t\tint i=0; //지역변수.   \t\tint j = i;  }                            멤버 변수는 자동 초기화된다                  멤버변수(iv, cv) 초기화          명시적 초기화 - 간단 초기화                  기본형 변수의 초기화 - int a= 0;          참조형 변수의 초기화 - Print p = new Print();)                    초기화 블럭 - 복잡한 초기화                  인스턴스 초기화 : {} (잘안씀)          클래스 초기화 블럭 : static{}                    생성자 - 인스턴스 변수 초기화. 복잡한 초기화에 사용        cv초기화가 먼저되고 iv초기화가 이루어짐. 자동→간단→복잡 초기화      class a {  \tstatic int[] arr = new int[10]  //명시적 초기화    \t  \tstatic { //클래스 초기화 블럭 - 배열 arr을 난수로 채운다  \t\tfor (...............  .....        — 클래스 변수 초기화 시점          클래스 변수 초기화 시점 - 클래스가 처음 로딩될 때 단 한번      인스턴스 변수 초기화 시점 - 객체가 만들어질때      "
  },
  
  {
    "title": "자바의 정석 강의 - 배열",
    "url": "/posts/%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 배열",
    "date": "2022-07-31 00:00:00 +0900",
    





    
    "snippet": "배열 : 같은 타입의 변수를 하나의 묶음으로 다루는 것.      선언 : 배열을 다루기 위한 참조변수의 선언    int[] score; / String[] name; - 자바스타일    int score[]; / String name[]; - c언어 스타일    둘다 가능은 함. 편한걸로 쓸것.    int[] score; score = new i...",
    "content": "배열 : 같은 타입의 변수를 하나의 묶음으로 다루는 것.      선언 : 배열을 다루기 위한 참조변수의 선언    int[] score; / String[] name; - 자바스타일    int score[]; / String name[]; - c언어 스타일    둘다 가능은 함. 편한걸로 쓸것.    int[] score; score = new int [5];    배열은 한번 생성하면 실행하는 동안 그 길이를 바꿀 수 없다. 배열의 길이 - int형 상수      char배열인 경우에만    char charr[] = {’a’,’b’,’c’,’d’}    system.out.println(charr)    으로 출력이 가능함. 다른 경우는 for문 또는 Arrays.toString(배열)을 써야 전체출력할 수 있음.  import java.util.*;public class array {\tpublic static void main(String[] args) {\t\t\t\tint iarr1[] = new int[10];\t\tint iarr2[] = new int[10];\t\tint iarr3[] = {100,95,80,70,60};\t\tchar charr[] = {'a','b','c','d'};\t\t\t\tfor(int i=0;i&lt;iarr1.length;i++) {\t\t\tiarr1[i] = i+1;\t\t}\t\t\t\tfor(int i=0;i&lt;iarr2.length;i++) {\t\t\tiarr2[i] = (int)(Math.random()*10)+1;\t\t}\t\tSystem.out.println(Arrays.toString(iarr1));\t\tSystem.out.println(Arrays.toString(iarr2));\t\tSystem.out.println(Arrays.toString(iarr3));\t\tSystem.out.println(charr);\t}}public class array {\tpublic static void main(String[] args) {\t\tint sum = 0;\t\tfloat avg = 0f;\t\t\t\tint score[] = {100,88,100,100,90};\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tsum += score[i];\t\t}\t\t\t\tavg = (float)sum / score.length;\t\t//\t\tSystem.out.printf(\"총점 : %d%n\", sum);//\t\tSystem.out.printf(\"평균 : %.1f%n\", avg);\t\t\t\tSystem.out.println(\"총점 : \"+sum);\t\tSystem.out.println(\"평균 : \"+avg);\t}}public class array {\tpublic static void main(String[] args) {\t\tint score[] = {79,88,91,33,100,55,95};\t\t\t\tint max = score[0];\t\tint min = score[0];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tif(score[i]&gt;max)\t\t\t\tmax=score[i];\t\t\telse if(score[i]&lt;min)\t\t\t\tmin=score[i];\t\t}\t\t\tSystem.out.println(\"최대값 : \"+max);\t\t\tSystem.out.println(\"최소값 : \"+min);\t\t\t\t}}배열 섞기import java.util.Arrays;public class array {\tpublic static void main(String[] args) {\t\t//배열 섞기\t\tint numarr[]= {0,1,2,3,4,5,6,7,8,9};\t\tSystem.out.println(Arrays.toString(numarr));\t\t\t\tfor(int i=0;i&lt;numarr.length;i++) {\t\t\tint n = (int)(Math.random()*10); //이건 [i]값을 랜덤으로 받는거고 실질적으로 배열값만 섞으니까 중복이 안나옴\t\t\tint tmp = numarr[i];\t\t\tnumarr[i] = numarr[n];\t\t\tnumarr[n]=tmp;\t\t}\t\tSystem.out.println(Arrays.toString(numarr));\t}}import java.util.Arrays;public class array {\tpublic static void main(String[] args) {\t\t\tint numarr[] = new int[45];\t\t\t\tfor(int i=0;i&lt;numarr.length;i++) {\t\t\tnumarr[i] = i+1;\t\t}\t\t\t\tint tmp = 0, n = 0;\t\tfor(int j=0;j&lt;numarr.length;j++) {\t\t\tn = (int)(Math.random()*45); //그냥 랜덤으로 numarr[n]을 구하면 중복값이 나옴\t\t\ttmp = numarr[0];\t\t\tnumarr[0]=numarr[n];\t\t\tnumarr[n]=tmp;\t\t}\t\tfor(int k = 0;k&lt;6;k++) {\t\tSystem.out.println(numarr[k]);\t\t}\t}}      String 배열                  선언  String[] name = new String[3];        String name[] = {”aa”,”bb”,”cc”}                import java.util.Arrays;      public class array {      \tpublic static void main(String[] args) {    \t  \t\tString strarr[]= {\"가위\",\"바위\",\"보\"};  \t\tSystem.out.println(Arrays.toString(strarr));    \t\t    \t\t  \t\tfor(int i = 0; i&lt;10;i++) {  \t\tint tmp = (int)(Math.random()*3);  \t\tSystem.out.println(strarr[tmp]);  \t\t}  \t}  }            커맨드라인을 통해 입력받기    args[]를 통해 입력받기임. cmd통해 입력받기 가능        n차원 배열 : n-1차원 배열이 여러개 모인것 보통 3차원부터는 잘 안쓰임, 표현하기 위해서 n중for문 필요함.                  2차원배열        int score [] [] = new int [4] [3]; = 4행 3열                                                           score[0][0]              score[0][1]              score[0][2]                                                          score[0]              score[0][0]              score[0][1]              score[0][2]                                      score[1]              score[1][0]              score[1][1]              score[1][2]                                      score[2]              score[2][0]              score[2][1]              score[2][2]                                      score[3]              score[3][0]              score[3][1]              score[3][2]                                      int arr[] [] ={ {1,2,3}, {4,5,6}}                    public class array {                \tpublic static void main(String[] args) {        \t        \t\tint score[][] = {        \t\t\t\t{100,100,100},        \t\t\t\t{20,20,20,20,20},        \t\t\t\t{30,30,30},        \t\t\t\t{40,40}        \t\t};        \t\tint sum = 0;        \t\t        \t\tfor(int i = 0; i&lt;score.length;i++) {        \t\t\tfor(int j=0;j&lt;score[i].length;j++) {        \t\t\t\tSystem.out.printf(\"score[%d][%d] = %d%n\",i,j,score[i][j]);        \t\t\t\t        \t\t\t\tsum +=score[i][j];        \t\t\t}        \t\t}        \t\tSystem.out.println(\"sum = \"+sum);        \t}        }        public class array {                \tpublic static void main(String[] args) {        \t        \t\tint score[][] = {        \t\t\t\t{100,100,100},        \t\t\t\t{20,20,20},        \t\t\t\t{30,30,30},        \t\t\t\t{40,40,40},        \t\t\t\t{50,50,50}        \t\t};        \t\tint kortotal = 0, engtotal = 0, mathtotal = 0;        \t\t        \t\tSystem.out.println(\"번호  국어   영어   수학   총점  평균\");        \t\tSystem.out.println(\"=============================\");        \t\t        \t\tfor(int i = 0; i&lt;score.length;i++) {        \t\t\tint sum = 0;        \t\t\tfloat avg = 0.0f;        \t\t\t        \t\t\tkortotal += score[i][0];        \t\t\tengtotal += score[i][1];        \t\t\tmathtotal += score[i][2];        \t\t\tSystem.out.printf(\"%3d\", i+1);        \t\t\tfor(int j=0;j&lt;score[i].length;j++) {        \t\t\t\tsum += score[i][j];        \t\t\t\tSystem.out.printf(\"%5d\",score[i][j]);        \t\t\t}        \t\t\tavg = sum/ (float)score[i].length;        \t\t\tSystem.out.printf(\"   %d %2.1f%n\",sum,avg);        \t\t\t}        \t\t}        \t}        import java.util.*;                public class array {                \tpublic static void main(String[] args) {        \t        \t\tString[][] words = {        \t\t\t{\"chair\", \"의자\"},        \t\t\t{\"computer\",\"컴퓨터\"},        \t\t\t{\"integer\",\"정수\"}        \t\t};        \t\t        \t\tScanner scanner = new Scanner(System.in);        \t\t        \t\tfor(int i =0; i&lt;words.length;i++) {        \t\t\tSystem.out.printf(\"Q%d. %s의 뜻은??\",i+1,words[i][0]);        \t\t\t        \t\t\tString tmp = scanner.nextLine();        \t\t\t        \t\t\tif(tmp.equals(words[i][0])) {        \t\t\t\tSystem.out.printf(\"정답입니다!!%n%n\");        \t\t\t}        \t\t\telse {        \t\t\t\tSystem.out.println(\"틀렸습니다! 정답은 \"+words[i][1]+\"입니다.\");        \t\t\t}        \t\t}        \t}        }  String class = char[] + method : 내용을 변경할 수 없다.(read only)  String a =”a”; String b = “b”; a=a+b; 하면 String a와 a값이 따로 저장됨. 덮어쓰기안됨. 연결은 a랑만 돼서 String a는 못씀    charAt - 원하는 위치의 문자를 가져옴.  substring - 원하는 부분의 문자열을 가져옴(마지막글자 안들고오니까 조심)public class array {\tpublic static void main(String[] args) {\t\t\tString str = \"abcdefg\";\t\tchar ch = str.charAt(2);\t\tSystem.out.println(ch); //c\t\tString str2 = str.substring(1,4);\t\tSystem.out.println(str2); //bcd\t\tString str3 = str.substring(1);\t\tSystem.out.println(str3); //bcdefg\t\t\t}}      arrays(class)로 배열 다루기          equals() : 같은 값 비교      toString()      deepToString : 2차원 이상의 다차원 배열의 출력              deepEquals : 2차원 이상의 배열들끼리 값이 같은지 비교  Arrays.deepEquals(배열1,배열2)                    copyOf() : 배열 복사  Arrays.copyOf(배열,복사할 개수) - 전체복사            copyRange : 배열 원하는부분(from~to)까지 복사. 마지막값(to)복사안됨      sort(배열) : 배열 정렬. 숫자 오름차순 정렬.          import java.util.Arrays;        public class array {        \tpublic static void main(String[] args) {    \t    \t\tint arr[] = {0,1,2,3,4};    \t\tint arr2d[][] = { {11,22}, {21,22} };    \t\t    \t\tSystem.out.println(Arrays.toString(arr));    \t\tSystem.out.println(Arrays.deepToString(arr2d));    \t\t    \t\tString str2d[][] = { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\"} };    \t\tString str2d2[][] = { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\"} };    \t\t    \t\tSystem.out.println(Arrays.deepEquals(str2d, str2d2));    \t\t    \t\tint arr2[] = Arrays.copyOf(arr, arr.length);    \t\tSystem.out.println(Arrays.toString(arr2));    \t\tint arr3[] = Arrays.copyOfRange(arr, 2,4);    \t\tSystem.out.println(Arrays.toString(arr3));    \t\t    \t\tint arr4[] = {0,4,2,1,3};    \t\tSystem.out.println(Arrays.toString(arr4));    \t\tArrays.sort(arr4);    \t\tSystem.out.println(Arrays.toString(arr4));    \t}    }"
  },
  
  {
    "title": "자바의 정석 강의 - 제어문 (flow control statemt)",
    "url": "/posts/%EC%A0%9C%EC%96%B4%EB%AC%B8-(flow-control-statemt)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 제어문",
    "date": "2022-07-30 00:00:00 +0900",
    





    
    "snippet": "  조건문          if문                  switch : 처리해야하는 경우의 수가 많을 때 씀(if-else if문보다 효율적)          switch (조건식) {  \tcase 값1 :   \t\t\t//...  \t\t\tbreak;  \tcase 값2 :   \t\t\t//...  \t\t\tbreak;  \t//...  \tdefault : ...",
    "content": "  조건문          if문                  switch : 처리해야하는 경우의 수가 많을 때 씀(if-else if문보다 효율적)          switch (조건식) {  \tcase 값1 :   \t\t\t//...  \t\t\tbreak;  \tcase 값2 :   \t\t\t//...  \t\t\tbreak;  \t//...  \tdefault :  \t\t//....조건식의 결과와 일치하는 case문이 없을떄  \t\t//....  }                      제약조건\t      - 조건식 결과가 정수 또는 문자열이여야함.      - case문의 값은 정수 상수(문자포함), 문자열만 가능, 중복 금지        import java.util.*;        public class ScanfEx1 {                \tpublic static void main(String[] args) {        \t        \tSystem.out.println(\"현재 월을 입력하세요\");        \t        \tScanner scanner = new Scanner(System.in);        \tint month = scanner.nextInt();        \t        \tswitch (month) {        \t\tcase 3: case 4: case 5:        \t\t\tSystem.out.println(\"현재 계절은 봄입니다.\");        \t\t\tbreak;         \t\tcase 6: case 7:case 8:        \t\t\tSystem.out.println(\"현재 계절은 여름입니다.\");        \t\t\tbreak;        \t\tcase 9: case 10:        \t\t\tSystem.out.println(\"현재 계절은 가을입니다.\");        \t\t\tbreak;        \t\tcase 11: case 12: case 1: case 2:        \t\t\tSystem.out.println(\"현재 계절은 겨울입니다.\");        \t\t\tbreak;        \t\tdefault :        \t\t\tSystem.out.println(\"잘못 입력했습니다.\");        \t\t}        \t}        }— Math.random() : 0.0과 1.0사이의 임의의 double값을 반환0.0 * 3 ≤ Math.random() &lt; 1.0*3  ex)원하는 값 1~3      각변에 3을 곱한다    0.0 * 3 ≤ Math.random() * 3 &lt; 1.0 * 3        각 변을 int형으로 변환한다    (int)0.0 * 3 ≤ (int)(Math.random() * 3) &lt; (int)1.0 * 3    0 ≤ Math.random() * 3 &lt; 3        각 변에 1을 더한다    0 + 1 ≤ (Math.random() * 3) +1 &lt; 3 + 1    1 ≤ (Math.random() * 3) +1 &lt; 4      public class ex4_7 {    \tpublic static void main(String[] args) {    \t\tint num=0;    \t\t//1~10사이의 난수를 20개 출력할 것.    \t\tfor(int i=0;i&lt;=20;i++) {    \t\t\tSystem.out.println((int)(Math.random()*10)+1);    \t\t}    \t\tSystem.out.println(\"===============\");        \t\t\t//-5~5사이의 난수를 20개 출력할 것.    \t\tfor(int j=0;j&lt;=20;j++) {    \t\t\tSystem.out.println((int)(Math.random()*11)-5); //0도 포함이라 값이 11개임    \t\t}    \t}    }  반복문          for          public class ex4_8 {        \tpublic static void main(String[] args) {    \t\tfor(int i=1, j=10;i&lt;=10;i++,j--) {    \t\t\tSystem.out.println(\"i=\"+i+\", j=\"+j);    \t}    \t    \t//구구단    \tfor(int j = 2;j&lt;=9;j++){    \t\tSystem.out.println(j+\"단 시작!!!\");    \t\tfor(int k=1;k&lt;=9;k++) {    \t\t\tSystem.out.println(j+\" * \" +k+\" = \"+j*k);    \t\t\tif(k==9)    \t\t\tSystem.out.println(\"====\"+j+\"단 종료====\\n\");    \t\t}    \t}    \t//별 찍기    \t\tfor(int n=1;n&lt;10;n++) {    \t\t\tfor(int x=1;x&lt;n;x++) {    \t\t\t\tSystem.out.print(\"★\");    \t\t\t}    \t\t\tSystem.out.println();    \t\t}     \t}    }  while - 조건식을 만족시키는 동안 블럭을 반복. do while문을 사용.    public class ex4_13 {        \tpublic static void main(String[] args) {    \t\tint sum=0;    \t\tint i=0;    \t\t    \t\twhile (sum&lt;=100) {    \t\t\tSystem.out.printf(\"%d : %d%n\",i,sum);    \t\t\tsum += ++i;    \t\t}    \t}        }    import java.util.*;        public class Ex4_14 {        \tpublic static void main(String[] args) {    \t\tint num=0, sum = 0;    \t\tSystem.out.println(\"숫자를 입력하세요.\");    \t\t    \t\tScanner scanner = new Scanner(System.in);    \t\tString tmp = scanner.nextLine();    \t\tnum = Integer.parseInt(tmp);    \t\t    \t\twhile (num != 0) {    \t\t\tsum += num%10;    \t\t\tSystem.out.printf(\"sum = %d num = %d%n\",sum,num);    \t\t\t    \t\t\tnum /= 10;    \t\t}    \t\tSystem.out.println(\"각 자리수의 합 : \"+sum);    \t\t    \t\tint sum2 = 0;    \t\tfor(num = Integer.parseInt(tmp);num&gt;0;num = num / 10)    \t\t{    \t\t\tsum2 += num%10;    \t\t\tSystem.out.printf(\"sum = %d num = %d%n\",sum2,num);    \t\t}    \t\tSystem.out.println(\"각 자리수의 합 : \"+sum2);    \t}        }  do while : 반복횟수를 알거나 코드가 중복이면 do while문을 사용  do{조건식이 참일 때 수행 될 문장. 처음 한번든 무조건 실행}  while(조건식);    import java.util.*;        public class ex4_15 {        \tpublic static void main(String[] args) {    \t\tint input = 0 , answer = 0;    \t\t    \t\tanswer = (int)(Math.random()*100)+1;    \t\tScanner scanner = new Scanner(System.in);    \t\t    \t\tdo {    \t\t\tSystem.out.println(\"1과 100사이의 정수를 입력하세요.&gt;&gt;\");    \t\t\tinput = scanner.nextInt();    \t\t\t    \t\t\tif (input &gt; answer) {    \t\t\t\tSystem.out.println(\"더 작은 수로 다시 시도하세요.\");    \t\t\t}    \t\t\telse if (input &lt; answer) {    \t\t\t\tSystem.out.println(\"더 큰 수로 다시 시도하세요.\");    \t\t\t}    \t\t} while (input != answer);    \t\t\tSystem.out.println(\"정답입니다!\");    \t\t}    \t}    public class ex4_16 {        \tpublic static void main(String[] args) {    \t\tint i = 0, sum = 0;    \t\t    \t\tdo {    \t\t\t++i;    \t\t\tsum += i;    \t\t} while(sum&lt;100);    \t\tSystem.out.println(\"i=\"+i);    \t\tSystem.out.println(\"sum=\"+sum);    \t}        }    public class ex4_16 {        \tpublic static void main(String[] args) {    \t\tint i = 0, sum = 0;    \t\t    \t\twhile (true) {    \t\t\tif(sum&gt;100)    \t\t\t\tbreak;    \t\t\t++i;    \t\t\tsum += i;    \t\t}    \t\tSystem.out.println(\"i=\"+i);    \t\tSystem.out.println(\"sum=\"+sum);    \t}        }  continue : 조건이 충족된다면 블록의 끝으로 이동, 다시 반복문 수행.public class ex4_17 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;=10;i++) {\t\t\tif(i%2==0)\t\t\t\tcontinue;\t\t\tSystem.out.println(i);\t\t}\t}}  이름붙은 반복문 : 반복문에 이름을 붙여서 break앞에 적어주면 하나이상의 반복문을 벗어날 수 있다Loop1 : for( ......\tfor( ...........\t\t\t\tbreak Loop1;import java.util.*;public class ex4_18 {\tpublic static void main(String[] args) {\t\tint menu = 0;\t\tint num = 0;\t\t\t\tScanner scanner = new Scanner(System.in);\t\t\t\touter : while (true) {\t\t\tSystem.out.println(\"(1) square\");\t\t\tSystem.out.println(\"(2) square root\");\t\t\tSystem.out.println(\"(3) log\");\t\t\tSystem.out.println(\"원하는 메뉴를 입력하세요. (종료 : 0)\");\t\t\t\t\t\tString tmp = scanner.nextLine();\t\t\tmenu = Integer.parseInt(tmp);\t\t\t\t\t\tif(menu == 0) {\t\t\t\tSystem.out.println(\"프로그램을 종료합니다.\");\t\t\t\tbreak;\t\t\t}\t\t\telse if (!(menu&gt;=1 &amp;&amp; menu&lt;=3)) {\t\t\t\tSystem.out.println(\"메뉴를 잘못 선택하셨습니다. (종료는 0)\");\t\t\t\tcontinue;\t\t\t}\t\t\tSystem.out.println(\"선택하신 메뉴는 \"+menu+\"번입니다.\");\t\t\t\t\t\tfor(;;) {\t\t\t\tSystem.out.println(\"계산할 값을 입력하세요.(계산종료 : 0, 전체종료 : 99)&gt;&gt;\");\t\t\t\ttmp = scanner.nextLine();\t\t\t\tnum = Integer.parseInt(tmp);\t\t\t\t\t\t\t\tif(num==0)\t\t\t\t\tbreak;\t\t\t\tif(num==99)\t\t\t\t\tbreak outer;\t\t\t\t\t\t\t\tswitch(menu) {\t\t\t\t\tcase 1:\t\t\t\t\t\tSystem.out.println(\"result=\"+num*num);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 2:\t\t\t\t\t\tSystem.out.println(\"result=\"+Math.sqrt(num)); //제곱근\t\t\t\t\t\tbreak;\t\t\t\t\tcase 3:\t\t\t\t\t\tSystem.out.println(\"result=\"+Math.log(num)); //로그\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t}}"
  },
  
  {
    "title": "자바의 정석 강의 - 연산자(Operator)",
    "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90(Operator)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연산자",
    "date": "2022-07-30 00:00:00 +0900",
    





    
    "snippet": "연산자 : 연산을 수행하는 기호 (+,-,*,/)피연산자 : 연산자의 수행 대상(x+3에서 x와 3)                                             종류      연산자      설명              산술 연산자      + - * / % ==« »==      사칙연산과 나머지 연산              비교...",
    "content": "연산자 : 연산을 수행하는 기호 (+,-,*,/)피연산자 : 연산자의 수행 대상(x+3에서 x와 3)                                             종류      연산자      설명              산술 연산자      + - * / % ==« »==      사칙연산과 나머지 연산              비교 연산자      &lt; &gt; ≥ ≤ == !=      크고 작음과 같고 다름을 비교              논리 연산자      &amp;&amp; | !(not)      and와 or으로 조건을 연결              대입 연산자      =      우변의 값을 좌변에 저장              기타      (type) ?: instanceof      형변환 연산자, 삼항 연산자, instanceof 연산자        증감 연산자          j = ++i : 값이 참조 되기 전에 증가시 = 일단 i+1하고 i값으로 할거 함      j = i++ : 값이 참조 된 후에 증가시킴 = i값으로 할거 다하고 +1      i++, ++i처럼 독립적으로 쓰였을때는 차이가 없음            형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것.    double d= 85.5; int score = (int)d; //85    ❗반올림 안됨! 그냥 버림!!실수→정수는 모두 그럼          자동 형변환 : 서로 다른 두 타입을 일치시킬깨 형변환을 생략하면 대부분 컴파일러가 알아서 형변환을 자동적으로 한다.                  생략 가능                          float f = 1234; == float f = (float)1234; //컴파일러가 자동으로 형변환. 두개가 같은거임.              byte - int는 int값이 byte타입의 범위 -128~127사이의 값이라면 값 손실이 없기 때문에 예외적으로 가능.  int i = 100; byte b = i ; 는 에러남. 변수값이라 값손실이 없음을 확신할 수 없기 때문.                                생략 불가능                                          int i = 3.14f; //에러남. float가 int보다 크기때문에 값손실이 발생됨.  int i = (int)3.14f로 써줘야함.                                            short - char끼리 자동 형변환 불가능. short가 부호있는 연산자라서. chat - int변환은 가능                                                              산술 변환 : 연산 전에 피연산자의 자동으로 타입을 일치시키는 것.          두 피연산자의 타입을 큰 타입으로 일치시킴              int보다 작은 타입이면 int로 변환된다.  byte + short = int / char + short = int        ‘2’ - ‘0’ = 2 (문자 2의 코드가 50이고 문자 0의 코드가 48이라서. 문자코드가 순서대로 1씩 증가해서 문자끼리 식은 일반 식과 결과값이 같음 )                public class ScanfEx1 {  \tpublic static void main(String[] args) {  \t\tint a = 1_000_000;  \t\tint b = 2_000_000;    \t\t  \t\tlong c = (long)a*b;  \t\tSystem.out.println(c);  \t}  }            반올림 - Math.round - 실수를 소수 첫째 자리에서 반올림  Math.round(4.52) = 5  —n의 자리까지 반올림을 해주려면?    Math.round(Math.PI*1000.0)/1000.0); → 3.142 이렇게 10의 n제곱을 곱하고 나눠줌    equals();String str1 = \"abc\";String str2 = \"abc\";system.out.println(str1==str삼2); //값의 위치가 같음String str3 = new String(\"abc\");String str4 = new String(\"abc\");system.out.println(str3.equals(str4); //인스턴스라서 값을 복제해와서 값의 위치가 다름!!      조건 연산자 ? : 조건식의 결과에 따라 연산결과를 달리한다.    조건식 ? 식1 : 식2 //조건식이 참이면 식1 거짓이면 식2    result = (x&gt;y) ? x : y ; //괄호 생략가능    if문을 간단하게 쓸 수 있는 장점이 있음!!        대입 연산자          lvalue : 왼쪽 피연산자, 저장공간 3, i+3같은 값이 오거나 final을 붙여 상수가 되면 에러남      rvalue : 오른쪽 피연산자      !(not)은 가독성에 안좋으니 가급적 쓰지말것 쓸거면 처음부터 쓰기. 중간부터 쓰면 알아보기 힘들어짐"
  },
  
  {
    "title": "자바의 정석 강의 - 변수(Variable)",
    "url": "/posts/%EB%B3%80%EC%88%98(Variable)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 변수",
    "date": "2022-07-29 06:27:00 +0900",
    





    
    "snippet": "  system.out.println(); 에서 print==ln==이 \\n이거라서 따로 \\n안해줘도 지금까지 줄바꿈이 됐던거임..! 충격! pintf도 있다..!      public class Ex2_1 {      \tpublic static void main(String[] args) {  \t\tSystem.out.printf(\"hello\");  ...",
    "content": "  system.out.println(); 에서 print==ln==이 \\n이거라서 따로 \\n안해줘도 지금까지 줄바꿈이 됐던거임..! 충격! pintf도 있다..!      public class Ex2_1 {      \tpublic static void main(String[] args) {  \t\tSystem.out.printf(\"hello\");  \t\tSystem.out.printf(\"hello\");  \t\tSystem.out.printf(\"hello\");  \t}      }        이거는 줄바꿈 안되고 hellohellohello로 실행됨. print로 바꿔도 마찬가지    변수(variable) : 하나의 값을 저장할 수 있는 메모리 공간(RAM). 변경가능  — 변수 선언 이유 : 값(data)를 저장할 수 있는 공간을 마련하기 위해.      변수타입 변수이름; ex)int age;                  =는 등호가 아니라 대입. 그래서 if문에서는 == 를 썼구나  int x=0; 변수 x를 선언 후 0으로 초기화  int y=5; 변수 y를 선언 후 5로 초기화        ❗지역변수는 읽기전에 꼭 초기화를 해주어야 함            변수 타입                  기본형(Primitive type) - 8개                          정수 :                                  int                  byte : 0~127, 이진데이터를 다루는데 사용                  short : c언어와의 호환을 위해 사용. 잘안쓰임                  long : int에 못넣는 20억이 넘는 값을 넣음                                            문자 : char (한글자) - 빈문자(’’;)불가능              문자열 : String (여러글자) -                                                      빈문자(””;) 가능  ⇒ “”+7 = “7” : 숫자 7이 문자열로 변환됨.  ex) “”+7+7 = “7”+7→”7”+”7”⇒ “77”  7+7+”” = 14+””→”14”+””⇒”14”                                                        class이나 너무 자주 쓰여서 String s1 = “ab”; 로 사용가능                                                              실수 (소수점) : double, float              논리(boolean) : true, false. 조선식과 논리적 계산에 사용                                                                        종류/크기                  1byte                  2byte                  4byte                  8byte                                                                              논리형                  boolean                                                                                                           문자형                                     char                                                                                        정수형                  byte                  short                  int                  long                                                  실수형                                                        float                  double                                                      n비트로 표현할 수 있는 값의 개수 : 2의 n제곱            n비트로 표현할 수 있는 부호없는 정수의 범위 : 0~2의n제곱-1            n비트로 표현할 수 있는 부호있는 정수의 범위 : -2의 n-1제곱 ~2의 n-1제곱-1                          부호비트 (sign bit)                                                      byte = -2의 7제곱~ 2의 7제곱 -1 =                                                                                            0                          7bit                                                                                      부호비트가 0이니까 양수                                                                                            1                          7bit                                                                                      부호비트가 1이니까 음수                                                        short = -2의 15제곱~ 2의 15제곱 -1 =                                                                                            s                          15bit                                                                                                                          char = 0~2의 16제곱 -1 (2진수로 변환)                                                                                            16bit                          160000000001000001                                                                                                                          int = -2의 31제곱~ 2의 31제곱 -1 = -20억~20억                                                                                            s                          31bit                                                                                                                          int = -2의 63제곱~ 2의 63제곱 -1 = -800경 ~ 800경                                                                                            s                          63bit                                                                                      혹시 부족하면 Big integer사용                                                        float = 1+8+23 = 32bit = 4byte = -1.410의 -45제곱~1.410의 -45제곱                                                                                            S                          E(8)                          M(23)                                                                                      정밀도 : 7자리                                                        double = 1+11+52 = 64bit = 8byte = -3.410의 38제곱~3.410의 38제곱                                                                                            S                          E(11)                          M(50)                                                                                      정밀도 : 15자리 (float보다 정확함)                                                                                            참조형(Reference type) : 기본형을 제외한 나머지. 무한개                          메모리주소를 저장. (4byte[40억] or 8 byte[160억])                        ex) today = new Date(); - 참조형 변수 today에 객체의 주소를 저장                              리터럴 (literal) : 그 자체로 값을 의미. 기존의 상수.                              리터럴 타입과 접미사                                                            종류                  리터럴                  접미사                                                                              논리형                  false, true                  없음                                                  정수형                  int - 123, Ob0101, 077, 0xFF,  Long - 100L                  L                                                  실수형                  3.14, 3.0e8, 1.4f, 0x1.0p-1                  f(float),  d(double, 생략가능)                                                  문자형                  ‘A’, ‘1’, ’\\n’                  없음                                                  문자열                  “ABC”, “123”, “A”, “true”                  없음                                                      정수형, 실수형은 접미사로 구분함.                                          int oct = 010;            \t\tint hex = 0x10;            \t\t            \t\tSystem.out.println(oct);            \t\tSystem.out.println(hex);            // println을 쓰면 8진수와 16진수를 표현못해서 8과 16이 나옴.            // printf를 쓰면 가능  10진수 : int i = 100;  8진수 : int i = 0100;  16진수 : int i = 0x100;  long i = 10_000_000_000L ⇒ 100억. int가 20억까지 가능함. 꼭 L붙일것.  1e3 = 여기서 e가 10의 n제곱임. = 1000.0 (접미사 없으니 double형)  int i = ‘A’; ⇒ A의 문자열코드인 65가 출력됨  상수(constant) : 한 번만 값을 저장 가능한 변수. 변경 불가능. 앞에 final을 붙이면 됨.ex) final int MAX = 100;MAX = 200;(에러남)&lt;/mark&gt;\tint score = 100;\tscore = 200;\tfinal int MAX = 100;\tchar ch = 'a';\tString str = \"abc\";— 변수와 리터럴 타입 불일치  범위가 변수&gt;리터럴 인 경우 가능함          int &gt; char / long &gt; int / double &gt; float        범위가 변수 &lt; 리터럴 인 경우 에러남          long i = 3.14f - long&lt;float이라 에러      float f = 3.14 (접미사 생략됐으니 double형) 에러. float &lt; double  double d = 3.14f ⇒ 가능      byte, short변수에 int 리터럴 사용 가능        두 변수 값 교환하는 법      int x = 10, y = 20;  int tmp;//빈공간  x=tmp;  x=y;  y=tmp;      pritnln 단점  출력형식 지정 불가 (ex.소수점 자리지정 불가)  10진수로만 출력됨⇒ printf를 사용하면 가능해짐            지시자      설명                  %b      boolean 형식으로 출력              %d      10진 정수의 형식으로 출력              %o      8진 정수의 형식으로 출력  #을 붙여야 접두사도 출력됨              %x, %X      16진 정수의 형식으로 출력  #을 붙여야 접두사도 출력됨              %f      부동 소수점의 형식으로 출력  %g를 사용하면 간략하게 출력              %e, %E (1.234e+02)      지수 표현식의 형식으로 출력              %c      문자로 출력              %s      문자열로 출력      ❗\\n, %n 둘다 줄바꿈이나 %n을 자주 사용할 것.      지시자    system.out.printf(”[%5d]%n”, 10); // [ 10] - 5자리 출력    system.out.printf(”[%-5d]%n”, 10); // [10 ] - 5자리 출력, 왼쪽정렬    system.out.printf(”[%05d]%n”, 10); // [00010] - 5자리 출력(숫자, 문자열 다 됨)    system.out.printf(”[%5d]%n”, 1234567); // [1234567] - 7자리 출력    system.out.printf(“[%14.10f]%n”, 1.23456789); // [ 1.2345678900]   (전체자리 14자리에서 소수점 10자리 출력)  화면으로 입력받기부터 - Scanner : 화면으로부터 데이터를 입력받는 class  import문 필수 - import java.util.*;  Scanner 객체의 생성 Scanner scanner = new Scanner system.in;  Scanner 객체의 사용          int num = scanner.nextInt(); //화면에서 입력받은 정수를 num에 저장      String input = scanner.nextLine(); //화면에서 입력받은 내용을 input에 저장  int num = Integer.parseInt(input); //문자열(input)을 숫자(num)으로 전환                  숫자 → 문자열 = 숫자 + “”          문자열 → 숫자 = Integer.parseInt(”문자열”)  — 한 문장에 여러 값을 받을경우 필요함                    \timport java.util.*;\t\tpublic class ScanfEx1 {\t\t\tpublic static void main(String[] args) {\t\t\t\t//정수\t\t\tScanner scanner = new Scanner(System.in);\t\t\tint num = scanner.nextInt();\t\t\tSystem.out.println(num);\t\t\t\t\t\t//문자열\t\t\tScanner scanner2 = new Scanner(System.in);\t\t\tString input = scanner2.nextLine();\t\t\tSystem.out.println(input);\t\t\t\t\t\t//문자열 -&gt; 숫자\t\t\tScanner scanner3 = new Scanner(System.in);\t\t\tString input2 = scanner3.nextLine();\t\t\tint num2 = Integer.parseInt(input2);\t\t\tSystem.out.println(input2);\t\t}\t}❗Scanner밑에 밑줄은 입출력 관련 객체들은 원칙적으로 반드시 닫아주어야함. 하지만 화면입력같은경우에는 자바 버추얼머신에서 기본적으로 관리가 되기때문에 닫아주지 않아도 됨. 오류는 무시할 것.오버플로우 : 표현할 수 있는 범위를 넘어섰다.최대값 + 1 = 최소값최소값 - 1 = 최대값10진수 :9999→0000 (칸이 4칸이라서)부호없는 정수 : ex) 4bit (표현범위0~15)15(최대값) + 1 → 0(최소값)2진수 : 1111→0000부호있는 정수 : ex) 4bit (표현범위-8~7)7(최대값)+1 → -8(최소값)부호 없는 정수 : 부호 +나-가 존재하지 않는 숫자 세계를 나타냄.(0이하의 음수를 표현x)부호 있는 정수 : 양수타입간의 변환 방법 - 외우지는 못해도 필요할때 찾아볼 수 있는 정도는 돼야함  문자 → 숫자 = 3 - ’0’  숫자 → 문자 = 3 + ’0’  문자→ 문자열 = ‘3’ + “”  문자열 → 문자 = “3”.charAt(0)  숫자 → 문자열 = 3 + ””  문자열 → 숫자  = Integer.parseInt(”3”)  = Double.parseDouble(”3.4”)\timport java.util.*;\t\tpublic class ScanfEx1 {\t\t\tpublic static void main(String[] args) {\t\t\tString str = \"3\";\t\t\tSystem.out.println(str.charAt(0)); //문자열 -&gt; 문자\t\t\tSystem.out.println('3' - '0' + 1); //문자-&gt;숫자\t\t\tSystem.out.println(Integer.parseInt(\"3\")+1); //문자열 -&gt; 숫자\t\t\tSystem.out.println(\"3\"+1); //문자열+숫자 =&gt; 31\t\t\tSystem.out.println(3+'0'); //문자 0은 숫자로 48 =&gt; 51\t\t\tSystem.out.println((char)(3+'0')); // 문자 '3' 출력\t\t}\t}printf사용시 %#x는 접두사 0x가 붙음"
  },
  
  {
    "title": "자바의 정석 강의 - 자바 시작하기 전",
    "url": "/posts/%EC%9E%90%EB%B0%94-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-07-28 21:27:00 +0900",
    





    
    "snippet": "  자바 : 프로그래밍 언어. 컴퓨터 프로그램(애플리케이션)을 만드는데 사용  실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)                  라이브러리 : 프로그램을 만드는데 필요한 기능들을 미리 만들어놓은 것.        ⇒ 쉽고 빠른 개발 가능            pc애플리케이션, 웹 애플리케이션, 모바일 애플리케이...",
    "content": "  자바 : 프로그래밍 언어. 컴퓨터 프로그램(애플리케이션)을 만드는데 사용  실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)                  라이브러리 : 프로그램을 만드는데 필요한 기능들을 미리 만들어놓은 것.        ⇒ 쉽고 빠른 개발 가능            pc애플리케이션, 웹 애플리케이션, 모바일 애플리케이션(안드로이드), 빅 데이터, 게임(ex.마크), 과학, 소형기기 등 에 활용 가능      모던 프로그래밍 언어(객체지향 + 함수형)      특징                  배우기쉬운 객체지향언어(프로그래밍언어+객체지향개념[c++,java,python])          자동 메모리 관리          멀티 쓰레드 지원 - 하나의 프로그램에서 동시에 여러작업 가능.          풍부한 라이브러리로 쉽게 개발가능.          운영체제에 독립적 - 수정없이 여러 운영체제에서 사용가능                          자바 가상 머신(JVM) : 자바 프로그램이 실행되는 가상 컴퓨터(VM). 한번 작성하면, 어디서든(어떤 운영체제에서도) 실행 가능.                                            java API문서 : java API가 제공하는 기능에 대한 상세한 정보를 제공(html)  https://docs.oracle.com/javase/7/docs/api/index.html      단축키          ctrl + shift + L : 단축키 전체 목록      alt + shift + A : 멀티컬럼 편집 - 커서가 +모양으로 바뀌는데 바꾸고 싶은 부분을 드래그해서 한번에 바꿈      ctrl + i : 자동들여쓰기      ctrl + shift + o : import java.util.~; 자동추가      "
  }
  
]

