[
  
  {
    "title": "자바의 정석 연습문자 7장 - 상속 2",
    "url": "/posts/%EC%9E%90%EB%B0%94%EC%9D%98%EC%A0%95%EC%84%9D_%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C_7%EC%9E%A5_%EC%83%81%EC%86%8D_2/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 상속",
    "date": "2022-10-10 00:00:00 +0900",
    





    
    "snippet": "[7-17] 예제코드의 세 클래스에서 공통부분을 뽑아 Unit 클래스를 만들고 이 클래스를 상속받도록 코드를 변경  예제    class Marine{  int x,y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Tank{  int x, y;  void move(int x...",
    "content": "[7-17] 예제코드의 세 클래스에서 공통부분을 뽑아 Unit 클래스를 만들고 이 클래스를 상속받도록 코드를 변경  예제    class Marine{  int x,y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Tank{  int x, y;  void move(int x, int y){}  void stop(){}  void changeMode(){}}class Dropship{  int x,y;  void move(int x, int y){}  void stop(){}  void load(){}  void unload(){}}        변경 코드package _2javajungsuktestEx7;class Unit{\tint x, y;\tvoid move(int x, int y) {}\tvoid stop() {}}class Marine extends Unit {\tvoid stimPack() {}}class Tank extends Unit {\tvoid changeMode() {}}class Droppship extends Unit{\tvoid load(){}\tvoid unload() {}}public class ex7_17 {\tpublic static void main(String[] args) {\t}}공통적으로 등장하는 부분만 Unit으로 묶어서 만들어준후 상속처리 해줬음  답지package _2javajungsuktestEx7;class Unit{\tint x, y;\tabstract void move(int x, int y) {}\tvoid stop() {}}class Marine extends Unit {\tvoid stimPack() {}}class Tank extends Unit {\tvoid changeMode() {}}class Droppship extends Unit{\tvoid load(){}\tvoid unload() {}}public class ex7_17 {\tpublic static void main(String[] args) {\t}}Unit클래스의 move메소드에 abstract를 붙여 추상메소드 처리를 해주었음. 각 클래스마다 이동방법이 다르기때문..[7-18] action메소드를 실행하면 매개변수에 해당하는 클래스의 메소드를 실행하도록 만드는 문제package _2javajungsuktestEx7;class Robot{}class DanceRobot extends Robot{\tvoid dance(){\t\tSystem.out.println(\"춤\");\t}}class SingRobot extends Robot{\tvoid sing(){\t\tSystem.out.println(\"노래\");\t}}class DrawRobot extends Robot{\tvoid draw(){\t\tSystem.out.println(\"그림\");\t}}public class ex7_18 {\t\tstatic void action(Robot r) {\t\tif(r instanceof DanceRobot) \t\t\t((DanceRobot) r).dance();\t\telse if(r instanceof SingRobot) \t\t\t((SingRobot) r).sing();\t\telse if(r instanceof DrawRobot) \t\t\t((DrawRobot) r).draw();\t}\tpublic static void main(String[] args) {\t\tRobot arr[] = {new DanceRobot(), new SingRobot(), new DrawRobot()};\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\taction(arr[i]);\t\t}\t}}Robot타입의 배열을 생성해서 서로 상속관계인 DrawRobot, SingRobot, DanceRobot을 배열에 넣어줬음. 다음에 배열의 i값이 특정 클래스와 상속관계라면 특정클래스의 메소드를 실행하도록 코드를 짰음.  답지package _2javajungsuktestEx7;class Robot{}class DanceRobot extends Robot{\tvoid dance() {\t\tSystem.out.println(\"춤을 춥니다.\");\t}}class SingRobot extends Robot{\tvoid sing() {\t\tSystem.out.println(\"노래를 합니다.\");\t\t}}class DrawRobot extends Robot{\tvoid draw() {\t\tSystem.out.println(\"그림을 그립니다.\");\t}}public class ex7_18 {\tstatic void action(Robot r) {\t\tif(r instanceof DanceRobot) {\t\t\tDanceRobot dr = (DanceRobot)r;\t\t\tdr.dance();\t\t}else if(r instanceof SingRobot) {\t\t\tSingRobot SR = (SingRobot)r;\t\t\tSR.sing();\t\t}else if(r instanceof DrawRobot) {\t\t\tDrawRobot Draw = (DrawRobot)r;\t\t\tDraw.draw();\t\t}\t}\t\tpublic static void main(String[] args) {\t\tRobot arr[] = {new DanceRobot(), new SingRobot(), new DrawRobot()};\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\taction(arr[i]);\t\t}\t}}if문에서 객체를 생성해서 메소드를 실행함.[7-19] Buyer 클래스의 제품구입 기능, 장바구니 추가기능, 구입물건 목록 조회기능, 남은 금액 출력 기능 구현package _2javajungsuktestEx7;class Buyer{\tint money =1000;\tProduct cart[] = new Product[3];\tint i=0;\t\tvoid buy(Product p) {\t\tif(money &lt; p.price) {\t\t\tSystem.out.println(p+\"를 구매할 돈이 부족합니다.\");\t\t\treturn;\t\t}else {\t\t\tmoney-=p.price;\t\t\tadd(p);\t\t}\t}\tvoid add(Product p) {\t\tif(i&gt;=cart.length) {\t\t\tProduct[] cart2 = new Product[cart.length*2];\t\t\tSystem.arraycopy(cart, 0, cart2, 0, cart.length);\t\t\tcart = cart2;\t\t}\t\tcart[i++] = p;\t}\tvoid summary() {\t\tint sum = 0;\t\tfor(int i=0;i&lt;cart.length;i++) {\t\t\tSystem.out.print(cart[i]+\", \");\t\t\tsum += cart[i].price;\t\t}\t\tSystem.out.println();\t\tSystem.out.println(\"쓴 돈 : \" + sum);\t\tSystem.out.println(\"남은 돈 : \"+  money);\t}}class Product{\tint price;\t\tProduct(int price){\t\tthis.price=price;\t}}class Tv2 extends Product{\tTv2(){super(100);}\tpublic String toString () {return \"Tv\";}}class Computer extends Product{\tComputer(){super(200);}\tpublic String toString () {return \"Computer\";}}class Audio extends Product{\tAudio(){super(50);}\tpublic String toString () {return \"Audio\";}}public class ex7_19 {\tpublic static void main(String[] args) {\t\tBuyer b = new Buyer();\t\tb.buy(new Tv2());\t\tb.buy(new Computer());\t\tb.buy(new Tv2());\t\tb.buy(new Audio());\t\tb.buy(new Computer());\t\tb.buy(new Computer());\t\tb.buy(new Computer());\t\t\t\tb.summary();\t\t\t}}일단 책에 적혀진 가이드대로 따라 만들어보았는데 가이드없이도 만들 줄 알아야할 것같다..컬렉션프레임워크의 List를 이용package Ex7;public class Product{  public int price;  public Product(int price){    this.price = price;  }}package Ex7;public class Tv extends Product{  public Tv(){    super(100);  }  public String toString(){    return \"Tv\";  }}package Ex7;public class Computer extends Product{  public Computer(){    super(200);  }  public String toString(){    return \"Computer\";  }}package Ex7;public class Audio extends Product{  public Audio(){    super(50);  }  public String toString(){    return \"Audio\";  }}package Ex7;import java.util.ArrayList;import java.util.List;public class Buyer {  int money = 1000;  List&lt;Product&gt; cart = new ArrayList&lt;Product&gt;();  void buy(Product p){    if(money&lt;p.price){      System.out.println(\"돈이 부족해서\"+p+\"을(를) 구매할 수 없습니다.\");      return;    }    money -= p.price;    add(p);    System.out.println(p+\"을(를) 구매했습니다.\");  }  void add(Product p){    cart.add(p);  }  void summary(){    System.out.print(\"구입한 물건 : \");    int sum=0;    for(Product p : cart){      System.out.print(p+\", \");      sum+=p.price;    }    System.out.println();    System.out.println(\"사용한 금액 : \"+sum);    System.out.println(\"남은 금액 : \"+money);  }  }package Ex7;public class ProductMain {  public static void main(String[] args) {    Buyer b = new Buyer();    b.buy(new Tv());    b.buy(new Computer());    b.buy(new Tv());    b.buy(new Audio());    b.buy(new Computer());    b.buy(new Computer());    b.buy(new Computer());        b.summary();  }}훨신 더 간단해졌다[7-20] 아래 코드의 실행결과는?class Parent{\tint x=100;\tvoid method() {\t\tSystem.out.println(\"Parent Method\");\t}}class Child extends Parent{\tint x=200;\tvoid method() {\t\tSystem.out.println(\"Child Method\");\t}}public class ex7_20 {\tpublic static void main(String[] args) {\t\tParent p = new Parent();\t\tChild c = new Child();\t\t\t\tSystem.out.println(\"p.x : \"+p.x);\t\tp.method();\t\tSystem.out.println(\"c.x : \"+c.x);\t\tc.method();\t}}순서대로p.x : 100Parent Methodc.x : 200Child Method가 출력됨.[7-21] attack메소드의 매개변수로 가능한 것 두가지는?interface Moveable{\tvoid move(int x, int y);}void attack(Moveable f){\t//내용 생략}null과 Moveable 인터페이스를 구현한 클래스나 그 자손의 인스턴스[7-22] Shape클래스를 조상으로 하는 Circle클래스와 Rectangle클래스를 작성하시오. 생성자도 각 클래스에 맞게 적절히 추가하시오package _3javajungsuktestEx7_3;abstract class Shape{\tPoint p;\t\tShape(){\t\tthis(new Point(0,0));\t}\tShape(Point p){\t\tthis.p=p;\t}\t\tabstract double calcArea(); //도형 면적 계산 후 반환\t\tPoint getPosition() {\t\treturn p;\t}\tvoid setPosition(Point p) {\t\tthis.p=p;\t}\t}class Point{\tint x, y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tpublic String toString() {\t\treturn \"[\" + x+\", \"+y+\"]\";\t}}class Circle extends Shape{\tdouble r; //반지름\t\tCircle(double r){\t\tthis(new Point(0,0),r);\t}\tCircle(Point p, double r){\t\tsuper(p); //조상의 멤버는 조상의 생성자가 초기화하도록 함\t\tthis.r=r;\t}\t\tdouble calcArea() {\t\treturn Math.PI*r*r;\t}}class Rectangle extends Shape{\tdouble width, height;\t\tRectangle(double width, double height){\t\tthis(new Point(0,0),width, height);\t}\tRectangle(Point p, double width, double height){\t\tsuper(p); //조상의 멤버는 조상의 생성자가 초기화하도록 함\t\tthis.height=height;\t\tthis.width=width;\t}\t\tdouble calcArea() {\t\treturn width *height;\t}\tboolean isSquare(){\t\tif(width == height) return true;\t\telse return false;\t}}public class ex7_22 {\t\tpublic static void main(String[] args) {\t}}[7-23] 면적을 구하는 sumArea 메소드를 작성하고 테스트package _3javajungsuktestEx7_3;abstract class Shape{\tPoint p;\t\tShape(){\t\tthis(new Point(0,0));\t}\tShape(Point p){\t\tthis.p=p;\t}\t\tabstract double calcArea(); //도형 면적 계산 후 반환\t\tPoint getPosition() {\t\treturn p;\t}\tvoid setPosition(Point p) {\t\tthis.p=p;\t}\t}class Point{\tint x, y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tpublic String toString() {\t\treturn \"[\" + x+\", \"+y+\"]\";\t}}class Circle extends Shape{\tdouble r; //반지름\t\tCircle(double r){\t\tthis(new Point(0,0),r);\t}\tCircle(Point p, double r){\t\tsuper(p);\t\tthis.r=r;\t}\t\tdouble calcArea() {\t\treturn Math.PI*r*r;\t}}class Rectangle extends Shape{\tdouble width, height;\t\tRectangle(double width, double height){\t\tthis(new Point(0,0),width, height);\t}\tRectangle(Point p, double width, double height){\t\tsuper(p);\t\tthis.height=height;\t\tthis.width=width;\t}\t\tdouble calcArea() {\t\treturn width *height;\t}\tboolean isSquare(){\t\tif(width == height) return true;\t\telse return false;\t}}public class ex7_22 {\tstatic double sumArea(Shape arr[]) {\t\tdouble sum=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tsum+=arr[i].calcArea();\t\t}\t\t\t\treturn sum;\t}\t\tpublic static void main(String[] args) {\t\tShape arr[] = {new Circle(5.0), new Rectangle(3,4), new Circle(1)};\t\tSystem.out.println(\"면적의 합 : \"+sumArea(arr));\t}}[7-24] 인터페이스의 장점이 아닌 것?  표준화를 가능하게 해줌  서로 관계없는 클래스들에게 관계를 맺어 줄 수 있음  독립적인 프로그래밍이 가능  다중상속을 가능하게 해줌  패키지간의 연결을 도와줌외에 개발시간 단축한다는 장점이 있음(동시에 여럿이서 개발 가능)"
  },
  
  {
    "title": "자바의 정석 연습문자 7장 - 상속 1",
    "url": "/posts/7%EC%9E%A5_%EC%83%81%EC%86%8D_1/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 상속",
    "date": "2022-10-07 00:00:00 +0900",
    





    
    "snippet": "[7-1] SutdaCard 배열을 초기화하는 문제. 숫자가 1,3,8인경우 isKwang이 true여야함.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int...",
    "content": "[7-1] SutdaCard 배열을 초기화하는 문제. 숫자가 1,3,8인경우 isKwang이 true여야함.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int i=0;i&lt;CARD_NUM;i++) {\t\t\tint num = i%10+1;\t\t\tboolean isKwang = i&lt;10&amp;&amp; (num==1 || num==3 || num==8);\t\t\t\t\t\tcards[i] = new SutdaCard(num, isKwang);\t\t}\t\t// for(int i=0;i&lt;10;i++){    //   isKwang = i==0 || i==2 || i==7;    //   cards[i] = new SutdaCard(i+1, isKwang);    //   cards[i+10] = new SutdaCard(i+1, false);    // } //이렇게해도됨\t\t//for(int i=0;i&lt;CARD_NUM;i++){    //   num = i+1;    //   isKwang = false;    //   if(i&gt;=10) num=i-9;    //   else if(i==0 || i==2 ||i==7) isKwang=true;    //   cards[i] = new SutdaCard(num, isKwang);    // } //이것도 됨\t}\t}class SutdaCard{\tint num;\tboolean isKwang;\t\tSutdaCard() {\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_1 {\tpublic static void main(String[] args) {\t\tSutdaDeck deck = new SutdaDeck();\t\t\t\tfor(int i=0;i&lt;deck.cards.length;i++) {\t\t\tSystem.out.print(deck.cards[i]+\" \");\t\t}\t}}[7-2] 클래스 SutdaDeck에 shuffle, pick메소드를 추가하는문제. pick은 매개변수가 있는것과 없는 것 둘다 만들 것.package _2javajungsuktestEx7;class SutdaDeck{\tfinal int CARD_NUM=20;\tSutdaCard cards[] = new SutdaCard[CARD_NUM];\t\tSutdaDeck() {\t\tfor(int i=0;i&lt;CARD_NUM;i++) {\t\t\tint num = i%10+1;\t\t\tboolean isKwang = i&lt;10&amp;&amp; (num==1 || num==3 || num==8);\t\t\t\t\t\tcards[i] = new SutdaCard(num, isKwang);\t\t}\t}\t\tvoid shuffle() {\t\tSutdaCard tmp;\t\tfor(int i=0;i&lt;cards.length*2;i++) {\t\t\tint n = (int)(Math.random()*CARD_NUM);\t\t\tint n2 = (int)(Math.random()*CARD_NUM);\t\t\ttmp = cards[n];\t\t\tcards[n] = cards[n2];\t\t\tcards[n2]=tmp;\t\t}\t}\tSutdaCard pick(int index){\t\treturn cards[index];\t}\tSutdaCard pick() {\t\tint n = (int)(Math.random()*CARD_NUM);\t\treturn cards[n];\t}\t}class SutdaCard{\tint num;\tboolean isKwang;\t\tSutdaCard() {\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_1 {\tpublic static void main(String[] args) {\t\tSutdaDeck deck = new SutdaDeck();\t\t\t\tSystem.out.println(deck.pick(0));\t\tSystem.out.println(deck.pick());\t\tdeck.shuffle();\t\tfor(int i=0;i&lt;deck.cards.length;i++) {\t\t\tSystem.out.print(deck.cards[i]+\" \");\t\t}\t\tSystem.out.println();\t\tSystem.out.println(deck.pick(0));\t\t\t}}처음 shuffle메소드를 만들때void shuffle() {  \tSutdaCard tmp;  \tfor(int i=0;i&lt;cards.length;i++) {  \t\tint n = (int)(Math.random()*CARD_NUM);  \t\ttmp = cards[i];  \t\tcards[i] = cards[n];  \t\tcards[n]=tmp;  }  으로 만들었는데 cards.length가 배열을 충분히 섞기에 부족하다는 생각이 들어서 int n2을 추가로 만들어줬음.List로 변환public class SutdaCard {  int num;  boolean iskwang;  public SutdaCard(){    this(1,true);  }   public SutdaCard(int num, boolean isKwang){    this.num = num;    this.iskwang = isKwang;  }   String info(){    return num+(iskwang?\"K\":\"\");  }  @Override  public String toString(){    return num+(iskwang?\"K\":\"\");  }}import java.util.ArrayList;import java.util.List;public class SutdaDeck{  final int CARD_NUM = 20;  // SutdaCard[] cards = new SutdaCard[CARD_NUM];  List&lt;SutdaCard&gt; cards = new ArrayList&lt;SutdaCard&gt;();  public SutdaDeck(){    for(int i=0;i&lt;CARD_NUM;i++){      int num = i%10+1;      boolean isKwang = (i==1 || i==3 || i==8);      cards.add(new SutdaCard(num, isKwang));    }  }  SutdaCard pick(int index){    return cards.get(index);  }  SutdaCard pick(){    int r = (int)(Math.random()*CARD_NUM);        return cards.get(r);  }  void shuffle(){    List&lt;SutdaCard&gt; temp = new ArrayList&lt;SutdaCard&gt;();    while(cards.size()!=0){        int r = (int)(Math.random()*cards.size());        temp.add(cards.remove(r)); //temp에 저장 후 cards에서 삭제    }    cards = temp;  }}public class SutdaCardMain {  public static void main(String[] args) {    // SutdaCard card1 = new SutdaCard(3, false);    // SutdaCard card2 = new SutdaCard();    // System.out.println(card1.info());    // System.out.println(card2.info());    SutdaDeck deck = new SutdaDeck();        for(int i=0;i&lt;deck.cards.size();i++){      System.out.print(deck.cards.get(i)+\", \");    }    System.out.println();    System.out.println(deck.pick());    System.out.println(deck.pick(3));        deck.shuffle();    for(int i=0;i&lt;deck.cards.size();i++){      System.out.print(deck.cards.get(i)+\", \");    }  }}[7-3] 오버라이딩의 정의와 필요성 :조상클래스에게 상속받은 메소드를 수정할 수 있음. 자손클래스에서 그대로 사용할 수 없는 경우가 많아서 오버리이딩이 필요함.[7-4] 오버라이딩의 조건으로 옳지않은 것을 모두 고르시오  조상의 메소드와 이름이 같아야한다.  매개변수의 수와 타입이 모두 값아야한다.  리턴타입이 같아야한다.  접근 제어자는 조상의 메소드보다 좁은 범위로만 변경할 수 있다. - 조상 클래스의 메소드보다 좁은범위로 변경 불가  조상의 메소드보다 더 많은 예외를 선언할 수 있다. - 조상 클래스의 메소드보다 더 많은 예외 선언 불가오버로딩 : 이미 있는 이름의 메소드를 매개변수의 갯수나 타입을 다르게해서 새로 정의하는 것. 오버라이딩이랑은 관련 없음!!![7-5] 코드에서 오류가 나는 부분을 고치고 오류의 이유를 서술하시오package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}}class Tv extends Product{\tTv(){} //에러\tpublic String toStirng() {\t\treturn \"Tv\";\t}\t}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}class Tv extends Product{Tv(){}Tv(){}부분에서 오류가 난다 안에 super(매개변수); 를 넣어주면 해결된다.Product 클래스 안에 기본생성자가 없어서 발생하는 오류인데, Product클래스안에 기본생성자를 추가해주면 super()를 사용해주지않아도 된다.package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}\tProduct(){\t\tthis(100);\t}}class Tv extends Product{\tTv(){}\tpublic String toStirng() {\t\treturn \"Tv\";\t}}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}package _2javajungsuktestEx7;class Product{\tint price;\tint bonusPoint;\t\tProduct(int price){\t\tthis.price=price;\t\tbonusPoint = (int)(price/10.0);\t}}class Tv extends Product{\tTv(){\t\tsuper(100);\t\t}\tpublic String toStirng() {\t\treturn \"Tv\";\t}\t}public class ex7_5 {\tpublic static void main(String[] args) {\t\tTv tv = new Tv();\t\tSystem.out.println(tv.price);\t\tSystem.out.println(tv.bonusPoint);\t}}이런 식이다.[7-6] 자손 클래스의 생성자에서 조상 클래스의 생성자를 호출해야하는 이유는?조상 클래스에 정의된 인스턴스 변수들을 초기화해주어야함.직접 초기화해도 되지만 조상의 생성자를 호출하는 것이 더 효율적임.[7-7] 호출되는 생성자의 순서와 실행결과를 적으시오package _2javajungsuktestEx7;class Parent{\tint x=100;\t\tParent(){\t\tthis(200);\t}\tParent(int x){\t\tthis.x=x;\t}\tint getx() {\t\treturn x;\t}}class Child extends Parent{\tint x=3000;\tChild(){\t\tthis(1000);\t}\tChild(int x){\t\tthis.x=x;\t}}public class ex7_7 {\tpublic static void main(String[] args) {\t\tChild c = new Child();\t\t\t\tSystem.out.println(c.getx());\t}}main → child() → child(int x) → parent() → parent(int x) → Object()child(int x)와 Parent(int x)에는 생략되어있지만 super()이 존재함.x값은 200. child에 getx()가 없기때문에 Parent 클래스 내에서 구해야하는데 매개변수가 없으니 Parent()의 x값인 200이 나옴[7-8] 접근범위가 넚은 것에서 좁은 순으로 나열하시오public → protected → (default) → private[7-9] 다음 중 제어자 final을 붙일 수 있는 대상과 붙였을 때 그 의미를 적은 것 중 옳지 않은 것은?  지역변수 - 값 변경 불가능  클래스 - 상속을 통해 클래스에 새로운 멤버를 추가할 수 없음  메소드 - 오버로딩을 할 수 없음 - 오버라이딩을 할 수 없음  멤버변수 - 값 변경 불가[7-10] isPowerOn, channel, volume을 클래스 외부에서 접근 못하도록 제어자를 붙이고 이 멤버변수들의 값을 어디서나 읽고 변경할 수 있는 getter와 setter메소드를 추가하라package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}void setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t\t\tt.setVolume(20);\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t}}❗매개변수가 있는 메소드는 반드시 유효성검사를 해줘야함!![7-11] 이전채널로 이동하는 메소드를 추가package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\tprivate int prev;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tprev = this.channel;\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}\tvoid setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\tvoid gotoPrevChannel(){\t\tint tmp;\t\ttmp = channel;\t\tchannel = prev;\t\tprev = tmp;\t}\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t//\t\tt.setVolume(20);//\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t\t\t\tt.setChannel(20);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t}}int prev를 만들어준 뒤 getChannel에서 channel을 바꾸기 전에 prev에 저장해준 후gotoPrevChannel에서 channel과 prev의 값을 바꿔주게 만들었다.  답지package _2javajungsuktestEx7;class MyTv2{\tprivate boolean isPowerOn;\tprivate int channel;\tprivate int volume;\tprivate int prev;\t\tfinal int MAX_VOLUME=100;\tfinal int MIN_VOLUME=0;\tfinal int MAX_CHANNEL=100;\tfinal int MIN_CHANNEL=1;\t\tint getChannel(){\t\treturn channel;\t}\tint getVolume(){\t\treturn channel;\t}\tvoid setChannel(int channel) {\t\tprev = this.channel;\t\tif(channel &gt; MAX_CHANNEL || channel &lt; MIN_CHANNEL ) return;\t\tthis.channel=channel;\t}\tvoid setVolume(int volume) {\t\tif(volume &gt; MAX_VOLUME || volume &lt; MIN_VOLUME ) return;\t\tthis.volume=volume;\t}\tvoid gotoPrevChannel(){\t\tsetChannel(prev);\t}\t\t}public class ex7_10 {\tpublic static void main(String[] args) {\t\tMyTv2 t = new MyTv2();\t\t\t\tt.setChannel(10);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\t//\t\tt.setVolume(20);//\t\tSystem.out.println(\"VOL : \"+t.getVolume());\t\t\t\tt.setChannel(20);\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t\tt.gotoPrevChannel();\t\tSystem.out.println(\"CH : \"+t.getChannel());\t}}왜 있는 메소드를 활용할 생각을 못했을까ㅜ[7-12] 다음 중 접근제어자에 대한 설명으로 옳지 않은 것을 모두 고르시오  public은 접근 제한이 전혀 없는 접근 제어자이다  (default)가 붙으면, 같은 패키지 내에서만 접근 가능함  지역변수에도 접근 제어자를 사용할 수 있음  protected가 붙으면, 같은 패키지 내에서 접근 가능  protected가 붙으면, 다른 패키지의 자손 클래스에서 접근 가능[7-13] Math클래스의 생성자의 접근 제어자가 private인 이유?Math클래스의 모든 메소드가 static메소드이고 인스턴스 변수가 존재하지 않기 떄문에 객체를 생성할 필요가 없음.[7-14] 섯다 카드의 숫자와 종류를 변경할 수 없도록 코드를 수정하는 문제package _2javajungsuktestEx7;class SutdaCard{\t//인스턴스 변수라서 생성자에서 초기화해줘도 됨\tfinal int num;\tfinal boolean isKwang;\t\tSutdaCard(){\t\tthis(1,true);\t}\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tpublic String toString() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex7_14 {\tpublic static void main(String[] args) {\t\tSutdaCard card = new SutdaCard();\t\tSystem.out.println(card.toString());\t}}[7-15] 형변환이 올바르지 않은 것은?class Unit() {}class AirUnit() extends Unit{}class GroundUnit() extends Unit{}class Tank extends GroundUnit{}class AirCraft extends AirUnit() {}Unit u = new GroundUnit();Tank t = new Tank();AirCraft ac = new AirCraft();  u = (Unit)ac;  u = ac;  GrountUnit gu = (GroundUnit)u;  u가 생성될때 GroundUnit을 참고하도록 설정해놨음 가능  AirUnit au = ac;  t = (Tank)u; 조상타입 인스턴스 → 자손타입 불가능  GroundUnit gu = t;[7-16] 다음 중 연산결과가 true가 아닌 것을 모두 골라라class Car{}class FireEngine extends Car implements Movable{}class Ambulance extends Car{}FireEngine fe = new FIreEngine();  fe instanceof FireEngine  fe instanceof Movable  fe instanceof Obeject  fe instanceof Car  fe instanceof Ambulanceinstanceof : 조상이나 구현한 인터페이스관계일경우 true를 반환함."
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 3",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_3/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-06 00:00:00 +0900",
    





    
    "snippet": "[6-20] 메소드 shuffle을 정의해 배열을 섞기package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_20 {\tstatic int[] shuffle(int arr[]) {\t\tif(arr==null || arr.length==0) return arr;\t\tint tmp=0;\t\tf...",
    "content": "[6-20] 메소드 shuffle을 정의해 배열을 섞기package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_20 {\tstatic int[] shuffle(int arr[]) {\t\tif(arr==null || arr.length==0) return arr;\t\tint tmp=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tint x = (int)(Math.random()*arr.length);\t\t\ttmp=arr[i];\t\t\tarr[i] = arr[x];\t\t\tarr[x] = tmp;\t\t}\t\treturn arr;\t}\t\tpublic static void main(String[] args) {\t\tint original[]= {1,2,3,4,5,6,7,8,9};\t\tSystem.out.println(Arrays.toString(original));\t\t\t\tint result[] = shuffle(original);\t\tSystem.out.println(Arrays.toString(result));\t}}배열을 몇번 섞을지 애매해서 일단 배열값만큼 섞어주었다. 더 크게 지정하면 또 Math.random으로 새 변수를 지정해줘야하기도해서..[6-21] MyTv클래스 완성하기package _2javajungsuktestEx6;class MyTv{\tboolean isPowerOn;\tint channel;\tint volume;\t\tfinal int MAX_VOLUME = 100;\tfinal int MIN_VOLUME = 0;\tfinal int MAX_CHANNEL = 100;\tfinal int MIN_CHANNEL = 1;\t\tvoid turnOnOff() {\t\tisPowerOn = !isPowerOn;\t}\tvoid volumeUp() {\t\tif(volume &lt; MAX_VOLUME) \t\tvolume++;\t}\tvoid volumeDown() {\t\tif(volume &gt; MIN_VOLUME) \t\tvolume--;\t}\tvoid channelUp() {\t\tif(channel == MAX_CHANNEL) \t\t\tchannel = MIN_CHANNEL;\t\telse channel++;\t}\tvoid channelDown() {\t\tif(channel == MIN_CHANNEL) { \t\t\tchannel = MAX_CHANNEL;\t\t} else {\t\t\tchannel--;\t\t}\t}}public class ex6_21 {\tpublic static void main(String[] args) {\t\tMyTv t = new MyTv();\t\t\t\tt.channel=100;\t\tt.volume=0;\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t\t\t\tt.channelDown();\t\tt.volumeDown();\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t\t\t\tt.volume=100;\t\tt.channelUp();\t\tt.volumeUp();\t\tSystem.out.println(\"CH : \"+t.channel);\t\tSystem.out.println(\"VOL : \"+t.volume);\t}}[6-22] 문자열 str이 숫자로만 이루어졌는지 확인하는 메소드를 작성하는 문제package _2javajungsuktestEx6;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex6_22 {\t\tstatic boolean isNumber(String str) {\t\tif(str.equals(\"\") || str == null) return false;\t\tfor(int i=0;i&lt;str.length();i++) {\t\t\tchar ch = str.charAt(i);\t\t\tif(!(ch&gt;='0' &amp;&amp; ch&lt;= '9')) return false;\t\t}\t\treturn true;\t}\tpublic static void main(String[] args) throws IOException {//\t\tString str = \"123\";//\t\tSystem.out.println(str +\"는 숫자입니까?\" + isNumber(str));////\t\tString str2 = \"123o\";//\t\tSystem.out.println(str2 +\"는 숫자입니까?\" + isNumber(str2));\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString str = br.readLine();\t\tSystem.out.println(str +\"는 숫자입니까?\" + isNumber(str));\t\t\t}}[6-23] 배열에서 가장 큰 값을 구하는 메소드를 작성package _2javajungsuktestEx6;import java.util.Arrays;public class ex6_23 {\t\tstatic int max(int arr[]) {\t\tif(arr == null || arr.length==0) return -999999;\t\t\t\tint max=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tif(arr[i]&gt;=max) {\t\t\t\tmax=arr[i];\t\t\t}\t\t}\t\treturn max;\t}\tpublic static void main(String[] args) {\t\tint data[] = {3,2,9,4,7};\t\t\t\tSystem.out.println(Arrays.toString(data));\t\tSystem.out.println(\"최대값 : \"+max(data));\t\tSystem.out.println(\"최대값 : \"+max(null));\t\tSystem.out.println(\"최대값 : \"+max(new int[] {})); //크기가 0인 배열\t}}[6-24] 절대값을 구하는 메소드를 정의package _2javajungsuktestEx6;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex6_24 {\t\tstatic int abs(int value) {\t\treturn Math.abs(value);\t}\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\twhile(true) {\t\t\tSystem.out.println(\"절대값을 구할 수를 입력하세요. 종료하려면 0를 입력하세요. \");\t\t\tint value = Integer.parseInt(br.readLine());\t\t\tif(value == 0) {\t\t\t\tSystem.out.println(\"프로그램을 종료합니다.\");\t\t\t\tbreak;\t\t\t}\t\tSystem.out.println(value +\"의 절대값 : \"+abs(value));\t\t\t\t}\t}}간단하게 계속 반복하도록 만들어봤음 0을 입력하면 종료되게했음"
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 2",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_2/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-06 00:00:00 +0900",
    





    
    "snippet": "[6-8] 다음 코드에 정의된 변수들을 종류별로 구분해서 적기class PlayingCard{\tint kind;\tint num;\tstatic int width;\tstatic int height;\tPlayingCard(int k, int n){\t\tkind = k;\t\tnum = n;\t}\tpublic static void main(String[] args)...",
    "content": "[6-8] 다음 코드에 정의된 변수들을 종류별로 구분해서 적기class PlayingCard{\tint kind;\tint num;\tstatic int width;\tstatic int height;\tPlayingCard(int k, int n){\t\tkind = k;\t\tnum = n;\t}\tpublic static void main(String[] args){\t\tPlayingCard card= new PlayingCard(1,1);}  클래스변수 (static변수) : width, height  인스턴스변수 : kind, num  지역변수: k, n, card[6-9] static이 붙어야하는 것과 그 이유는?(모든 병사의 공격력과 방어력은 같아야함)class Marine{\tint x=0, y=0; //위치\tint hp = 60; //체력\tint weapon = 6; //공격력\tint armor = 0; //방어력\tvoid weaponUp(){\t\tweapon++;\t}\tvoid armorUp(){\t\tweapon++;\t}\tvoid move(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}}weapon과 armor. 메소드 weaponUP()과 armorUp()도 static이 붙어야함인스턴스 변수는 객체 생성해서 값을 수정하면 원본 값은 변하지 않음. 모든 병사의 공격력이 같아야하는데 공격력과 방어력이 인스턴스변수라면 각 병사마다 다른 공격력과 방어력을 가지는 일이 발생할 수도 있음.그래서 모든 병사의 공격력과 방어력을 관리하기위해서는 static변수로 관리해줘야함.체력은 각 병사마다 공격받은정도가 다르니까, 위치는 당연히 병사별로 달라야함. → 인스턴스변수 사용[6-10] 다음 중 생성자에 대한 설명으로 옳지 않은 것을 모두 고르시오  모든 생성자의 이름은 클래스의 이름과 동일해야한다  생성자는 객체를 생성하기 위한 것이다 - 객체 초기화 목적임. 객체를 생성하는 건 new 연산자임  클래스에는 생성자가 반드시 하나 이상 있어야 한다  생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다  생성자는 오버로딩 할 수 없다 - 가능함.[6-11] 다음 중this에 대한 설명으로 맞지 않은 것을 모두 고르시오  객체 자신을 가리키는 참조변수이다  클래스 내에서라면 어디서든 사용할 수 있다 - static이 붙은 변수나 메소드(클래스 멤버)에서는 사용 불가  지역변수와 인스턴스변수를 구별할 때 사용한다  클래스 메서드 내에서는 사용할 수 없다[6-12] 다음 중 오버로딩이 성립하기 위한 조건이 아닌 것을 모두 고르시오  메서드의 이름이 같아야 한다  매개변수의 개수나 타입이 달라야 한다  리턴타입이 달라야 한다 - 상관 없음  매개변수의 이름이 달라야 한다 - 상관없음[6-13] add 메소드를 올바르게 오버로딩한것은?                               long add(int a, int b) {return a+b;}        long add(int x, int y} {return x+y}  long add(long a, long b) {return a+b;} - 이름 같고, 매개변수의 타입이 달라 가능  int add(byte a, byte b) {return a+b;} - 이름 같고, 매개변수의 타입이 달라 가능  int add(long a, int b) {return (int)a+b;} - 이름 같고, 매개변수의 타입이 달라 가능[6-14] 다음 중 초기화에 대한 설명으로 옳지 않은 것을 모두 고르시오  멤버 변수는 자동 초기화되므로 초기화하지 않고도 값을 참조할 수 있다  지역변수는 사용하기 전에 반드시 초기화해야 한다  초기화 블럭보다 생성자가 먼저 수행된다 - 초기화 블럭이 먼저 수행됨  명시적 초기화를 제일 우선적으로 고려해야 한다  클래스변수보다 인스턴스변수가 먼저 초기화된다 - 클래스 변수가 먼저 초기화됨클래스 변수는 클래스가 처음 메모리에 로딩될 때, 자동 초기화 됨. → 인스턴스변수보다 먼저 초기화 됨. 그리고 초기화 블럭이 수행된 다음 생성자가 수행됨.==[6-15] 다음중 인스턴스변수의 초기화 순서가 올바른 것은?  기본값 - 명시적초기화 - 초기화블럭 - 생성자  기본값 - 명시적초기화 - 생성자 - 초기화블럭  기본값 - 초기화블럭 - 명시적초기화 - 생성자  기본값 - 초기화블럭 - 생성자 - 명시적초기화클래스 변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화가 이루어진다.클래스 변수의 초기화 순서 : 기본값 → 명시적 초기화 → 클래스 초기화 블럭인스턴스 변수의 초기화 순서 : 시본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자[6-16] 다음 중 지역변수에 대한 설명으로 옳지 않은 것을 모두 고르시오  자동 초기화되므로 별도의 초기화가 필요없다 - 자동초기화 안됨. 초기화 필수  지역변수가 선언된 메서드가 종료되면 지역변수도 함께 소멸된다  매서드의 매개변수로 선언된 변수도 지역변수이다  클래스변수나 인스턴스변수보다 메모리 부담이 적다  힙(heap) 영역에 생성되며 가비지 컬렉터에 의해 소멸된다 - 힙(heap)은 인스턴스가 생성되는 영역. 지역변수는 호출스택(call stack)에서 생성됨.[6-17] 호출스택이 다음과 같은 상황일 때 옳지 않은 설명을 모두 고르시오                                              println              method1              method2              main        제일 먼저 호출스택에 저장된 것은 main 메서드이다  println메서드를 제외한 나머지 메서드들은 모두 종료된 상태이다 - 종료된건 아니고 대기중인 상태  method2메서드를 호출한 것은 main메서드이다  println메서드가 종료되면 method1메서드가 수행을 재개한다  main-method2-method1-println의 순서로 호출되었다  현재 실행중인 메소드는 println뿐이다.[6-18] 컴파일 에러가 발생하는 라인과 이유를 설명class MemberCall{\tint iv=10;\tstatic int cv = 20;\t\tint iv2=cv;\tstatic int cv2= iv;    //라인 A\tstatic void staticMethod1(){\t\tSystem.out.println(cv);\t\tSystem.out.println(iv); //라인 b\t}\tvoid instanceMethod1(){\t\tSystem.out.println(cv);\t\tSystem.out.println(iv); //라인 c\t}\tstatic void staticMethod2(){\t\tstaticMethod1():\t\tinstanceMethod1(); //라인 d\t}\tvoid instanceMethod2(){\t\tstaticMethod1(); //라인 e\t\tinstanceMethod1();\t}}라인 a,b,d 오류.static변수 초기화시에 instance변수를 사용할 수 없으며, static메소드 안에서는 instance변수를 사용할 수 없음.instance메소드 안에서는 static변수를 사용 가능함.[6-19] 실행결과 예상하기class ex{\tpublic static void change(String str){\t\tstr+=\"456\";\t}\tpublic static void main(String[] args){\t\tString str = \"ABC123\";\t\tchange(str);\t\tSystem.out.println(\"After change : \"+str);\t}}결과 : ABC123오른쪽 그림 참고. 참조형 매개변수라서 x값도 같이 변경될 것 같지만 String객체는 수정이 불가능함.그래서 change에서 str+=”456”을 하려면 새로운 String객체를 하나 더 생성해야 함. 생성된 change()의 str객체는 change()가 종료될 때 함께 종료됨. 최종적으로 남은 str은 main메소드의 ABC123뿐이라서 출력은 ABC123이됨. change메소드에서 생성된 String객체 “ABC123456”은 나중에 가비지컬렉터가 제거해줌"
  },
  
  {
    "title": "자바의 정석 연습문제 6장 - 객체 1",
    "url": "/posts/6%EC%9E%A5_%EA%B0%9D%EC%B2%B4_1/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 객체",
    "date": "2022-10-05 00:00:00 +0900",
    





    
    "snippet": "[6-1~6-2] SutdaCard클래스를 정의하고 두개의 생성자와 info()를 추가package _2javajungsuktestEx6;class SutdaCard{\tint num=3 ;\tboolean isKwang=true;\t\tSutdaCard(){\t\tthis(1,true);\t}\t\tSutdaCard(int num, boolean isKwang){\t...",
    "content": "[6-1~6-2] SutdaCard클래스를 정의하고 두개의 생성자와 info()를 추가package _2javajungsuktestEx6;class SutdaCard{\tint num=3 ;\tboolean isKwang=true;\t\tSutdaCard(){\t\tthis(1,true);\t}\t\tSutdaCard(int num, boolean isKwang){\t\tthis.num=num;\t\tthis.isKwang=isKwang;\t}\tString info() {\t\treturn num+(isKwang?\"K\":\"\");\t}}public class ex6_1 {\t\tpublic static void main(String[] args) {\t\tSutdaCard card1 = new SutdaCard(3,false);\t\tSutdaCard card2 = new SutdaCard();\t\t\t\tSystem.out.println(card1.info());\t\tSystem.out.println(card2.info());\t}}[6-3~6-4] Student클래스를 정의해서 안에 메소드 getTotal()과 getAverage()를 추가해서 총점과 평균을 구하는 문제package _2javajungsuktestEx6;class Student{\tString name;\tint ban;\tint no;\tint kor;\tint eng;\tint math;\t\tint getTotal(){\t\treturn kor+eng+math;\t}\tfloat getAverage() {\t\treturn Math.round(getTotal()*10/ 3f)/10f;\t}}public class ex6_3 {\tpublic static void main(String[] args) {\t\tStudent s = new Student();\t\ts.name = \"홍길동\";\t\ts.ban=1;\t\ts.no=1;\t\ts.kor=100;\t\ts.eng=60;\t\ts.math=76;\t\t\t\tSystem.out.println(\"이름 : \"+s.name);\t\tSystem.out.println(\"총점 : \"+s.getTotal());\t\tSystem.out.println(\"평균 : \"+s.getAverage());\t}}[6-5] 6-3~6-4에 생성자와 info추가package _2javajungsuktestEx6;class Student{\tString name;\tint ban;\tint no;\tint kor;\tint eng;\tint math;\t\tint getTotal(){\t\treturn kor+eng+math;\t}\tfloat getAverage() {\t\treturn Math.round(getTotal()*10/ 3f)/10f;\t}\tStudent(){\t\t\t}\tStudent(String name, int ban, int no, int kor, int eng, int math){\t\tthis.name=name;\t\tthis.ban=ban;\t\tthis.no=no;\t\tthis.kor = kor;\t\tthis.eng=eng;\t\tthis.math=math;\t}\tvoid info(){\t\tSystem.out.println(name+\", \"+ban+\", \"+no+\", \"+kor+\", \"+eng+\", \"+math);\t}}public class ex6_3 {\tpublic static void main(String[] args) {\t\tStudent s = new Student();\t\ts.name = \"홍길동\";\t\ts.ban=1;\t\ts.no=1;\t\ts.kor=100;\t\ts.eng=60;\t\ts.math=76;\t\t\t\tSystem.out.println(\"이름 : \"+s.name);\t\tSystem.out.println(\"총점 : \"+s.getTotal());\t\tSystem.out.println(\"평균 : \"+s.getAverage());\t\tSystem.out.println();\t\tStudent s2 = new Student(\"김길동\",1,1,95,80,63);\t\ts2.info();\t\tSystem.out.println(\"이름 : \"+s2.name);\t\tSystem.out.println(\"총점 : \"+s2.getTotal());\t\tSystem.out.println(\"평균 : \"+s2.getAverage());\t\t\t}}[6-6] 메소드 getDisrance()로 두 점 사이 거리 계산package _2javajungsuktestEx6;public class ex6_6 {\tstatic double getDistance(int x, int y, int x1, int y1) {\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}\t\tpublic static void main(String[] args) {\t\tSystem.out.println(getDistance(1,1,2,2));\t}}[6-7] MyPoint 클래스에 getDistance()를 인스턴스 메소드로 정의package _2javajungsuktestEx6;class MyPoint{\tint x;\tint y;\t\tMyPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y;\t}\tdouble getDistance(int x1, int y1){\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}}public class ex6_6 {\tstatic double getDistance(int x, int y, int x1, int y1) {\t\treturn Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));\t}\t\tpublic static void main(String[] args) {\t\tSystem.out.println(getDistance(1,1,2,2));\t\t\t\tMyPoint p = new MyPoint(1,1);\t\tSystem.out.println(p.getDistance(2, 2));\t}}"
  },
  
  {
    "title": "자바의 정석 연습문제 5장 - 배열",
    "url": "/posts/5%EC%9E%A5_%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 배열",
    "date": "2022-10-03 00:00:00 +0900",
    





    
    "snippet": "[5-1] 잘못된것을 고르시오a. int[] arr[];b. int[] arr = {1,2,3,};c. int[] arr = new int[5];d. int[] arr = new int[5]{1,2,3,4,5}; - new int[5]나 {1,2,3,4,5} 둘중 하나를 지워야 함.e. int arr[5]; 선언하면서 크기지정 불가f. int[] ar...",
    "content": "[5-1] 잘못된것을 고르시오a. int[] arr[];b. int[] arr = {1,2,3,};c. int[] arr = new int[5];d. int[] arr = new int[5]{1,2,3,4,5}; - new int[5]나 {1,2,3,4,5} 둘중 하나를 지워야 함.e. int arr[5]; 선언하면서 크기지정 불가f. int[] arr[] = new int[3][];[5-2] arr[3].length의 값은?int [][] arr = {\t\t\t\t\t\t{5,5,5,5,5},\t\t\t\t\t\t{10,10,10},\t\t\t\t\t\t{20,20,20,20},\t\t\t\t\t\t{30,30}};arr[3]은 {30,30}를 뜻함. arr[3]은 값이 2개니까 length는 2.순서대로 5,3,4,2순임[5-3] 배열 arr에 담긴 모든 값의 합을 구하는 문제package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class ex5_3 {\tpublic static void main(String[] args) throws IOException {//\t\tint arr[] = {10,20,30,40,50};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint n= Integer.parseInt(br.readLine());\t\tint arr[] = new int[n];\t\tfor(int i=0;i&lt;n;i++) {\t\t\tarr[i]=Integer.parseInt(br.readLine());\t\t}\t\tint sum = 0;\t\t\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tsum+=arr[i];\t\t}\t\t\t\tSystem.out.println(\"sum = \"+sum);\t}}int arr[]을 입력값 n을 받아 크기를 결정하고, arr[]의 크기만큼 값을 입력받아 배열 arr[]을 만드는 방식으로 수정해서 풀어보았음[5-4] 2차원 배열 arr의 모든 값의 합과 평균package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_4 {\tpublic static void main(String[] args) throws IOException {//\t\tint arr[][] = {//\t\t\t\t{5,5,5,5,5},//\t\t\t\t{10,10,10,10,10},//\t\t\t\t{20,20,20,20,20},//\t\t\t\t{30,30,30,30,30}//\t\t\t\t};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint n= Integer.parseInt(br.readLine());\t\tint n2 = Integer.parseInt(br.readLine());\t\tint arr[][] = new int[n][n2];\t\tfor(int i=0;i&lt;n;i++) {\t\t\tfor(int j=0;j&lt;n2;j++) {\t\t\t\tarr[i][j]+=Integer.parseInt(br.readLine());\t\t\t}\t\t}\t\tint total = 0;\t\tfloat average=0;\t\t\t\tint count=0;\t\tfor(int i=0;i&lt;arr.length;i++) {\t\t\tfor(int j=0;j&lt;arr[i].length;j++) {\t\t\t\ttotal += arr[i][j];\t\t\t\tcount++;\t\t\t\t}\t\t\taverage = (float)total / count;\t\t}\t\tSystem.out.println(\"total = \"+total);\t\tSystem.out.println(\"average = \"+average);\t}}average를 구할때 나눌 수를 구하기가 애매해서 count를 새로 지정해줬음답지보니까 arr.length * arr[0].length를 해줬구나.. arr[i]를 넣었다가 그럼 for문 안에 넣어야해서 count를 만든건데 0을하면 되는구나!이후에 BufferedReader를 사용해서 arr값도 새로 입력값을 받아서 계산도 해봤음[5-5] 중복되지 않는 3가지 숫자 뽑아내는 문제package _2javajungsuktestEx5;import java.util.Arrays;public class ex5_5 {\tpublic static void main(String[] args) {\t\tint ballArr[] = {1,2,3,4,5,6,7,8,9};\t\tint ball3[] = new int[3];\t\t\t\tfor(int x=0;x&lt;20;x++) {\t\t\tint i=(int)(Math.random()*ballArr.length);\t\t\tint j=(int)(Math.random()*ballArr.length);\t\t\tint tmp=0;\t\t\t\t\t\ttmp=ballArr[i];\t\t\tballArr[i]=ballArr[j];\t\t\tballArr[j]=tmp;\t\t}\t\t\t\tSystem.arraycopy(ballArr,0,ball3,0,3);\t\tfor(int i=0;i&lt;ball3.length;i++) {\t\t\tSystem.out.print(ball3[i]);\t\t}\t}}[5-6] 필요한 동전 수를 구하는 문제package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_6 {\tpublic static void main(String[] args) throws IOException {\t\tint coinUnit[]= {500,100,50,10};//\t\tint money=2680;\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint money = Integer.parseInt(br.readLine());\t\tSystem.out.println(\"money = \"+money);\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint count = money/coinUnit[i];\t\t\tmoney %= coinUnit[i];\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+count);\t\t\t\t\t}\t}}/와 %를 이용하여 구했음[5-7] 필요한 동전의 수와 남은 동전의 수를 구하는 문제. 돈이 부족하다면 부족하다고 출력됨package _2javajungsuktestEx5;public class ex5_7 {\tpublic static void main(String[] args) {\t\tif(args.length!=1) {\t\t\tSystem.out.println(\"USAGE : java Exercise5_7 3120\");\t\t\tSystem.exit(0);\t\t}\t\tint money = Integer.parseInt(args[0]);\t\tSystem.out.println(\"money = \"+money);\t\t\t\tint coinUnit[] = {500,100,50,10};\t\tint coin[] = {5,5,5,5};\t\t\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint coinNum = 0;\t\t\tcoinNum = money/coinUnit[i];\t\t\tmoney %= coinUnit[i];\t\t\tif(coinNum&gt;coin[i]) {\t\t\t\tmoney+= (coinNum-coin[i])*coinUnit[i];\t\t\t\tcoinNum = coin[i];\t\t\t}\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coinNum);\t\t\tcoin[i]-=coinNum;\t\t}\t\tif(money&gt;0) {\t\t\tSystem.out.println(\"거스름돈이 부족합니다.\");\t\t\tSystem.exit(0);\t\t}\t\tSystem.out.println(\"=====남은 동전 개수=====\");\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coin[i]);\t\t}\t}}5-6과 비슷하게 했는데 만약 필요한 코인수가 소유 코인수보다 많다면 if문을 사용해서 money를 부족한 코인수만큼 채워주고 coinNum을 coin[i]로 맞춰주었음  답지package _2javajungsuktestEx5;public class ex5_7 {\tpublic static void main(String[] args) {\t\tif(args.length!=1) {\t\t\tSystem.out.println(\"USAGE : java Exercise5_7 3120\");\t\t\tSystem.exit(0);\t\t}\t\tint money = Integer.parseInt(args[0]);\t\tSystem.out.println(\"money = \"+money);\t\t\t\tint coinUnit[] = {500,100,50,10};\t\tint coin[] = {5,5,5,5};\t\t\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tint coinNum =0;\t\t\tcoinNum = money/coinUnit[i];\t\t\tif(coin[i]&gt;=coinNum) {\t\t\t\tcoin[i]-=coinNum;\t\t\t}else {\t\t\t\tcoinNum = coin[i];\t\t\t\tcoin[i]=0;\t\t\t}\t\t\tmoney -= coinNum*coinNum;\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coinNum);\t\t}\t\tif(money&gt;0) {\t\t\tSystem.out.println(\"거스름돈이 부족합니다.\");\t\t\tSystem.exit(0);\t\t}\t\tSystem.out.println(\"=====남은 동전 개수=====\");\t\tfor(int i=0;i&lt;coinUnit.length;i++) {\t\t\tSystem.out.println(coinUnit[i]+\"원 : \"+coin[i]);\t\t}\t}}난 money를 먼저 구한 후에 돈이 부족하면 모자란 돈만큼 money를 수정해주고 coinNum을 보유동전수만큼 맞춰주었는데 답지의 코드는 coinNum을 먼저 맞춰주고 money를 구해줬구나이게 더 효율적이기는 한듯[5-8] 배열 answer에서 각 숫자의 개수를 세어 개수만큼 * 을 출력package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_8 {\tpublic static void main(String[] args) throws IOException {//\t\tint answer[] = {1,4,4,3,1,4,4,2,1,3,2};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint answer[] = new int[11];\t\tString str[] = br.readLine().split(\" \");\t\tfor(int i=0;i&lt;str.length;i++) {\t\t\tanswer[i] = Integer.parseInt(str[i]);\t\t}\t\tint counter[] = new int[4];\t\t\t\tfor(int i=0;i&lt;answer.length;i++) {\t\t\tint arr[] = {1,2,3,4};\t\t\tfor(int j=0;j&lt;arr.length;j++) {\t\t\t\tif(answer[i]==arr[j])\t\t\t\t\tcounter[arr[j]-1]+=1;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;counter.length;i++) {\t\t\tSystem.out.print(counter[i]);\t\t\tfor(int j=0;j&lt;counter[i];j++) {\t\t\t\tSystem.out.print(\"*\");\t\t\t}\t\t\t\t\t\tSystem.out.println();\t\t}\t}}생각해보니까 BufferedReader로 String형 배열을 입력받는 법은 알고 String을 int로 변환하는 법도 아는데 int형 배열을 입력받는법을 몰라서 한번 써봤음String형 배열을 먼저 받은 다음에 for문을 써서 int형 배열에 넣는 방법밖에 없는거같다.  답지package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_8 {\tpublic static void main(String[] args) throws IOException {//\t\tint answer[] = {1,4,4,3,1,4,4,2,1,3,2};\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint answer[] = new int[11];\t\tString str[] = br.readLine().split(\" \");\t\tfor(int i=0;i&lt;str.length;i++) {\t\t\tanswer[i] = Integer.parseInt(str[i]);\t\t}\t\tint counter[] = new int[4];\t\t\t\tfor(int i=0;i&lt;answer.length;i++) {\t\t\tcounter[answer[i]-1]++;\t\t}\t\tfor(int i=0;i&lt;counter.length;i++) {\t\t\tSystem.out.print(counter[i]);\t\t\tfor(int j=0;j&lt;counter[i];j++) {\t\t\t\tSystem.out.print(\"*\");\t\t\t}\t\t\t\t\t\tSystem.out.println();\t\t}\t}}counter[answer[i]-1] 를 생각못해서 배열하나 더 만들었네..[5-9] 배열을 시계방향으로 90도 회전원본 배열이**  **  ***** ***** 인데 이걸****  ****  **  **  ** 이렇게 바꾸면됨  자리값으로 찍어보면00 0110 1120 21 22 23 2430 31 32 33 34 이걸30 20 10 0031 21 11 0132 2233 2334 24 이렇게 다.표현은 안해줬지만 공백값도 있어서 02 03 04도 다 있는 상태임.00→30, 01→20, 02→10, 03→0010→31, 11→21 .. 뭐 이런식. star의 x값과 result의 y값이 같은 상태라 x값만 구하면됨  1차시도(실패)package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tresult[j][i]=star[star.length-1][i];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}뭔가 잘못됐다.result[5][4]고 star[4][5]니까.. 아 star에 y값을 j로 해야하는구나 j가 범위를 5까지 잡아놨으니까star에 x값은 어떻게 하지? 지금 문제에 적힌 코드대로 하다보니까 x를 값을 먼저 바꿔가면서 구한다음에 y값을 바꾸면서 구하는게 돼버려서 좀 햇갈린다;;그니까 지금 x값이0→3 0→2 0→1 0→01→3 1→2 1→1 1→0+3 +2 +1 0+2 +1 0 -1이꼴인데.. 지금 y값이 고정인채로 x값이 바뀌는 상태니까0→3 1→3 2→3 3→30→2 1→2 2→2 3→20→1 1→1 2→1 3→1 이렇게 되는거잖아.. star.length가 4니까 -1에서 y값을 추가로 빼주면 되는거 아닌가?  2차시도(성공)package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tresult[j][i]=star[star.length-1-i][j];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}됐당!!package _2javajungsuktestEx5;public class ex5_9 {\tpublic static void main(String[] args) {\t\tchar[][] star = {\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*',' ',' ',' '},\t\t\t{'*','*','*','*','*'},\t\t\t{'*','*','*','*','*'}\t\t};\t\tchar[][] result = new char[star[0].length][star.length];\t\t\t\tfor(int i=0;i&lt;star.length;i++) {\t\t\tfor(int j=0;j&lt;star[i].length;j++) {\t\t\t\tSystem.out.print(star[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t\tSystem.out.println();\t\tfor(int i=0;i&lt;star[0].length;i++) {\t\t\tfor(int j=0;j&lt;star.length;j++) {\t\t\t\tresult[i][j] = star[star.length-1-j][i];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.print(result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}for문 순서때문에 약간 헷갈려서 순서바꿔서 한번 해봤당[5-10] 문자열 암호화package _2javajungsuktestEx5;public class ex5_10 {\tpublic static void main(String[] args) {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse result+=abcCode[ch-'a'];\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_10 {\tpublic static void main(String[] args) throws IOException {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString scr = br.readLine();//\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse if(ch&gt;='a' &amp;&amp; ch&lt;='z')\t\t\t\tresult+=abcCode[ch-'a'];\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}위 코드대로 했다가 BufferedReader를 통해 입력받았을때 대문자가 들어오니까 에러가 나길래 else if를 추가해줬음. 대문자가 들어오니까 공백으로 처리하고 남은것만 암호화하더라package _2javajungsuktestEx5;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex5_10 {\tpublic static void main(String[] args) throws IOException {\t\tchar abcCode[]= {'`','~','!','@','#','$','%','^','&amp;','*',\t\t\t\t'(',')','-','_','+','=','|','[',']','{',\t\t\t\t'}',';',':',',','.','/'};\t\t\t\t\t\t// 0   1   2   3   4   5   6   7   8   9\t\tchar numCode[] = {'q','w','e','r','t','y','u','i','o','p'};\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString scr = br.readLine();//\t\tString scr = \"abc123\";\t\tString result = \"\";\t\t\t\t//문자열 scr의 문자를 하나씩 읽어서 변환 후 result에 저장\t\tfor(int i=0;i&lt;scr.length();i++) {\t\t\tchar ch = scr.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') \t\t\t\tresult += numCode[ch-'0'];\t\t\telse if(ch&gt;='a' &amp;&amp; ch&lt;='z')\t\t\t\tresult+=abcCode[ch-'a'];\t\t\telse {\t\t\t\tSystem.out.println(\"입력값이 잘못됐습니다.\");\t\t\t\tSystem.exit(0);\t\t\t}\t\t}\t\tSystem.out.println(\"scr : \"+scr);\t\tSystem.out.println(\"result : \"+result);\t}}지정된 문자 말고 다른게 들어오면 경고문구띄우면서 종료되게 바꿔봄[5-11] 2차원 배열 score보다 가로, 세로로 한칸씩 더 큰 배열을 반들어 마지막에 각 열과 행의 합을 구하는 문제  1차시도 (실패)package _2javajungsuktestEx5;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tint sum=0;\t\t\tint sum2=0;\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tsum+=score[i][j];\t\t\t\tsum2+=score[i][j];\t\t\t\tresult[i][score[i].length] = sum;\t\t\t\tresult[score.length][j]=sum2;\t\t\t\tresult[score.length][score[i].length] += sum;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}일단 저 sum을 쓴거자체가 잘못된듯. 아니면 sum2를 for문 안으로 넣어서 계속 초기화를 시켜줘서 result[score].length +=sum2를 하거나.. 5,3값에도 +=sum2를 하면 될거같기는 한데 일단 아래처럼 수정해봄  2차시도(개선필요)package _2javajungsuktestEx5;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tint sum=0;\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tint sum2=0;\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tsum+=score[i][j];\t\t\t\tsum2+=score[i][j];\t\t\t\tresult[i][score[i].length] = sum;\t\t\t\tresult[score.length][j]+=sum2;\t\t\t\tresult[score.length][score[i].length] += sum2;\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}이렇게 할거면 너무 비효율적이라서 굳이 sum, sum2를 고집할 필요가 없을듯..  3차시도 - 성공(sum,sum2 안씀)package _2javajungsuktestEx5;import java.util.Arrays;public class ex5_11 {\tpublic static void main(String[] args) {\t\tint score[][] = {\t\t\t\t{100,100,100},\t\t\t\t{20,20,20},\t\t\t\t{30,30,30},\t\t\t\t{40,40,40},\t\t\t\t{50,50,50}\t\t};\t\tint result[][] = new int[score.length+1][score[0].length+1];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tfor(int j=0;j&lt;score[i].length;j++) {\t\t\t\tresult[i][j] = score[i][j];\t\t\t\tresult[i][score[i].length] += result[i][j];\t\t\t\tresult[score.length][j]+=result[i][j];\t\t\t\tresult[score.length][score[i].length] += result[i][j];\t\t\t}\t\t}\t\tfor(int i=0;i&lt;result.length;i++) {\t\t\tfor(int j=0;j&lt;result[i].length;j++) {\t\t\t\tSystem.out.printf(\"%4d\",result[i][j]);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}더 쉽게하려고 변수 sum을 선언해줬는데 더 어렵게돼서 당황스럽다😭너무 꼬아서 생각하지말고 단순하게 생각도 해봐야겠음"
  },
  
  {
    "title": "자바의 정석 연습문제 4장 - 조건문, 반복문",
    "url": "/posts/4%EC%9E%A5_%EC%A1%B0%EA%B1%B4%EB%AC%B8_%EB%B0%98%EB%B3%B5%EB%AC%B8/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 조건문, 반복문",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "[4-1] 다음의 문장들을 조건식으로 표현하라.package _2javajungsuktestEx4;public class ex4_1 {\tpublic static void main(String[] args) {//\t\t1. int형 변수 x가 10보다 크고 20 보다 작을 때 true인 조건식\t\tint x=10;\t\tSystem.out.println(x&g...",
    "content": "[4-1] 다음의 문장들을 조건식으로 표현하라.package _2javajungsuktestEx4;public class ex4_1 {\tpublic static void main(String[] args) {//\t\t1. int형 변수 x가 10보다 크고 20 보다 작을 때 true인 조건식\t\tint x=10;\t\tSystem.out.println(x&gt;=10 &amp;&amp; x&lt;=20);//\t\t2. char형 변수 ch가 공백이나 탭이 아닐 때 true인 조건식\t\tchar ch = 'a';\t\tSystem.out.println(!(ch==' ' || ch=='\\t'));//\t\t3. char형 변수 ch가 ‘x'또는 ’X' 일 때 true인 조건식\t\tchar ch2 = 'x';\t\tSystem.out.println(ch2 =='x' || ch2 =='X');//\t\t4. char형 변수 ch가 숫자(‘0’~‘9’)일 때 true인 조건식\t\tchar ch3 = '9';\t\tSystem.out.println(ch3 &gt;='0' &amp;&amp; ch3 &lt;='9');//\t\t5. char형 변수 ch가 영문자(대문자 또는 소문자) 일 때 true인 조건식\t\tchar ch4= 'a';\t\tSystem.out.println((ch4&gt;='A' &amp;&amp; ch4&lt;='Z') || (ch4&gt;='a' &amp;&amp; ch4&lt;='z'));//\t\t6. int형 변수 year가 400으로 나눠떨어지거나 또는 4로 나눠떨어지고 100으로 나눠떨어지지않을 때 true인 조건식\t\tint year = 124;\t\tSystem.out.println(year%400==0 ||year%4==0 &amp;&amp; year%100!=0);//\t\t7. boolean형 변수가 powerOn false 일 때 true인 조건식\t\tboolean powerOn = false;\t\tSystem.out.println(!powerOn);//\t\t8. 문자열 참조변수 str이 “yes” 일 때 true인 조건식\t\tString str = \"yes\";\t\tSystem.out.println(str.equals(\"yes\"));\t\t\t}}[4-2] 1~20중 2또는 3의 배수가 아닌 수의 합package _2javajungsuktestEx4;public class ex4_2 {\tpublic static void main(String[] args) {\t\tint sum=0;\t\tfor(int i=1;i&lt;=20;i++) {\t\t\tif(!(i%2==0 || i%3==0))\t\t\t\tsum+=i;\t\t}\t\tSystem.out.println(sum);\t\tsum=0;    for(int i=1;i&lt;=20;i++){      if(i%2==0 || i%3==0) continue;      sum+=i;      }      System.out.println(sum);\t}}[4-3] 1+(1+2)+(1+2+3)+…(1+2+3+4+…+10)은?package _2javajungsuktestEx4;public class ex4_3 {\tpublic static void main(String[] args) {\t\tint sum=0;\t\tint result=0;\t\tfor(int i=1;i&lt;=10;i++) {\t\t\tsum+=i;\t\t\tresult+=sum;\t\t}\t\tSystem.out.println(result);\t}}답:220[4-4] 1+-2+3+-4+5+-6…일때 합이 100이상이 되려면 몇번 더해야하는가?package _2javajungsuktestEx4;public class ex4_4 {\tpublic static void main(String[] args) {\t\tint sum = 0;\t\tfor(int i=0;true;i++) {\t\t\tif(i%2==0) sum-=i;\t\t\telse sum+=i;\t\t\t\t\t\tif(sum&gt;=100) {\t\t\t\tSystem.out.println(i);\t\t\t\tbreak;\t\t\t}\t\t}\t}}음수값이 2의 배수이길래 if문을 써서 2의 배수면 -i를 하게 만들었음package _2javajungsuktestEx4;public class ex4_4 {\tpublic static void main(String[] args) {\t\tint sum=0,n=1;\t\tfor(int i=1;true;i++,n*=-1) {\t\t\tsum += i*n;\t\t\tif(sum&gt;=100) {\t\t\t\tSystem.out.println(i);\t\t\t\tbreak;\t\t\t}\t\t}\t}}이번엔 n값을 추가해서 n*=-1로 sum을 i값을 양수와 음수를 번갈아가게 나타나게 만들어봤음public class jungsukEx4_2 {    public static void main(String[] args) {        int sum=0;        int count = 0;        for(int i=1;true;i++){            if(i%2==0) i*=-1;            sum+=i;\t\t        count++;            if(sum&gt;=100) break;            i=Math.abs(i);        }        System.out.println(count);    }}i값을 마지막에 절대값처리해서 초기화도 시켜줘봄public class jungsukEx4_2 {    public static void main(String[] args) { \t\t\t\tsum=0;        int count = 0;        for(int i=1;true;i++){            if(i%2==0) i*=-1;            sum+=i;            if(sum&gt;=100) break;            count++;            i=Math.abs(i);        }\t}}while문 사용  답지 코드```javapackage _2javajungsuktestEx4;public class ex4_4 {public static void main(String[] args) {\tint sum=0,n=1,num=0;\tfor(int i=1;true;i++,n=-n) {\t\tnum=n*i;\t\tsum+=num;\t\tif(sum&gt;=100) break;\t}\tSystem.out.println(num);}}---### [4-5]```javapackage _2javajungsuktestEx4;public class ex4_5 {\tpublic static void main(String[] args) {\t\tfor(int i=0; i&lt;=10; i++) {\t\t\tfor(int j=0; j&lt;=i; j++)\t\t\tSystem.out.print(\"*\");\t\t\tSystem.out.println();\t\t}\t}}위 별찍기 for문을 while문으로 변환package _2javajungsuktestEx4;public class ex4_5 {\tpublic static void main(String[] args) {\t\tint i=0;\t\twhile(i&lt;=10) {\t\t\tint j=0;\t\t\twhile(j&lt;=i) {\t\t\t\tSystem.out.print(\"*\");\t\t\t\tj++;\t\t\t}\t\t\tSystem.out.println();\t\t\ti++;\t\t}\t\t\t}}처음에 int i와 j를 같이 선언해줬다가 이상하게 나와서 뭐지?했는데 while문안에 int j=0을 넣어서 매번 값을 초기화해줘야하는 걸 잊었다;; 일단 해결[4-6] 주사위 두개를 굴려 두 수의 합이 6이 나오는 모든 경우의 수package _2javajungsuktestEx4;public class ex4_6 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=6;i++) {\t\t\tfor(int j=1;j&lt;=6;j++) {\t\t\t\tif(i+j==6) System.out.println(i+\" + \"+j+\" = \"+(i+j));\t\t\t}\t\t}\t}}답 :1 + 5 = 62 + 4 = 63 + 3 = 64 + 2 = 65 + 1 = 6[4-7] value에 1~6까지의 랜덤 값을 Math.random()을 이용하여 받는 문제package _2javajungsuktestEx4;public class ex4_7 {\tpublic static void main(String[] args) {\t\tint value = (int) ((Math.random()*6))+1;\t\tSystem.out.println(value);\t}}Math.random()은 double형 결과값을 출력해서 소수점 까지 다 나오니까 원하는 값을 얻으려면 int형으로 변환해주어야함. 1.xxx값에 6을 곱한 후 int형으로 변환해 소수점을 버리면 0~5값이 나오기 때문에 +1까지 해주어야 한다.[4-8] 2x +4y =10인 모든 경우의 수 출력package _2javajungsuktestEx4;public class ex4_8 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;=10;i++) {\t\t\tfor(int j=0;j&lt;=10;j++) {\t\t\t\tif(i*2+4*j==10) System.out.println(\"x = \"+i+\", y = \"+j);\t\t\t}\t\t}\t}}[4-9] 문자열 str의 각 자리수의 합을 구하는 문제package _2javajungsuktestEx4;public class ex4_9 {\tpublic static void main(String[] args) {\t\tString str = \"12345\";\t\tint sum=0;\t\t\t\tfor(int i=0;i&lt;str.length();i++) {\t\t\tsum+= str.charAt(i)-'0';\t\t}\t\tSystem.out.println(\"sum=\"+sum);\t}}[4-10] 숫자 num의 각 자리수의 합을 구하는 문제package _2javajungsuktestEx4;public class ex4_10 {\tpublic static void main(String[] args) {\t\tint num=12345;\t\tint sum=0;\t\t\t\twhile(num&gt;0) {\t\t\tsum+=num%10;\t\t\tnum/=10;\t\t}\t\t\t\tSystem.out.println(\"sum=\"+sum);\t}}처음에 당당하게 num.length()쓰다가 자동완성이 안떠서 length()가 String클래스의 메소드인걸 생각해냄ㅋㅋ…그래서 for문을 쓰기엔 i값 범위 지정하기가 애매해서 그냥 while문을 사용하기로 결정함[4-11] 피보나치수열, 맨 앞 두 수가 1,1일때 10번째 값을 구하는 문제package _2javajungsuktestEx4;public class ex4_11 {\tpublic static void main(String[] args) {\t\tint num1= 1;\t\tint num2=1;\t\tint num3=0;\t\tSystem.out.print(num1+\",\"+num2);\t\tfor(int i=0;i&lt;8;i++) {\t\t\tnum3=num1+num2;\t\t\tSystem.out.print(\",\"+num3);\t\t\tnum1=num2;\t\t\tnum2=num3;\t\t}\t}}[4-12] 구구단 출력 문제이 형태임package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=2;i&lt;=9;i++) {\t\t\tfor(int j=1;j&lt;=3;j++) {\t\t\t\tSystem.out.println(i+\" * \"+j+\" = \"+i*j);\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}모양이 복잡해 보여서 일단 찍어봄.2 * 1 = 22 * 2 = 42 * 3 = 63 * 1 = 33 * 2 = 63 * 3 = 94 * 1 = 44 * 2 = 84 * 3 = 125 * 1 = 55 * 2 = 105 * 3 = 156 * 1 = 66 * 2 = 126 * 3 = 187 * 1 = 77 * 2 = 147 * 3 = 218 * 1 = 88 * 2 = 168 * 3 = 249 * 1 = 99 * 2 = 189 * 3 = 27첫번째 for문의 System.out.println()을 print(”\\t”)으로 바꿔보면 진전이있을거같아서 해봤는데 3 * 1=3 4 * 1=4같이 첫 시작만 탭이 먹힘. 생각을 잘못한거같은게.. 저렇게 출력이되려면 맨 첫줄만 생각했을때 i값은 2~4가 계속 반복되고 j값은 1~3이 계속 반복됨. 일단 2~4단만 먼저 찍어보는게 나을것같음package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=3;i++) {\t\t\tfor(int j=2;j&lt;=4;j++) {\t\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\t\tSystem.out.print(\"\\t\");\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}추가로 i와 j값의 위치를 바꿔줌2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 12으로 2~4단은 잘 출력됨. 이제 다음걸 출력하려면.. j%3 == 2일때 println을 사용해본다면?package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=3;i++) {\t\t\tfor(int j=2;j&lt;=9;j++) {\t\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\t\tSystem.out.println();\t\t\t\t}\t\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\t\tSystem.out.print(\"\\t\");\t\t\t}\t\t}\t}}출력: 2 * 1 = 2 3 * 1 = 3 4 * 1 = 45 * 1 = 5 6 * 1 = 6 7 * 1 = 78 * 1 = 8 9 * 1 = 9 2 * 2 = 4 3 * 2 = 6 4 * 2 = 85 * 2 = 10 6 * 2 = 12 7 * 2 = 148 * 2 = 16 9 * 2 = 18 2 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 3 = 24 9 * 3 = 27예 이꼴났어요곱하는 수도 1~3이 계속 반복되어야하고 단도 3번은 반복되어야하는데.. if문안에 j-3값을 넣어봐야겠음..package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1,j=2;i&lt;=3&amp;&amp;j&lt;=9;j++) {\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\tSystem.out.println();\t\t\t\tj-=3;\t\t\t\ti++;\t\t\t\tif(i&gt;3) {\t\t\t\t\tSystem.out.println();\t\t\t\t\ti-=3;\t\t\t\t\tj+=3;\t\t\t\t}\t\t\t}\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\tSystem.out.print(\"\\t\");\t\t}\t}}출력2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 9좀만 더하면 될거같은데ㅜpackage _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1,j=2;i&lt;=3&amp;&amp;j&lt;=11;j++) {\t\t\tif(j==10&amp;&amp;i==3) break;\t\t\tif(j%10==0 &amp;&amp; i&lt;=3) continue;\t\t\tif(j&gt;2 &amp;&amp; j%3==2) {\t\t\t\tSystem.out.println();\t\t\t\tj-=3;\t\t\t\ti++;\t\t\t\tif(i&gt;3) {\t\t\t\t\tSystem.out.println();\t\t\t\t\ti-=3;\t\t\t\t\tj+=3;\t\t\t\t}\t\t\t}\t\t\tSystem.out.print(j+\" * \"+i+\" = \"+i*j);\t\t\tSystem.out.print(\"\\t\");\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 9 10 * 1 = 108 * 2 = 16 9 * 2 = 18 10 * 2 = 208 * 3 = 24 9 * 3 = 27일단 되긴 됐는데 이게 좋은 코드같지가않다…..ㅋㅋ내일 좀 더 생각해봐야겠음..for문을 한번 더 써보는게 나을 듯..package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;3;i++) {\t\t\tfor(int y=1;y&lt;=3;y++) {\t\t\t\tfor(int x=2;x&lt;=9;x++) {\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y);\t\t\t\t\tSystem.out.print(\"\\t\");\t\t\t\t\t}\t\t\t\tSystem.out.println();\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 272 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 272 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 92 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 182 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 27음…일단 x값을 ≤4로 해봐야겠음x값을 x≤4로한 다음에 i값이랑 x값이랑 같게해서 i를 +3씩 한다면.. 괜찮지않을까?package _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=2;i&lt;9;i+=3) {\t\t\tfor(int y=1;y&lt;=3;y++) {\t\t\t\tfor(int x=i;x&lt;=i+2&amp;&amp;x&lt;=9;x++) {\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y);\t\t\t\t\tSystem.out.print(\"\\t\");\t\t\t\t\t}\t\t\t\tSystem.out.println();\t\t\t}\t\t\tSystem.out.println();\t\t}\t}}2 * 1 = 2 3 * 1 = 3 4 * 1 = 42 * 2 = 4 3 * 2 = 6 4 * 2 = 82 * 3 = 6 3 * 3 = 9 4 * 3 = 125 * 1 = 5 6 * 1 = 6 7 * 1 = 75 * 2 = 10 6 * 2 = 12 7 * 2 = 145 * 3 = 15 6 * 3 = 18 7 * 3 = 218 * 1 = 8 9 * 1 = 98 * 2 = 16 9 * 2 = 188 * 3 = 24 9 * 3 = 27됐다!!!!!!!!!!!!!!!!!!!!!!!!11  답지\tpackage _2javajungsuktestEx4;public class ex4_12 {\tpublic static void main(String[] args) {\t\tfor(int i=1;i&lt;=9;i++) {\t\t\tfor(int j=1;j&lt;=3;j++) {\t\t\t//i가 3이상이 되면 x에 i-1값을 더해서 반복되는 단을 변경해줌(2~4-&gt;5~7-&gt;8~9)\t\t\t\tint x=j+1+ (i-1)/3*3;\t\t\t\tint y=i%3==0?3:i%3;  \t\t\t\t\t\t\t\tif(x&gt;9) break;\t\t\t\t\tSystem.out.print(x+\" * \"+y+\" = \"+x*y+\"\\t\");\t\t\t}\t\t\tSystem.out.println();\t\t\tif(i%3==0) System.out.println();\t\t}\t}}음.. 근데 int x구하는 식에서 굳이 +1을 해줘야 하나? for문쓸때 2~4로 해주면 되는거 아닌감..코드 이해는 했는데..ㅜㅜ어렵구만  for문을 한번만 쓰라는 조건이 없어서 for문을 3번적는 방법도 있다    public class Gugu {  public static void main(String[] args) {      for(int i=1;i&lt;=3;i++){          for(int j=2;j&lt;=4;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }      System.out.println();      for(int i=1;i&lt;=3;i++){          for(int j=5;j&lt;=7;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }      System.out.println();      for(int i=1;i&lt;=3;i++){          for(int j=8;j&lt;=9;j++){              System.out.print(j+\" X \"+i+\" = \"+j*i+\"\\t\");          }          System.out.println();      }  }}      [4-13] 문자열이 숫자로만 이루어졌는지 판단하는 문제package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_13 {\tpublic static void main(String[] args) throws IOException{\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tString value = br.readLine();\t\tchar ch = ' ';\t\tboolean isNumber = true;\t\t\t\tfor(int i=0;i&lt;value.length();i++) {\t\t\tch=value.charAt(i);\t\t\tif(ch&gt;='0' &amp;&amp; ch&lt;='9') {\t\t\t\tisNumber=true;\t\t\t\t}\t\t\telse {\t\t\t\tisNumber = false;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif(isNumber) System.out.println(value+\"는 숫자입니다\");\t\telse System.out.println(value+\"는 숫자가 아닙니다.\");\t}}문자열은 BufferedReader를 통해 입력받아보았다.[4-14] 숫자맞추기 문제package _2javajungsuktestEx4;import java.util.Scanner;public class ex4_14 {\tpublic static void main(String[] args) {\t\tint answer = (int)(Math.random()*100)+1;\t\tint input=0;\t\tint count=0;\t\t\t\tScanner s = new Scanner(System.in);\t\t\t\tdo {\t\t\tcount++;\t\t\tSystem.out.println(\"1~100사이의 값을 입력하세요 : \");\t\t\tinput= s.nextInt();\t\t\t\t\t\tif(input&gt;answer) System.out.println(\"더 작은 수를 입력하세요.\");\t\t\telse if(input&lt;answer) System.out.println(\"더 큰 수를 입략하세요.\");\t\t\telse {\t\t\t\tSystem.out.println(\"정답입니다. 시도횟수는 \"+count+\"번 입니다.\");\t\t\t\tbreak;\t\t\t}\t\t}while(true);\t}}package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_14 {\tpublic static void main(String[] args) throws IOException {\t\tint answer = (int)(Math.random()*100)+1;\t\tint input=0;\t\tint count=0;\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\t\t\t\tdo {\t\t\tcount++;\t\t\tSystem.out.println(\"1~100사이의 값을 입력하세요 : \");\t\t\tinput= Integer.parseInt(br.readLine());\t\t\t\t\t\tif(input&gt;answer) System.out.println(\"더 작은 수를 입력하세요.\");\t\t\telse if(input&lt;answer) System.out.println(\"더 큰 수를 입략하세요.\");\t\t\telse {\t\t\t\tSystem.out.println(\"정답입니다. 시도횟수는 \"+count+\"번 입니다.\");\t\t\t\tbreak;\t\t\t}\t\t}while(true);\t}}Scanner대신 BufferedReader를 사용했다.import java.util.Scanner;public class UpAndDown {    public static void main(String[] args) {        int answer = (int)(Math.random()*100)+1 ;        int input = 0; // 사용자입력을 저장할 공간        int count = 0; // 시도횟수를 세기위한 변수        // Scanner 화면으로 부터 사용자입력을 받기 위해서 클래스 사용        Scanner s = new Scanner(System.in);        while (true) {            count++;            System.out.print(\"1과 100사이의 값을 입력하세요 :\");            input = s.nextInt(); // input . 입력받은 값을 변수 에 저장한다            if(input &lt; answer) System.out.println(\"입력한 값이 정답보다 큽니다.\");            else if(input &gt; answer) System.out.println(\"입력한 값이 정답보다 작습니다.\");            else {                 System.out.println(\"정답입니다.\");                System.out.println(\"시도횟수는 \"+count+\"번 입니다.\");                break;            }        }    }}그냥 while문 사용함[4-15] 회문수(앞뒤가 같은 수)를 구하는 문제package _2javajungsuktestEx4;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex4_15 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint number = Integer.parseInt(br.readLine());\t\tint tmp=number;\t\t\t\tint result =0;\t\t\t\twhile(tmp!=0) {\t\t\tresult = tmp%10+result*10;\t\t\ttmp/=10;\t\t}\t\tif(number == result) System.out.println(number+\"는 회문수입니다.\");\t\telse System.out.println(number+\"는 회문수가 아닙니다.\");\t}}이것도 입력값 받는 문제로 바꿔서 풀었다"
  },
  
  {
    "title": "자바의 정석 연습문제 3장 - 연산자",
    "url": "/posts/3%EC%9E%A5_%EC%97%B0%EC%82%B0%EC%9E%90/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 연산자",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "3-1 출력값을 적어라class Exercise3_1 {public static void main(String[] args) {int x = 2;int y = 5;char c = 'A'; // 'A' 65 의 문자코드는System.out.println(1 + x &lt;&lt; 33);System.out.println(y &gt;= 5 || x &lt...",
    "content": "3-1 출력값을 적어라class Exercise3_1 {public static void main(String[] args) {int x = 2;int y = 5;char c = 'A'; // 'A' 65 의 문자코드는System.out.println(1 + x &lt;&lt; 33);System.out.println(y &gt;= 5 || x &lt; 0 &amp;&amp; x &gt; 2);System.out.println(y += 10 - x++);System.out.println(x+=2);System.out.println( !('A' &lt;= c &amp;&amp; c &lt;='Z') );System.out.println('C'-c);System.out.println('5'-'0');System.out.println(c+1);System.out.println(++c);System.out.println(c++);System.out.println(c);순서대로6true135false2566BBC이 출력됨.      System.out.println(1 + x &lt;&lt; 33);  +가 우선순위라 1+x부터 계산됨. 33은 int라서 int는 32bit니까 1만 계산하면 됨. 최종적으로 3«1        « : 비트이동 연산자. 왼쪽으로 이동 ⇒ 3을 왼쪽으로 1 이동  3«1 = 3*2 =6        System.out.println(y &gt;= 5 || x &lt; 0 &amp;&amp; x &gt; 2); | |보다 &amp;&amp;이 우선순위가 높음. 그럼 x&lt;0 &amp;&amp; x&gt;2는 false&amp;&amp;false임. y≥5는 true니까 최종 코드가 true | | false 로 true가 반환됨.        System.out.println(y += 10 - x++);  y=y+(10-x);    x++은 계산 후 1을 더해줌. 그럼 5+8로 13        System.out.println(x+=2);    위 식에서 x=3이됨. 5출력        System.out.println( !('A' &lt;= c &amp;&amp; c &lt;='Z') );    c가 A보다 크고 Z보다 작지 않을때 = c가 대문자가 아니면 true. c는 ‘A’니까 false        System.out.println('C'-c);    ‘C’ - ‘A’. C=67, A=65  2출력        System.out.println('5'-'0');    ‘5’-’0’ 53-48=5  5출력        System.out.println(c+1);    65(’A’) + 1 = ‘B’  c값의 변동은 없음        System.out.println(++c);    ++c는 먼저 값을 바꾸고 출력됨  B출력. c의 값이 B로 바뀜        System.out.println(c++);    c++은 출력 후 값이 바뀜. c=’B’니까 B 출력  출력후 c=’C’로 값 변동        System.out.println(c);  c=’C’니까 C출력  3-2 사과 박스의 \b갯수는?package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_2 {\tpublic static void main(String[] args) throws IOException {//\t\tint numOfApples = 123;\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint numOfApples = Integer.parseInt(br.readLine());\t\tint sizeOfBucket = 10;\t\tint numOfBucket = numOfApples/sizeOfBucket + (numOfApples%sizeOfBucket&gt;0?1:0);\t\tSystem.out.println(\"필요한 바구니의 수 : \"+numOfBucket);\t}}예제랑 다르게 bufferedReader를 사용해 입력값을 받아보았다3-3 삼항연산자를 2번 사용해서 num이 양수, 음수, 0중 어디에 해당하는가?package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_3 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num&gt;0?\"양수\":num&lt;0?\"음수\":0);\t\t\t}}삼항연산자 - 조건식?(true일때)값:(false일때)값3-4 백의자리 이하를 버려라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_4 {\tpublic static void main(String[] args) throws IOException{\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num/100*100);\t}}int는 소수점을 자동으로 버리기 때문에(반올림xxx) num을 100으로 나눈 후 100을 곱해줬음3-5 1의 자리를 1로 바꿔라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_5 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(num/10*10+1);\t}}3-4처럼 일의자리를 버린 후 1을 더해줬다3-6 %연산자를 사용하여 크면서도 가까운 10의 배수에서 num값을 뺀 나머지를 구하라package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class ex3_6 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tint num = Integer.parseInt(br.readLine());\t\tSystem.out.println(+num+\"의 크면서도 가까운 10의 배수 : \"+(10-num%10+num));\t\tSystem.out.println(\"나머지 수 : \"+(10-num%10));\t}}3-7 화씨를 섭씨로 변환  변환 공식 - 5/9 * (f-32)public class ex3_7 {\tpublic static void main(String[] args) {\t\tint fahrenheit = 100;\t\tfloat celcius = (int)(5/9f * (fahrenheit-32)*100+0.5)/100f;\t\tSystem.out.println(\"Fahrenheit : \"+fahrenheit);\t\tSystem.out.println(\"celcius : \"+celcius);\t}}섭씨로 바꾸는 공식을 사용하여 100을 곱하고 반올림을 위해 0.5를 더한다.+0.5를 했을때 일의 자리 수 값이 변한다면 어차피 반올림해도 변함 - 여기까지 int형으로 계산해서 3번째 자리수부터 버림그 후 다시 100f로 나눠 소수점을 만들어 준다3-8 정해진 값을 출력하라차례로c = 30ch = Cf = 1.5l = 1230196224result = true을 출력하는 문제package _2javajungsuktestEx3;public class ex3_8 {\tpublic static void main(String[] args) {\t\tbyte a=10;\t\tbyte b=20;\t\tbyte c =(byte) (a+b);\t\t\t\tchar ch ='A';\t\tch = (char)(ch+2);\t\tfloat f = 3/2f;\t\tlong l = 3000*3000*3000L;\t\t\t\tfloat f2 = 0.1f;\t\tdouble d = 0.1;\t\t\t\tboolean result = (float)d==f2;\t\t\t\tSystem.out.println(\"c = \"+c);\t\tSystem.out.println(\"ch = \"+ch);\t\tSystem.out.println(\"f = \" +f);\t\tSystem.out.println(\"l = \"+l);\t\tSystem.out.println(\"result = \"+result);\t\t\t}}byte c = a+b같은 경우에는 a+b가 int로 자동 형변환 되기때문에 앞에 (byte)를 붙여서 다시 byte로 형변환을 해주었다.ch =ch+2도 마찬가지로 앞에 (char)을 붙여서 형변환을 해주었다float f=3/2는 int/int라 2에 f를 붙여 float로 변환해주었다. long l = 300030003000도 뒤에 L이 빠져있었다. 3000중에 하나는 long타입이어야 오버플로우가 나타나지 않는다boolean result = d == f2는 d와 f2의 형식이 달라 false가 출력된다. float를 double로 형변환했을 때 오차가 발생할 수 있어서 d를 float으로 변환해주었다3-9 ch가 영어(대문자,소문자 둘다)거나 숫자일경우 true를 출력package _2javajungsuktestEx3;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class cx3_9 {\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\t\tchar ch = br.readLine().charAt(0);\t\tboolean b= (ch&gt;='A'&amp;&amp; ch&lt;='z') || (ch&gt;='a' &amp;&amp; ch&lt;='z') || (ch&gt;='0' &amp;&amp; ch&lt;='9');\t\t\t\tSystem.out.println(b);\t}\t}char ch를 BufferedReader를 통해 입력받아보았다. char형을 입력받는 것은 처음이라 charAt()을 써보면 될거같아 시도해보았더니 성공했다!3-10 대문자를 소문자로 변환package _2javajungsuktestEx3;public class ex3_10 {\tpublic static void main(String[] args) {\t\tchar ch = 'A';\t\t\t\tchar lowerCase = (char) ((ch&gt;=65 &amp;&amp; ch&lt;97)?ch+32:ch);\t\t\t\tSystem.out.println(\"ch:\"+ch);\t\tSystem.out.println(\"ch to lowerCase : \"+lowerCase);\t}}"
  },
  
  {
    "title": "자바의 정석 연습문제 2장 - 변수",
    "url": "/posts/2%EC%9E%A5_%EB%B3%80%EC%88%98/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연습문제, 변수",
    "date": "2022-10-02 00:00:00 +0900",
    





    
    "snippet": "[2-1] 기본형 8개를 알맞은 자리에 적으시요            종류/크기      1byte      2byte      4byte      8byte                  논리형      boolean                                   문자형             char                     ...",
    "content": "[2-1] 기본형 8개를 알맞은 자리에 적으시요            종류/크기      1byte      2byte      4byte      8byte                  논리형      boolean                                   문자형             char                            정수형      byte      short      int      long              실수형                    float      double      [2-2] 주민등록번호를 초기화하는 코드 적기long regNo = 9701012222222L;int의 범위를 넘어서는 값이라 long을 사용함→ 원래는 이렇게 하면 됐는데 20000년생 부터는 long이 아닌 String으로 사용해야 온전한 값이 나옴[2-3] 리터럴, 변수, 상수, 키워드 구분하기int i = 100;long l =100L;final float PI = 3.14f;  리터럴 : 100,100L, 3.14f  변수 : i, l  키워드(=예약어) : int, long, final, float  상수 : PIPI는 final때문에 변경 불가능함[2-4] 기본형이 아닌 것.  int  ==Byte== - 기본형은 byte임.  double  boolean[2-5] 출력결과 적기System.out.println(“1” + “2”) → 12System.out.println(true + “”) → trueSystem.out.println(‘A’ + ‘B’) → 131 (A-65, b-66)System.out.println(‘1’ + 2) → 51 (’1’=49)System.out.println(‘1’ + ‘2’) → 99 (’1’=49, ‘2’=50)System.out.println(‘J’ + “ava”) → JavaSystem.out.println(true + null) → 오류![2-6] 키워드가 아닌 것  if  ==True== - true는 키워드임  ==NULL==  ==Class==  ==System== - 클래스명임키워드 :abstract, do, if, package, synchronized, boolean, double, implements, private, this, break, else, import, protected, throw, byte, enum, instanceof, public, throws, case, extends, int, return, transient, catch, false, interface, short, true, char, final, long, static, try, class, finally, native, strictfp, void, continue, float, new, super, volatile, default, for, null, switch, while[2-7] 변수이름으로 사용가능 한 것.==a. $ystem==b. channel==#==5 - # 불가c.==7==eleven - 숫자로 시작 불가==d. If====e. 자바==f.==new== - 예약어라 불가능==g. $MAX_NUM==h. hello==@==com - @불가[2-8] 참조형변수(reference type)과 같은 크기의 기본형(primitive type)  ==int== - 4byte  long - 8byte  short - 2byte  ==float== - 4byte  double - 8byte참조형 변수는 4byte임[2-9] 형변환 생략 가능한 것byte b=10;char ch = ‘A’;int i =100;long l = 1000L;  b = (byte) i; int(4byte) &gt; byte(1byte) 불가능  ch = (char)b; byte(1byte) &lt; char(2byte). 범위가 달라서 해줘야함  short s = (short) ch; char(2byte) = short(2byte). 범위가 달라서 해줘야함  float f = (float)l; long(8byte) &gt; float(4byte). 그러나 범위가 float이 더 커서 생략가능  i = (int)ch; char(2byte) &lt; int(4byte) 생략가능선생님은 정답 없다고하심[2-10] char타입에 저장될 수 있는 정수 값의 범위(10진수로)0~65535[2-11] 변수를 잘못 초기화 한것은?  ==byte b = 256;== byte의 범위값을 넘음  ==char c = ‘’;== 띄어쓰기 해야함 ‘ ‘  ==char answer = ‘no’;== 두글자 안됨  ==float f = 3.14== f 빠짐  double d = 1.4e3f;[2-12] main메소드의 선언부로 알맞은것은?  ==public static void main(String[] args)==  ==public static void main(String args[])==  ==public static void main(String[] arv)==  public void static main(String[] args) void는 main앞에 와야함  static public void main(String[] args)[2-13] 타입과 기본형의 연결이 잘못된 것  boolean = false  char = ‘\\u0000’  ==float - 0.0== f빠짐  int = 0  ==long = 0== L빠짐  ==String = “”== String의 기본형은 null임"
  },
  
  {
    "title": "람다와 스트림(Lambda & Stream)",
    "url": "/posts/%EB%9E%8C%EB%8B%A4%EC%99%80-%EC%8A%A4%ED%8A%B8%EB%A6%BC(Lambda&Stream)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-09-02 00:00:00 +0900",
    





    
    "snippet": "람다식(Lambda Experssion): 함수(메소드)를 간단한 식으로 표현하는 법 (ex. (a, b) → a &gt; b ? a : b )  익명함수(이름이 없는 함수, anonymous function) : 반환타입, 이름을 지우고 사이에 →를 붙인다  함수와 메소드는 근본적으로 동일하나 함수는 일반적 용어, 메소드는 객체지향개념 용어. 함수는...",
    "content": "람다식(Lambda Experssion): 함수(메소드)를 간단한 식으로 표현하는 법 (ex. (a, b) → a &gt; b ? a : b )  익명함수(이름이 없는 함수, anonymous function) : 반환타입, 이름을 지우고 사이에 →를 붙인다  함수와 메소드는 근본적으로 동일하나 함수는 일반적 용어, 메소드는 객체지향개념 용어. 함수는 클래스에 독립적(클래스 바깥에 있는것. 자바에서는 불가능), 메소드는 클래스에 종속적(클래스안에 있음)  작성 법                  메소드의 이름과 반환타입 제거 후 ‘ →’를 블럭{}앞에 추가 ( ex. (int a, int b) → return a&gt;b? a:b;)                    반환값이 있는 경우, 식이나 값만 적고 return문 생략 가능. 끝에 ; 안붙임 (ex. (int a, int b) → a&gt;b? a:b)                    매개변수의 타입이 추론 가능하면, 생략 가능(대부분의 경우 생략가능) (ex. (a, b) → a&gt;b?a:b              주의사항                  매개변수가 하나인 경우, 괄호() 생략가능(타입이 없을 때만)  (a) → aa ⇒ a → aa 가능, (int a) → aa ⇒ int a → aa 불가능.                    블록안의 문장이 하나일 겅우 {}생략가능. 끝에 ; 안붙음. (return문은 생략안됨)  (int i) → { System.out.println(i);} ⇒ (int i) → System.out.println(i) 가능            — 예시      int max(int a, int b){ retrun a&gt;b?a:b;} ⇒ (a, b) → a&gt;b? a:b;        int printVar(String name, int i){System.out.println(name+”=”+i);} ⇒ (name, i) → System.out.println(name+”=”+i)        int square(int x){return x * x; } ⇒ x→ x*x        int roll(){return (int)(Math.random()6); ⇒ () → (int)(Math.random()6)        익명 함수가 아니고 익명 객체임  new Object(){ int max(int a, int b){ return a&gt;b? a:b;} 를 (a, b) → a&gt;b? a:b;으로 쓴거라 객체임.        람다식(익명 객체)를 다루기 위해 참조변수가 필요함.  class  Main{\tpublic static void main(String[] args) throws Exception {//\tObject obj = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체 에러남\t\tObject obj = new Object() {\t\t\tint max(int a, int b) {\t\t\t\treturn a&gt;b? a:b;\t\t\t}\t\t};//\t\tint value = obj.max(3,5); //에러, Object리모컨인 obj는 max를 호출할 수 없음\t\t//=&gt; 함수형 인터페이스가 필요\t}}함수형 인터페이스: 단 하나의 추상 메소드만 선언된 인터페이스@FunctionalInterface //붙이는게 좋음interface MyFunction{ \tpublic abstract int max(int a, int b);}class  Main{\tpublic static void main(String[] args) throws Exception {\t\tMyFunction f= new MyFunction(){\t\t\tpublic int max(int a, int b){ \t\t\t\treturn a&gt;b? a:b; \t\t\t}\t\t};\t\tint value = f.max(3, 5);//가능. MyFunction에 max()가 있음\t\tSystem.out.println(value);  \t}}  함수형 인터페이스 타입의 참조변수로 람다식을 참고 가능 (단, 함수형 인터페이스의 메소드와 람다식의 매개변수 개수와 반환타입이 일치해야 함)  Myfunction f = (a,b) →a&gt;b?a:b;  int value = f.max(3,5);class  Main{\tpublic static void main(String[] args) throws Exception {//\tObject obj = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체 에러남//\t\tMyfunction f = new Myfunction() {//\t\t\tpublic int max(int a, int b) { //오버라이딩 규칙, 접근제어자는 좁게 못바꿈//\t\t\t\treturn a&gt;b? a:b;//\t\t\t}//\t\t};\t\t//람다식을 다루기 위한 참조변수의 타입은 함수형 인터페이스로 한다\t\tMyfunction f = (a,b) -&gt; a&gt;b?a:b;//람다식, 익명객체\t\t//람다식을 사용하려면 이름이 있어야해서 이름을 붙여준거임(추상메소드와 연결)\t\tint value = f.max(3, 5);\t\tSystem.out.println(\"value : \"+value);\t}}@FunctionalInterface //함수형 인터페이스는 단 하나의 추상메소드만 가질 수 있다.interface Myfunction{//\tpublic abstract int max(int a, int b);\t\t\t\t\tint max(int a, int b); //public abstract 생략가능}— 예시      익명 객체를 람다식으로 대체      import java.util.*;      class  Main{  \tpublic static void main(String[] args)  {  \t\tList&lt;String&gt; list = Arrays.asList(\"abc\",\"aaa\",\"bbb\",\"ddd\",\"aaa\");    \t\t  //\t\tCollections.sort(list, new Comparator&lt;String&gt;() {  //\t\t\tpublic int compare(String s1, String s2) {  //\t\t\t\treturn s2.compareTo(s1);  //\t\t\t}  //\t\t});    \t\t  \t\tCollections.sort(list, (s1,s2)-&gt;s2.compareTo(s1));  \t\tSystem.out.println(list);  \t}  }  @FunctionalInterface  interface Comparator&lt;T&gt;{  \tint compare(T o1, T o2);  }        함수형 인터페이스타입의 매개변수, 반환타입                  함수형 인터페이스타입의 매개변수        @FunctionalInterface  interface MyFunction{  void myMethod(); }  void aMethod(MyFuction f) {  f.myMethod(); //람다식 호출  }  aMethod(()→System.out.println(”myMethod()”));                  함수형 인터페이스 타입의 반환타입    MyFunction myMethod(){ //람다식 반환  return ()→{}; }      import java.util.*;  @FunctionalInterface  interface MyFunction{  \tvoid run();  }      class  Main{  \tstatic void execute(MyFunction f) {//매개변수 타입이 MyFunction인 메소드  \t\tf.run();  \t}  \tstatic MyFunction getMyFunction() { //반환타입이 MyFunction인 메소드  //\t\tMyFunction f = () -&gt; System.out.println(\"f3.run()\");  //\t\treturn f;  \t\treturn ()-&gt;System.out.println(\"f3.run()\");  \t}  \tpublic static void main(String[] args)  {  \t\t//람다식으로 MyFunction의 run()을 구현  \t\tMyFunction f1 = ()-&gt;System.out.println(\"f1.run()\");    \t\t  \t\tMyFunction f2 = new MyFunction() {  \t\t\tpublic void run() {  \t\t\t\tSystem.out.println(\"f2.run()\");  \t\t\t}  \t\t};  \t\tMyFunction f3 = getMyFunction();    \t\t  \t\tf1.run();  \t\tf2.run();  \t\tf3.run();    \t\t  \t\texecute(f1);  \t\texecute(()-&gt;System.out.println(\"run()\"));  \t}  }      java.util.function패키지      자주 사용되는 다양한 함수형 인테페이스를 제공.        Predicate isEmptyStr = s→ s.length() == 0;    String s=””;    if(isEmptyStr.test(s) //if(s.length()==0)    Sysout(”This is an empty String”)  ![[assets/images/java/2022-09-02-람다와 스트림(Lambda&amp;Stream) 1/IMG-20240902151633.png]]  — 예시Supplier f = ()→(int)(Math.random()*100)+1; (공급자)Consumer f = i→ System.out.print(i+””);Predicate f = i→ i%2==0;Function f = i→ i/10*10; //25를 넣으면 20으로 반환  매개변수가 두개인 함수형 인터페이스Bi가 2개를 의미      매개변수가 3개인경우엔 만들어서 쓸것.  @FunctionalInterface  interface TriFunction&lt;T,U,V,R&gt;{  R apply(T t, U u, V v); //매개변수 3개  }        매개변수의 타입과 반환타입이 일치하는 함수형 인터페이스  UnaryOperator : 단항 연산자BinaryOperator : 이항 연산자@FunctionalInterfacepublic interface UnaryOperator extends Function&lt;T,T&gt;{  static UnaryOperrator  identity(){  return t→ t;} //입출력 타입 일치@FunctionalInterfacepublic interface Function&lt;T,R&gt;{R apply(T t);}import java.util.ArrayList;import java.util.List;import java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\t\tSupplier&lt;Integer&gt; s = () -&gt;(int)(Math.random()*100)+1; //1~100사이 양수\t\tConsumer&lt;Integer&gt; c = i-&gt;System.out.print(i+\", \");\t\tPredicate&lt;Integer&gt; p = i-&gt;i%2==0; //짝수인지 검사\t\tFunction&lt;Integer, Integer&gt; f = i-&gt;i/10*10; //i의 일의 자리수 버림\t\t\t\tList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\t\tmakeRandomList(s, list); //s에서 값(랜덤값)을 꺼내 list를 채운다\t\tSystem.out.println(list);\t\tprintEvenNum(p,c,list); //짝수 출력\t\tList&lt;Integer&gt; newList = doSomething(f,list); //새로운 list를 생성\t\tSystem.out.println(newList);\t}\t\tstatic&lt;T&gt; List&lt;T&gt; doSomething(Function&lt;T,T&gt; f, List&lt;T&gt; list){\t\tList&lt;T&gt; newList = new ArrayList&lt;T&gt;(list.size());\t\t\t\tfor(T i : list) {\t\t\tnewList.add(f.apply(i)); //list안의 값에서 1의 자리수를 버려 newlist 생성\t\t}\t\treturn newList;\t}\tstatic&lt;T&gt; void printEvenNum(Predicate&lt;T&gt; p, Consumer&lt;T&gt; c, List&lt;T&gt; list) {\t\tSystem.out.print(\"[\");\t\tfor(T i:list) {\t\t\tif(p.test(i)) //짝수인지 검사\t\t\t\tc.accept(i); //짝수면,System.out.print(i+\", \");로 화면에 i 출력\t\t}\t\tSystem.out.println(\"]\");\t}\tstatic&lt;T&gt; void makeRandomList(Supplier&lt;T&gt; s, List&lt;T&gt; list) {\t\tfor(int i=0;i&lt;10;i++) {\t\t\tlist.add(s.get()); //Supplier로 부터 1~100까지의 난수를 받아서 list에 10번 추가\t\t}\t}}Predicate의 결합      and(), or(), negate()로 두 Predicate를 하나로 결합(default메소드)    Predicate p = i → i&lt;100;    Predicate q = i → i&lt;200;    Predicate r = i → i%2 ==0;    Predicate notP = p.negate(); //i≥100    Predicate all = notP.and(q).or(r); //100≤i &amp;&amp; i&lt;200 || i%2==0    Predicate all2 = notP.and(q.or(r))//100≤i &amp;&amp; (i&lt;200 || i%2==0 )    System.out.println(all.test(2)); //true  System.out.println(all2.test(2)); //false        등가비교를 위한 predicate의 작성에는 isEqual()를 사용(static메소드)  Predicate [ =Predicate.isEqual(str1); //isEquals()은 static메소드    Boolean result = p.test(str2); //str1과 str2가 같은지 비교한 결과를 반환    ⇒ Boolean result = Predicate.isEqual(str1).test(str2);  import java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\tFunction&lt;String, Integer&gt; f = (s)-&gt;Integer.parseInt(s,16); //문자열을 16진수로\tFunction&lt;Integer, String&gt; g = (i)-&gt;Integer.toBinaryString(i); //2진수로\t\t//andThen : 두 function을 하나로 연결\t//f가 String입력, Integer출력. 출력된 Integer를 g에 입력, String출력하는 함수 h를 생성함\tFunction&lt;String, String&gt; h = f.andThen(g); //f적용하고 g를 적용. String입력, String출력\t//compose : f가 뒤에오고 g가 앞에옴\tFunction&lt;Integer, Integer&gt; h2 = f.compose(g); //Integer입력, Integer출력\t\tSystem.out.println(h.apply(\"FF\")); //\"FF\" -&gt; 255 -&gt; \"11111111\"\tSystem.out.println(h2.apply(2)); //2 -&gt; \"10\" -&gt; 16\t\tFunction&lt;String, String&gt; f2 = x-&gt;x; //항등함수(identity function)\tSystem.out.println(f2.apply(\"AAA\")); //AAA가 그대로 출력됨\t\tPredicate&lt;Integer&gt; p = i -&gt; i&lt;100;\tPredicate&lt;Integer&gt; q = i -&gt; i&lt;200;\tPredicate&lt;Integer&gt; r = i -&gt; i%2==0;\tPredicate&lt;Integer&gt; notP = p.negate(); //i&gt;=100\t\tPredicate&lt;Integer&gt; all = notP.and(q.or(r)); //i&gt;=100 &amp;&amp; (i&lt;200 || i%2==0)\tSystem.out.println(all.test(150)); //true\tSystem.out.println(all.test(149)); //true\tSystem.out.println(all.test(300)); //true\tSystem.out.println(all.test(10)); //false\t\tString str1 = \"abc\";\tString str2 = \"abc\";\t\t//str1과 str2가 같은지 비교\tPredicate&lt;String&gt; p2 = Predicate.isEqual(str1);\tboolean result = p2.test(str2);\tSystem.out.println(result); //true\t\tString str3 = new String(\"abc\");\t\t//str1과 str2가 같은지 비교//\tPredicate&lt;String&gt; p3 = Predicate.isEqual(str2);//\tboolean result2 = str1.equals(str2);\tboolean result2 = Predicate.isEqual(str2).test(str3);\tSystem.out.println(result2); //true\t}}컬렉션 프레임웍과 함수형 인터페이스  함수형 인터페이스를 사용하는 컬렉션 프레임웍의 메소드(와일드카드 생략)forEach는 consumer임(입력값만 있음)import java.util.*;class  Main{\tpublic static void main(String[] args)  {\t\tArrayList&lt;Integer&gt; list = new ArrayList();\t\tfor(int i=0;i&lt;10;i++) {\t\t\tlist.add(i);\t\t}\t\t\t\t//list의 모든 요소 출력\t\t//\t\tIterator it = list.iterator();//\t\twhile(it.hasNext()) {//\t\t\tSystem.out.print(it.next()+\",\");//\t\t}//\t\tSystem.out.println();\t\t//아래 한문장으로\t\tlist.forEach(i-&gt; System.out.print(i+\", \"));\t\tSystem.out.println();\t\tSystem.out.println(list); //이것도 되긴함\t\t\t\t\t\t//list에서 2또는 3의 배수를 제거\t\tlist.removeIf(x-&gt;x%2==0 || x%3==0); \t\tSystem.out.println(list);\t\t\t\tlist.replaceAll(i-&gt;i*10);\t\tSystem.out.println(list);\t\t\t\tMap&lt;String, String&gt; map = new HashMap();\t\tmap.put(\"1\", \"1\");\t\tmap.put(\"2\", \"2\");\t\tmap.put(\"3\", \"3\");\t\tmap.put(\"4\", \"4\");\t\t\t\t//map의 모든 요소를 {k,v}형식으로 출력//\t\tIterator it2 = map.entrySet().iterator();//\t\twhile(it2.hasNext()) {//\t\t\tSystem.out.print(\"{\"+it2.next()+\"}\");//\t\t}//\t\tSystem.out.println();\t\t//위에꺼 한문장으로\t\tmap.forEach((k,v)-&gt;System.out.print(\"{\"+k+\", \"+v+\"}\"));\t\tSystem.out.println();\t}}메소드 참조(method reference)  클래스이름 :: 메소드이름: 하나의 메소드만 호출하는 람다식을 ‘메소드 참조’로 더 간단히 할 수 있다            종류      람다      메소드 참조                  static메소드 참조      (x) → ClassName.method(x)      ClassName::method              인스턴스 메소드 참조      (obj,x) → obj.method(x)      ClassName::method              특정 객체 인스턴스 메소드 참조      (x)→ obj.method(x)      obj::method      import java.util.function.Function;class  Main{\tpublic static void main(String[] args)  {//\t\tFunction&lt;String, Integer&gt; f = (String s) -&gt; Integer.parseInt(s);\t\tFunction&lt;String, Integer&gt; f = Integer::parseInt; //메소드 참조. 위랑 같음\t\t\t\tSystem.out.println(f.apply(\"100\")+200); //f.apply(\"100\")이 숫자로 바뀜\t}}  생성자의 메소드 참조 - 클래스이름::new  배열과 메소드 참조 - 타입[]::newimport java.util.function.*;class  Main{\tpublic static void main(String[] args)  {\t\t//매개변수 없는 경우//\t\tSupplier&lt;MyClass&gt; s = ()-&gt;new MyClass(); //입력x, 출력o\t\tSupplier&lt;MyClass&gt; s = MyClass::new;\t\t\t\tMyClass mc = s.get(); //객체 값 반환\t\tSystem.out.println(mc); \t\tSystem.out.println(s.get()); //위랑 다른 새로운 객체 생성\t\t\t\t//매개변수 있는 경우//\t\tFunction &lt;Integer, MyClass2&gt; f = (i)-&gt;new MyClass2(i); //입력o, 출력o\t\tFunction &lt;Integer, MyClass2&gt; f = MyClass2::new;\t\t\t\tMyClass2 mc2 = f.apply(100);\t\tSystem.out.println(mc2.iv); \t\tSystem.out.println(f.apply(100).iv); \t\t//\t\tFunction&lt;Integer, int[]&gt; f2 = (i)-&gt;new int[i];\t\tFunction&lt;Integer, int[]&gt; f2 = int[]::new;\t\tint[] arr = f2.apply(500);\t\tSystem.out.println(arr.length); //길이가 500인 배열\t}}class MyClass{}class MyClass2{\tint iv;\tMyClass2(int iv){\t\tthis.iv=iv;\t}}스트림(Stream): 다양한 데이터 소스를 표준화한 방법으로 다루기 위한 것  스트림이 제공하는 기능 - 중간 연산과 최종 연산— 스트림 만들기 3단계      스트림만들기                  컬렉션 - Collection인터페이스의 stream()으로 컬렉션을 스트림으로 변환  Stream stream() //Collection인터페이스의 메소드            배열                              객체 배열로부터 스트림 생성하기  Stream Stream.of(가변인자) or Stream Arrays.stream(T[])                                기본형 배열로부터 스트림 생성하기(Stream이 아니라 IntStream)  IntStream IntStream.of(int….value) or IntStream Arrays.Stream(int[])                                      임의의 수(난수)를 요소로 갖는 스트림 생성          import java.util.Random;  import java.util.stream.IntStream;          class  Main{  \tpublic static void main(String[] args)  {        \t\t  \t\tIntStream intStream = new Random().ints();   \t\tintStream.limit(5).forEach(System.out::println);  \t\tSystem.out.println();  \t\tIntStream intStream2 = new Random().ints(5);   \t\tintStream2.forEach(System.out::println);  \t\tSystem.out.println();  \t\tIntStream intStream3 = new Random().ints(10,5,10);   \t\tintStream3.forEach(System.out::println);  \t}  }                            특정범위의 정수를 요소로 갖는 스트림 생성하기(IntStream, LongStream)  IntSream IntStream.range(int begin, int end)                    람다식으로 스트림만들기  static  Stream iterate(T seed, UnaryOperator f) //이전요소에 종속적    static  Stream generate(Supplier s) //이전요소에 독립적                              iterate() : 이전요소를 seed로 해서 다음 요소를 계산  Stream evenStream = Stream.iterate(0, n→n+2); //0,2,4,6,..                                generate() : seed를 사용하지 않음  Stream randomStream = Stream.generate(Math::random);    Stream oneStream = Stream.generate(()→1); //1,1,1,1,…..                            import java.util.Random;  import java.util.stream.IntStream;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\t//iterate(T seed, UnaryOperator f)  단항연산자  \t\tStream&lt;Integer&gt; intStream = Stream.iterate(0, n-&gt;n+2);  \t\tintStream.limit(10).forEach(System.out::println);  \t\tSystem.out.println();  \t\tStream&lt;Integer&gt; intStream2 = Stream.iterate(1, n-&gt;n+2);  \t\tintStream2.limit(10).forEach(System.out::println);  \t\tSystem.out.println();  \t\t//generate(Supplier s)  입력x, 출력o  \t\tStream&lt;Integer&gt; oneStream = Stream.generate(()-&gt;1);  \t\toneStream.limit(5).forEach(System.out::println);  \t}  }                            파일을 소스로 하는 스트림생성  Stream Files.list(Path dir); //Path는 파일 또는 디렉토리    Stream Files.lines(Path path)    Stream Files.lines(Path path, Charset cs)    Stream lines() //BufferedReader클래스의 메소드            비어있는 스트림 생성하기  Stream emptyStream = Stream.empty(); //empty()는 빈 스트림을 생성해서 반환  long count = emptyStream.count(); //count의 값은 0         List&lt;Integer&gt; list =Arrays.asList(1,2,3,4,5); \t\tStream&lt;Integer&gt; intStream = list.stream(); //컬렉션 \t\tStream&lt;String&gt; strStream = Stream.of(new String[] {\"a\",\"b\",\"c\"}); //배열 \t\tStream&lt;Integer&gt; evenStream = Stream.iterate(0,n-&gt;n+2); //0,2,4,6... \t\tStream&lt;Double&gt; randomStream = Stream.generate(Math::random);//람다식 \t\tIntStream intStream2 = new Random().ints(5); //난수 스트림. 크기가 5     //컬렉션으로 스트림 생성 \t\tintStream.forEach(System.out::print); //최종연산 //\tintStream.forEach(System.out::print); //최종연산을 해서 Stream이 닫힘    \t\t \t\tintStream=list.stream(); \t\tintStream.forEach(System.out::print); //최종연산         import java.util.Arrays; import java.util.stream.IntStream; import java.util.stream.Stream;     class  Main{ \tpublic static void main(String[] args)  { //\t\tList&lt;Integer&gt; list =Arrays.asList(1,2,3,4,5); //\t\tStream&lt;Integer&gt; intStream = list.stream(); //list를 Stream으로 변환 //\t\tintStream.forEach(System.out::print); //최종연산 ////\t\tintStream.forEach(System.out::print); //최종연산을 해서 Stream이 닫힘 //\t\t //\t\tintStream=list.stream(); //\t\tintStream.forEach(System.out::print); //최종연산    \t\t \t\tStream&lt;String&gt; strstream = Stream.of(new String[] {\"a\",\"b\",\"c\",\"d\"}); \t\tstrstream.forEach(System.out::println);    \t\t \t\t//기본형 \t\tint[] intArr = {1,2,3,4,5}; \t\tIntStream intStream = Arrays.stream(intArr); //\t\tintStream.forEach(System.out::println); //\t\tSystem.out.println(\"count = \"+intStream.count()); //최종연산 //\t\tSystem.out.println(\"sum = \"+intStream.sum()); //최종연산 \t\tSystem.out.println(\"avg = \"+intStream.average()); //최종연산    \t\t \t\t//참조형 //\t\tInteger[] intArr = {1,2,3,4,5}; //\t\tStream&lt;Integer&gt; intStream = Arrays.stream(intArr); //\t\tintStream.forEach(System.out::println); //\t\tSystem.out.println(\"count = \"+intStream.count()); //count말고 다른건 안됨(sum, avg 등) \t\t//Stream&lt;T&gt;는 숫자 외에도 여러타입의 스트림이 가능해서 숫자 스트림에서만 사용할 수 있는 sum(), average()는 뺌 \t} }        중간연산(0~n번) : 연산결과가 스트림인 연산. 반복적으로 적용가능          스트림 자르기 - skip(long n)[앞에서부터 n개 건너뛰기), limit()[잘라내기]      스트림의 요소 걸러내기- filter()[조건에 맞는요소만 남김], distinct()[중복제거]              스트림 정렬 - sorted()[정렬기준안주면 스트림요소의 기본정렬]                                      Comparator의 comparing()으로 정렬기준을 제공  comparing(Function&lt;T,U&gt; keyExteactor)  comparing(Function&lt;T,U&gt; keyExteactor, Comparator, keyComparetor)                                추가정렬기준을 제공할 때는 thenComparing()사용  thenComparing(Function&lt;T,U&gt; keyExteactor)  thenComparing(Function&lt;T,U&gt; keyExteactor, Comparator, keyComparetor)              import java.util.Comparator;  import java.util.stream.Stream;              class  Main{  \tpublic static void main(String[] args)  {  \t\tStream&lt;Student&gt; studentStream = Stream.of(  \t\t\t\tnew Student(\"이자바\",3,300),  \t\t\t\tnew Student(\"김자바\",1,200),  \t\t\t\tnew Student(\"안자바\",2,100),  \t\t\t\tnew Student(\"박자바\",2,150),  \t\t\t\tnew Student(\"소자바\",1,200),  \t\t\t\tnew Student(\"나자바\",3,290),  \t\t\t\tnew Student(\"감자바\",3,180));            \t\t  \t\tstudentStream.sorted(Comparator.comparing(Student::getBan) //반별정렬  \t\t\t\t.thenComparing(Comparator.naturalOrder()))//기본정렬  \t\t\t\t.forEach(System.out::println);  \t}  }              class Student implements Comparable&lt;Student&gt;{  \tString name;  \tint ban;  \tint totalScore;            \t  \tStudent(String name, int ban, int totalScore){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.totalScore=totalScore;  \t}  \tpublic String toString() {  \t\treturn String.format(\"[%s, %d, %d]\",name,ban,totalScore);  \t}            \t  \tString getName() {return name;}  \tint getBan() {return ban;}  \tint getTotalScore() {return totalScore;}            \t  \t//총점 내림차순을 기본정렬로 한다  \tpublic int compareTo(Student s) {  \t\treturn s.totalScore - this.totalScore;  \t}  }                                          스트림의 요소 변환 - map()              forEach(의 중간연산버전(스트림소비x : 반환타입 void) - peek() : 중간점검          import java.io.File;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\tFile fileArr[] = { new File(\"Ex1.java\"), new File(\"Ex1.bak\"), new File(\"ex2.java\"), new File(\"java\"), new File(\"Ex1.txt\")};  \t\tStream&lt;File&gt; fileStream = Stream.of(fileArr);  \t\t//map()으로 Stream&lt;File&gt;을 Stream&lt;String&gt;으로 변환  \t\tStream&lt;String&gt; filenameStream = fileStream.map(File::getName);  \t\tfilenameStream.forEach(System.out::println); //모든 파일이름 출력        \t\t  \t\tfileStream = Stream.of(fileArr); //스트림 재생성  \t\tfileStream.map(File::getName)  \t\t\t.filter(s-&gt;s.indexOf('.')!=-1)///확장자가 없는 것 제외  \t\t\t.peek(s-&gt;System.out.printf(\"filename=%s%n\",s))  \t\t\t.map(s-&gt;s.substring((s.indexOf('.')+1))) //확장자만 추출  \t\t\t.peek(s-&gt;System.out.printf(\"extension=%s%n\",s))  \t\t\t.map(String::toUpperCase) //모두 대문자로 변환  \t\t\t.distinct() //중복제거  \t\t\t.forEach(System.out::print); //JAVABAKTXT        \t\t  \t\tSystem.out.println();        \t\t  \t}  }                            스트림의 스트림을 스트림으로 변환 : 여러 스트림 배열을 하나의 스트림배열로 변환 - flatmap()          import java.io.File;  import java.util.Arrays;  import java.util.stream.Stream;          class  Main{  \tpublic static void main(String[] args)  {  \t\tStream&lt;String[]&gt; strArrStrm = Stream.of(  \t\t\t\tnew String[] {\"abc\",\"def\",\"jkl\"},  \t\t\t\tnew String[] {\"ABC\",\"GHI\",\"JKL\"}  \t\t\t\t);        \t\t  //\t\tStream&lt;Stream&lt;String&gt;&gt; strStrmStrm = strArrStrm.map(Arrays::stream);  //\t\tstrStrmStrm.forEach(System.out::println);  //\t\tSystem.out.println();  \t\t//두 스트림배열을 하나의 스트림배열로 합침  \t\tStream&lt;String&gt; strStrm = strArrStrm.flatMap(Arrays::stream);        \t\t  \t\tstrStrm.map(String::toLowerCase) //대문자-&gt;소문자  \t\t.distinct()  \t\t.sorted()  \t\t.forEach(System.out::println);  \t\tSystem.out.println();        \t\t  \t\tString lineArr[] = {  \t\t\t\t\"Believe or not It is true\",  \t\t\t\t\"Do or not There is no try\"  \t\t};        \t\t  \t\tStream&lt;String&gt; lineStream = Arrays.stream(lineArr);  \t\tlineStream.flatMap(line -&gt; Stream.of(line.split(\" +\")))  \t\t.map(String::toLowerCase)  \t\t.distinct()  \t\t.sorted()  \t\t.forEach(System.out::println);  \t}  }                          최종연산(1번) : 연산결과가 스트림이 아닌 연산. 단 한번만 적용가능(스트림의 요소를 소모)          스트림의 모든 요소에 지정된 작업을 수행 - forEach(), forEachOrdered()                  sequential() : 직렬스트림(생략가능)          parallel() : 병렬 스트림 (순서보장x) - forEachOrdered를 써야 순서유지가 됨                    조건검사                  allMatch() : 모든 요소가 조건을 만족시키면 true          anyMatch() : 한 요소라도 조건을 만족시키면 true          noneMatch() : 모든 요소가 조건을 만족시키지 않으면 true          findFirst() : 첫번째 요소를 반환, 순차 스트림에 사용(결과가 null일수도 있어 Optional사용)          findAny() : 아무거나 하나를 반환, 병렬 스트림에 이용(결과가 null일수도 있어 Optional사용)                    reduce() : 스트림의 요소를 하나씩 줄여가며 누적연산 수행 (count, max, min, sum, collect는 reduce를 바탕으로 만든것). 전체 리듀싱                  identity : 초기값(대부분 0)          accumulator : 이전연산결과와 스트림의 요소에 수행할 연산                       import java.util.Optional; import java.util.OptionalInt; import java.util.stream.IntStream; import java.util.stream.Stream;     class  Main{ \tpublic static void main(String[] args)  { \t\tString strArr[] = { \t\t\t\t\"Ingeritance\",\"Java\",\"Lambda\",\"stream\",\"OptionalDouble\", \t\t\t\t\"IntStream\",\"count\",\"sum\", \t\t\t\t}; \t\tStream.of(strArr) \t\t.parallel() //병렬정렬 \t\t.forEachOrdered(System.out::println); //순서유지 \t\tSystem.out.println(\"---------------------------\");    \t\t \t\tboolean noEmptyStr = Stream.of(strArr).noneMatch(s-&gt;s.length()==0); //문자열길이가 0인게 없으면 true //\t\tOptional&lt;String&gt; sWord = Stream.of(strArr).parallel().filter(s-&gt;s.charAt(0)=='s').findAny(); //시작이 's'인 것 중 아무거나 가져옴 - 실행할때마다 값이 다름 \t\tOptional&lt;String&gt; sWord = Stream.of(strArr).filter(s-&gt;s.charAt(0)=='s').findFirst(); //시작이 's'인 것 중 첫번째 거만 가져옴    \t\t \t\tSystem.out.println(\"noEmptyStr=\"+noEmptyStr); \t\tSystem.out.println(\"-----------------\"); \t\tSystem.out.println(\"sWord=\"+sWord.get()); \t\tSystem.out.println(\"---------------------------\");    \t\t \t\t//Stream&lt;String&gt;을 String&lt;Integer&gt;로 변환 //\t\tStream&lt;Integer&gt; intStream = Stream.of(strArr).map(String::length);    \t\t \t\t//Stream&lt;String[]&gt;을 IntStream으로 변환. 성능이 더 놓음 \t\tIntStream intStream1 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream2 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream3 = Stream.of(strArr).mapToInt(String::length); \t\tIntStream intStream4 = Stream.of(strArr).mapToInt(String::length);    \t    \t\t \t\tint count = intStream1.reduce(0,(a,b)-&gt;a+1); \t\tint sum = intStream2.reduce(0,(a,b)-&gt;a+b); //단어길이 모두 더하기    \t\t \t\tOptionalInt max = intStream3.reduce(Integer::max); //가장긴거 \t\tOptionalInt min = intStream4.reduce(Integer::min); //가장 짧은거 \t\tOptionalInt max2 = IntStream.empty().reduce(Integer::max); //가장긴거 \t\tSystem.out.println(\"count = \"+count); \t\tSystem.out.println(\"sum = \"+sum); \t\tSystem.out.println(\"max = \"+max.getAsInt()); \t\tSystem.out.println(\"min = \"+min.getAsInt()); \t\tSystem.out.println(\"max2 = \"+max2.orElse(0)); //결과가 없으면 0을 반환 \t\tSystem.out.println(\"max2 = \"+max2.orElseGet(()-&gt;0)); //결과가 없으면 0을 반환 \t} }                      collect() : Collector(interface)를 매개변수로 하는 스트림의 최종 연산. 그룹별 리듀싱이 가능함                  Collector : 수집(collect)에 필요한 메소드를 정의해 놓은 인터페이스, Collectors클래스에서 구현해놔서 다 할 필요 없음                  interface Collector&lt;T, A, R&gt;{//T(요소)를 A에 누적한 다음, 결과를 R로 변환해서 반환  \tSupplier&lt;A&gt;\t\t\t\tsupplier(); //StringBuilder::new  누적할 곳 - A  \tBiConsumer&lt;A, T&gt;\t\taccumulator();//(sb, s)-&gt;sb.appens(s) 누적방법  \tBinaryOperator&lt;A&gt;\t\tcombiner();//(sb1,sb2)-&gt;sb1.append(sb2) 결합방법(병렬)  \tFunction&lt;A, R&gt; \t\t\tfinisher();//sb-&gt;ab.toString() 최종변환  \tSet&lt;Characteristics&gt; \tcharacteristics();//컬렉터의 특성이 담긴 set을 반환 - R  }                                      Collectors : 클래스. 다양한 기능의 컬렉터(Collector를 구현한 클래스)를 제공                          변환 - mapping(), toList(), toSet(), toCollection() 등              통계 - counting(), summingInt(), averagingInt(), maxBy(), minBy(), summarizingInt() 등              문자열 결합 - joining()              리듀싱 - reducing() : 그룹별 리듀싱 가능              그룹화와 분할 - groupingBy(), partitioningBy(), collectingAndThen()                        — 스트림을 컬렉션으로 변환 - toList(), toSet(), toMap(), toCollection()            Collectors.toList() 이렇게 사용함            — 스트림을 배열로 변환 - toArray()                              ex) stream.distinct().limit(5).sorted().forEach(System.out::println)Stream&lt;String&gt; stream = Stream.of(strArr); //문자열배열이 소스인 스트림생성\t\tStream&lt;String&gt; filteredStream = stream.filter(); //걸러내기(중간연산)\t\tStream&lt;String&gt; distinctedStream = stream.distinct(); //중복 제거(중간연산)\t\tStream&lt;String&gt; sortedStream = stream.sorted();//정렬(중간연산)\t\tStream&lt;String&gt; limitedStream = stream.limit(5);//스트림자르기(중간연산);\t\tint total = stream.count(); //요소 개수 세기(최종연산)  스트림의 특징          데이터소스로부터 데이터를 읽기만 할 뿐, 변경하지 않음(원본을 건들지 않음. read only)      Iterator처럼 일회용이다(필요하면 다시 스트림을 생성해야함) : 최종연산 후 스트림이 닫혀 사용할 수 없음      최종연산 전까지 중간연산이 수행되지 않는다. - 지연된 연산      작업을 내부 반복으로 처리한다.      작업을 병렬로 처리 - stream.parallel() : 병렬스트림으로 전환(속성만 변경)      기본형 스트림 - IntStream, LongStream, DoubleStream                  오토박싱&amp;언박싱의 비효율이 제거(Stream대신 IntStream사용) - 데이터소스가 기본형일때 사용가능          숫자와 관련된 유용한 메소드를 Stream보다 더 많이 제공                          스트림의 그룹화와 분할                  partitioningBy()는 스트림을 2분할함(다중분할 가능)          import java.util.*;  import java.util.function.*;  import java.util.stream.*;  import static java.util.stream.Collectors.*;  import static java.util.Comparator.*;          class Student{  \tString name;  \tboolean isMale; // 성별  \tint hak;        // 학년  \tint ban;        // 반  \tint score;          \tStudent(String name, boolean isMale, int hak, int ban, int score) {   \t\tthis.name\t= name;  \t\tthis.isMale\t= isMale;  \t\tthis.hak\t= hak;  \t\tthis.ban\t= ban;  \t\tthis.score  = score;  \t}  \tString\tgetName()    { return name;\t}  \tboolean  isMale()     { return isMale;\t}  \tint      getHak()     { return hak;\t}  \tint      getBan()     { return ban;\t}  \tint      getScore()   { return score;}        \t  \tpublic String toString() {  \t\treturn String.format(\"[%s, %s, %d학년 %d반, %3d점]\",name, isMale ? \"남\":\"여\", hak, ban, score);   \t}        \t  \t   // groupingBy()에서 사용  \t\tenum Level { HIGH, MID, LOW }  // 성적을 상, 중, 하 세 단계로 분류  }  class  Main{  \tpublic static void main(String[] args)  {  \t\tStudent[] stuArr = {  \t\t\t\tnew Student(\"나자바\", true,  1, 1, 300),\t  \t\t\t\tnew Student(\"김지미\", false, 1, 1, 250),\t  \t\t\t\tnew Student(\"김자바\", true,  1, 1, 200),\t  \t\t\t\tnew Student(\"이지미\", false, 1, 2, 150),\t  \t\t\t\tnew Student(\"남자바\", true,  1, 2, 100),\t  \t\t\t\tnew Student(\"안지미\", false, 1, 2,  50),\t  \t\t\t\tnew Student(\"황지미\", false, 1, 3, 100),\t  \t\t\t\tnew Student(\"강지미\", false, 1, 3, 150),\t  \t\t\t\tnew Student(\"이자바\", true,  1, 3, 200),\t  \t\t\t\tnew Student(\"나자바\", true,  2, 1, 300),\t  \t\t\t\tnew Student(\"김지미\", false, 2, 1, 250),\t  \t\t\t\tnew Student(\"김자바\", true,  2, 1, 200),\t  \t\t\t\tnew Student(\"이지미\", false, 2, 2, 150),\t  \t\t\t\tnew Student(\"남자바\", true,  2, 2, 100),\t  \t\t\t\tnew Student(\"안지미\", false, 2, 2,  50),\t  \t\t\t\tnew Student(\"황지미\", false, 2, 3, 100),\t  \t\t\t\tnew Student(\"강지미\", false, 2, 3, 150),\t  \t\t\t\tnew Student(\"이자바\", true,  2, 3, 200)\t  \t\t\t};  \t\tSystem.out.printf(\"1. 단순분할(성별로 분할)%n\");  \t\tMap&lt;Boolean, List&lt;Student&gt;&gt; stuBySex =  Stream.of(stuArr).collect(partitioningBy(Student::isMale));        \t\t  \t\tList&lt;Student&gt; maleStudent   = stuBySex.get(true);  \t\tList&lt;Student&gt; femaleStudent = stuBySex.get(false);        \t\t  \t\tfor(Student s : maleStudent)   System.out.println(s);  \t\tfor(Student s : femaleStudent) System.out.println(s);        \t\t  \t\tSystem.out.printf(\"%n2. 단순분할 + 통계(성별 학생수)%n\");  \t\tMap&lt;Boolean, Long&gt; stuNumBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale, counting()));\t          \t\tSystem.out.println(\"남학생 수 :\"+ stuNumBySex.get(true));  \t\tSystem.out.println(\"여학생 수 :\"+ stuNumBySex.get(false));        \t\t  \t\tSystem.out.printf(\"%n3. 단순분할 + 통계(성별 1등)%n\");  \t\tMap&lt;Boolean, Optional&lt;Student&gt;&gt; topScoreBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale, maxBy(comparingInt(Student::getScore))));  \t\tSystem.out.println(\"남학생 1등 :\"+ topScoreBySex.get(true));  \t\tSystem.out.println(\"여학생 1등 :\"+ topScoreBySex.get(false));        \t  \t\tMap&lt;Boolean, Student&gt; topScoreBySex2 = Stream.of(stuArr).collect(partitioningBy(Student::isMale,collectingAndThen(maxBy(comparingInt(Student::getScore)), Optional::get)));  \t\tSystem.out.println(\"남학생 1등:\"+topScoreBySex.get(true));  \t\tSystem.out.println(\"여학생 1등:\"+topScoreBySex.get(false));        \t\t  \t\tSystem.out.printf(\"%n4.다중분할(성적 불합격자, 100점 이하)%n\");        \t\t  \t\tMap&lt;Boolean, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; failedstuBySex = Stream.of(stuArr).collect(partitioningBy(Student::isMale,partitioningBy(s-&gt;s.getScore()&lt;=100)));        \t\t  \t\tList&lt;Student&gt; failedMaleStu   = failedstuBySex.get(true).get(true);  \t\tList&lt;Student&gt; failedFemaleStu = failedstuBySex.get(false).get(true);        \t\t  \t\tfor(Student s : failedMaleStu)   System.out.println(s);  \t\tfor(Student s : failedFemaleStu) System.out.println(s);        \t  \t}  }                            groupingBy()는 스트림을 n분할함                import java.util.*;  import java.util.function.*;  import java.util.stream.*;  import static java.util.stream.Collectors.*;  import static java.util.Comparator.*;      class Student3 {  \tString name;  \tboolean isMale; // 성별  \tint hak;        // 학년  \tint ban;        // 반  \tint score;      \tStudent3(String name, boolean isMale, int hak, int ban, int score) {   \t\tthis.name\t= name;  \t\tthis.isMale\t= isMale;  \t\tthis.hak   \t= hak;  \t\tthis.ban\t= ban;  \t\tthis.score \t= score;  \t}      \tString\tgetName() \t { return name;    }  \tboolean isMale()  \t { return isMale;  }  \tint\t\tgetHak()   \t { return hak;\t   }  \tint\t\tgetBan()  \t { return ban;\t   }  \tint\t\tgetScore()\t { return score;   }      \tpublic String toString() {  \t\treturn String.format(\"[%s, %s, %d학년 %d반, %3d점]\", name, isMale ? \"남\" : \"여\", hak, ban, score);  \t}      \tenum Level {  \t\tHIGH, MID, LOW  \t}  }      class Main {  \tpublic static void main(String[] args) {  \t\tStudent3[] stuArr = {  \t\t\tnew Student3(\"나자바\", true,  1, 1, 300),\t  \t\t\tnew Student3(\"김지미\", false, 1, 1, 250),\t  \t\t\tnew Student3(\"김자바\", true,  1, 1, 200),\t  \t\t\tnew Student3(\"이지미\", false, 1, 2, 150),\t  \t\t\tnew Student3(\"남자바\", true,  1, 2, 100),\t  \t\t\tnew Student3(\"안지미\", false, 1, 2,  50),\t  \t\t\tnew Student3(\"황지미\", false, 1, 3, 100),\t  \t\t\tnew Student3(\"강지미\", false, 1, 3, 150),\t  \t\t\tnew Student3(\"이자바\", true,  1, 3, 200),\t  \t\t\tnew Student3(\"나자바\", true,  2, 1, 300),\t  \t\t\tnew Student3(\"김지미\", false, 2, 1, 250),\t  \t\t\tnew Student3(\"김자바\", true,  2, 1, 200),\t  \t\t\tnew Student3(\"이지미\", false, 2, 2, 150),\t  \t\t\tnew Student3(\"남자바\", true,  2, 2, 100),\t  \t\t\tnew Student3(\"안지미\", false, 2, 2,  50),\t  \t\t\tnew Student3(\"황지미\", false, 2, 3, 100),\t  \t\t\tnew Student3(\"강지미\", false, 2, 3, 150),\t  \t\t\tnew Student3(\"이자바\", true,  2, 3, 200)\t  \t\t};      \t\tSystem.out.printf(\"1. 단순그룹화(반별로 그룹화)%n\");  \t\tMap&lt;Integer, List&lt;Student3&gt;&gt; stuByBan = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getBan));      \t\tfor(List&lt;Student3&gt; ban : stuByBan.values()) {  \t\t\tfor(Student3 s : ban) {  \t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}      \t\tSystem.out.printf(\"%n2. 단순그룹화(성적별로 그룹화)%n\");  \t\tMap&lt;Student3.Level, List&lt;Student3&gt;&gt; stuByLevel = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(s-&gt; {  \t\t\t\t\t\t if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\telse                         return Student3.Level.LOW;  \t\t\t\t}));      \t\tTreeSet&lt;Student3.Level&gt; keySet = new TreeSet&lt;&gt;(stuByLevel.keySet());      \t\tfor(Student3.Level key : keySet) {  \t\t\tSystem.out.println(\"[\"+key+\"]\");      \t\t\tfor(Student3 s : stuByLevel.get(key))  \t\t\t\tSystem.out.println(s);  \t\t\tSystem.out.println();  \t\t}      \t\tSystem.out.printf(\"%n3. 단순그룹화 + 통계(성적별 학생수)%n\");  \t\tMap&lt;Student3.Level, Long&gt; stuCntByLevel = Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(s-&gt; {  \t\t\t\t\t     if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\telse                         return Student3.Level.LOW;  \t\t\t\t}, counting()));  \t\tfor(Student3.Level key : stuCntByLevel.keySet())  \t\t\tSystem.out.printf(\"[%s] - %d명, \", key, stuCntByLevel.get(key));  \t\tSystem.out.println();  /*  \t\tfor(List&lt;Student3&gt; level : stuByLevel.values()) {  \t\t\tSystem.out.println();  \t\t\tfor(Student3 s : level) {  \t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}  */  \t\tSystem.out.printf(\"%n4. 다중그룹화(학년별, 반별)\");  \t\tMap&lt;Integer, Map&lt;Integer, List&lt;Student3&gt;&gt;&gt; stuByHakAndBan =            Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getHak,  \t\t\t\t\t\t groupingBy(Student3::getBan)  \t\t\t\t));      \t\tfor(Map&lt;Integer, List&lt;Student3&gt;&gt; hak : stuByHakAndBan.values()) {  \t\t\tfor(List&lt;Student3&gt; ban : hak.values()) {  \t\t\t\tSystem.out.println();  \t\t\t\tfor(Student3 s : ban)  \t\t\t\t\tSystem.out.println(s);  \t\t\t}  \t\t}      \t\tSystem.out.printf(\"%n5. 다중그룹화 + 통계(학년별, 반별 1등)%n\");  \t\tMap&lt;Integer, Map&lt;Integer, Student3&gt;&gt; topStuByHakAndBan =            Stream.of(stuArr)  \t\t\t\t.collect(groupingBy(Student3::getHak,  \t\t\t\t\t\t groupingBy(Student3::getBan,  \t\t\t\t\t\t     collectingAndThen(  \t\t\t\t\t\t         maxBy(comparingInt(Student3::getScore))  \t\t\t\t\t\t         , Optional::get  \t\t\t\t\t\t     )  \t\t\t\t\t\t )  \t\t\t\t));      \t\tfor(Map&lt;Integer, Student3&gt; ban : topStuByHakAndBan.values())  \t\t\tfor(Student3 s : ban.values())  \t\t\t\tSystem.out.println(s);      \t\tSystem.out.printf(\"%n6. 다중그룹화 + 통계(학년별, 반별 성적그룹)%n\");  \t\tMap&lt;String, Set&lt;Student3.Level&gt;&gt; stuByScoreGroup = Stream.of(stuArr)  \t\t\t.collect(groupingBy(s-&gt; s.getHak() + \"-\" + s.getBan(),  \t\t\t\t\tmapping(s-&gt; {  \t\t\t\t\t\t if(s.getScore() &gt;= 200) return Student3.Level.HIGH;  \t\t\t\t\telse if(s.getScore() &gt;= 100) return Student3.Level.MID;  \t\t\t\t\t\t else                    return Student3.Level.LOW;  \t\t\t\t\t} , toSet())  \t\t\t));      \t\tSet&lt;String&gt; keySet2 = stuByScoreGroup.keySet();      \t\tfor(String key : keySet2) {  \t\t\tSystem.out.println(\"[\"+key+\"]\" + stuByScoreGroup.get(key));  \t\t}  \t}    }      Optional: T타입 객체의 래퍼클래스. null을 간접적으로 사용하기 위해 씀null을 Optional객체 안에 넣어서 사용. null값이 필요할떄 빈Optional객체의 주소값을 받음  Optional객체의 값 가지고 오기 - get(), orElse(), orElseGet(), orElseThrow()  isPresent() : Optional객체의 값이 null이면 false, 아니면 true - null이 아닐때만 작업 수행— 사용이유  null을 직접 다루는 것은 위험 - nullPointException 위험 → 간접적으로 null을 사용하기 위해 사용  null체크는 if문 필수 : 코드가 지저분해짐 → 코드를 깔끔히 하기위해 사용import java.util.Optional;class  Main{\tpublic static void main(String[] args)  {//\t\tint arr[] = null; //nullpointException발생\t\tint arr[] = new int[0];\t\tSystem.out.println(\"arr.length = \"+arr.length);\t\t//\t\tOptional&lt;String&gt; opt = null; //가능한데 바람직하지않음\t\tOptional&lt;String&gt; opt = Optional.empty();//\t\tOptional&lt;String&gt; opt = Optional.of(\"abc\");\t\tSystem.out.println(\"opt=\"+opt);//\t\tSystem.out.println(\"opt.get()=\"+opt.get()); //에러. 값이없어서. 이래서 잘 안씀//\t\tString str = \"\";//\t\ttry {//\t\t\tstr = opt.get(); //\t\t} catch (Exception e) {//\t\t\tstr = \"\"; //예외 발생시 빈문자열(\"\")로 초기화//\t\t}//\t\tSystem.out.println();\t\t\t\t//Optional에 저장된 값이 null이면 \"\"반환//\t\tString str = opt.orElse(\"\");//\t\tString str = opt.orElseGet(()-&gt;new String());\t\tString str = opt.orElseGet(String::new);\t\tSystem.out.println(\"str=\"+str);\t}}      기본형을 감싸는 래퍼클래스 - OptionalInt, OptionalLong, OptionalDouble - Optional를 써도 되지만 성능이 떨어짐                            Optional클래스          값을 반환하는 메소드                                      Optional          T get()                          OptionalInt          int gerAsInt()                          OptionalLong          long gerAsLong()                          OptionalDouble          double getAsDouble()                            빈 Optional객체와의 비교 - OptionalInt.of(0)과 OptionalInt.empty() 구별에 isPresent()를 사용  OptionalInt.of(0)은 true, OptionalInt.empty()는 false. 두개 equals해도 false나옴          import java.util.Optional;  import java.util.OptionalInt;      class  Main{  \tpublic static void main(String[] args)  {  \t\tOptional&lt;String&gt; optStr = Optional.of(\"abcde\");  \t\tOptional&lt;Integer&gt; optInt = optStr.map(String::length);  \t\tSystem.out.println(\"optStr=\"+optStr.get());  \t\tSystem.out.println(\"optInt=\"+optInt.get());    \t\t  \t\tint result1 = Optional.of(\"123\")  \t\t\t\t.filter(x-&gt;x.length() &gt;0)  \t\t\t\t.map(Integer::parseInt).get();    \t\t  \t\tint result2 = Optional.of(\"\")  \t\t\t\t.filter(x-&gt;x.length() &gt;0) //false  \t\t\t\t.map(Integer::parseInt).orElse(-1); //값이 없으면 -1 반환    \t\t  \t\tSystem.out.println(\"result1 = \"+result1);  \t\tSystem.out.println(\"result2 = \"+result2);    \t\t  \t\tOptional.of(\"456\").map(Integer::parseInt)  \t\t.ifPresent(x-&gt;System.out.printf(\"result3 = %d%n\",x)); //ifPresent : 값이 있으면    \t\t  \t\tOptionalInt optInt1 = OptionalInt.of(0); //0을 저장  \t\tOptionalInt optInt2 = OptionalInt.empty(); //빈 객체 생성    \t\t  \t\tSystem.out.println(optInt1.isPresent()); //true  \t\tSystem.out.println(optInt2.isPresent()); //false  \t\tSystem.out.println(\"optInt1=\"+optInt1);  \t\tSystem.out.println(\"optInt2=\"+optInt2);  \t\tSystem.out.println(\"opt1.equals(optInt2)?\"+optInt1.equals(optInt2));//false  \t}  }      "
  },
  
  {
    "title": "쓰레드(thread)",
    "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C(thread)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 쓰레드",
    "date": "2022-08-28 00:00:00 +0900",
    





    
    "snippet": "프로세스와 쓰레드(process &amp; thread)  프로세스 : 실행중인 프로그램. 자원(resources)과 쓰레드로 구성 (공장)  쓰레드 : 프로세스 내에서 실제 작업을 수행. 모든 프로세서는 최소 하나의 쓰레드를 가지고 있다. (일꾼)      싱글 쓰레드 프로세스 = 자원 + 쓰레드      public class  Main {    ...",
    "content": "프로세스와 쓰레드(process &amp; thread)  프로세스 : 실행중인 프로그램. 자원(resources)과 쓰레드로 구성 (공장)  쓰레드 : 프로세스 내에서 실제 작업을 수행. 모든 프로세서는 최소 하나의 쓰레드를 가지고 있다. (일꾼)      싱글 쓰레드 프로세스 = 자원 + 쓰레드      public class  Main {      \tpublic static void main(String[] args) {  \t\tlong startTime = System.currentTimeMillis();    \t\t  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.printf(\"%s\", new String(\"-\"));  \t\t}    \t\t  \t\tSystem.out.println(\"소요시간 1 : \"+(System.currentTimeMillis()-startTime));    \t\t  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.printf(\"%s\", new String(\"|\"));  \t\t}  \t\tSystem.out.println(\"소요시간 2 : \"+(System.currentTimeMillis()-startTime));  \t} // 싱글쓰레드라 작업이 겹치지 않음  }        멀티 쓰레드 프로세스 = 자원 + 쓰레드 + 쓰레드…+쓰레드 (대부분이 멀티쓰레드)          장점                  시스템 자원을 보다 효율적으로 사용가능          사용자에 대한 응답성(responsencess)이 향상된다.          작업이 분리되어 코드가 간결해짐                            단점 : 고려할 사항이 많음                  동기화(synchronization)에 주의          교착상태(dead-lock)가 발생하지 않도록 주의          각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야함          context switching(쓰레드 전환)으로 시간이 좀 더 걸림                  public class  Main {          \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tThread2 t2 = new Thread2();  \t\tt1.start();  \t\tt2.start();  \t}   }          class Thread1 extends Thread{  \tpublic void run () {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t}  }  class Thread2 extends Thread{  \tpublic void run () {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(\"|\");  \t\t}  \t}  }  //멀티쓰레드라 번갈아가면서 실행됨                  public class  Main {  \tstatic long startTime = 0;          \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tt1.start();   \t\tstartTime = System.currentTimeMillis();        \t\t  \t\tfor(int i=0; i&lt;300; i++)   \t\t\tSystem.out.printf(\"%s\",new String(\"-\"));        \t\t  \t\tSystem.out.println(\"소요시간1 : \"+(System.currentTimeMillis() - startTime));  \t}  }          class Thread1 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++)   \t\t\tSystem.out.printf(\"%s\", new String(\"|\"));        \t\t  \t\tSystem.out.println(\"소요시간2 : \"+(System.currentTimeMillis() - Main.startTime));  \t}  }  // 멀티쓰레드라 번갈아가면서 실행됨                      쓰레드 구현과 실행                  Thread클래스를 상속(자바는 단일상속만 허용해서 쓰레드를 상속받으면 다른 것은 상속받을수 없음  class MyThread wxtends Thread { public void run(){ /Thread클래스의 run()을 오버라이딩/ }}  MyThread t = new MyThread(); //쓰레드 생성  t1.start(); //쓰레드의 실행                    Runnable인터페이스를 구현        class TyThread implements Runnable { public void run() { /Runnable인터페이스의 추상메소드 run()을 구현/}}  Runnable r = new MyThread();  Thread t = new Thread(r); //Thread(Runnable r)  //Thread t = new Thread(new MyThread()); //위에꺼 한줄로 줄임  t.start();                  쓰레드의 실행 - start() : 쓰레드를 생성한 후에 start를 호출해야 쓰레드가 작업을 시작함    — 각각의 쓰레드가 각각의 호출 스택을 가지고 있어 서로 독립적으로 작업을 수행함      public class  Main {  \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();    \t\t  \t\tRunnable r = new Thread2();  \t\tThread t2 = new Thread(r);  //생성자 Thread(Runnable target)    \t\t  \t\tt1.start(); //start했다고 바로 실행 안됨  \t\tt2.start(); //OS의 스케줄러가 실행순서를 결정. t1이 먼저 실행될 확률이 높기는 하나 100프로는 아님  \t}  }      class Thread1 extends Thread { //쓰레드 클래스를 상속해서 구현  \tpublic void run() { //쓰레드가 수행할 작업을 작성  \t\tfor(int i=0; i&lt;500; i++) {  \t\t\tSystem.out.print(getName()); //조상인 Thread의 getName()을 호출  \t\t}  \t}  }      class Thread2 implements Runnable{ //Runnable인터페이스를 구현해서 쓰레드를 구현  \tpublic void run() { ////쓰레드가 수행할 작업을 작성  \t\tfor(int  i=0;i&lt;500;i++) {  \t\t\t//Thread.currentThread() - 현재 실행중인 Thread를 반환  \t\t\tSystem.out.print(Thread.currentThread().getName());  \t\t}  \t}  }  //순서대로 실행되는게 아니라 번갈아서 실행됨        start()와 run()      main쓰레드 : main메소드의 코드를 수행하는 쓰레드.      public class  Main {  \tstatic long startTime = 0;      \tpublic static void main(String[] args) {  \t\tThread1 t1 = new Thread1();  \t\tThread2 t2 = new Thread2();  \t\tt1.start();   \t\tt2.start();   \t\tstartTime = System.currentTimeMillis();    \t\t  \t\ttry {  \t\t\tt1.join(); //main쓰레드가 th1의 작업이 끝날 떄까지 기다린다.  \t\t\tt2.join(); //main쓰레드가 th2의 작업이 끝날 때까지 기다린다.  \t\t}catch(InterruptedException e) {}    \t\t  \t\tSystem.out.println(\"소요시간 : \"+(System.currentTimeMillis() - startTime));  \t}  }      class Thread1 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t}  }  class Thread2 extends Thread {   \tpublic void run() {   \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"|\");   \t\t}  \t}  }              사용자 쓰레드                  메인쓰레드.          실행중인 사용자쓰레드가 하나도 없을때, 프로그램 종료                            데몬 쓰레드(daemon Thread)                  일반 쓰레드(non-daemon thread)의 작업을 돕는 보조적인 역할을 수행          일반쓰레드가 모두 종료되면 자동적으로 종료된다          가비지 컬렉터(쓰지않는 메모리 정리), 자동저장, 화면 자동갱신 등에 사용됨          무한루프와 조건문(while(true) 등)을 이용해서 실행 후 대기하다가 특정조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다.                  boolean inDaemon() //쓰레드가 데몬 쓰레드인지 확인. 데몬쓰레드이면 true반환  void setDaemon(boolean on) //쓰레드를 데몬쓰레드로 또는 사용자 쓰레드로 변경. 매개변수 on을 true로 지정하면 데몬쓰레드가 된다.                  public class  Main implements Runnable {  \tstatic boolean autoSave = false;          \tpublic static void main(String[] args) {  \t\tThread t = new Thread(new Main()); //Thread(Runnable r)  \t\tt.setDaemon(true); //이부분이 없이면 종료되지 않음  \t\tt.start();        \t\t  \t\tfor(int i=1;i&lt;=10;i++) {  \t\t\ttry {  \t\t\t\tThread.sleep(1000);  \t\t\t}catch (InterruptedException e) {}  \t\t\tSystem.out.println(i);        \t\t\t  \t\t\tif(i==5) autoSave = true;  \t\t}  \t\tSystem.out.println(\"프로그램을 종료합니다.\");  \t}  \tpublic void run() {  \t\twhile(true) { //무한루프지만 메인쓰레드가 종료되면(일반쓰레드가 하나도 없으면) 같이 종료될 예정임(데몬쓰레드라서)  \t\t\ttry {  \t\t\t\tThread.sleep(3*1000);//3초마다  \t\t\t}catch(InterruptedException e) {}        \t\t\t  \t\t\tif(autoSave) autoSave();  \t\t}  \t}  \tprivate void autoSave() {  \t\tSystem.out.println(\"파일이 자동저장되었습니다\");  \t}\t  }                          쓰레드의 I/O블락킹(blocking) : 사용자가 입력할때까지 아무것도 하지않고 멈춤(멀티쓰레드는 이때에 다른 쓰레드가 일하면 됨)  ⇒ 멀티쓰레드일때 더 빠름          싱글쓰레드          import javax.swing.JOptionPane;      public class  Main {      \tpublic static void main(String[] args) {  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은 \" +input+\"입니다.\");    \t\t  \t\tfor(int i=10; i&gt;0; i--) {  \t\t\tSystem.out.println(i);  \t\t\ttry {  \t\t\t\tThread.sleep(100); //1초간 정지  \t\t\t}catch (Exception e) {}  }  \t}  }              멀티쓰레드          import javax.swing.JOptionPane;      public class  Main {      \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tth1.start();    \t\t  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은 \" +input+\"입니다.\");    \t\t  \t\t}\t  \t}      class Thread1 extends Thread{  \tpublic void run() {  \t\tfor(int i=10; i&gt;0; i--) {  \t\t\tSystem.out.println(i);  \t\t\ttry {  \t\t\t\tThread.sleep(100); //1초간 정지  \t\t\t}catch (Exception e) {}  \t\t}  \t}  }  //입력을 안해도 카운트다운이 진행됨. -&gt; 프로그램 먼저 종료            쓰레드의 우선순위(priority of thread) : 작업의 중요도에 따라 쓰레드의 우선순위를 다르게 하여 특정 쓰레드가 더 많은 작업시간을 갖게 할 수 있다. (1~10까지 부여. 10이 최대 우선순위, 5가 보통 우선순위, 1이 최소 우선순위)      void setPriority(int new Priority); //쓰레드의 우선순위를 지정한 값으로 변경  int getPriority();      public static final int MAX_PRIORITY = 10; //최대 우선순위  public static final int MIN_PRIORITY = 1; //최소 우선순위  public static final int NORM_PRIORITY = 5; //보통 우선순위            쓰레드 그룹          서로 관련된 쓰레드를 그룹으로 묶어서 다루기위한 것      모든 쓰레드는 반드시 하나의 쓰레드 그룹에 포함되어 있어야한다.      쓰레드 그룹을 지정하지 않으면 생성한 쓰레드는 ‘main쓰레드 그룹’에 속한다      자신을 생성한 쓰레드(부모 쓰레드)의 그룹과 우선순위를 상속받는다.          Thread(ThreadGroup group, String name)  Thread(ThreadGroup group, Runnable target)  Thread(ThreadGroup group, Runnable target, String name)  Thread(ThreadGroup group, Runnable target, String name, long stackSize)      ThreadGroup getThreadGroup() //자신이 속한 쓰레드 그룹을 반환한다.  void uncaughtException(Thread t, Throwable e) //처리되지 않은 예외에 의해 쓰렏  //그룹에 의해 쓰레드가 실행종료되었을 때, JVM에 의해 매소드가 자동적으로 호출된가.                                ![[IMG-20240902151251.png          IMG-20240902151251.png]]                          쓰레드의 상태                            상태          설명                                      NEW          쓰레드가 _생성_되고 아직 start가 호출되지 않은 상태                          RUNNABLE          실행 중 또는 실행 가능한 상태(대기열에 대기중)                          BLOCKED          동기화 블럭에 의해 _일시정지_된 상태(lock이 풀릴 때 까지 기다리는 상태)                          WAITING TIMED_WAITING          쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은(unrunnalble) 일시정지상태, TIMED_WAITING은 _일시정지시간_이 지정된 경우를 의미                          TERMINATED          쓰레드의 작업이 _종료_된 상태                          쓰레드의 실행제어          쓰레드의 실행을 제어할 수 있는 메소드가 제공된다.                                ![[IMG-20240902151251-1.png          IMG-20240902151251-1.png]]                      static붙은건 자기 자신에게만 적용됨                  sleep() : 현재 스레드를 지정된 시간동안 멈추게 한다.  static void sleep(long millis) //천분의 1초 단위  static void sleep(long millis, int nanos) //천분의 일초 + 나노초                              예외처리를 해줘야 한다. 예외 필수처리(InterruptedException이 발생하면 깨어남)            try { Thread.sleep(1,500000); //쓰레드를 0.0015초동안 멈추게한다  } catch (InterruptedException e){} //누가 깨운 상태                                특정 쓰레드를 지정해서 멈추게 하는 것은 불가능하다.(th1.sleep()으로 쓰면 가능은 하지만 오해의 여지가 있어서 Thread.sleep()으로 써야함)                            class  Main{  \tstatic void delay(long millis) {  \t\ttry {  //\t\t\tth1.sleep(2000); //th1을 2초 잠자게가 아니고 main쓰레드가 잠이드는데, 이렇게 쓰면 헷갈림  \t\t\tThread.sleep(millis);  \t\t}catch (InterruptedException e){}  \t}  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tThread2 th2 = new Thread2();  \t\tth1.start();  \t\tth2.start();        \t\t  \t\tdelay(2*1000);        \t\t  \t\tSystem.out.println(\"&lt;&lt;main 종료&gt;&gt;\");  \t}  }  class Thread1 extends Thread {  \tpublic void run(){  \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"-\");  \t\t}  \t\tSystem.out.println(\"&lt;&lt;th1 종료&gt;&gt;\");  \t}  }  class Thread2 extends Thread {  \tpublic void run(){  \t\tfor(int i=0; i&lt;300; i++) {  \t\t\tSystem.out.print(\"|\");  \t\t}  \t\tSystem.out.println(\"&lt;&lt;th2 종료&gt;&gt;\");  \t}  }                            interrupt()                  대기상태(WAITING)의 쓰레드를 실행대기 상태(RUNNABLE) 로 만든다                  import javax.swing.JOptionPane;          class  Main{  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tth1.start();        \t\t  \t\tSystem.out.println(\"interrupted() : \"+th1.isInterrupted()); //true반환  \t\tString input = JOptionPane.showInputDialog(\"아무값이나 입력하세요\");  \t\tSystem.out.println(\"입력하신 값은\"+input+\"입니다\");  \t\tth1.interrupt();  \t\tSystem.out.println(\"isInterrupted() : \"+th1.isInterrupted()); //true반환  \t\tSystem.out.println(\"isInterrupted() : \"+th1.isInterrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+th1.interrupted()); //false반환. static메소드임. main쓰레드의 Interrupt되었는지 확인  \t\t//카운트 세는 도중, 입력값을 주면 카운트 종료  \t\t//게임에서 계속하시겠습니까?하고 카운트세다가 y/n선택하면 카운트 종료되는거 이거임  \t}  }  class Thread1 extends Thread{  \tpublic void run() {  \t\tint i=10;        \t\t  \t\twhile (i!=0 &amp;&amp; !isInterrupted()) {  \t\t\tSystem.out.println(i--);  \t\t\tfor(long x=0;x&lt;2500000000L;x++); //시간지연  \t\t}  \t\tSystem.out.println(\"isInterrupted() : \"+this.isInterrupted()); //true반환  \t\tSystem.out.println(\"isInterrupted() : \"+this.isInterrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+this.interrupted()); //true반환  \t\tSystem.out.println(\"Interrupted() : \"+this.interrupted()); //false 위에서 확인 후 초기화 됨.  \t\t//isInterrupted()와 달리 interrupted는 interrupted라는 상태변수를 false로 초기화  \t\tSystem.out.println(\"카운트가 종료되었습니다.\");  \t}  }                      — 아래 3개 모두 deprecated되었음. 사용 권장안함. dead-lock가능성이 있음          suspend() : 쓰레드 일시정지      resume() : suspend()에 의해 일시정지 된 쓰레드를 실행대기상태로 만든다. (재개)      stop() : 완전 정지. 즉시종료          class  Main{  \tpublic static void main(String[] args) {  \t\tMyThread th1 = new MyThread(\"*\");  \t\tMyThread th2 = new MyThread(\"**\");  \t\tMyThread th3 = new MyThread(\"***\");    \t\t  \t\tth1.start();  \t\tth2.start();  \t\tth3.start();    \t\t  \t\ttry {  \t\t\tThread.sleep(2000);  \t\t\tth1.suspend(); //쓰레드 th1을 잠시 중단  \t\t\tThread.sleep(2000);  \t\t\tth2.suspend();   \t\t\tThread.sleep(3000);  \t\t\tth1.resume(); //쓰레드 th1 재 동작  \t\t\tThread.sleep(3000);  \t\t\tth1.stop();  \t\t\tth2.stop();  \t\t\tThread.sleep(2000);  \t\t\tth3.stop();  \t\t} catch (InterruptedException e) {}  \t}  }      class MyThread implements Runnable{  \tvolatile boolean suspended = false;   \t//volatile : 쉽게 바뀌는 변수(cpu의 코어는 복사본을 가지고 있는데(가끔 원본의 값이 변경됐을때 복사본의 값은 안바뀌는 경우 발생), volatile을 사용하면 원본을 바로 사용함  \t//자주 바뀌는 값이니까 복사본말고 원본 쓰라는 의미  \tvolatile boolean stopped = false;     \t  \tThread th;    \t  \tMyThread(String name){  \t\tth = new Thread(this,name);  \t}  \tvoid start() {  \t\tth.start();  \t}    \t  \tvoid stop() {  \t\tstopped = true;  \t}    \t  \tvoid suspend() { //일시정지  \t\tsuspended = true;  \t}    \t  \tvoid resume() { //재실행  \t\tsuspended = false;  \t}  \tpublic void run() {  \t\twhile(!stopped) {  \t\t\tif(!suspended) {  \t\t\tSystem.out.println(Thread.currentThread().getName());  \t\t\ttry {  \t\t\t\tThread.sleep(1000); //1초마다 쓰레드 이름찍기  \t\t\t} catch(InterruptedException e) {}  \t\t\t}  \t\t}  \t}  }              join() : 지정된 시간동안 특정 쓰레드가 작업하는 것을 기다린다. 예외처리 필수 (InterruptedException이 발생하면 작업 재개)          class  Main{  \tstatic long starttime = 0;  \tpublic static void main(String[] args) {  \t\tThread1 th1 = new Thread1();  \t\tThread2 th2 = new Thread2();  \t\tth1.start();  \t\tth2.start();  \t\tstarttime = System.currentTimeMillis();    \t\t  \t\ttry {  \t\t\tth1.join(); //main쓰레드가 th1의 작업이 끝날때까지 기다린다.  \t\t\tth2.join(); //main쓰레드가 th2의 작업이 끝날때까지 기다린다.  \t\t}catch(InterruptedException e) {}  \t\t//이거 안해주면 main쓰레드가 먼저 끝나서 소요시간이 제대로 안나옴. 덜끝났는데 시간을 계산해버림    \t\t  \t\tSystem.out.println(\"소요시간 : \"+(System.currentTimeMillis()-starttime));    \t\t  \t}  }  class Thread1 extends Thread{  \tpublic void run() {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(new String(\"-\"));  \t\t}  \t}  }  class Thread2 extends Thread{  \tpublic void run() {  \t\tfor(int i=0;i&lt;300;i++) {  \t\t\tSystem.out.print(new String(\"|\"));  \t\t}  \t}  }          public void run() {  \twhile(true) {  \t\ttry {  \t\tThread.sleep(10*1000); //10초 기다림  \t\t}catch(InterruptedException e) {}  \t\tSystem.out.println(\"Awaken by interrupt().\");  \t}  \tgc(); //garbage collection을 수행 : 사용하지 않는 객체 제거  \tSystem.out.println(\"Garbage Collection. Free Memory : \"+freeMemory());  }      for(int i=0;i&lt;20;i++) {  \trequiredMemory = (int)(Math.random()*10)*20; //requiredMemory 필요한 메모리  \t//필요한 메모리가 사용할 수 있는 양보다 적거나 전체 메모리의 60%이상 사용했을 경우 gc를 깨운다  \tif(gc.freeMemry()&lt; requireMemory || gc.freeMemory()&lt;gc.totalMemory()*0.4) { //메모리 부족한 경우  \t\tgc.interrupt(); //잠자고있는 쓰레드 gc를 깨운다  \t\ttry {  \t\t\tgc.join(100); //gc가 작업(메모리정리)할 시간을 줌. 0.1초  \t\t}catch(InterruptedException e) {}  \t}  \tgc.usedMemory += requiredMemory; //메모리 사용  \tSystem.out.println(\"usedMemory : \"+gc.usedMemory);  }              yield() : 남은 시간을 다음 쓰레드에게 양보하고, 자신(현재 쓰레드)은 실행대기한다. yield()와 interrupt()를 적절히 사용하면, 응답성과 효율을 높일 수 있다.          class  Main{  \tpublic static void main(String[] args) {  \t\tMyThread th1 = new MyThread(\"*\");  \t\tMyThread th2 = new MyThread(\"**\");  \t\tMyThread th3 = new MyThread(\"***\");    \t\t  \t\tth1.start();  \t\tth2.start();  \t\tth3.start();    \t\t  \t\ttry {  \t\t\tThread.sleep(2000);  \t\t\tth1.suspend(); //쓰레드 th1을 잠시 중단  \t\t\tThread.sleep(2000);  \t\t\tth2.suspend();   \t\t\tThread.sleep(3000);  \t\t\tth1.resume(); //쓰레드 th1 재 동작  \t\t\tThread.sleep(3000);  \t\t\tth1.stop();  \t\t\tth2.stop();  \t\t\tThread.sleep(2000);  \t\t\tth3.stop();  \t\t} catch (InterruptedException e) {}  \t}  }      class MyThread implements Runnable{  \tvolatile boolean suspended = false;   \t//volatile : 쉽게 바뀌는 변수(cpu의 코어는 복사본을 가지고 있는데(가끔 원본의 값이 변경됐을때 복사본의 값은 안바뀌는 경우 발생), volatile을 사용하면 원본을 바로 사용함  \t//자주 바뀌는 값이니까 복사본말고 원본 쓰라는 의미  \tvolatile boolean stopped = false;     \t  \tThread th;    \t  \tMyThread(String name){  \t\tth = new Thread(this,name);  \t}  \tvoid start() {  \t\tth.start();  \t}    \t  \tvoid stop() {  \t\tstopped = true;  \t\tth.interrupt(); //쓰레드가 자고있을 확률이 있어서 깨워줌  \t}    \t  \tvoid suspend() { //일시정지  \t\tsuspended = true;  \t\tth.interrupt(); //쓰레드가 자고있을 확률이 있어서 깨워줌  \t}    \t  \tvoid resume() { //재실행  \t\tsuspended = false;  \t}  \tpublic void run() {  \t\twhile(!stopped) {  \t\t\tif(!suspended) {  \t\t\tSystem.out.println(Thread.currentThread().getName());  \t\t\ttry {  \t\t\t\tThread.sleep(1000); //1초마다 쓰레드 이름찍기  \t\t\t} catch(InterruptedException e) {}  \t\t\t}else {  \t\t\t\tThread.yield(); //쓰레드가 일시정지 상태이면, 다른 쓰레드에게 순서를 양보함. os에게 통보는 하지만 반드시 작동한다는 보장은 없음.(써도 큰 차이는 없음..^^  \t\t\t}  \t\t}  \t}  }        쓰레드의 동기화(synchronization)          멀티 쓰레드 프로세스에서는 다른 쓰레드의 작업에 영향을 미칠 수 있다.      진행중인 작업이 다른 쓰레드에게 간섭받지 않게 하려면 ‘동기화’가 필요      쓰레드 동기화 : 한 스레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는것      동기화 하려면 간섭받지 않아야 하는 문장들을 ‘임계 영역(critical section)’으로 설정      임계영역은 락(lock)을 얻은 단 하나의 쓰레드만 출입가능(객체 1개에 락 1개)            synchronized를 이용한 동기화          synchronized로 임계영역(lock이 걸리는 영역)을 설정하는 방법 2가지                      메소드 전체를 임계 영역으로 지정(많을수록 성능이 떨어져서 최소한으로 좁은 영역에 쓰는 것이 좋음. 메소드 전체를 임계영역으로 지정하는 것은 비효율적)        Public synchronized void calcSum(){ /**/ }                    특정한 영역을 임계 영역으로 지정 synchronized(객체의 참조변수){ /**/ }                class Account{  \t//계좌에 1000있음  \tprivate int balance = 1000; //private로 해야 동기화가 의미있음    \t  \tpublic int getBalance() {  \t\treturn balance;  \t}  \t//출금 메소드. 잔고뺄떄 쓰레드 여러개가 들어오면 마이너스잔고가 뜰수도 잇음. 임계영역 지정  \tpublic synchronized void withdraw(int money) { //synchronized로 메소드를 동기화  \t\tif(balance&gt;=money) { //잔고보다 출금하려는 돈이 많아야 출금 가능  \t\t\ttry{Thread.sleep(1000); //별 의미없는 코드  \t\t\t} catch(InterruptedException e) {}  \t\t\tbalance -= money;  \t\t}//임계영역  \t}  }      class RunnableEx1 implements Runnable {  \tAccount acc = new Account();      \tpublic void run() {  \t\twhile(acc.getBalance()&gt;0) {  \t\t\t//100,200,300 중 한 값을 임으로 선택해서 출금(withdraw)  \t\t\tint money = (int)(Math.random()*3+1)*100;  \t\t\tacc.withdraw(money);  \t\t\tSystem.out.println(\"balance : \"+acc.getBalance());  \t\t}  \t}   }  class  Main{  \tpublic static void main(String[] args) {  \t\tRunnableEx1 r = new RunnableEx1();  \t\tnew Thread(r).start(); //ThreadGroup에 의해 참조되므로 gc대상이 아니다  \t\tnew Thread(r).start(); //ThreadGroup에 의해 참조되므로 gc대상이 아니다    \t\t  \t}  }            wait(), notify()          동기화의 효율을 높이기 위해 사용      Object클래스에 정의되어 있으며, 동기화 블록 내에서만 사용할 수 있다.      wait() : 객체의 lock을 풀고 쓰레드를 해당 객체의 waiting pool에 넣는다      notify() : waiting pool에서 대기중인 쓰레드 중의 하나를 깨운다.      notifyAll() : waiting pool에서 대기중인 모든 쓰레드를 깨운다.          class Account{  \t//계좌에 1000있음  \tprivate int balance = 1000; //private로 해야 동기화가 의미있음    \t  \tpublic synchronized void withdraw(int money) { //synchronized로 메소드를 동기화  \t\tif(balance &lt;money) {  \t\t\ttry{  \t\t\t\twait(); //대기, 락을 풀고 기다린다. 통지를 받으면 락을 재획득  \t\t\t} catch(InterruptedException e) {}  \t\t\tbalance -= money;  \t\t}//임계영역  \t}    \t  \tpublic synchronized void deposit(int money) {  \t\tbalance += money;  \t\tnotify(); //통지. 대기중인 쓰레드 중 하나에게 알림  \t}  }      class  Main{  \tpublic static void main(String[] args) {  \t}  }          import java.util.ArrayList;;      class Customer implements Runnable{  \tprivate Table table;  \tprivate String food;    \t  \tCustomer(Table table, String food){  \t\tthis.table = table;  \t\tthis.food = food;  \t}    \t  \tpublic void run() {  \t\twhile(true) {  \t\t\ttry { Thread.sleep(0);} catch(InterruptedException e) {}  \t\t\tString name = Thread.currentThread().getName();    \t\t\t  \t\t\ttable.remove(food);  \t\t\tSystem.out.println(name + \" ate a \"+food);  \t\t}  \t}  }    \t  class Cook implements Runnable{  \tprivate Table table;    \t  \tCook(Table  table){ this.table = table;}    \t  \tpublic void run() {  \t\twhile(true) {  \t\t\tint idx = (int)(Math.random()*table.dishNum());  \t\t\ttable.add(table.dishNames[idx]);  \t\t\ttry {Thread.sleep(10);} catch(InterruptedException e) {}  \t\t}  \t}  }  class Table {  \tString [] dishNames = {\"donut\",\"donut\", \"burger\"}; //donut의 확률을 높인다  \tfinal int MAX_FOOD = 6;  \tprivate ArrayList&lt;String&gt; dishes = new ArrayList&lt;&gt;();    \t  \tpublic synchronized void add(String dish) {  \t\twhile(dishes.size()&gt;=MAX_FOOD) {  \t\t\tString name = Thread.currentThread().getName();  \t\t\tSystem.out.println(name+\" is waiting.\");  \t\t\ttry {  \t\t\t\twait(); //COOK쓰레드(요리사)를 기다린다.  \t\t\t\tThread.sleep(500);  \t\t\t}catch(InterruptedException e) {}  \t\t}  \t\tdishes.add(dish);  \t\tnotify(); //기다리고 있는 CUST를 깨우기 위함.  \t\tSystem.out.println(\"Dishes : \"+dishes.toString());  \t}  \tpublic void remove(String dishName) {  \t\tsynchronized(this) {  \t\t\tString name = Thread.currentThread().getName();    \t\t\t  \t\t\twhile(dishes.size()==0) {  \t\t\t\tSystem.out.println(name + \" is waiting. \");  \t\t\t\ttry {  \t\t\t\t\twait();  \t\t\t\t\tThread.sleep(500);  \t\t\t\t}catch(InterruptedException e) {}  \t\t\t}  \t\t\twhile(true) {  \t\t\t\tfor(int i =0; i&lt;dishes.size();i++) {  \t\t\t\t\tif(dishName.equals(dishes.get(i))) {  \t\t\t\t\tdishes.remove(i);  \t\t\t\t\tnotify(); //자고있는 COOK을 깨우기 위함  \t\t\t\t\treturn;  \t\t\t\t\t}  \t\t\t\t}  \t\t\t\ttry {  \t\t\t\t\tSystem.out.println(name+\" is waiting.\");  \t\t\t\t\twait();  \t\t\t\t\tThread.sleep(500);  \t\t\t\t}catch(InterruptedException e) {}  \t\t\t}  \t\t}  \t}  \tpublic int dishNum() {return dishNames.length;}  }  class  Main{  \tpublic static void main(String[] args) throws Exception {  \t\tTable table = new Table();    \t\t  \t\tnew Thread(new Cook(table), \"COOK\").start();  \t\tnew Thread(new Customer(table, \"donut\"), \"CUST1\").start();  \t\tnew Thread(new Customer(table, \"burger\"), \"CUST2\").start();  \t\tThread.sleep(2000);  \t\tSystem.exit(0);    \t\t  \t}  }      "
  },
  
  {
    "title": "지네릭스, 열거형, 애너테이션",
    "url": "/posts/%EC%A7%80%EB%84%A4%EB%A6%AD%EC%8A%A4_%EC%97%B4%EA%B1%B0%ED%98%95_%EC%95%A0%EB%84%88%ED%85%8C%EC%9D%B4%EC%85%98/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-26 00:00:00 +0900",
    





    
    "snippet": "지네릭스(Generics): 컴파일시 타입을 체크해주는 기능(compile-time type check) - JDK1.5객체의 타입 안정성을 높이고 형변환의 번거로움을 줄임.⇒ 코드가 간결해짐, ClassCastException(형변환 에러) 방지import java.util.ArrayList;public class  Main {\t\tpublic sta...",
    "content": "지네릭스(Generics): 컴파일시 타입을 체크해주는 기능(compile-time type check) - JDK1.5객체의 타입 안정성을 높이고 형변환의 번거로움을 줄임.⇒ 코드가 간결해짐, ClassCastException(형변환 에러) 방지import java.util.ArrayList;public class  Main {\t\tpublic static void main(String[] args) {//\t\tArrayList list = new ArrayList(); //JDK1.5이전, 지네릭스 도입이전에는 이렇게 썻음//\t\tlist.add(10);//\t\tlist.add(20);//\t\tlist.add(\"30\");  //String//\t\t//\t\tInteger i = (int)list.get(2);  //[10, 20, 30]중 30을 꺼냄. 30이 String임//\t\t// =&gt; Object를 int로 형변환 해서 컴파일은 ok 에러없음//\t\t//그러나 실행하면 에러남. java.lang.ClassCastException 형변환 에러//\t\t//컴파일러의 한계. 30이 String인걸 체크 못함.//\t\t//\t\tSystem.out.println(list);\t\t\t\t//위 같은 사항을 방지하기 위해 지네릭스 등장\t\t\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\t\tlist.add(10);\t\tlist.add(20);//\t\tlist.add(\"30\");  //String이라 에러남. 위에서 &lt;Integer&gt;로 지정해줘서 잘못된 타입인걸 컴파일러가 잡아줌\t\tlist.add(30);\t\t\t\tInteger i = list.get(2);  //[10, 20, 30]중 30을 꺼냄. 어차피 Integet만 올 수 있어서 형변환 안해줘도 됨\t\t\t\tSystem.out.println(list);\t\tSystem.out.println(i);\t\t\t\tArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;(); //모든 타입 저장가능 JKD1.5이후부터 이렇게 씀\t\tlist2.add(10);\t\tlist2.add(20);\t\tlist2.add(\"30\");  //String\t\t\t\tString i2= (String)list2.get(2);\t\tSystem.out.println(list2);\t\tSystem.out.println(i2);\t\tObject i3 = list2.get(1);\t\tObject i4 = list2.get(2);\t\tSystem.out.println(i3);\t\tSystem.out.println(i4);\t}}      타입변수          클래스 작성 시, Object타입 대신 타입 변수(T or E)를 선언해서 사용      객체 생성 시, 타입변수 대신 실제타입을 지정(대입)  ⇒ 형변환 생략가능.          //public class ArrayList extends AbstractList{   //\tprivate transient Object[] elementData;  //\tpublic boolean add(Object o) {/*생략*/}  //\tpublic Object get(int inex); {/*생략*/}  //}  //   ↓ JDK1.5부터 아래코드로 변경  public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;{   \tprivate transient E[] elementData;  \tpublic boolean add(E o) {/*생략*/}  \tpublic E get(int inex); {/*생략*/}  }  class Main{  public static void main(String[] args){  \t\t//타입변수 대신 실제 타입을 대입시킴. 참조변수와 생성자에 지정  \t\t//생상자의 실제타입과 참조변수의 실제타입이 일치해야함  \t\t//Tv가 E에 대입됨  \t\tArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();  \t\ttvList.add(new Tv());  //\tTv v = (Tv)tvList.get(0); //반환타입이 Object가 아닌 Tv라 형변환 필요없음. 주석처리  \t\tTv v = tvList.get(0);  \t}  }          import java.util.*;      class Tv{}  class Audio{}      public class  Main {    \t  \tpublic static void main(String[] args) {  //\t\tArrayList List = new ArrayList();  //\t\tList.add(new Tv());  //\t\tList.add(new Audio());    \t\t  \t\tArrayList list2 = new ArrayList();  \t\tTv v2 = (Tv)list2.get(0); //list2의 첫번째 요소를 꺼냄 Tv로 형변환 필수    \t\t  \t\tArrayList&lt;Tv&gt; list = new ArrayList&lt;Tv&gt;();  \t\tlist.add(new Tv());  //\t\tlist.add(new Audio()); //위와 다르게 Tv객체만 저장하게 지정돼서 에러남.  \t\tTv v = list.get(0); //형변환 불필요. 어차피 Tv객체만 저장하게 돼있음  \t}  }        지네릭스 용어          Box : 지네릭 클래스. ‘T의 Box’ or ‘T Box’라고 읽는다.      T : 타입변수 or 타입 매개변수(T는 타입문자)      Box : 원시타입(raw type). 일반클래스가 지네릭클래스로 바뀌어서 원 Box클래스를 원시타입이라 부름      대입된 타입(매개변수화된 타입, parameterized) : Box b = new Box();에서 String. 객체를 만들때마다 변경가능.            지네릭 타입과 다형성          참조변수와 생성자의 대입된 타입은 일치해야 한다.(조상과 자손관계여도 안됨)      지네릭클래스간의 타형성 성립은 성립.(여전히 대입된 타입은 일치해야함)      매개변수 다형성도 성립됨.          import java.util.*;      class Product{}  class Tv extends Product{}  class Audio extends Product{}      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tArrayList&lt;Product&gt; productList = new ArrayList&lt;Product&gt;();  \t\tArrayList&lt;Tv&gt; tvList = new ArrayList&lt;Tv&gt;();  //\t\tArrayList&lt;Product&gt; tvList1 = new ArrayList&lt;Tv&gt;(); //에러. 조상자손관계여도 안됨  \t\tList&lt;Tv&gt; tvList2 = new ArrayList&lt;Tv&gt;(); //가능. 다형성이지만 대입된 타입이 일치함    \t\t   \t\tproductList.add(new Tv()); //다형성. public boolean add(Product e)라서 Product의 자손인 Tv도 가능  \t\tproductList.add(new Audio());    \t\t  \t\ttvList.add(new Tv()); //public boolean add(Tv e)  //\t\ttvList.add(new Audio()); //Tv와 Audio는 공통 조상을 가진것이지 상속관계는 아니라 에러      \t\tprintAll(productList);  \t\t//printAll(tvList) //컴파일 에러. printAll은 Product타입임.   \t}      \tpublic static void printAll(ArrayList&lt;Product&gt; list){  \t\tfor(Product p : list) {  \t\t\tSystem.out.println(p);  \t\t}  \t}  }            Iterator          클래스를 작성할 때, Object타입 대신 T와 같은 타입 변수를 사용          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();  \t\tlist.add(new Student(\"자바왕\",1,1));  \t\tlist.add(new Student(\"자바짱\",1,2));  \t\tlist.add(new Student(\"홍길동\",2,1));    \t\t  \t\tIterator&lt;Student&gt; it =list.iterator();  \t\twhile(it.hasNext()) {  //\t\t\tStudent s = (Student)it.next(); //지네릭스를 사용해서 형변환 필요없음. Iterator it =list.iterator(); 였다면 형변환 해줘야함  //\t\t\tStudent s = it.next();  //\t\t\tSystem.out.println(s.name); //밑의 한줄로 줄임  //\t\t\tSystem.out.println(((Student)it.next()).name); //형변환 필요없음.  \t\t\tSystem.out.println(it.next().name);  \t\t}  \t}  }  class Student{  \tString name = \"\";  \tint ban; //반  \tint no; //번호    \t  \tStudent(String name, int ban, int no){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.no = no;  \t}  }            HashMap&lt;K,V&gt;          여러 개의 타입 변수가 필요한 경우, 콤마(,)를 구분자로 선언          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tHashMap&lt;String, Student&gt; map = new HashMap&lt;&gt;(); //JDK1.7부터 생성자의 타입지정 생략가능  \t\tmap.put(\"자바왕\", new Student(\"자바왕\",1,1,100,100,100));  \t\tmap.put(\"자바짱\", new Student(\"자바짱\",1,2,100,100,100));  \t\tmap.put(\"홍길동\", new Student(\"홍길동\",2,1,100,100,100));    \t\t  \t\t//public Student get(Object Key){}  \t\tStudent s = map.get(\"자바왕\"); //형변환 생략    \t\t  \t\tSystem.out.println(map.get(\"자바왕\").name);  \t}  }  class Student{  \tString name = \"\";  \tint ban; //반  \tint no; //번호  \tint kor;  \tint eng;  \tint math;    \t  \tStudent(String name, int ban, int no, int kor, int eng, int math){  \t\tthis.name = name;  \t\tthis.ban = ban;  \t\tthis.no = no;  \t\tthis.kor=kor;  \t\tthis.eng=eng;  \t\tthis.math=math;  \t}  }            제한된 지네릭 클래스          extends로 대입할 수 있는 타입을 제한 - class avg                  Student의 자손만 타입으로 지정가능.                    인터페이스인 경우에도 extends를 사용(implement안씀)          import java.util.*;      interface Eatable{};      class Fruit implements Eatable{  \tpublic String toString() {return \"fruit\";}  }      class Apple extends Fruit{public String toString() {return \"Apple\";} }  class Grape extends Fruit{public String toString() {return \"Grape\";} }  class Toy {public String toString() {return \"Toy\";} }  public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; fruitBox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; appleBox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Grape&gt;();  //\t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Apple&gt;(); //에러. 타입 불일치  //\t\tFruitBox&lt;Toy&gt; toyBox = new FruitBox&lt;Toy&gt;(); //에러. Toy클래스는 Fruit의 자손이 아님  \t\tBox&lt;Toy&gt; toyBox = new Box&lt;Toy&gt;();     \t\t  \t\tfruitBox.add(new Fruit());                     \t\tfruitBox.add(new Apple());                     \t\tfruitBox.add(new Grape());                     \t\tappleBox.add(new Apple());                     //\t\tappleBox.add(new Grape()); //Grape는 Apple의 자손이 아님              \t\tgrapeBox.add(new Grape());            \t\t  \t\tSystem.out.println(\"fruitBox - \"+fruitBox);  \t\tSystem.out.println(\"appleBox - \"+appleBox);  \t\tSystem.out.println(\"grapeBox - \"+grapeBox);  \t}  }  class FruitBox&lt;T extends Fruit &amp; Eatable&gt; extends Box&lt;T&gt;{}       class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); //아이템을 저장할 list  \tvoid add(T item)\t\t{list.add(item);} //박스에 추가  \tT get(int i) \t\t\t{return list.get(i);} //박스에서 아이템 꺼냄  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  \t}        지네릭스의 제약                  타입변수에 대입은 인스턴스 별로 다르게 가능        ⇒ static멤버에 타입 변수 사용불가.(모든 인스턴스에 공통이기 때문)        class BOX{    static T item; //에러    static int compare(T t1, T t2); //에러 }                    배열 생성할 떄 타입 변수 사용 불가. 타입 변수로 배열 선언은 가능        class Box{    T[] itemArr; //Ok, T타입의 배열을 위한 참조변수    T[] toArray() {    T[] tmpArr = new T[itemArr.length]; //에러. 지네릭 배열 생성불가 } }                  와일드 카드 &lt;?&gt; : 하나의 참조변수로 대입된 타입이 다른 객체를 참조 가능          &lt;? extends T&gt; : 와일드 카드의 상한 제한. T와 그의 자손들만 가능      &lt;? super T&gt; : 와일드 카드의 하한 제한. T와 그의 조상들만 가능      &lt;?&gt; == &lt;? extends Object&gt; : 제한없음. 모든 타입이 가능.        — 메소드의 매개변수에 와일드카드를 사용    static Juice makeJuice(FruitBox&lt;? extends Fruit&gt; box) {  String tmp = “”;  for(Fruit f : box.getList()) tmp += f +””;  return new Juice(tmp); }      import java.util.*;      class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }      class Juice{  \tString name;    \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }      class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";    \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; fruitBox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; appleBox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Grape&gt;();    \t\t  \t\t//appleBox에 Fruit와 그 자손(Apple, Grape)들 사용 가능  //\t\tFruitBox&lt;? extends Fruit&gt; appleBox = new FruitBox&lt;Apple&gt;();  //\t\tappleBox = new FruitBox&lt;Fruit&gt;();  //\t\tappleBox = new FruitBox&lt;Apple&gt;();  //\t\tappleBox = new FruitBox&lt;Grape&gt;();  //일단 주석처리해놓음 전부 에러안뜨고 잘 됨    \t\t   \t\tfruitBox.add(new Apple());  \t\tfruitBox.add(new Grape());  \t\tappleBox.add(new Apple());  \t\tgrapeBox.add(new Grape());     \t\t  \t\tSystem.out.println(Juicer.makeJuice(fruitBox));  \t\tSystem.out.println(Juicer.makeJuice(appleBox));  \t\tSystem.out.println(Juicer.makeJuice(grapeBox));  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}      class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }        지네릭 메소드                  지네릭 타입이 선언된 메소드(타입 변수는 메소드 내에서만 유효)  static  void sort(List list, Comparator&lt;? super T&gt; c)                    클래스의 타입 매개변수 와 메소드의 타입 매개변수 는 별개    class FruitBox{ /….    static  void sort(List list, Comparator&lt;? super T&gt; c){/*..*/} }        → class와 메소드의 타입변수가 다를수도 있음. 가까운 쪽의 것을 따름                    메소드를 호출할 때마다 타입을 대입해야함(대부분 생략가능)        FruitBox fruitBox = new FruitBox();    FruitBox appleBox = new FruitBox();    System.out.println(Juicer.makeJuice(fruitBox)); //생략 가능    System.out.println(Juicer.makeJuice(appleBox)); //생략가능                    메소드를 호출할 때 타입을 생략하지 않았을 때는 클래스 이름 생략 불가(아주 드뭄)  System.out.println(makeJuice(fruitBox));//에러. 클래스 생략 불가    System.out.println(this.makeJuice(fruitBox));    System.out.println(Juicer.makeJuice(fruitBox));            — 와일드카드메소드는 하나의 참조변수로 대입된 타입이 다른 여러 지네릭 객체를 다루기위해서 사용, 지네릭 메소드는 호출할때마다 다른 타입을 대입할 수 있음. 용도가 다름. (보통 와일드카드 못쓸때 지네릭 씀)  지네릭형 변환          지네릭 타입과 원시타입간의 형변환은 바람직하지 않음(경고발생, 가능은 함) 원시 타입을 사용하는 것부터 비효율적.              와일드 카드가 사용된 지네릭타입으로는 형변환 가능          import java.util.*;          class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }          class Juice{  \tString name;        \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }          class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";        \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tBox b = null;  \t\tBox&lt;String&gt; bstr = null;        \t\t  \t\tb = (Box)bstr;  //Box&lt;String&gt;-&gt;Box 가능은 하나 경고. 바람직하지않음  \t\tbstr = (Box&lt;String&gt;)b; //Box -&gt; Box&lt;String&gt;  가능은 하나 경고. 바람직하지않음        \t\t  \t\tBox b2 = new Box&lt;String&gt;();//가능 원래는 Box&lt;String&gt; b2 = new Box&lt;String&gt;();로 사용햐여함  \t\tb2.add(100);  \t\tb2.add(200);  \t\tSystem.out.println(b2);        \t\t  \t\tBox&lt;String&gt; b3 = new Box&lt;String&gt;();//가능 원래는 Box&lt;String&gt; b2 = new Box&lt;String&gt;();로 사용햐여함  //\t\tb3.add(100);  //\t\tb3.add(200);  //에러. b3는 &lt;String&gt;으로 타입을 지정해놔서 에러뜸  \t\t//어지간하면 섞어쓰지말고 꼭 지네릭으로 써줄 것.        \t\t  \t\tBox&lt;Object&gt; objBox = null;  //\t\tobjBox = (Box&lt;Object&gt;)bstr; //Box&lt;String&gt; -&gt; Box&lt;Objecte&gt; 불가능  //\t\tbstr = (Box&lt;String&gt;)objstr; //Box&lt;Object&gt; -&gt; Box&lt;String&gt; 불가능  //\t\tBox&lt;Sting&gt; b4 = new Box&lt;Object&gt;(); //불가능. 타입안맞음        \t\t  \t\tBox&lt;? extends Object&gt; wBox = (Box&lt;? extends Object&gt;)new Box&lt;String&gt;(); //가능  \t\tBox&lt;? extends Object&gt; wBox2 = new Box&lt;String&gt;(); //위 문장과 동일. 형변환 생략됨.        \t\t  \t\tFruitBox&lt;? extends Fruit&gt; Fbox = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;? extends Fruit&gt; Fbox2 = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;? extends Fruit&gt; Fbox3 = new FruitBox&lt;Grape&gt;();        \t\t  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}          class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }                  import java.util.*;          class Fruit\t\t\t\t\t{public String toString() { return \"Fruit\";} }  class Apple extends Fruit\t{public String toString() { return \"Apple\";} }  class Grape extends Fruit\t{public String toString() { return \"Grape\";} }          class Juice{  \tString name;        \t  \tJuice(String name)\t\t {this.name = name + \"Juice\";}  \tpublic String toString() {return name;}  }          class Juicer {  \tstatic Juice makeJuice(FruitBox&lt;? extends Fruit&gt;box) {  \t\tString tmp =\"\";        \t\t  \t\tfor(Fruit f : box.getList())//box안에 잇는 요소를 전부 꺼내서 f에 넣음  \t\t\ttmp += f+\"\";  \t\treturn new Juice(tmp);  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tFruitBox&lt;Fruit&gt; box = new FruitBox&lt;Fruit&gt;();  \t\tFruitBox&lt;Apple&gt; abox = new FruitBox&lt;Apple&gt;();  \t\tFruitBox&lt;Grape&gt; gbox = new FruitBox&lt;Grape&gt;();        \t\t  \t\tFruitBox&lt;? extends Fruit&gt; box2 = new FruitBox&lt;Fruit&gt;();  \t\t//FruitBox&lt;Apple&gt; -&gt; FruitBox&lt;? extends Fruit&gt;  \t\tFruitBox&lt;? extends Fruit&gt; abox2 = new FruitBox&lt;Apple&gt;();  \t\t//FruitBox&lt;Grape&gt; -&gt; FruitBox&lt;? extends Fruit&gt;  \t\tFruitBox&lt;? extends Fruit&gt; gbox2 = new FruitBox&lt;Grape&gt;();        \t\t  \t\t//FruitBox&lt;? extends Fruit&gt; -&gt; FruitBox&lt;Apple&gt;   \t\tFruitBox&lt;Apple&gt; abox3 = (FruitBox&lt;Apple&gt;)abox2; //가능. 경고발생  \t\t//FruitBox&lt;? extends Fruit&gt; -&gt; FruitBox&lt;Grape&gt;   \t\tFruitBox&lt;Grape&gt; gbox3 = (FruitBox&lt;Grape&gt;)gbox2;  \t}  }  class FruitBox&lt;T extends Fruit&gt; extends Box&lt;T&gt;{}          class Box&lt;T&gt;{  \tArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();  \tvoid add(T item) \t\t{list.add(item);}  \tT get(int i)\t\t\t{return list.get(i);}  \tArrayList&lt;T&gt; getList() \t{return list;}  \tint size()\t\t\t\t{return list.size();}  \tpublic String toString(){return list.toString();}  }                      지네릭타입의 제거          컴파일러는 지네릭타입을 제거하고, 필요한 곳에 형변환을 넣는다.                              지네릭 타입의 경계(bound)를 제거( → Object) - 하위호환성때문에 타입을 제거하기로 결정 ⇒ 안정성 증가            class box{void att(T t) } → class box{void add(Fruit t)} 으로 변경                                지네릭 타입 제거 후에 타입이 불일치하면, 형변환을 추가 T get(int i){return list.get(i);} → Fruit get(int i){return (Fruit)list.get(i);}                                와일드 카드가 포함된 경우, 적절한 타입으로 형변환 추가                                    열거형(enum) : 관련된 상수들을 같이 묶어놓은 것. java는 타입에 안전한 열거형을 제공. ==연산자 사용시 값과 타입 둘다 체크함          정의 방법 - enum 열거형 이름{ 상수명1, 상수명2, 상수명3 ,…}      열거형 타입의 변수를 선언, 사용          enum Direction { EAST, SOUTH, WEST, NORTH}      class Unit {  \tint x, y; //유닛의 위치  \tDirection dir; //열거형 인스턴스 변수를 선언    \t  \tvoid init() {  \t\tdir = Direction.EAST; //유닛의 방향을 EAST로 초기화\t\t  \t}  }              열서형 상수의 비교에 ==와 compareTo() 사용가능          void init() {  \t\tdir = Direction.EAST; //유닛의 방향을 EAST로 초기화\t\t  \t\tif(dir == Direction.EAST) {  \t\t\tx++; }  //\t\telse if(dir &gt; Direction.WEST) { //에러, 열거형 상수에 비교 연산자 사용 불가능  \t\telse if(dir.compareTo(Direction.WEST)&gt;0) {  /*compare은 사용 가능*/}  \t}                      열거형의 조상 - java.lang.Enum                  모든 열거형은 Enum의 자손이며, 아래의 메소드를 상속받는다.                                                    메소드              설명                                                          Class getDeclaringClass()              열거형의 Class객체를 반환                                      String name()              열거형 상수의 이름을 문자열로 반환                                      int ordinal()              열거형 상수가 정의된 순서를 반환(0부터 시작)                                      T valueOf(Class enumType, String name)              지정된 열거형에서 name과 일치하는 열거형 상수를 반환                                                values(), valueOf()는 컴파일러가 자동으로 추가                  static E[] values()  \t\tstatic E valueOf(String name)        \t\t  \t\tDirection [] dArr = Direction.values();        \t\t  \t\tfor(Direction d : dArr) {  \t\t\tSystem.err.printf(\"%s = $d%n\",d.name(),d.ordinal());  \t\t}                  import java.util.*;          enum Direction { EAST, SOUTH, WEST, NORTH}          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tDirection d1 = Direction.EAST;  \t\tDirection d2 = Direction.valueOf(\"WEST\");  \t\tDirection d3 = Enum.valueOf(Direction.class, \"EAST\");        \t\t  \t\tSystem.out.println(\"d1 = \" + d1);  \t\tSystem.out.println(\"d2 = \" + d2);  \t\tSystem.out.println(\"d3 = \" + d3);        \t\t  \t\tSystem.out.println(\"d1==d2 ? \"+(d1==d2));  \t\tSystem.out.println(\"d1==d3 ? \"+(d1==d3));  \t\tSystem.out.println(\"d1.equals(d3) \"+(d1.equals(d3)));  //\t\tSystem.out.println(\"d2&gt;d3 ? \"+(d1&gt;d3)); //에러. 객체가 없어서 비교연산자 사용 불가  \t\tSystem.out.println(\"d1.compareTo(d3) ? \"+(d1.compareTo(d3)));  \t\tSystem.out.println(\"d1.compareTo(d2) ? \"+(d1.compareTo(d2))); //0-2 = -2 출력        \t\t  \t\tswitch(d1) {  \t\tcase EAST: //Direction.EAST라고 못씀  \t\t\tSystem.out.println(\"The direction is EAST. \"); break;  \t\tcase SOUTH:   \t\t\tSystem.out.println(\"The direction is SOUTH. \"); break;  \t\tcase WEST:   \t\t\tSystem.out.println(\"The direction is WEST. \"); break;  \t\tcase NORTH:   \t\t\tSystem.out.println(\"The direction is NORTH. \"); break;  \t\tdefault:  \t\t\tSystem.out.println(\"Invalid direction\"); break;  \t\t}  \t\tDirection[] dArr = Direction.values(); //열겨형의 모든 상수를 배열로 반환  \t\tfor(Direction d : dArr) { //for(Direction d : Direction.values()  \t\t\tSystem.out.printf(\"%s = %d%n\",d.name(),d.ordinal());  \t\t}  \t}  }                            열거형에 멤버 추가하기                  불연속적인 열거형 상수의 경우 원하는 값을 괄호()안에 넣는다. 여러개도 가능          괄호를 사용하려면, 인스턴스 변수와 생성자를 새로 추가해줘야 함                  import java.util.*;          enum Direction { EAST(1), SOUTH(5), WEST(-1), NORTH(10);  \tprivate final int value;// 정수를 저장할 필드(인스턴스변수)를 추가  \tDirection(int value) {this.value = value;} //생성자 추가, private 생략        \t  \tpublic int getValue() {return value;}          }          public class  Main {        \t  \tpublic static void main(String[] args) {  //\t\tDirection d = new Direction(1); //에러, 열거형의 생성자는 외부에서 호출불가(무조건 private라서)   \t}  }                  import java.util.*;          enum Direction { EAST(1,\"&gt;\"), SOUTH(2,\"V\"), WEST(3,\"&lt;\"), NORTH(4,\"^\");        \t  \tprivate static final Direction[] DIR_ARR = Direction.values();  \tprivate final int value;// 정수를 저장할 필드(인스턴스변수)를 추가  \tprivate final String symbol;        \t  \tDirection(int value, String symbol) {  \t\tthis.value = value;  \t\tthis.symbol=symbol;  \t} //생성자 추가, private 생략        \t  \tpublic int getValue() {return value;}  \tpublic String getSymbol() {return symbol;}        \t  \tpublic static Direction of(int dir) {  \t\tif(dir&lt;1 || dir&gt;4) //1~4이외의 값이면 x  \t\t\tthrow new IllegalArgumentException(\"Invalid value : \"+dir);  \t\treturn DIR_ARR[dir-1];   \t}  \t//방향 회전 메소드, num의 값만큼 90도씩 시계방향으로 회전  \tpublic Direction rotate(int num) {  \t\tnum = num%4;        \t\t  \t\tif(num&lt;0) num +=4;  //num이 음수일때는 시계 반대방형으로 회전        \t\t  \t\treturn DIR_ARR[(value-1+num)];  \t}        \t  \tpublic String toString() {  \t\treturn name()+getSymbol();  \t}  }  public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tfor(Direction d : Direction.values()) {  \t\t\tSystem.out.printf(\"%s = %d%n\",d.name(),d.ordinal());  \t\t}  \t\tSystem.out.println();  \t\t\tDirection d1 = Direction.EAST;  \t\t\tDirection d2 = Direction.of(1); //DIR_ARR[0]반환        \t\t\t  \t\t\tSystem.out.printf(\"d1 = %s, %d%n\",d1.name(),d1.getValue());  \t\t\tSystem.out.printf(\"d2 = %s, %d%n\",d2.name(),d2.getValue());  \t\t\tSystem.out.println();  \t\t\tSystem.out.println(Direction.EAST.rotate(1)); //EAST에서 한번 회전  \t\t\tSystem.out.println(Direction.EAST.rotate(2));  \t\t\tSystem.out.println(Direction.EAST.rotate(-1));//EAST에서 시계반대방향으로 한번 회전  \t\t\tSystem.out.println(Direction.EAST.rotate(-2));  \t}  }                            애너테이션                  주석처럼 프로그래밍 언어에 영향을 미치지 않으며, (프로그램에게)유용한 정보를 제공          /*~~~/ : javadoc.exe주석          애너테이션 사용 예  @Text //이 메소드가 테스트 대상임을 테스트 프로그램에게 알림  public void method{}                                                    ![[IMG-20240902151155.png              IMG-20240902151155.png]]                                      메타애너테이션 : 애너테이션을 만들때 사용                  @Override : 오버라이딩을 올바르게 했는지 컴파일러가 체크. 메소드 이름 잘못적을때가 많음. 오버라이딩 하기전에 적어줄 것.                      @Deprecated : 앞으로 사용하지 않을 것을 권장하는 필드, 메소드에 붙임 (ex. Date클래스의 getDate())  ⇒ @Deprecate가 붙은 대상을 사용하면 에러는 안뜨나 경고메세지(이클립스에선 취소선)가뜸                    @FunctionalInterface : 함수형 인터페이스(14장)에 붙이면, 컴파일러가 올바르게 작성했는지 체크, 함수형 인터페이스는 하나의 추상 메소드만 가질수 있다는 제약이 있음                      @SuppressWarings                          컴파일러의 경고메세지가 나타나지않게 억제              ()안에 억제하고자 하는 경고의 종류를 문자열로 지정 (경고를 확인했다는 의미)              여러 경고를 동시에 억제 가능함.              ‘-Xlint’옵션으로 컴파일 하면, 경고메세지를 확인할 수 있음. []안이 경고의 종류.                          class Parent{  \tvoid parentMethod() {}  \tvoid parentMethod2() {}  }              class Child extends Parent{  \t@Override  \t@Deprecated  \tvoid parentMethod() {};  //\t@Override  //\tvoid parentmethod2() {}; //에러. 이름불일치로 오버라이딩이 안됨.(@Override가 없으면 에러 안뜸)\t  }              @FunctionalInterface  interface Testable{ //함수형 인터페이스는 하나의 추상메소드만 가질 수 있음  \tvoid test(); //추상메소드  //\tvoid check(); //추상메소드 //추상메소드가 두개라서 에러, @FunctionlInterface가 없으면 가능함  }  public class  Main {  @SuppressWarnings(\"deprecation\")//이클립스에서는 차이가 없으나 cmd에서 컴파일하면 경고가 안뜸.  \tpublic static void main(String[] args) {  \t\tChild c = new Child();  \t\tc.parentMethod();  \t}  }                                메타애너테이션 : 애너테이션을 위한 에터테이션. java.lang.annotation 패키지에 포함                                          @Target : 애너테이션 정의할 때, 적용대상 지정에 사용                                                                            ![[IMG-20240902151156.png                      IMG-20240902151156.png]]                                                                                  @Retention : 애너테이션이 유지(retrntion)되는 기간을 지정하는데 사용                                  SOURCE : 소스파일에만 존재. 클래스파일에는 없음. 컴파일러에 의해 사용되는 애너테이션의 유지정책                  ==CLASS : 클래스파일에 존재. 실행시 사용불가. 기본값==                  RUNTIME : 클래스파일에 존재. 실행시 사용가능                                            @Documented : javadoc으로 작성한 문서에 포함시킴              @Ingerited : 애너테이션을 자손 클래스에 상속시킴              @Repeatable : 반복해서 붙일 수 있는 애너테이션을 정의. @ToDo를 하나로 묶을 컨테이너 애너테이션도 정의해야함                                            애너테이션 타입 정의                          직접 만들 수 있음 : @Interface 애너테이션이름{}              애너테이션의 메소드는 추상 메소드이며, 애너테이션을 적용할 때 지정(순서x)              애너테이션의 요소                                  적용시 값을 지정하지 않으면, 사용될 수 있는 기본 값 지정가능(null제외)                  요소가 하나이고 이름이 value일때는 요소의 이름 생략 가능                  요소의 타입이 배열인경우, {}를 사용(값이 여러개일때만, 값이 없을땐 빈{}라도 반드시 적어줘야함)                                            모든 애너테이션의 조상 - java.lang.annotation.Annotation                                  Annotation은 모든 애너테이션의 조상이지만 상속 불가능.                  사실 Annotation은 인터페이스임                                            마커 애너테이션(Marker Annotation) : 요소가 하나도 정의되지 않은 애너테이션              애너테이션 요소의 규칙                                  요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용됨                  ()안에 매개변수 선언 불가                  예외 선언 불가                  요소를 타입 매개변수로 정의 불가                                                        import java.lang.annotation.*;              @Deprecated  @SuppressWarnings(\"1111\") //유효하지 않은 애너테이션은 무시  @TestInfo(testedBy =\"aaa\", testTools= {\"JUnit\",\"JUnit5\"}, testDate = @DateTime(yymmdd=\"160101\",hhmmss=\"235959\"))  public class  Main {  \tpublic static void main(String[] args) {  \t\tClass&lt;Main&gt; cls = Main.class;            \t\t  \t\tTestInfo anno = cls.getAnnotation(TestInfo.class);  \t\tSystem.out.println(\"anno.testedBy() = \"+anno.testedBy());  \t\tSystem.out.println(\"anno.testDate().yymmdd()=\" +anno.testDate().yymmdd());  \t\tSystem.out.println(\"anno.testDate().hhmmss()=\" +anno.testDate().hhmmss());            \t\t  \t\tfor(String str : anno.testTools())   \t\t\tSystem.out.println(\"testTools = \" +str);            \t\t  \t\tSystem.out.println();            \t\t  \t\t//Main에 적용된 모든 애너테이션을 가져온다.  \t\tAnnotation[] annoArr = cls.getAnnotations();            \t\t  \t\tfor(Annotation a : annoArr)  \t\t\tSystem.out.println(a);  \t}  }  @Retention(RetentionPolicy.RUNTIME) //실행시 사용 가능하도록 지정  @interface TestInfo{  \tint count() default 1;  \tString testedBy();  \tString[] testTools() default \"JUnit\";  \tTestType TestType() default TestType.FIRST;  \tDateTime testDate();  }              @Retention(RetentionPolicy.RUNTIME) //실행시 사용 가능하도록 지정  @interface DateTime{  \tString yymmdd();  \tString hhmmss();  }              enum TestType{FIRST, FINAL}                                          "
  },
  
  {
    "title": "컬렉션 프레임웍(collections framework)",
    "url": "/posts/%EC%BB%AC%EB%A0%89%EC%85%98_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8D(collections_framework)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, collection",
    "date": "2022-08-21 00:00:00 +0900",
    





    
    "snippet": "컬렉션 프레임웍(collections framework)      컬렉션(collection)    : 여러 객체(데이터)를 모아놓은 것        프레임웍(framework)    : 표준화, 정형화된 체계적인 프로그램 방식 (Spring)        컬렉션 프레임웍(collections framework)    : 컬렉션(다수의 객체)를 다루기...",
    "content": "컬렉션 프레임웍(collections framework)      컬렉션(collection)    : 여러 객체(데이터)를 모아놓은 것        프레임웍(framework)    : 표준화, 정형화된 체계적인 프로그램 방식 (Spring)        컬렉션 프레임웍(collections framework)    : 컬렉션(다수의 객체)를 다루기 위한 표준화된 프로그래밍 방식    컬랙션을 쉽고 편리하게 다룰 수 있는 다양한 클래스 제공(객체 저장, 삭제, 검색, 정렬 등)    java.util 패키지에 포함. JDK1.2부터 제공(그전엔 표준화가 안됨)        컬렉션 클래스(collections class)    : 다수의 데이터를 저장할 수 있는 클래스(ex. Vector, ArrayList, HashSet)  ❗❗컬렉션 크레임웍의 핵심 인터페이스Map구현 클래스 이름에 Map이 없는 것은 표준화되기 전 옛날에 생긴 것— List와 Set의 공통부분 만 모아서 Collection이라는 인터페이스를 정의함. Map은 성격이 달라서 공통부분이 없음  Collection인터페이스의 메소드 - 순서ox,중복ox(상관없음)      List인터페이스 - (저장)순서o, 중복o          ArrayList (배열기반):                              기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일  (Vector써도 되지만[동기화o] 가능하면 ArrayList[동기화x]쓸것.)                    List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용          데이터의 저장공간으로 배열을 사용(배열기반)                      ArrayList의 메소드                          생성자                                  ArrayList() - 기본생성자                  ArrayList(Collection) - 컬렉션들 끼리 변환할때 많이 씀                  ArrayList(int initialCapacity) - 배열의 길이를 지정해주어야함(원래 배열은 길이를 조절못해서. 만들때 넉넉하게 만드는게 좋음)                                            추가                                  boolean add(Object o) - 객체 추가. 성공하면 true, 실패하면 false                  void add(int index, Object element) - 저장위치 지정(안하면 맨 뒤에 저장됨)                  boolean addAll(Collection c) - 컬렉션이 가진 요소를 그대로 저장                  boolean addAll(int index, Collection c) - 컬렉션의 저장위치지정                                            삭제                                  boolean remove(Object o) - 삭제                  Object remove(int index) - 특정위치 객체 삭제                  boolean removeAll(Collection c) - 컬렉션에 있는 객체 삭제                  void clear() - Array의 모든 객체 삭제                                            검색                                  int indexOf(Object o) - 객체가 몇번째에 저장됐는지(못찾으면 -1)                  int lastIndexOf(Object o) - 끝에서 부터 객체를 찾음                  boolean contains(Object o) - 객체가 있는지(있으면 true, 없으면 false)                  Object get(int index) - 객체 읽기                  Object set(int index, Object element) - 특정 위치 객체를 다른 걸로 변경                                                            기타                                  List subList(int fromIndex, int toIndex) -from부터 to까지 객체를 뽑아서 새로운 List를 만듦                  Object[] toArray() - ArrayList의 객체배열을 반환                  Object[] toArray(Object[] a)                  boolean isEmpty() - ArrayList가 비어있는지 확인                  void trimToSize() - 빈공간 제거                  int size() - 저장된 객체의 갯수                                  import java.util.*;                  public class  Main {  \tpublic static void main(String[] args) {  \t\t//기본길이(용량, capacity)가 10인 ArrayList를 생성  \t\tArrayList list1 = new ArrayList(10);  //\t\tlist1.add(new Integer(5));  //\t\tlist1.add(new Integer(4));  //\t\tlist1.add(new Integer(2));  //\t\tlist1.add(new Integer(0));  //\t\tlist1.add(new Integer(1));  //\t\tlist1.add(new Integer(3));  \t\t//ArrayList는 객체만 저장되나 autoboxing에 의해 기본형이 참조형으로 자동변환되서 밑처럼 써도 됨  \t\tlist1.add(5);  \t\tlist1.add(4);  \t\tlist1.add(2);  \t\tlist1.add(0);  \t\tlist1.add(1);  \t\tlist1.add(3);                \t\t  \t\t//ArrayList(Collection c)  //\t\tList sub = list1.subList(1, 4);  //\t\tArrayList list2 = new ArrayList(sub);  \t\tArrayList list2 = new ArrayList(list1.subList(1, 4));                \t\t  \t\tprint(list1, list2);                \t\t  \t\t//Collection은 인터페이스, Collections는 유틸클래스  \t\tCollections.sort(list1); //list1과 list2를 정렬한다  \t\tCollections.sort(list2); //Collections.sort(list1)  \t\tprint(list1, list2);                \t\t  \t\t//list1이 list2의 모든 요소를 포함하고 있는가?  \t\tSystem.out.println(\"list1.conrainsAll(list2) : \"+list1.containsAll(list2));                \t\t  \t\tlist2.add(\"B\");  \t\tlist2.add(\"C\");  \t\tlist2.add(3,\"A\"); //기존 값은 삭제되니 신중히  \t\tprint(list1, list2);                \t\t  \t\tlist2.set(3, \"AA\");  \t\tprint(list1, list2);                \t\t  \t\tlist1.add(0,\"1\");  \t\t//list1에서 \"1\"이 어느 위치에 있는지 출력   \t\tSystem.out.println(\"\\\"1\\\"의 index = \"+list1.indexOf(\"1\")); //0  \t\tSystem.out.println(\"1의 index = \"+list1.indexOf(1)); //2  \t\tprint(list1,list2);  \t\tlist1.remove(0); //list1[0]자리의 값을 0으로(String이라)  \t\tprint(list1, list2);  \t\tlist1.remove(5); //list1[5]를 삭제  \t\tprint(list1, list2);                \t\t  \t\tlist1.remove(new Integer(1)); //값이 1인 것을 삭제  \t\tprint(list1, list2);                \t\t  \t\t// list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제  \t\tSystem.out.println(\"list1.retainAll(list2) : \"+list1.retainAll(list2));  \t\tprint(list1, list2);                \t\t  \t\t//list2에서 list1에 포함된 객체들을 삭제  \t\tfor(int i = list2.size()-1;i&gt;=0;i--) {  \t\t\tif(list1.contains(list2.get(i)))  \t\t\t\t\tlist2.remove(i);  \t\t}  \t\tprint(list1, list2);  \t}                  \tprivate static void print(ArrayList list1, ArrayList list2) {  \t\tSystem.out.println(\"list1:\"+list1);  \t\tSystem.out.println(\"list2:\"+list2);  \t\tSystem.out.println();  \t}  }                                                            ArrayList에 저장된 객체의 삭제 과정                                                      삭제할 데이터 아래의 데이터를 한 칸씩 위로 복사해서 삭제할 데이터 덮어쓰기(부담 많이감.) System.arraycopy(data, 3, data, 2, 2) data[3]에서 data[2]로 2개의 데이터를 복사함                                                        데이터가 모두 한 칸씩 이동했으므로 마지막 데이터는 null로 변경 data[size-1]=null;                                                        데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 감소시킨다 size–;                                                        마지막데이터를 삭제하는 경우 1번은 안해도됨.                                                  — for문으로 모든 객체 지우기                for(int i =list.size()-1;i&gt;=0;i–) { list.remove(i); }  이렇게안하면 배열이 자꾸 위로 올라가서 다 안지워짐                                                                LinkedList : 배열의 단점을 보완 (연결기반)                  배열의 장단점                          배열의 장점 : 구조가 간단, 데이터를 읽는데 걸리는 시간이(접근시간, access time) 짧음              배열의 단점                                  크기 변경x : 변경 시 새로운 배열을 생성한 후 데이터를 복사해야함. 미리 넉넉하게 배열크기를 지정하면 메모리가 낭비됨                                          더 큰 배열 생성                      복사                      참조 변경                                                        비순차적인 데이터의 추가, 삭제에 시간이 많이 걸림  → 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.  그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠름                                                              배열과 달리 LinkedList는 불연속적으로 존재하는 데이터를 연결          데이터의 삭제 : 단 한번의 참조 변경만으로 가능          데이터 추가 : 한번의 Node객체 생성과 두번의 참조 변경만으로 가능                      단점                          접근성이 나쁨. (불연속적이라서)  첫번째 배열에서 마지막 배열까지 가려면 모든 배열을 거쳐서 가야함                        ⇒ 서큘러 링크드 리스트(이중 원형리스트, doubly circular linked list)[첫번째애서 마지막으로 이동이 편리) , 이중연결리스트(doubly linked list)[앞뒤 이동만 편해짐]로 , 접근성 향상                                      [!important]ArrayList vs Linked List데이터를 순차적 추가/삭제 - ArrayList데이터를 비순차적으로 추가/삭제 - LinkedList접근시간(access time) - ArrayList⇒ 읽기는 ArrayList, 추가/삭제는 LinkedList가 빠르다      Collection인터페이스의 메소드는 제외됨(자손이라 쓸 수 있음)  Set인터페이스 - 순서x, 중복x (집합)                  HashSet : Set인터페이스를 구현한 대표적인 컬렉션 클래스. 순서를 유지하려면 LInkedHashSet을 사용 (중복 방지를 위해 객체 저장 전에 기존에 같은 객체가 있는지 확인함)                  생성자                          HashSet()              HashSet(Collection c) : 지정된 컬렉션에 모든 객체 저장              HashSet(int initialCapacity) : 초기용량 지정(보통 2배)              HashSet(int initialCapacity, float loadFactor) : 언제 용량을 늘릴건지(보통2배)                                추가/삭제                          boolean add(Object o) : 추가 - 중복 확인을 위해 저장할 객체의 equals()와 hashCode()를 호출, equals()와 hashCode()가 오버라이딩 되어있어야함(equals()만 해도되나 hashCode()까지 오버라이딩 해주는 것이 정석임)              boolean addAll(Collection c) : 추가(합집합)              boolean remove(Object o) : 삭제              boolean removeAll(Collection c) : 삭제 (교집합)              boolean retainAll(Collection c) : Collection에 있는거만 남기고 삭제(조건부삭제, 차집합)              void clear() : 모두 삭제                                포함                          boolean contains(Object o) : set이 객체를 포함했다면 true, 아니라면 false              boolean containsAll(Collection c) : Collection에 담긴 여러 객체가 모두 포함되어있는지              Iterator iterator() : 컬랙션의 요소를 읽어옴                                확인                          boolean isEmpty() : 비었는지              int size() : 저장된 객체의 갯수              Object[] toArray() : set에 저장된 객체를 객체배열로 반환              Object[] toArray(Object[] a)                                        import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tObject [] objarr = {\"1\", new Integer(1),\"2\",\"2\",\"3\",\"3\",\"4\",\"4\",\"4\"};  \t\tSet set = new HashSet();  \t\tfor(int i=0;i&lt;objarr.length;i++) {  \t\t\tSystem.out.println(objarr[i]+\"=\"+set.add(objarr[i])); //HashSet에 objarr의 모든 요소를 저장  \t\t}  \t\t//HashSet에 저장된 요소를 출력(set이라서 중복된 것 제외됨)  \t\tSystem.out.println();  \t\tSystem.out.println(set);        \t\t  \t\t//HashSet에 저장된 요소들을 출력(Iterator이용)  \t\tIterator it = set.iterator();        \t\t  \t\twhile(it.hasNext()) { //읽을 요소가 남아있는지 확인  \t\t\tSystem.out.println(it.next()); //요소 하나 꺼내오기  \t\t}// =&gt; 읽은 요소가 없을때까지 꺼내옴  \t}                }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tSet set = new HashSet();        \t\t  \t\t//set의 크기가 6보다 작은 동안 1~45사이의 난수를 저장  \t\tfor(int i=0; set.size()&lt;6 ;i++) {  \t\t\tint num = (int)(Math.random()*45+1);  \t\t\tset.add(num);  \t\t}  \t\tSystem.out.println(set);  \t\t//set은 정렬(순서유지) 안됨 -&gt; LinkedList사용   \t\tList list = new LinkedList(set); //LinkedList(Collection c)  \t\tCollections.sort(list);  //Collections.sort(List list)  \t\tSystem.out.println(list);  \t}                }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashSet set = new HashSet();        \t\t  \t\tset.add(\"abc\");  \t\tset.add(\"abc\");  \t\tset.add(new Person(\"Daivd\",10));  \t\tset.add(new Person(\"Daivd\",10));        \t\t  \t\tSystem.out.println(set);  \t}                }  //equals와 hashCode를 오버라이딩 안해주면 david,10이 두번 다 저장됨  class Person{  \tString name;  \tint age;        \t  \tPerson(String name, int age){  \t\tthis.name=name;  \t\tthis.age = age;  \t}        \t  \tpublic String toString() {  \t\treturn name+\" : \"+age;  \t}          \tpublic int hashCode() {  \t\t//int hash(Object... values);//가변인자  \t\treturn Objects.hash(name,age);  \t}          \tpublic boolean equals(Object obj) {  \t\tif(!(obj instanceof Person)) return false;        \t\t  \t\tPerson p =(Person)obj;  \t\t//나자신의 이름과 나이를 p와 비교  \t\treturn this.name.equals(p.name) &amp;&amp; this.age==p.age;  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashSet setA = new HashSet();  \t\tHashSet setB = new HashSet();  \t\tHashSet setHab = new HashSet();  \t\tHashSet setKyo = new HashSet();  \t\tHashSet setCha = new HashSet();        \t\t  \t\tsetA.add(\"1\"); setA.add(\"2\"); setA.add(\"3\"); setA.add(\"4\"); setA.add(\"5\");  \t\tSystem.out.println(\"A = \"+setA);        \t\t  \t\tsetB.add(\"4\"); setB.add(\"5\"); setB.add(\"6\"); setB.add(\"7\"); setB.add(\"8\");  \t\tSystem.out.println(\"B = \"+setB);        \t\t  \t\t//교집합  \t\tIterator it = setB.iterator();  \t\twhile(it.hasNext()) {  \t\t\tObject tmp = it.next();  \t\t\tif(setA.contains(tmp)) { //setB의 구성요소를 하나씩 빼서 setA에 있는지 확인  \t\t\t\tsetKyo.add(tmp);  \t\t\t}  \t\t}        \t\t  \t\t//차집합  \t\tit = setA.iterator();  \t\twhile(it.hasNext()) {  \t\t\tObject tmp = it.next();  \t\t\tif(!setB.contains(tmp)) {  \t\t\t\tsetCha.add(tmp);  \t\t\t}  \t\t}        \t\t  \t\t//합집합  \t\tit = setA.iterator();  \t\twhile(it.hasNext()) {  \t\t\tsetHab.add(it.next());  \t\t}  \t\tit = setB.iterator();  \t\twhile(it.hasNext()) {  \t\t\tsetHab.add(it.next());  \t\t} //어차피 set은 중복 제거 돼서 중복제거안해줘도됨        \t\t  \t\tSystem.out.println(\"A ∩ B = \"+setKyo);  \t\tSystem.out.println(\"A ∪ B = \"+setHab);  \t\tSystem.out.println(\"A - B = \"+setCha);        \t\t  \t\t//교집합(위에거 간단히)  //\t\tsetA.retainAll(setB);  //\t\tSystem.out.println(\"A ∩ B = \"+setA);  \t\t//합집합  //\t\tsetA.addAll(setB);  //\t\tSystem.out.println(\"A ∪ B = \"+setA);  \t\t//차집합  //\t\tsetA.removeAll(setB);  //\t\tSystem.out.println(\"A - B = \"+setA);  \t}  }                            TreeSet : 범위 검색과 정렬에 유리한 컬렉션 클래스. HashSet보다 데이터 추가, 삭제에 시간이 더 걸림. 이진 탐색 트리(binary search tree)로 구현.                  이진트리는 모든 노드(요소)가 최대 2개의 하위노드(요소)를 갖음. 각 요소가 나무 형태로 연결(LinkedList의 변형)          이진 탐색 트리(binary search tree) : 부모보다 작은 값은 왼쪽에, 큰 값은 오른쪽에 저장(이진트리는 값의 크기랑은 상관없음). 데이터가 많이질 수록 추가, 삭제에 시간이 더 걸림(비교횟수 추가)          데이터 저장 과정 : boolean add(Object o) - 중복이면 false반환, 저장안됨                        Comparator : 비교기준            import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tSet set = new TreeSet();        \t\t  //\t\tfor(int i =0; set.size()&lt;6;i++) {  //\t\t\tint num = (int)(Math.random()*45)+1;  //\t\t\tset.add(num); //set.add(new Integer(num));  //\t\t}  //\t\tSystem.out.println(set);  \t\t//TreeSet이라서 정렬안해도 해줌(Hashset은 정렬 필요)  //\t\tset.add(new Test());   //\t\tset.add(new Test());   //\t\tset.add(new Test());   \t\tset.add(new Test());   \t\tSystem.out.println(set); //[Test@77459877, Test@5b2133b1, Test@72ea2f77, Test@33c7353a]  \t}  }                  //class TestComp implements Comparator{  //  //\t@Override  //\tpublic int compare(Object o1, Object o2) {  //\t\treturn -1; //같은 객체가 아님을 지정  //\t}  //}  class Test implements Comparable{//비교기준이 없다면 에러.           \t@Override  \tpublic int compareTo(Object o) {  \t\treturn -1;  \t}         \t  }  //결론 : \tSet set = new TreeSet(new TestComp);, set.add(new Test()); 처럼 둘중에 하나는 비교기준을 지정해 줘야함                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tTreeSet set = new TreeSet(); //범위검색에 유리        \t\t  \t\tString from = \"b\";  \t\tString to = \"d\";        \t\t  \t\tset.add(\"abc\"); set.add(\"alien\"); set.add(\"bat\");  \t\tset.add(\"car\"); set.add(\"Car\"); set.add(\"disc\");  \t\tset.add(\"dance\"); set.add(\"dZZZZ\"); set.add(\"dzzzz\");  \t\tset.add(\"elephant\"); set.add(\"elevator\"); set.add(\"fan\");  \t\tset.add(\"flower\");        \t\t  \t\tSystem.out.println(set);  \t\tSystem.out.println(\"range search : from \"+from + \" to \"+to);  \t\tSystem.out.println(\"result1 : \"+set.subSet(from, to));  \t\tSystem.out.println(\"result2 : \"+set.subSet(from, to+\"zzz\")); //\"b\"~~~zzz으로 끝나는 부분까지 출력  \t\t/* result1 : [bat, car]  \t\tresult2 : [bat, car, dZZZZ, dance, disc] */  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tTreeSet set = new TreeSet();   \t\tint score[]= {80,95,50,35,45,65,10,100};        \t\t  \t\tfor(int i=0;i&lt;score.length;i++) {  \t\t\tset.add(new Integer(score[i]));  \t\t}        \t\t  \t\tSystem.out.println(\"50보다 작은 값 : \"+set.headSet(50));  \t\tSystem.out.println(\"50보다 큰 값 : \"+set.tailSet(50));  \t\tSystem.out.println(\"50보다 큰 값 : \"+set.subSet(40,80));  \t}  }                — 트리 순회(tree traversal) : 이진트리의 모든 노드를 한번 씩 읽는 것                  전위순회 : 부모 먼저 읽음          후위순위 : 자식 먼저 읽음                      중위순외 : (좌)자식-부모-(우)자식순으로 읽음 (오름차순 정렬됨)  ⇒ treeSet이 정렬에 유리한 이유                    레벨순회 : 순서대로 위에서부터 좌우로 읽음                    Set인터페이스의 메소드 == Collection인터페이스의 메소드              집합과 관련된 메소드(Collection에 변화가 있으면 true, 아니면 false                          Map인터페이스 - 순서x, 중복(키x,값o)                  HashMap(동기화x) : Map인터페이스를 구현한 대표적인 클래스, 데이터를 키와 값의 쌍으로 저장, Hashtable의 신버전. Hashtable은 동기화가 됨.  해싱(hashing)기법으로 데이터를 저장. 데이터가 많아도 검색이 빠름                  LinkedHashMap : 순서 필요할때 사용          해싱(hashing) : 해시함수를 이용해서 헤시테이블(hash table)에 데이터를 저장, 검색                          해시함수(hash function) : key를 넣으면 index를 반환 - 같은 키를 넣으면 항상 같은 값이 나옴              해시테이블(hash table) : 배열과 LikedList가 조합된 형태                              해시테이블에 저장된 데이터를 가져오는 과정                                  키로 해시함수를 호출, 해시코드를 얻는다.                  해시코드(해시함수의 반환값)에 대응하는 LikedList를 배열에서 찾는다.                  LikedList에서 키와 일치하는 데이터를 찾는다.                                — 해시함수는 같은 키에 대해 항상 같은 해시코드를 반환해야 한다. 서로 다른 키일지라도 같은 값의 해시코드를 반환할 수도 있다.                                              주요 메소드                          생성자                                  HashMap()                  HashMap(int initialCapacity) :                  HashMap(int initalCapacity, float loadFactor)                  HashMap(Map m) : 다른 Map을 HashMap으로 변경 가능                                            저장/삭제/수정                                  Object put(Object key, Object value) : 데이터 저장                  void putAll(Map m) : 지정된 Map을 모두 저장                  Object remove(Object key, Object value) : 삭제                  boolean replace(Object key, Object odlValue, Object newValue) : 기존 키를 새로운 키로 변경                                            읽기                                  Set entrySet() : 키과 값으로 이루어진 set을 얻을 수 있음                  Set keySet() : 키 값만 가져옴                  Collection values() : 값만 가져옴                                            기타                                  Object get(Object key) : 키를 넣으면 값이 반환됨                  Object getOr Default(Object key, Object defaultValue) : 저장된 키가 없다면 지정된 값을 반환                  boolean containsKey(Object key) : 지정된 키가 있는지. 있으면 t, 없으면 f                  boolean containsValue(Object value) : 지정된 값이 있는지 있으면 t, 없으면 f                                                                      import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashMap map = new HashMap();  \t\tmap.put(\"myId\",\"1234\");  \t\tmap.put(\"asdf\",\"1111\");   //\t\tSystem.out.println(map);  \t\tmap.put(\"asdf\",\"1234\");  //\t\tSystem.out.println(map);  //\t\t//마지막값으로 입력됨        \t\t  \t\tScanner s = new Scanner(System.in);        \t\t  \t\twhile(true) {  \t\t\tSystem.out.println(\"id와 password를 입력해주세요\");  \t\t\tSystem.out.println(\"id : \");  \t\t\tString id = s.nextLine().trim();        \t\t\t  \t\t\tSystem.out.println(\"password : \");  \t\t\tString password = s.nextLine().trim();  \t\t\tSystem.out.println();        \t\t\t  \t\t\tif(!map.containsKey(id)) {  \t\t\t\tSystem.out.println(\"입력하신 아이디는 존재하지 않습니다. 다시 시도해주세요\");  \t\t\t\tcontinue;  \t\t\t}  \t\t\tif(!(map.get(id).equals(password))) {  \t\t\t\tSystem.out.println(\"비밀번호가 일치하지 않습니다. 다시 시도해주세요\");  \t\t\t\tcontinue;  \t\t\t}else {  \t\t\t\tSystem.out.println(\"로그인 되었습니다!\");  \t\t\t\tbreak;  \t\t\t}  \t\t}  \t}  }                  import java.util.*;          public class  Main {        \t  \tpublic static void main(String[] args) {  \t\tHashMap map = new HashMap();  \t\tmap.put(\"김자바\", new Integer(90));  \t\tmap.put(\"김자바\", new Integer(100));  \t\tmap.put(\"이자바\", new Integer(100));  \t\tmap.put(\"강자바\", new Integer(80));  \t\tmap.put(\"안자바\", new Integer(90));        \t\t  \t\t//entry는 map인터페이스의 내부 인터페이스  \t\tSet set = map.entrySet();  \t\tIterator it = set.iterator();        \t\t  \t\twhile(it.hasNext()) {  \t\t\tMap.Entry e = (Map.Entry)it.next();  \t\t\tSystem.out.println(\"이름 : \"+e.getKey() + \", 점수 : \"+e.getValue());  \t\t}  \t\tset = map.keySet();  \t\tSystem.out.println(\"참가자 명단 : \"+set);        \t\t  \t\tCollection values = map.values();  \t\tit = values.iterator();        \t\t  \t\tint total=0;        \t\t  \t\twhile(it.hasNext()) {  \t\t\tint i = (int)it.next();  \t\t\ttotal += i;  \t\t}  \t\tSystem.out.println(\"총점 : \"+total);  \t\tSystem.out.println(\"평균 : \"+(float)total/set.size());  \t\tSystem.out.println(\"최고 점수 : \"+Collections.max(values));  \t\tSystem.out.println(\"최저 점수 : \"+Collections.min(values));  \t}  }                            TreeMap : 이진탐색트리. 범위검색과 정렬에 유리하며, HashMap보다 데이터 추가, 삭제에 시간이 더 걸림                import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tString data[] = {\"A\",\"K\",\"A\",\"K\",\"D\",\"K\",\"A\",\"K\",\"k\",\"K\",\"Z\",\"D\"};  \t\tHashMap map = new HashMap();    \t\t  \t\tfor(int i=0;i&lt;data.length;i++) {  \t\t\tif(map.containsKey(data[i])) {  \t\t\t\tint value = (int)map.get(data[i]); //map.get() 키를 넣으면 값이 반환  \t\t\t\tmap.put(data[i], value+1);  \t\t\t} else {  \t\t\t\tmap.put(data[i], 1);  \t\t\t}  \t\t}  \t\tIterator it = map.entrySet().iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tMap.Entry entry = (Map.Entry)it.next();  \t\t\tint value = (int)entry.getValue();  \t\t\tSystem.out.println(entry.getKey()+\" : \"+printBar('*',value)+\" \"+value);  \t\t}  \t}  \tpublic static String printBar(char ch, int value) {  \t\tchar bar[] = new char[value];  \t\tfor(int i=0;i&lt;bar.length;i++) {  \t\t\tbar[i] = ch;  \t\t}  \t\treturn new String(bar);  \t}  }      스택과 큐(Stack &amp; Queue)import java.util.*;public class  Main {\tpublic static void main(String[] args) {\t\tStack st = new Stack();\t\tQueue q = new LinkedList(); //Queue인테페이스의 구현체인 LinkedList사용\t\t\t\tst.push(\"0\");\t\tst.push(\"1\");\t\tst.push(\"2\");\t\t            \t\tq.offer(\"0\");\t\tq.offer(\"1\");\t\tq.offer(\"2\");\t\t\t\tSystem.out.println(\"=====Stack=====\");\t\twhile(!st.empty()) {\t\t\tSystem.out.println(st.pop()); //스택요소 하나하나 꺼내기\t\t}\t\tSystem.out.println(\"=====Queue=====\");\t\twhile(!q.isEmpty()) {\t\t\tSystem.out.println(q.poll()); //스택요소 하나하나 꺼내기\t\t}\t}}      스택 : LIFO(Last In First Out, 후입선출)구조. 저장(push), 추출(pop) — 배열이 효율적(순차적이라서)          활용 예 : 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로          import java.util.*;      public class  Main {  \tpublic static void main(String[] args) {  \t\tif(args.length !=1) {  \t\t\tSystem.out.println(\"usage : java Ex11_3 \\\"EXPRESSIN\\\"\");  \t\t\tSystem.out.println(\"Example : java Ex11_3 \\\"((2+3)*1)3\\\"\");  \t\t\tSystem.exit(0);  \t\t}    \t\t  \t\tStack st = new Stack();  \t\tString expression = args[0];    \t\t  \t\tSystem.out.println(\"expression : \"+expression);    \t\t  \t\ttry {  \t\t\tfor(int i=0;i&lt;expression.length();i++) {  \t\t\t\t//입력된 수식에서 하나씩 꺼내기  \t\t\t\tchar ch = expression.charAt(i);     \t\t\t  \t\t\tif(ch=='(') {  \t\t\t\t//여는괄호라면, 스택에 집어넣고  \t\t\t\tst.push(ch+\"\");  \t\t\t\t//닫는 괄호라면, 스택에서 꺼냄  \t\t\t}else if(ch==')') {  \t\t\t\tst.pop();  \t\t\t}  \t\t}  \t\t\t//스택이 비었다면?  \t\t\tif(st.isEmpty()) {  \t\t\t\tSystem.out.println(\"괄호가 일치합니다\");  \t\t\t}else {  \t\t\t\tSystem.out.println(\"1.괄호가 일치하지 않습니다\");  \t\t\t}  \t\t}catch (EmptyStackException e) {  \t\t\t//(2+3)*1)))) 이런식으로 꺼낼 괄호가 없는데 자꾸 추출하려해서 에러날떄  \t\t\tSystem.out.println(\"2.괄호가 일치하지 않습니다\");  \t\t}  }      }            큐 : FIFO(First in First Out, 선입선출)구조, 저장(offer), 추출(poll) — 링크드리스트가 효율적(비순차적이라서) - 인터페이스라 객체생성안됨          활용 예 : 최근사용문서(Recent Files), 인쇄작업 대기목록, 버퍼(buffer)      Queue를 직접 구현                  Queue를 구현할 클래스를 사용(LinkeList 등 공식문서 참조)  ⇒ Queue q = new LinkedList();                        import java.util.*;      public class  Main {  \tstatic Queue q = new LinkedList();  \tstatic final int MAX_SIZE = 5; //Queue에 최대 5개까지 저장됨(최근 5개의 명령어를 저장)    \t  \tpublic static void main(String[] args) {  \t\tSystem.out.println(\"help를 입력하면 도움말을 볼 수 있습니다.\");    \t\t  \t\twhile(true) {  \t\t\tSystem.out.println(\"&gt;&gt;\");  \t\t\ttry {  \t\t\t\t//화면으로부터 라인단위로 입력받음  \t\t\t\tScanner s = new Scanner(System.in);  \t\t\t\tString input = s.nextLine().trim();    \t\t\t\t  \t\t\t\tif(\"\".equals(input)) continue;    \t\t\t\t  \t\t\t\tif(input.equalsIgnoreCase(\"q\")) {  \t\t\t\tSystem.out.println(\"프로그램 종료\");  \t\t\t\tSystem.exit(0);  \t\t\t\t}  \t\t\t\tif(input.equalsIgnoreCase(\"help\")) {  \t\t\t\t\tSystem.out.println(\"help - 도움말을 표시합니다\");  \t\t\t\t\tSystem.out.println(\"q 또는 Q - 프로그램을 종료합니다\");  \t\t\t\t\tSystem.out.println(\"history - 최근에 입력한 명령어를 \"+MAX_SIZE+\"개 보여줍니다\");  \t\t\t\t}else if(input.equalsIgnoreCase(\"history\")) {  \t\t\t\t\tsave(input); //입력한 명령어 저장    \t\t\t\t\t  \t\t\t\t\t//LinkedList의 내용 표시  \t\t\t\t\tLinkedList list = (LinkedList)q;    \t\t\t\t\t  \t\t\t\t\tfinal int size = list.size();  \t\t\t\t\tfor(int i = 0 ; i&lt;size;i++)  \t\t\t\t\t\tSystem.out.println((i+1)+\".\"+list.get(i));  \t\t\t\t}else {  \t\t\t\t\tsave(input);  \t\t\t\t\tSystem.out.println(input);  \t\t\t\t} //if(input.equalsIgnoreCase(\"q\"))  \t\t\t}catch(Exception e) {  \t\t\t\tSystem.out.println(\"입력오류입니다\");  \t\t\t}  \t\t}  \t}      \tprivate static void save(String input) {  \t\t//queue에 저장(빈문자열은 저장안함)  \t\tif(!\"\".equals(input)) {  \t\t\tq.offer(input);    \t\t\t  \t\t\t//queue의 최대크기를 넘으면 제일 처음 입력된 것을 삭제  \t\t\tif(q.size()&gt;MAX_SIZE) //size()는 Collection인터페이스에 정의  \t\t\t\tq.remove(); // == q.pool();  \t\t}  \t}      }      peek : 꺼내지 않고 맨 위에 있는 것을 보는 것밑에 세 개가 예외발생x, 중점으로 쓸것Iterator(새버전), ListIterator, Enumeration(구버전): 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스      Iterator : 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한 것.  컬렉션에 iterator()를 호출해서 Iterator를 구현한 객체를 얻어서 사용          boolean hasNext() : 읽어올 요소가 남아있는지 확인, 있으면 true, 없으면 false(확인)      Object next() : 다음 요소를 읽어온다. next()를 호출하기 전에 hasnext()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다.(읽기)      Map에는 iterator()가 없다. keySet(), entrySet(), values()를 호출해야함                  Map map = new HashMap(); Iterator it =  map.entrySet().iterator();                        import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\tList list = new ArrayList(); //다른컬렉션으로 변경할때 이거만 수정하면 됨  \t\tIterator it =list.iterator();    \t\t  \t\twhile (it.hasNext()) { //boolean hasNext() 읽어올 요소가 있는지 확인  \t\t\tSystem.out.println(it.next()); //Object next() 다음요소 읽음  \t\t}  \t}  }          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t\t//Set은 Collection의 자손  //\t\tCollection c = new HashSet(); //for문의 get이 오류남  \t\tArrayList list = new ArrayList();  \t\tlist.add(\"1\");  \t\tlist.add(\"2\");  \t\tlist.add(\"3\");  \t\tlist.add(\"4\");  \t\tlist.add(\"5\");    \t\t  \t\t//Iterator를 사용했다면 표준화되어있기때문에 List나 Set 둘다 작동함  \t\tIterator it = list.iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t}    \t\t  \t\twhile(it.hasNext()) { //이미 한번 실행됐기때문에 false반환, 실행 안됨  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t\t//즉,Iterator는 1회용 코드임  \t\t}  \t\tSystem.out.println();  \t\t//새로운 iterator객체 얻어옴  \t\tit = list.iterator();    \t\t  \t\twhile(it.hasNext()) {  \t\t\tObject obj = it.next();  \t\t\tSystem.out.println(obj);  \t\t}  \t\tSystem.out.println();  \t\tfor(int i=0;i&lt;list.size();i++) {  \t\t\tObject obj = list.get(i);  \t\t\tSystem.out.println(obj);  \t\t}  \t}  }        Enumeration          boolean hasMoreElements() : 읽어올 요소가 남아있는지 확인, 있으면 true, 없으면 false(확인)      Object nextElement() : 다음 요소를 읽어온다. nextElements()를 호출하기 전에 hasMoreElements()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다.(읽기)        Listiterator : Iterator의 접근성을 향상시킨 것. (단방향 → 양방향 : 이전요소도 읽어올 수 있음)Array: 배열을 다루기 편한 메소드(static)을 제공  배열의 출력 -toString()  배열의 복사 - copyOf(), copyOfRange()  배열 채우기 - fill(), setAll()  배열의 정렬과 검색 - sort(), binarySearch()          sort()로 배열 정렬      binarySearch()로 위치 찾기        다차원 배열의 출력 - deepToString()  다차원 배열의 비교 - deepEquals()  배열을 List로 변환 - asList(Object…a)  람다와 스트임(14장)관련 - parallelXXX(). spliterator(), stream()import java.util.*;public class  Main {\t\tpublic static void main(String[] args) {\t\tint arr[] = {0,1,2,3,4};\t\tint arr2D[][] = { {11,12,13},{21,22,23} };\t\t\t\tSystem.out.println(\"arr = \"+Arrays.toString(arr));\t\tSystem.out.println(\"arr2D = \"+Arrays.toString(arr2D)); //arr2D = [[I@6b884d57, [I@38af3868]\t\tSystem.out.println(\"arr2D = \"+Arrays.deepToString(arr2D));\t\t        \t\tint arr2[] = Arrays.copyOf(arr, arr.length); //arr을 똑같이 복사\t\tint arr3[] = Arrays.copyOf(arr, 3);\t\tint arr4[] = Arrays.copyOf(arr, 7); //남는 공간에 0 채워넣음\t\tint arr5[] = Arrays.copyOfRange(arr, 2,4);\t\tint arr6[] = Arrays.copyOfRange(arr, 0,7);\t\t\t\tSystem.out.println(\"arr2 = \"+Arrays.toString(arr2));\t\tSystem.out.println(\"arr3 = \"+Arrays.toString(arr3));\t\tSystem.out.println(\"arr4 = \"+Arrays.toString(arr4));\t\tSystem.out.println(\"arr5 = \"+Arrays.toString(arr5));\t\tSystem.out.println(\"arr6 = \"+Arrays.toString(arr6));\t\t\t\tint arr7[] = new int[5];\t\tArrays.fill(arr7,9); //arr7 전부를 9로 채움 \t\tSystem.out.println(\"arr7 = \"+Arrays.toString(arr7));\t\t\t\tArrays.setAll(arr7,  i-&gt;(int)(Math.random()*6)+1);\t\tSystem.out.println(\"arr7 = \"+Arrays.toString(arr7));\t\t\t\t//향상된 for문. arr7에서 한개씩 꺼내서 i에 집어넣음 \t\tfor(int i : arr7) {\t\t\tchar graph[] = new char[i];\t\t\tArrays.fill(graph, '*');\t\t\tSystem.out.println(new String(graph)+i);\t\t}\t\t\t\tString str2D[][] = new String[][] { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\",\"CCC\"} };\t\tString str2D2[][] = new String[][] { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\",\"CCC\"} };\t\t\t\tSystem.out.println(Arrays.equals(str2D, str2D2)); //false\t\tSystem.out.println(Arrays.deepEquals(str2D, str2D2));\t\t\t\tchar charr[] = {'A','D','C','B','E'};\t\t\t\tSystem.out.println(\"charr = \"+Arrays.toString(charr));\t\tSystem.out.println(\"index of B = \"+Arrays.binarySearch(charr, 'B')); //정렬 전이라 안나옴\t\tSystem.out.println(\"= After sorting = \");\t\tArrays.sort(charr);\t\tSystem.out.println(\"charr = \"+Arrays.toString(charr));\t\tSystem.out.println(\"index of B = \"+Arrays.binarySearch(charr, 'B'));\t}              }— 순차 검색(탐색)과 이진 검색(탐색)  순차 검색 - 순차적으로 찾음  이진 검색 - 정렬 후 반씩 잘라서 특정지점만 찾기Comparator와 Comparable: 객체 정렬에 필요한 메소드(정렬기준 제공)를 정의한 인터페이스  Comparator : 기본 정렬기준을 구현, 두 객체를 비교  Comparable : 기본 정렬기준 외에 다른 기준으로 정렬, 주어진 객체를 자신과 비교  Compare()과 CompareTo()는 두 객체의 비교결과를 반환하도록 작성. 같으면 0, 오른쪽이 크면 음수, 오른쪽이 작으면 양수import java.util.*;public class  Main {\t\tpublic static void main(String[] args) {\t\tString strArr[] = {\"dog\",\"cat\",\"Tiger\",\"lion\"};\t\tSystem.out.println(\"strArrArray = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr); //Comparable구현에 의해 정렬\t\t//원래 Arrays.sort(정렬대상, 정렬기준)인데 String자체에 기본정렬기준[사전순]이 있어[String 안에 comparable 구현돼있음]지정안해줌\t\tSystem.out.println(\"strArrArray = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr, String.CASE_INSENSITIVE_ORDER); //대소문자 구분x\t\tSystem.out.println(\"strArr = \"+Arrays.toString(strArr));\t\t\t\tArrays.sort(strArr, new Descending());\t\tSystem.out.println(\"strArr = \"+Arrays.toString(strArr));\t}              }class Descending implements Comparator{\tpublic int compare(Object o1, Object o2) {\t\tif(o1 instanceof Comparable &amp;&amp; o2 instanceof Comparable) {\t\t\tComparable c1 = (Comparable)o1;\t\t\tComparable c2 = (Comparable)o2;\t\t\treturn c1.compareTo(c2)*-1;\t\t\t//-1을 곱해서 기본정렬방식의 역순으로 변경. \t\t}\t\treturn -1;\t}}      Integer와 Comparable          버블정렬(불변)          import java.util.*;      public class  Main {    \t  \tpublic static void main(String[] args) {  \t}                static void sort(int [] intarr) {  \tfor(int i=0;i&lt;intarr.length-1;i++) {  \t\tfor(int j=0;j&lt;intarr.length-1-i;i++) {  \t\t\tint tmp = 0;    \t\t\t  \t\t\tif(intarr[j] &gt; intarr[j+1]) {  \t\t\t\ttmp = intarr[j];  \t\t\t\tintarr[j] = intarr[j+1];  \t\t\t\tintarr[j+1]=tmp;  \t\t\t}  \t\t}  \t}  }  }      Collections: 컬렉션을 위한 메소드(static)을 제공  컬렉션 채우기, 복사, 정렬, 검색 - fill(), copy(), sort(), binarySearch() 등      컬렉션의 동기화 - synchronized-0~~~()  List syncList = Colloections.synchronizedList(new ArrayList(…));  ⇒ 동기화 안된 synchronizedList를 넣으면 동기화된 List(Vector와 똑같은 효과)인 syncList가 반환됨    변경불가(readOnly)컬렉션 만들기 - unmodifiable~~~()  싱글톤 컬렉션 만들기 - singleton~~~() : 객체 1개만 저장하는 컬렉션      한종류의 객체만 저장하는 컬력션 만들기 - checked~~~() : 한가지 타입의 객체만 저장가능    List list = new ArrayList();  List checkedList = checkedList(list, String.class); //String만 저장가능  checkedList.add(“abc”);  checkedList.add(3); //에러  import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import static java.util.Collections.*; //Collections를 생략 기능public class  Main {\t\tpublic static void main(String[] args) {\t\tList list = new ArrayList();\t\tSystem.out.println(list);\t\t\t\taddAll(list,1,2,3,4,5); //원래 Collections.addAll()로 써야함\t\tSystem.out.println(list);\t\t\t\trotate(list,2);//반시계방향으로두번회전\t\tSystem.out.println(list);\t\t\t\tswap(list,0,2); //첫번째와 세번쨰를 교환\t\tSystem.out.println(list);\t\t\t\tshuffle(list); //저장된요소의 위치를 임의로 변경\t\tSystem.out.println(list);\t\t\t\tsort(list,reverseOrder()); \t\tSystem.out.println(list);\t\t\t\tsort(list); \t\tSystem.out.println(list);\t\t\t\tint idx = binarySearch(list,3);\t\tSystem.out.println(\"index of 3 = \"+idx);\t\t\t\tSystem.out.println(\"max = \"+max(list));\t\tSystem.out.println(\"min = \"+min(list));\t\tSystem.out.println(\"min = \"+max(list,reverseOrder()));\t\t\t\tfill(list,9); //9로 채움\t\tSystem.out.println(list);\t\t\t\t//list와 같은 크기의 새로운 list생성, 2로 채움\t\tList newlist = nCopies(list.size(),2);\t\tSystem.out.println(\"newList=\"+newlist);\t\t\t\t//공통요소가 없으면 true\t\tSystem.out.println(disjoint(list, newlist));\t\t\t\tcopy(list, newlist);\t\tSystem.out.println(\"newlist=\"+newlist);\t\tSystem.out.println(\"list=\"+list);\t\t\t\t//2를 1로 변경\t\treplaceAll(list,2,1);\t\tSystem.out.println(\"list=\"+list);\t\t\t\tEnumeration e = enumeration(list);\t\tArrayList list2 = list(e);\t\t\t\tSystem.out.println(\"list2 = \"+list2);\t}}"
  },
  
  {
    "title": "날짜와 시간 & 형식화",
    "url": "/posts/%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84-&-%ED%98%95%EC%8B%9D%ED%99%94/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-21 00:00:00 +0900",
    





    
    "snippet": "날짜와 시간      java.util.Date : 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)  date의 메소드는 거의 사용되지 않지만(deprecated), 여전히 쓰이고 잇다.    java.util.Calendar :Date클래스를 개선한 새로운 클래스(JDK1.1), 여전히 단점이 있다 (실무에는 아직 쓰이는 곳이 많음    ...",
    "content": "날짜와 시간      java.util.Date : 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)  date의 메소드는 거의 사용되지 않지만(deprecated), 여전히 쓰이고 잇다.    java.util.Calendar :Date클래스를 개선한 새로운 클래스(JDK1.1), 여전히 단점이 있다 (실무에는 아직 쓰이는 곳이 많음          날짜와 시간을 같이 다루는 것이 단점        java.time 패키지 : Date와 Calendar의 단점을 개선한 새로운 클래스들을 제공(JDK1.8=JDK8)          날짜와 시간의 클래스를 나누어 놓음(LocalDate, LocalTime, LocalDateTime)      Calender클래스추상클래스. getinstace()를 통해 구현된 객체를 얻어야 한다.Calendar cal = new Calendar.getInstance(); //사용자 시스템에 기반해서 서양력, 불교력, 일본력 중 하나를 가져온다. (달력을 지정하는것 보다 애매하게 쓰는게 나중에 달력변경 시 조금만 수정해도 사용할 수 있음 - 추상화 )  get()으로 날짜와 시간 가져오기 - int ger(int field)import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar cal = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tint thisYear = cal.get(Calendar.YEAR); //현재 몇년도인지\t\tint lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);//이달의 마지막 날\t\tSystem.out.println(lastDayOfMonth);\t\t}}            필드명      설명                  YEAR      년              MONTH      월(0부터 시작)              WEEK_OF_MONTH      그 달의 몇 번째 주              WEEK_OF_YEAR      그 해의 몇 번째 주              DATE      일              DAY_OF_MONTH      그 달의 몇 번째 일              DAY_OF_YEAR      그 해의 몇 번째 일              DAY_OF_WEEK      요일              DAY_OF_WEEK_IN_MONTH      그 달의 몇 번째 요일              HOUR      시간(0~11)              HOUR_OF_DAY      시간(0~23)              MINUTE      분              SECOND      초              MILLISECOND      천분의 1초              ZONE_OFFSET      GMT기준 시차(천분의 1초단위)  (한국은 GMT시간보다 9시간빨라서 9로 표시)              AM_PM      오전/오후      import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar cal = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tint thisYear = cal.get(Calendar.YEAR); //현재 몇년도인지\t\tint lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);//이달의 마지막 날\t\tSystem.out.println(lastDayOfMonth);\t\tSystem.out.println(cal.get(Calendar.DAY_OF_WEEK_IN_MONTH));\t\tSystem.out.println(cal.get(Calendar.MONTH)); //0부터시작해서 7나옴 8월임\t\tSystem.out.println(cal.get(Calendar.WEEK_OF_YEAR)); //0부터시작해서 7나옴 8월임\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar today = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tSystem.out.println(\"이 해의 연도 : \"+today.get(Calendar.YEAR));\t\tSystem.out.println(\"월(0~11, 0:1월) : \"+today.get(Calendar.MONTH));\t\tSystem.out.println(\"이 해의 몇 째 주 : \"+today.get(Calendar.WEEK_OF_YEAR));\t\tSystem.out.println(\"이 달의 몇 째 주 : \"+today.get(Calendar.WEEK_OF_MONTH));\t\t\t//DATE와 DAY_OF_MONTH는 같다\t\tSystem.out.println(\"이 달의 며칠 : \"+today.get(Calendar.DATE));\t\tSystem.out.println(\"이 달의 며칠 : \"+today.get(Calendar.DAY_OF_MONTH));\t\tSystem.out.println(\"이 해의 며칠 : \"+today.get(Calendar.DAY_OF_YEAR));\t\tSystem.out.println(\"요일(1~7, 1은 일요일) : \"+today.get(Calendar.DAY_OF_WEEK));\t\tSystem.out.println(\"이 달의 몇 째 요일 : \"+today.get(Calendar.DAY_OF_WEEK_IN_MONTH));\t\tSystem.out.println(\"오전/오후(0:오전,1:오후) : \"+today.get(Calendar.AM_PM));\t\tSystem.out.println(\"시간(0~11) : \"+today.get(Calendar.HOUR));\t\tSystem.out.println(\"시간(0~23) : \"+today.get(Calendar.HOUR_OF_DAY));\t\tSystem.out.println(\"분(0~59) : \"+today.get(Calendar.MINUTE));\t\tSystem.out.println(\"초(0~59) : \"+today.get(Calendar.SECOND));\t\tSystem.out.println(\"1000분의 1초(0~999) : \"+today.get(Calendar.MILLISECOND));\t\t//천분의 1초를 시간으로 표시하기 위해 360000으로 나눔(1시간 = 60*60초)\t\tSystem.out.println(\"TimeZone : \"+today.get(Calendar.ZONE_OFFSET/(60*60/1000)));\t\tSystem.out.println(\"이 달의 마지막 날 : \"+today.getActualMaximum(Calendar.DATE));\t}}  set()으로 날짜와 시간 지정하기datel = Calendar.getInstance();//\t\tdatel.set(Calendar.YEAR, 2022);//\t\tdatel.set(Calendar.MONTH, 10); //11월//\t\tdatel.set(Calendar.DATE, 20);\t\tdatel.set(2022,10,20); //2022년 11월 20일\t\t\t\tCalendar timel = Calendar.getInstance();//\t\tdatel.set(Calendar.HOUR_OF_DAY, 10); //10시//\t\tdatel.set(Calendar.MINUTE, 20); //20분 //\t\tdatel.set(Calendar.SECOND, 30); //30초\t\ttimel.set(10,20,30); //10시import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\t//요일 숫자-&gt;문자열로 바꾸어 표시\t\tfinal String[] DAY_OF_WEEK = {\"\",\"일\",\"월\",\"화\",\"수\",\"목\",\"금\",\"토\",\"일\"};\t\tCalendar date1 = Calendar.getInstance();\t\tCalendar date2 = Calendar.getInstance();\t\t\t\t//month의 경우 0부터 시작하기 때문에 4월인경우 3으로 지정\t\tdate1.set(2022, 3,29);//2022년 4월 29일\t\tSystem.out.println(\"date1은 \" +toString(date1)+DAY_OF_WEEK[date1.get(Calendar.DAY_OF_WEEK)]+\"요일이고, \");\t\tSystem.out.println(\"date2는 \" +toString(date2)+DAY_OF_WEEK[date2.get(Calendar.DAY_OF_WEEK)]+\"요일입니다.\");\t\t//두 날짜간의 차이를 얻으려면, gerTimeInMillis()-날짜,시간을 초단위로 바꿔줌[/1000해줘야함]- 천분의 일초단위로 변환\tlong difference = (date2.getTimeInMillis() - date1.getTimeInMillis())/1000;\tSystem.out.println(\"date1부터 date2까지 \"+difference+\"초가 지났습니다.\");\tSystem.out.println(\"일(day)로 계산하면 \"+difference/(24*60*60)+\"일입니다\");\t//1일 = 24*60*60\t}\tpublic static String toString(Calendar date) {\t\treturn date.get(Calendar.YEAR)+\"년 \"+(date.get(Calendar.MONTH)+1)+\"월 \"+date.get(Calendar.DATE)+\"일\";\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tfinal int[] TIME_UNIT = {3600,60,1};\t\tfinal String[] TIME_UNIT_NAME= {\"시간\",\"분\",\"초\"};\t\tCalendar time1 = Calendar.getInstance();\t\tCalendar time2 = Calendar.getInstance();\t\t\t\ttime1.set(Calendar.HOUR_OF_DAY,10);\t\ttime1.set(Calendar.MINUTE,20);\t\ttime1.set(Calendar.SECOND,30);\t\ttime2.set(Calendar.HOUR_OF_DAY,20);\t\ttime2.set(Calendar.MINUTE,30);\t\ttime2.set(Calendar.SECOND,10);\t\t\t\tSystem.out.println(\"time1 : \"+time1.get(Calendar.HOUR_OF_DAY)+\"시 \"+time1.get(Calendar.MINUTE)+\"분 \"+time1.get(Calendar.SECOND)+\"초\");\t\tSystem.out.println(\"time2 : \"+time2.get(Calendar.HOUR_OF_DAY)+\"시 \"+time2.get(Calendar.MINUTE)+\"분 \"+time2.get(Calendar.SECOND)+\"초\");\t\t\t\t//Math.abs:절대값\t\tlong different = Math.abs(time2.getTimeInMillis()-time1.getTimeInMillis())/1000;\t\tSystem.out.println(\"time1과 time2의 차이는 \"+different+\"초 입니다\");\t\t\t\tString tmp=\"\";\t\tfor(int i=0;i&lt;TIME_UNIT.length;i++) {\t\t\ttmp += different/TIME_UNIT[i]+TIME_UNIT_NAME[i];\t\t\tdifferent %= TIME_UNIT[i];\t\t}\t\tSystem.out.println(\"시분초로 변환하면 \"+tmp+\"입니다.\");\t}}  clear()는 Calendar객체의 모든 필드를 초기화 → 1970년 1월 1일 00:00:00으로 초기화  clear(int field)는 Calendar객체의 특정 필드를 초기화 → 0초 or 0분 or …import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tSystem.out.println(getDaydiff(\"20010103\",\"20010101\")); //2\t\tSystem.out.println(getDaydiff(\"20010103\",\"20010103\")); //0\t\tSystem.out.println(getDaydiff(\"20010103\",\"200103\")); //형식안맞음.\t}\tpublic static int getDaydiff(String yyyymmdd1, String yyyymmdd2) {\t\tint diff=0;\t\ttry{\t\tint year1 = Integer.parseInt(yyyymmdd1.substring(0,4));\t\tint month1 = Integer.parseInt(yyyymmdd1.substring(4,6));\t\tint day1 = Integer.parseInt(yyyymmdd1.substring(6,8));\t\tint year2 = Integer.parseInt(yyyymmdd2.substring(0,4));\t\tint month2 = Integer.parseInt(yyyymmdd2.substring(4,6));\t\tint day2 = Integer.parseInt(yyyymmdd2.substring(6,8));\t\t\t\tCalendar date1 = Calendar.getInstance();\t\tCalendar date2 = Calendar.getInstance();\t\t//date1, date2사이의 약간의(0.000...초 정도)차이 발생//\t\tSystem.out.println(\"date1 : \"+date1);//\t\tSystem.out.println(\"date2 : \"+date2);\t\t//time세팅을 clear해줘야함\t\tdate1.clear();\t\tdate2.clear();\t\tdate1.set(year1, month1,day1);\t\tdate2.set(year2, month2,day2);\t\tdiff=(int)((date1.getTimeInMillis()-date2.getTimeInMillis())/(24*60*60*1000));\t\t} catch(Exception e) {\t\t\tdiff = 0;//substring, parseInt에서 예외 발생시\t\t}\t\treturn diff;\t}}            add()는 특정 필드의 값을 증가 또는 감소(다른 필드에 영향o)      8월 31일에서 일에 +1하면 월도 +1됨                  roll()은 특정 필드의 값을 증가 또는 감소(다른 필드에 영향x)      8월 31일에서 일에 +1해도 월은 그대로임      import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar date = Calendar.getInstance();\t\tdate.set(2022, 7,31);\t\t\t\tSystem.out.println(toString(date)); //8/31\t\tSystem.out.println(\"1일 후\");\t\tdate.add(Calendar.DATE, 1);\t\tSystem.out.println(toString(date)); //9/1\t\tSystem.out.println();\t\tSystem.out.println(\"6달 전\");\t\tdate.add(Calendar.MONTH, -6);\t\tSystem.out.println(toString(date));//3/1\t\tSystem.out.println();\t\tSystem.out.println(\"31일 후(roll)\"); //다른필드(월)에 영향x\t\tdate.roll(Calendar.DATE,31);\t\tSystem.out.println(toString(date)); //3/1\t\tSystem.out.println();\t\tSystem.out.println(\"31일 후(add)\");\t\tdate.add(Calendar.DATE,31);\t\tSystem.out.println(toString(date)); //4/1\t}\tpublic static String toString(Calendar date) {\t\treturn date.get(Calendar.YEAR)+\"년 \"+(date.get(Calendar.MONTH)+1)+\"월 \"+date.get(Calendar.DATE)+\"일\";\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {//달력찍기\t\tif(args.length !=2) {\t\t\tSystem.out.println(\"usage : java Ex10\");\t\t\treturn;\t\t}\t\tint year = Integer.parseInt(args[0]);\t\tint month = Integer.parseInt(args[1]);\t\tint START_DAY_OF_WEEK = 0;\t\tint END_DAY_OF_WEEK = 0;\t\t\t\tCalendar sDay = Calendar.getInstance();//시작일\t\tCalendar eDay = Calendar.getInstance();//끝일\t\t\t\t//월의 경우 -1해줘야함 (0~11)\t\tsDay.set(year,month-1,1);\t\teDay.set(year,month,1);\t\t\t\t//다음 달 첫날에서 하루를 빼면 현재달의 마치막 날이 출력\t\teDay.add(Calendar.DATE, -1);\t\t\t\t//첫번째요일이 무슨 요일인지\t\tSTART_DAY_OF_WEEK = sDay.get(Calendar.DAY_OF_WEEK);\t\t\t\t//eDay의 지정된 날짜\t\tEND_DAY_OF_WEEK=eDay.get(Calendar.DATE);\t\t\t\tSystem.out.println(\"       \"+args[0]+\"년 \"+args[1]+\"일\");\t\tSystem.out.println(\" SU MO TU WE TH FR SA\");\t\t\t\t//해당 월의 1일이 어느 요일인지에 따라서 공백을 출력(일요일부터 시작)\t\tfor(int i=1;i&lt;START_DAY_OF_WEEK;i++) {\t\t\tSystem.out.print(\"   \");\t\t}\t\tfor(int i = 1, n=START_DAY_OF_WEEK;i&lt;=END_DAY_OF_WEEK;i++,n++) {\t\t\tSystem.out.print((i&lt;10)?\"  \"+i:\" \"+i);\t\t\tif(n%7==0) System.out.println();\t\t}\t}}      Date와 Calendar간의 변환          Date의 메소드는 대부분 deprecated되었지만 여전히 사용됨(하위호환성-옛날 기능도 계속 지원해주려고 신경씀)          import java.util.Calendar;      public class  Main {  \tpublic static void main(String[] args) {  \t\t//Calendar-&gt;Date  \t\tCalendar cal = Calendar.getInstance();  \t\tDate d = new Date(cal.getTimeInMillis()); //Date(long date)    \t\t  \t\t//Date -&gt; Calendar  \t\tDate d = new Date();  \t\tCalendar cal = Calendar.getInstance();  \t\tcal.setTime(d);  \t}  }      형식화클래스: java.text 패키지의 DecimalFormat(10진수숫자형식) SimpleDateFormat(날짜형식화)  숫자와 날짜를 원하는 형식으로 쉽게 출력 가능 (숫자, 날짜 → 형식문자열)import java.text.DecimalFormat;public class  Main {\tpublic static void main(String[] args) {\t\tdouble num = 1234567.89;\t\tDecimalFormat df = new DecimalFormat(\"#.\\#E0\"); //지수형식 \t\tSystem.out.println(df); //java.text.DecimalFormat@5c8\t\tString result = df.format(num);\t\tSystem.out.println(result); //1.2E6\t}}  형식 문자열에서 숫자와 날짜를 뽑아내는 기능(형식문자열→숫자, 날짜)import java.text.DecimalFormat;import java.text.ParseException;public class  Main {\tpublic static void main(String[] args) throws ParseException {\t\tDecimalFormat df = new DecimalFormat(\"#,###.##\"); //지수형식 \t\tNumber num = df.parse(\"1,234,567.89\");\t\tdouble d = num.doubleValue();\t\tSystem.out.println(d); //1234567.89\t}}      DecimalFormat                  숫자를 형식화 할때 사용(숫자 → 형식문자열)                            특정 형식의 문자열을 숫자로 변환할 때도 사용(형식 문자열→숫자)          import java.text.DecimalFormat;          public class  Main {  \tpublic static void main(String[] args) {  \t\tdouble num = 1234567.89;  \t\tString[] pattern = {  \t\t\t\t\"0\",  \t\t\t\t\"#\",  \t\t\t\t\"0.0\",  \t\t\t\t\"#.#\",  \t\t\t\t\"0000000000.0000\",  \t\t\t\t\"##########.####\",  \t\t\t\t\"#.\\#-\",  \t\t\t\t\"-#.#\",  \t\t\t\t\"#,###.##\",  \t\t\t\t\"#,####.##\",  \t\t\t\t\"\\#E0\",  \t\t\t\t\"0E0\",  \t\t\t\t\"#\\#E0\",  \t\t\t\t\"00E0\",  \t\t\t\t\"###\\#E0\",  \t\t\t\t\"0000E0\",  \t\t\t\t\"#.\\#E0\",  \t\t\t\t\"0.0E0\",  \t\t\t\t\"0.000000000E0\",  \t\t\t\t\"00.00000000E0\",  \t\t\t\t\"000.0000000E0\",  \t\t\t\t\"#.########\\#E0\",  \t\t\t\t\"##.#######\\#E0\",  \t\t\t\t\"###.######\\#E0\",  \t\t\t\t\"#,###.##+;\\#m###.#\\#-\",  \t\t\t\t\"#.#%\",  \t\t\t\t\"#,#\\u2030\",  \t\t\t\t\"\\u00A4 #,####\",  \t\t\t\t\"'#'#,###\",  \t\t\t\t\"''#,###\",  \t\t};  \t\tfor(int i=0;i&lt;pattern.length;i++) {  \t\t\tDecimalFormat df = new DecimalFormat(pattern[i]);  \t\t\tSystem.out.printf(\"%19s : %s\\n\",pattern[i],df.format(num));  \t\t}  \t}  }  /*  0 : 1234568  # : 1234568  0.0 : 1234567.9  #.# : 1234567.9  0000000000.0000 : 0001234567.8900  ##########.#### : 1234567.89  #.\\#- : 1234567.9-  -#.# : -1234567.9  #,###.## : 1,234,567.89  #,####.## : 123,4567.89  \\#E0 : .1E7  0E0 : 1E6  #\\#E0 : 1.2E6  00E0 : 12E5  ###\\#E0 : 123.5E4  0000E0 : 1235E3  #.\\#E0 : 1.2E6  0.0E0 : 1.2E6  0.000000000E0 : 1.234567890E6  00.00000000E0 : 12.34567890E5  000.0000000E0 : 123.4567890E4  #.########\\#E0 : 1.23456789E6  ##.#######\\#E0 : 1.23456789E6  ###.######\\#E0 : 1.23456789E6  #,###.##+;\\#m###.#\\#- : 1,234,567.89+  #.#% : 123456789%  #,#‰ : 1,2,3,4,5,6,7,8,9,0‰  ¤ #,#### : ? 123,4568  '#'#,### : \\#1,234,568  ''#,### : '1,234,568  */                      ⚠️ Integer,parseInt는 콤마(,)가 포함된 문자열을 숫자로 변환 못함      import java.text.DecimalFormat;      public class  Main {  \tpublic static void main(String[] args) {  \t\tDecimalFormat df = new DecimalFormat(\"#,###.#\");  \t\tDecimalFormat df2 = new DecimalFormat(\"#.##\\#E0\");    \t\t  \t\ttry {  //\t\t\tSystem.out.println(Double.parseDouble(\"1,234,567.89\")); //콤마때매 변환 불가로 에러  \t\t\tSystem.out.println(Double.parseDouble(\"1234567.89\"));   \t\t\tNumber num = df.parse(\"1,2 34,567.89\");  \t\t\tSystem.out.print(\"1,234,567.89\"+\" -&gt; \");    \t\t\t  \t\t\tdouble d = num.doubleValue();  \t\t\tSystem.out.print(d+\" -&gt; \"); //1234567.89    \t\t\t  \t\t\tSystem.out.println(df2.format(num)); //1.235E6  \t\t} catch(Exception e) {  \t\t}  \t}  }            SimpleDateFormat          날짜와 시간을 다양한 형식으로 출력할 수 있게 해줌          import java.text.SimpleDateFormat;  import java.util.Date;      public class  Main {  \tpublic static void main(String[] args) {  \t\tDate today = new Date();  \t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");//소문자 mm은 분이 출력    \t\t  \t\tString result = df.format(today);  \t\tSystem.out.println(result);  \t}  }              특정 형식으로 된 문자열에서 날짜와 시간 뽑아내기          import java.text.DateFormat;  import java.text.ParseException;  import java.text.SimpleDateFormat;  import java.util.Date;      public class  Main {  \tpublic static void main(String[] args) throws ParseException {  \t\tDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");  \t\tDateFormat df2 = new SimpleDateFormat(\"yyyy/MM/dd\");    \t\t  \t\tDate d = df.parse(\"2015년 11월 23일\"); //문자열에서 날짜 뽑기  \t\tString result = df2.format(d); //뽑은 날자 문자열로 바꾸기  \t\tSystem.out.println(result); //2015/11/23    \t\t  \t}  }      월은 MM으로import java.text.SimpleDateFormat;import java.util.Date;public class  Main {\tpublic static void main(String[] args) {\t\tDate today = new Date();\t\t\t\tSimpleDateFormat sdf1, sdf2,sdf3,sdf4;\t\tSimpleDateFormat sdf5, sdf6,sdf7,sdf8,sdf9;\t\t\t\tsdf1=new SimpleDateFormat(\"yyyy-MM-dd\");\t\tsdf2=new SimpleDateFormat(\"''yy년 MMM dd일 E요일\");\t\tsdf3=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\t\tsdf4=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss a\");\t\t\t\tsdf5=new SimpleDateFormat(\"오늘은 올 해의 D번째 날입니다\");\t\tsdf6=new SimpleDateFormat(\"오늘은 이 달의 d번째 날입니다\");\t\tsdf7=new SimpleDateFormat(\"오늘은 올 해의 w번째 주입니다\");\t\tsdf8=new SimpleDateFormat(\"오늘은 이 달의 W번째 날입니다\");\t\tsdf9=new SimpleDateFormat(\"오늘은 이 달의 F번째 E요일입니다\");\t\t\t\tSystem.out.println(sdf1.format(today));\t\tSystem.out.println(sdf2.format(today));\t\tSystem.out.println(sdf3.format(today));\t\tSystem.out.println(sdf4.format(today));\t\tSystem.out.println(sdf5.format(today));\t\tSystem.out.println(sdf6.format(today));\t\tSystem.out.println(sdf7.format(today));\t\tSystem.out.println(sdf8.format(today));\t\tSystem.out.println(sdf9.format(today));\t}}import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;public class  Main {\tpublic static void main(String[] args) {\t\tDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");\t\tDateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd\");\t\t\t\ttry {\t\t\tDate d = df.parse(\"2022년 9월 30일\");\t\t\tSystem.out.println(df2.format(d));\t\t}catch(Exception e) {}\t}}"
  },
  
  {
    "title": "java.lang 패키지와 유용한 클래스",
    "url": "/posts/java.lang%ED%8C%A8%ED%82%A4%EC%A7%80%EC%99%80_%EC%9C%A0%EC%9A%A9%ED%95%9C_%ED%81%B4%EB%9E%98%EC%8A%A4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-15 00:00:00 +0900",
    





    
    "snippet": "Object 클래스: 모든 클래스의 최고 조상. 오직 11개의 메소드만을 가지고 있다.nitity(), wait() 등은 쓰레드(13장)와 관련된 메소드이다            Object클래스의 메소드      설명                  protected Object clone()      객체 자신의 복사본을 반환              ...",
    "content": "Object 클래스: 모든 클래스의 최고 조상. 오직 11개의 메소드만을 가지고 있다.nitity(), wait() 등은 쓰레드(13장)와 관련된 메소드이다            Object클래스의 메소드      설명                  protected Object clone()      객체 자신의 복사본을 반환              public boolean equals(Object obj)      객체 자신과 객체 obj가 같은 객체인지 알려준다(같으면 true)              protected public void finalize()      객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출. 이 때 수행되어야하는 코드가 있을 때 오버라이딩(거의 사용안함)              public Class getClass()      객체 자신의 클래스 정보를 담고있는 Class 인스턴스를 반환              public int hashCode      객체 자신의 해시코드를 반환              public String toString()      객체 자신의 정보를 문자열로 반환              public void notify()      객체 자신을 사용하려고 기다리는 쓰레드 하나만 깨움              public void notifyAll()      객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨움              public void wait()  public void wait(long time out)  public void wait(long timeout, int nanos)      다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다. (timeout은 천분의 1초, nanos는 10의9제곱분의 1초)        [!important]Class처럼 앞글자가 대문자인 Class는 클래스 정보를 담기위한 클래스이다.자바 파일을 저장할때 class파일이 생성되고, class 객체가 생성됨. Class를 호출하면 이때 생성된 class객체를 가지고옴이것을 가지고 객체 생성도 하고 정보를 얻을 수 있게 하는 것이 ReflectionAPI라고 한다.equals(Object obj): 객체 자신(this)과 주어진 객체(obj)를 비교한다. 같으면 true, 다르면 falseObject클래스의 equal()는 객체의 주소를 비교(참조변수 값 비교)— == 는 각 객체의 주소가 같을 경우에만 true. 서로 다른 두 객체는 항상 주소가 다르다.//Object의 equals()를 오버라이딩 해서 주소가 아닌 value값을 비교하도록 함class Value{\tint value;\t\tValue(int value){\t\tthis.value = value;\t}\tpublic boolean equals(Object obj) { //오버라이딩\t\t//참조변수의 형변환 전에는 반드시 instaceof로 확인해야 함.\t\tif(!(obj instanceof Value)) return false;\t\tValue v = (Value)obj; //obj를 value로 형변환. obj안에 value라는 멤버가 없음\t\t//return this == obj; //주소비교. 서로 다른 객체는 항상 다른 주소를 가져서 거짓이 나옴\t\treturn this.value == v.value;\t}}public class  Main {\tpublic static void main(Strin] args) {\t\tValue v1 = new Value(10);\t\tValue v2 = new Value(10);\t\tSystem.out.println(v1.value);\t\tSystem.out.println(v2.value);\t\tSystem.out.println(v1);\t\tSystem.out.println(v2);\t\tSystem.out.println(\"=====================\");\t\tif(v1 == v2) \t\t\tSystem.out.println(\"v1과 v2의 값이 같습니다\");\t\t\t\telse \t\t\tSystem.out.println(\"v1과 v2의 값이 다릅니다\"); //출력됨\t\tSystem.out.println(\"=================\");\t\tif(v1.equals(v2)) \t\t\tSystem.out.println(\"v1과 v2의 값이 같습니다\"); //출력됨\t\t\t\telse \t\t\tSystem.out.println(\"v1과 v2의 값이 다릅니다\");\t\t\t}}  인스턴스 변수의 값을 비교하도록 equals()를 오버라이딩class person{\tlong id;\t\tpublic boolean equals(Object obj) {\t\tif(obj instanceof person) {\t\t\treturn id == ((person)obj).id; //obj가 Object타입 값이므로 id값을 참조하기 위해서 person타입으로 형변환 필요\t\t}\t\telse \t\t\treturn false; //타입이 person이 아니라면 값을 비교할 필요도 없다.\t}}class Person{\tlong id;\t\tpublic boolean equals(Object obj) {\t\tif(!(obj instanceof Person)) {\t\t\treturn false; //타입이 person이 아니라면 값을 비교할 필요도 없다.\t}//\t\treturn id == ((Person)obj).id;\t\tPerson p = (Person)obj;\t\treturn id == p.id;\t}\tPerson(long id){\t\tthis.id = id;\t}}public class  Main {\tpublic static void main(Strin] args) {\t\tPerson p1 = new Person(8011081111222L);\t\tPerson p2 = new Person(8011081111222L);\t\t\t\tif(p1.equals(p2))\t\t\tSystem.out.println(\"p1과 p2는 같은 사람입니다\"); //출력\t\telse\t\t\tSystem.out.println(\"p1과 p2는 다른 사람입니다.\");\t}}hashCode(): 객체의 해시코드(hash code)를 반환하는 메소드Object클래스의 hashCode()는 객체의 주소를 int로 변환해서 반환⇒ 객체의 지문이라고 부르기도 함.public class Object{\tpublic native int hashcode();}      equals()를 오버라이딩하면, hashCode()도 오버라이딩해야한다.    : 둘다 객체의 주소를 가지고 작업하기 때문에 둘다 주소를 iv를 사용하여 작업하도록 오버라이딩 해야함    equals()의 결과가 true인 두 객체의 해시코드는 같아야 하기 때문      public class  Main {      \tpublic static void main(Strin] args) {  \t\tString str1 = new String(\"abc\");  \t\tString str2 = new String(\"abc\");  \t\tSystem.out.println(str1.equals(str2)); //true  \t\tSystem.out.println(str1.hashCode()); //96354  \t\tSystem.out.println(str2.hashCode()); //96354  \t\t//equals값이 같으면 hashCode값도 같아야 함    \t\t  \t\t//System.identityHashCode(str1) == Object클래스의 hashCode  \t\tSystem.out.println(System.identityHashCode(str1));  \t\tSystem.out.println(System.identityHashCode(str2));  \t\t//오버라이딩 하기 전의 기능이 필요할 때 사용. 객체마다 다른 해시코드를 반환함.  \t}  }      toString(), toString()의 오버라이딩      toString() : 객체를 문자열(string)으로 반환하기 위한 메소드  -&gt; ‘객체 == iv집합’이므로 객체를 문자열로 변환한다는 것은 iv값을 문자열로 변환한다는 것과 같은 의미    public String toString() { //Object클래스의 toString()  return  getClass().getName()+”@”+Integer.toHexString(hashCode());  }      class Card{  \tpublic String toString() {    //Object클래스의 toString()  \t\treturn \"kind : \"+kind+\", number : \"+number;  \t} //toString 오버라이딩  \tString kind;  \tint number;    \t  \tCard(){  \t\tthis(\"SPADE\",1);  \t}    \t  \tCard(String kind, int number){  \t\tthis.kind = kind;  \t\tthis.number = number;  \t}  }  public class  Main {  \tpublic static void main(Strin] args) {  \t\tSystem.out.println(new Card().toString()); //Card@7a81197d, kind : SPADE, number : 1  \t\tSystem.out.println(new Card(\"HEART\",10).toString()); //Card@5ca881b5 , kind : HEART, number : 10  \t}  }          import java.util.Objects;      class Card{  \tString kind;  \tint number;    \t  \tCard(){  \t\tthis(\"SPADE\",1);  \t}    \t  \t//============================  \t////Source탭의 Generate hashCode()and equals()가 자동으로 해준 hashCode와 equals의 오버라이딩  //\t@Override  //\tpublic int hashCode() {  //\t\treturn Objects.hash(kind, number);  //\t}  //  //\t@Override  //\tpublic boolean equals(Object obj) {  //\t\tif (this == obj)  //\t\t\treturn true;  //\t\tif (obj == null)  //\t\t\treturn false;  //\t\tif (getClass() != obj.getClass())  //\t\t\treturn false;  //\t\tCard other = (Card) obj;  //\t\treturn Objects.equals(kind, other.kind) &amp;&amp; number == other.number;  //\t} //별로 안어려워서 직접 만드는게 더 직관적이고 좋을 확률이 큼!!  //================================================  \tpublic boolean equals(Object obj) {  \t\tif(!(obj instanceof Card))  \t\t\treturn false;    \t\t  \t\tCard c = (Card)obj;  \t\treturn this.kind.equals(c.kind) &amp;&amp; this.number==c.number;  \t\t//kind가 문자열이라서 equals 써줌  \t}  \tequals() 오버라이딩 해주면 hashCode도 오버라이딩 해줘야함  \tpublic int hashCode() {  \t\treturn Objects.hash(kind, number /*더 넣어도 됨*/);   \tint hash(Object... value){...} : 매개변수가 가변인자(Object...)라서 호출시 지정하는 값의 개수가 정해져 있지 않다.  \t}//iv가 같으면 같은 값이 나오게 됨    \t    \t  \tCard(String kind, int number){  \t\tthis.kind = kind;  \t\tthis.number = number;  \t}  \tpublic String toString() {    //Object클래스의 toString()  \t\treturn \"kind : \"+kind+\", number : \"+number;  \t} //toString 오버라이딩  }  public class  Main {  \tpublic static void main(Strin] args) {  \t\tCard c1 = new Card();  \t\tCard c2 = new Card();  \t\tSystem.out.println(c1.toString()); //Card@7a81197d, kind : SPADE, number : 1  \t\tSystem.out.println(c2.toString()); //Card@5ca881b5 , kind : HEART, number : 10  \t\tSystem.out.println(\"===================\");  \t\tSystem.out.println(c1.equals(c2));  \t\tSystem.out.println(c1.hashCode()); //-1842861219  \t\tSystem.out.println(c2.hashCode()); //-1842861219  \t\t//equals가 true면 hashCode가 똑같이 나와야 함  \t\tSystem.out.println(\"===================\");  \t\tCard c3 = new Card(\"HEART\",10);  \t\tCard c4 = new Card(\"DIAMON\",5);  \t\tSystem.out.println(c3.toString()); //kind : HEART, number : 10  \t\tSystem.out.println(c4.toString()); //kind : DIAMON, number : 5  \t\tSystem.out.println(c3.equals(c4)); //false  \t\tSystem.out.println(c3.hashCode()); //2127040613  \t\tSystem.out.println(c4.hashCode()); //-1921929034  \t\t//equals가 false라서 hashCode도 다른 값이 출력됨  \t}  }      String클래스: 문자열을 다루기 위한 클래스String클래스 = 데이터(char[]) + 메소드(문자열관련)내용을 변경할 수 없는 불변(immutable) 클래스String a = “a”; String b = “b”; a=a+b;일때 a의 “a”값이 사라지고 “ab”가 들어오는게 아니라 “ab”라는 객체가 새로 생성되어 a에 “ab”객체의 주소가 들어가고 “a” 객체는 사라지지않음.⇒ 덧셈 연산자를 이용한 문자열 결합은 성능이 떨어짐(매번 객체가 새로 생성됨)문자열의 변경이나 결합이 잦다면, 내용을 변경 가능한 StringBuffer(내용변경가능)를 사용      문자열 비교      public class  Main {  \tpublic static void main(Strin] args) {  \t\t//하나의 문자열을 여러 참조변수가 공유  \t\tString str1 = \"abc\"; //문자열 리터럴 \"abc\"의 주소가 str1에 저장됨  \t\tString str2 = \"abc\"; //문자열 리터럴 \"abc\"의 주소가 str1에 저장됨  \t\tSystem.out.println(str1 == str2); //true  \t\tSystem.out.println(\"equals 비교 : \"+str1.equals(str2)); //true    \t\t  \t\t//항상 새로운 객체 생성  \t\tString str3 = new String(\"abc\");//새로운 String인스턴스 생성  \t\tString str4 = new String(\"abc\");//새로운 String인스턴스 생성  \t\tSystem.out.println(str3 == str4); //false  \t\tSystem.out.println(\"equals 비교 : \"+str3.equals(str4)); //true  \t\t//String은 변경 불가라 굳이 이렇게 할 필요는 없음  \t}  }        문자열 리터럴 : 프로그램 실행시 자동으로 생성 (constant pool에 저장”          같은 내용의 문자열 리터럴은 하나만 만들어짐(불변이라)ㅈ            빈 문자열 (””, empty string)    : 내용이 없는 크기가 0인 char형 배열을 저장하는 문자열        크기가 0인 배열을 생성하는 것은 어느 타입이나 가능.      public class  Main {  \tpublic static void main(Strin] args) {  \t\tchar charr[] = new char[0]; //길이가 0인 배열 = 데이터 저장 불가  \t\tint iarr[] = {}; //길이가 0인 배열 = 데이터 저장 불가  \t\t//주로 숫자를 문자로 바꿀때나(\"\"+5=\"5\") 배열초기화시(null보다 빈문자열이 편리) 사용함  \t}  }      CharSequence : 인터페이스. CharBuffer, Segment, String, StringBuffer, StringBuilder 클래스들의 공통 조상이 없어서 CharSequence 인터페이스로 묶어준거임.regex : 정규식join()과 StringJoinner: 여러 문자열 사이에 구분자를 넣어서 결합한다. (static메소드)import java.util.Arrays;public class  Main {\tpublic static void main(Strin] args) {\t\tString animals = \"dog,cat,bear\";\t\tString arr[] = animals.split(\",\"); //위 문자열을 ,별로 나눠서 배열로 저장\t\tSystem.out.println(Arrays.toString(arr));/dog, cat, bear]\t\tString str = String.join(\"-\", arr); //배열의 문자열을 '-'로 구분해서 결합(배열x 문자열o)\t\tSystem.out.println(str); //dog-cat-bear\t}}문자열과 기본형 간의 변환      숫자를 문자열로 바꾸는 법      \t\tint i = 100;  \t\tString str1 = i+\"\";  \t\tString str2 = String.valueOf(i);            문자열을 숫자로 바꾸는 법      \t\tint i2 = Integer.parseInt(\"100\"); //옛날 방법  \t\tint i3 = Integer.valueOf(\"100\"); //새로운 방법. 위 방법이 종류가 많아져서 통합해버림  \t\tInteger i4 = Integer.valueOf(\"100\"); //반환타입이 Integer  \t\tint i5 = new Integer(100).intValue(); //밑에서 자세히              [!important]byte, short을 문자열로 변경할 때는 String valueOf(int)를 사용하면 됨      public class  Main {\tpublic static void main(Strin] args) {\t\tint iVal = 100;//\t\tString strVal = String.valueOf(iVal);\t\tString strVal = iVal+\"\";\t\t\t\tdouble dVal = 200.0;//\t\tString strVal2 = String.valueOf(dVal);\t\tString strVal2 = dVal + \"\";\t\t\t\tdouble sum = Integer.parseInt(\"+\"+strVal) //문자열-&gt;숫자\t\t\t\t\t\t\t\t+Double.parseDouble(strVal2);\t\tdouble sum2 = Integer.valueOf(strVal)+Double.valueOf(strVal2);\t\t\t\t\t\tSystem.out.println(String.join(\"\",strVal,\"+\",strVal2,\"=\")+sum);\t\tSystem.out.println(strVal+\"+\"+strVal2+\"=\"+sum2); //성능 떨어짐\t}}      n진법 문자열을 숫자로      public class  Main {  \tpublic static void main(Strin] args) {  //\t\tint i5 = Integer.parseInt(\"FF\"); //에러. NumberFormatException. 10진수에 ff가 없음  \t\tSystem.out.println(\"i = \" +Integer.parseInt(\"100\")); //100  \t\tSystem.out.println(\"i = \" +Integer.parseInt(\"100\",10)); //100 위랑 같은거임  \t\tSystem.out.println(\"i1 = \"+Integer.parseInt(\"100\",2)); //4  \t\tSystem.out.println(\"i2 = \"+Integer.parseInt(\"100\",8)); //64  \t\tSystem.out.println(\"i3 = \"+Integer.parseInt(\"100\",16)); //256  \t\tSystem.out.println(\"i4 = \"+Integer.parseInt(\"FF\",16)); //255  \t}  }      StringBuffer의 생성자와 메소드StringBuffer sb = new StringBuffer(”Hi”) 는 16+2(”h”, “i”로 총 2칸)=18문자를 저장할 수 있는 StringBuffer인스턴스를 생성버퍼크기 = char[] 크기⚠️ 자바에서는 범위가 주어졌을때 start ≤ x &lt;end 라 끝 값은 언제나 포함안됨import javax.xml.transform.Source;public class  Main {\tpublic static void main(Strin] args) {\t\tStringBuffer sb = new StringBuffer(\"01\");\t\tStringBuffer sb2 = sb.append(23);\t\tsb.append(\"4\").append(56); //56도 문자로 들어감\t\t\t\tStringBuffer sb3 = sb.append(78);\t\tsb3.append(9.0);\t\t\t\tSystem.out.println(\"sb = \"+sb); //0123456789.0\t\tSystem.out.println(\"sb2 = \"+sb2); //0123456789.0\t\tSystem.out.println(\"sb3 = \"+sb3); //0123456789.0\t\t\t\tSystem.out.println(\"sb = \"+sb.deleteCharAt(10)); //01234567890\t\tSystem.out.println(\"sb = \"+sb.delete(3, 6)); //01267890\t\tSystem.out.println(\"sb = \"+sb.insert(3, \"abc\")); //012abc67890\t\tSystem.out.println(\"sb = \"+sb.replace(6, sb.length(), \"END\")); //012abcEND\t\t\t\tSystem.out.println(\"capacity : \"+sb.capacity()); //18. 처음 sb객체 생성시 \"01\"로 생성해서 16+2\t\tSystem.out.println(\"length : \"+sb.length()); //9\t}}StringBuilder      StringBuffer : 동기화 돼있다. 멀티 쓰레드(13장)에 안전(thread-safe)  → 멀티 쓰레드 프로그램이 아닌경우, 동기화는 불필요한 성능저하를 불러옴        StringBuilder : 동기화 안되어있다. 싱글 쓰레드일때는 StringBuilder를 사용하면 성능이 향상됨  Math: 수학관련 static 메소드의 집합  E : 자연로그의 밑  PI : 원주율  round : 반올림  — double d = 90.7552; d = (Math.round(d*100))/100.0; ⇒ 90.76            ![image](/assets/images/java/2022-08-15-javalang/IMG-20240818214102-9.png      ]      public class  Main {\tpublic static void main(Strin] args) {\t\tdouble sum=0;\t\tdouble sum1=0;\t\tdouble sum2=0;\t\tfor(double d = 1.5; d&lt;=10.5; d++) {\t\t\tdouble d1= Math.round(d);\t\t\tdouble d2= Math.rint(d); //반올림하는데 .5는 짝수를 출력\t\t\t\t\t\tSystem.out.printf(\"%4.1f %4.1f, %4.1f%n\",d,d1,d2);\t\t\t\t\t\tsum+=d;\t\t\tsum1+=d1;\t\t\tsum2+=d2;\t\t\tSystem.out.println(\"====================\");\t\t\tSystem.out.printf(\"%4.1f %4.1f, %4.1f%n\",sum,sum1,sum2);\t\t\tSystem.out.println(\"******************\");\t\t/*\t\t 1.5  2.0,  2.0\t\t====================\t\t 1.5  2.0,  2.0\t\t******************\t\t 2.5  3.0,  2.0\t\t====================\t\t 4.0  5.0,  4.0\t\t******************\t\t 3.5  4.0,  4.0\t\t====================\t\t 7.5  9.0,  8.0\t\t******************\t\t 4.5  5.0,  4.0\t\t====================\t\t12.0 14.0, 12.0\t\t******************\t\t 5.5  6.0,  6.0\t\t====================\t\t17.5 20.0, 18.0\t\t******************\t\t 6.5  7.0,  6.0\t\t====================\t\t24.0 27.0, 24.0\t\t******************\t\t 7.5  8.0,  8.0\t\t====================\t\t31.5 35.0, 32.0\t\t******************\t\t 8.5  9.0,  8.0\t\t====================\t\t40.0 44.0, 40.0\t\t******************\t\t 9.5 10.0, 10.0\t\t====================\t\t49.5 54.0, 50.0\t\t******************\t\t10.5 11.0, 10.0\t\t====================\t\t60.0 65.0, 60.0\t\t******************\t\t\t *///rint가 최종 합산이 더 정확함. \t\t}\t}}래퍼(wrapper)클래스: 기본형 값을 감싸는 클래스. 8개의 기본형을 객체로 다뤄야할 때 사용.public class  Main {\tpublic static void main(Strin] args) {\t\tInteger i = new Integer(100);\t\tInteger i2 = new Integer(100);\t\t\t\tSystem.out.println(\"i==i2 ? \"+(i==i2)); //false\t\tSystem.out.println(\"i.equals(i2)? \"+i.equals(i2)); //true\t\tSystem.out.println(\"i.compareTo(i2) \"+i.compareTo(i2)); //0, 같으면 0, 오른쪽이 작으면 양수, 오른쪽이 크면 음수\t\tSystem.out.println(\"i.toString() = \"+i.toString()); //100(문자열)\t\t\t\tSystem.out.println(\"MAX_VALUE = \"+Integer.MAX_VALUE); //2147483647 . 최댓값 (+20억)\t\tSystem.out.println(\"MIN_VALUE = \"+Integer.MIN_VALUE); //-2147483648 . 최솟값(-20억)\t\tSystem.out.println(\"SIZE = \"+Integer.SIZE+\"bits\"); //32bits\t\tSystem.out.println(\"BYTES = \"+Integer.BYTES+\"BYTES\"); //4BYTES\t\tSystem.out.println(\"TYPE = \"+Integer.TYPE); //int\t}}  타입Value - 래퍼객체 → 기본형 (new Integer → int)  래퍼클래스 → 문자열 - toString() 사용Number클래스: 모든 숫자 래퍼 클래스의 조상— byte, short, integer, long, float, double, BigInteger, BigDecimal오토박싱 &amp; 언박싱오토박싱 : 기본형 → 객체 자동변환 (int → Integer)언박싱 : Integer → int  JDK1.5부터는 기본형과 참조형간의 연산이 가능해짐(컴파일러가 바꿔줌)int i = 5; Integer iobj = new Integer(7); int sum = i+iobg;⇒ int i = 5; Integer iobj = new Integer(7); int sum = i+ iobg.intValue();로 자동 컴파일됨import java.util.ArrayList;public class  Main {\tpublic static void main(Strin] args) {\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\t\tlist.add(10); //오토박싱. 10-&gt; new Integer(10);  \t\t//↑ 원래는 list.add(new Integer)처럼 객체를 넣어줘야 함.JDK1.5이후에만 가능.(컴파일러가 자동변환)\t\t\t\t//list에 저장된 객체를 꺼내기. //\t\tint value = list.get(0).intValue();// 원래는 이렇게 써줘야함. intValue()로 Integer를 int로 변환\t\tint value = list.get(0);  //언박싱. new Integer(10) -&gt; 10;\t}}import java.util.ArrayList;public class  Main {\tpublic static void main(Strin] args) {\t\tint i = 10;\t\t\t\t//기본형 -&gt; 참조형\t\t//Integer intg = Integer.Value(i);\t\tInteger intg = (Integer)i;  \t\t//Object obg = (Object)Integer.Value(i);\t\tObject obg = (Object)i;\t\t\t\t//Long lng = new Long(100L);\t\tLong lng = 100L; //원래는 객체를 생성해줘야 하나 기본형을 바로 저장하도록 컴파일러가 바꿔줌\t\t\t\tint i2 = intg + 10; //참조형+기본형 가능\t\tLong l = intg + lng; //참조형+참조형 가능. \t\t\t\tInteger intg2 = new Integer(20);\t\tint i3 = (int)intg2; //참조형 -&gt; 기본형 가능\t\t\t\t/*컴파일 전 코드 \t\t\t\t\t\t컴파일 후 코드\t\t * Integer intg = (Integer)i;\t\tInteger intg = Integer.Value(i);\t\t *Object obg = (Object)i;\t\t\tObject obg = (Object)Integer.Value(i);\t\t *Long lng = 100L;\t\t\t\t\tLong lng =  new Long(100L);\t\t */\t\t\t}}"
  },
  
  {
    "title": "예외처리",
    "url": "/posts/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 예외",
    "date": "2022-08-14 00:00:00 +0900",
    





    
    "snippet": "프로그램 오류system.out.println(args[0]); //컴파일 에러System.out.println(args[0]); //런타임 에러 : 실행중 발생하는 에러. 매개변수로 받은 값이 없는데 실행해서 생김  논리적에러(logical error) : 작성 의도와 다르게 동작  컴파일러에러(compile-time error) : 컴파일 할 때 ...",
    "content": "프로그램 오류system.out.println(args[0]); //컴파일 에러System.out.println(args[0]); //런타임 에러 : 실행중 발생하는 에러. 매개변수로 받은 값이 없는데 실행해서 생김  논리적에러(logical error) : 작성 의도와 다르게 동작  컴파일러에러(compile-time error) : 컴파일 할 때 발생하는 에러번호          컴파일러                  구문체크          번역          최적화 (ex. int i = 3+5를 8로 변경)                      런타임에러(runtime error) : 실행할 때 발생하는 에러. 프로그램종료                  에러 (error) : 프로그램코드에 의해 수습될 수 없는 심각한 오류  ex)Out Of Memory Error - OOME : 메모리부족으로 일어나는 오류                    예외 (exception) : 프로그램코드에 의해 수습될 수 있는 다소 미약한 오류  ex)RuntimeException, IOException                              Excepton클래스들 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외            — checked예외 : 컴파일러가 예외처리 여부를 체크(예외처리 필수)                                RuntimeException 클래스들 : 프로그래머의 실수로 발생하는 예외            — unchecked예외 : 컴파일러가 예외처리 여부를 체크 안함.(예외처리 선택)              throw new Exception(\"고의로 발생\");  //try-catch문이 없어 컴파일 조차 안됨  \t\tthrow new RuntimeException(\"고의로 발생\");  //try-catch가 없어도 컴파일은 됐으나 실행중 에러. 비정상 종료                                            예외처리(exception handling) : 프로그램 실행시 발생할 수 있는 예외의 발생에 대비한 코드를 작성.  프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지  — try - catch문 사용 - {}생략불가.            try { /예외가 발생할 가능성이 있는 문장을 넣는다/  } catch (Exception1 e1) { /* Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣음/  } catch (Exception2 e2) { / Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 넣음/  catch (ExceptionN eN) { / ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 넣음*/                          try블럭에서 예외가 발생한 경우                                  발생한 예외와 일치하는 catch블럭이 있는지 확인                  일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.                                                            try블럭 내에서 예외가 발생하지 않은 경우                                  catch블럭을 거치지 않고 전체 try-catch문을 빠져나가 수행을 계속한다.                                  public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\ttry {  \t\t\tSystem.out.println(2);  \t\t\tSystem.out.println(3);  \t\t} catch (Exception e) {  \t\t\tSystem.out.println(4); //예외가 발생하지 않아서 출력안됨.   \t\t}//try-catch문의 끝  \t\tSystem.out.println(5);  //1 2 3 5 출력됨  \t\tSystem.out.println(\"=============\");  \t\tSystem.out.println(1);  \t\ttry {  \t\t\tSystem.out.println(0/0); //예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(2);  \t\t} catch (ArithmeticException e) {  \t\t\tSystem.out.println(3);  \t\t}//try-catch문의 끝  \t\tSystem.out.println(4);  //1 3 4 출력됨  \t}//main 메소드의 끝  }                                                              printStackTrace() : 예외발생 당시의 호출스택(Call strack)에 있었던 메소드의 정보와 예외 메시지를 화면에 출력한다.                      getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메세지를 얻을 수 있다.              public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\tSystem.out.println(2);  \t\ttry {  \t\t\tSystem.out.println(3);  \t\t\tSystem.out.println(0/0); //ArithmeticException예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(4); //실행안됨  \t\t} catch (ArithmeticException ae) {  \t\t\tae.printStackTrace();  \t\t\tSystem.out.println(\"예외 메세지 : \"+ae.getMessage());   \t\t} catch (Exception e) {  //Exception : 모든 예외의 최고조상, 모든 예외를 처리함(맨 마지막에 와야함)  \t\t\tSystem.out.println(\"Exception\"); //실행안됨  \t\t}//try-catch문의 끝  \t\tSystem.out.println(6);    \t\t//1 2 3   java.lang.ArithmeticException: / by   zero 예외 메세지 : / by zero   6 출력됨  \t}//main 메소드의 끝  }                                예외 발생시키기                                          연산자 new를 이용해 발생시키려는 예외 클래스의 객체를 만든다 Exception e = new Exception(”고의로 발생시켰음”);                                            키워드 throw를 이용해 예외 발생 throw e;                                              예외 처리방법                                          멀티 catch블럭(try - catch문) : 내용이 같은 catch블럭을 하나로 합친 것 (JDK1.7부터)  try { /…/ } catch (ExceptionA | ExceptionB) { e.printStackTrace (); }                멀티catch블록에 쓰는 두 클래스가 부모자식관계면 에러. 부모만써도 같은 의미라서 에러표시됨                  public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\tSystem.out.println(2);  \t\ttry {  \t\t\tSystem.out.println(3);  \t\t\tSystem.out.println(0/0); //ArithmeticException예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(4); //실행안됨  \t\t} catch (ExceptionA | ExceptionB e) {  //Exception : 모든 예외의 최고조상, 모든 예외를 처리함(맨 마지막에 와야함)  //\t\t\te.methodA(); //에러, e에 ExceptionA가 들어올지 ExceptionB가 들어올지 알수 없음. methodA는 ExceptionA의 멤버라서 에러  \t\t\t//ExceptionA,ExceptionB의 공통멤버는 사용 가능  \t\t\tif(e instanceof ExceptionA) {  \t\t\t\tExceptionA e1 = (ExceptionA)e;  \t\t\t\te1.methodA();  \t\t\t}  \t\t\telse {  \t\t\t\tExceptionB e2 = (ExceptionB)e;  \t\t\t\te2.methodB();  \t\t\t}  \t\t}//try-catch문의 끝  \t\tSystem.out.println(6);    \t}//main 메소드의 끝  }                                                            메소드에 예외 선언하기 : 빈catch블럭을 사용함                ❗예외를 발생시키는 키워드 throw와 메소드에 선언할 때 쓰이는 throws를 잘 구분 할 것.                  static void startInstall() throws SpaceException, MemoryException{  \tif(!enoughSpace()) //설치공간이 부족하다면  \t\tthrow new SpaceException(\"설치공간 부족\");  \tif(!enoughMemory()) //메모리가 부족하다면  \t\tthrow new MemoryException(\"메모리 부족\");  } //내가 처리할 수 없는 것들. 사용자에게 해결하고 오라고 떠넘김                                  public class ex {  \tpublic static void main(String[] args) throws Exception{  \tmethod1(); //같은 클래스 내의 static멤버이므로 객체생성없이 직접 호출 가능  \t}  \tstatic void method1()throws Exception {  \t\tmethod2();  \t}  \tstatic void method2() throws Exception{  \t\tthrow new Exception();  \t}  } //method2에서 발생한 Exception이 try-catch문을 만나지 못해 method1-main까지 올라갔다가 JVM까지 올라감 -&gt; 비정상종료  //try-catch문이 하나는 있어야 해결이됨.                                  import java.io.*;                  public class ex {  \tpublic static void main(String[] args) {  \t\t\tFile f = createFile(\"\");  \t\t\tSystem.out.println(f.getName()+\" 파일이 성공적으로 생성되었습니다\");  \t\t}                   static File createFile(String fileName){  \ttry {  \t\tif(fileName == null || fileName.equals(\"\"))  \t {  \t\t throw new Exception(\"파일 이름이 유효하지 않습니다.\");  \t }  \t} catch(Exception e) {  \t\t fileName = \"제목없음.txt\";  \t }  \t File f = new File(fileName); //File클래스의 객체 생성  \t try {  \t\tf.createNewFile();  \t} catch (IOException e) {  \t\te.printStackTrace();  \t}finally{  \t\t//예외 발생 여부와 상관없이 무조건 실행해야함. 코드 중복 박기 위해  \t}  \t return f;  \t}   }                                                            finally블럭 : 예외 발생 여부와 관계없이 수행되어야 하는 코드                ⚠️ try블럭안에 return문이 있어서 try블럭을 벗어나갈 때도 finally블럭이 실행 됨                                                          사용자정의 예외 만들기            : 우리가 직접 예외 클래스를 정의할 수 있다.            조상은 Exception과 RuntimeException중에 선택 (웬만하면 RuntimeException으로 할것. try-catch문 꼭 안써줘도 됨)              class MyException extends Exception{  \tMyException(String msg){ //문자열을 매개변수로 받는 생성자  \t\tsuper(msg); //조상인 Exception의 생성자를 호출  \t}  }                          class MyException extends Exception{  \t//에러코드 값을 저장하기 위한 필드 추가  \tprivate final int ERR_CODE;  \t MyException(String msg, int errCode){ //생성자  \t\t super(msg);  \t\t ERR_CODE = errCode;  \t }  \t MyException(String msg){ //생성자  \t\t this(msg, 100); //ERR_CODE를 100(기본값)으로 초기화  \t }  \t public int getErrCode() { //에러코드를 얻을 수 있는 메소드도 추가  \t\t return ERR_CODE; //주로 getMessage()와 함께 사용될 것.  \t }  \t}                                            예외 되던지기(exception re-throwing)            : 예외를 처리한 후에 다시 예외를 발생시킴              public class Main {  \tpublic static void main(String[] args) {  \t\ttry {  \t\t\tmethod1();  \t\t} catch (Exception e) {  \t\t\tSystem.out.println(\"main메소드에서 예외처리 되었습니다\");  \t\t} //예외 2번처리 = 예외 되던지기 = 예외 양쪽에서 처리  \t}  static void method1() throws Exception{  \t\ttry {  \t\t\tthrow new Exception();  \t\t}catch (Exception e) {  \t\t\tSystem.out.println(\"method1에서 예외가 처리되었습니다\");  \t\t\tthrow e;  \t\t}  \t}  }                                            연결된 예외(chained exception)            : 한 예외가 다른 예외를 발생시킬 수 있다.            예외 A가 예외 B를 발생시키면 A는 B의 원인예외(cause exception)            Throwable initCause(Throwable cause) : 지정된 예외를 원인 예외로 등록            Throwable getCause() : 원인 예외를 반환              public class Throwable implements Serializable{  \t//...  \tprivate Throwable cause = this; //객체 자신(this)을 원인 예외로 등록  \t//...  \tpublic synchronized Throwable initCause(Throwable cause) {  \t\t//...  \t\tthis.cause = cause; //cause를 원인 예외로 등록  \t\treturn this;  \t}  }                          void install() throws InstallException{ //실제로는 SpaceException이 발생했으나 InstallException안에 포함시켜서 예외 처리됨  \ttry {  \t\tstartInstall(); //SpaceException 발생, 저장공간 부족  \t\tcopyFiles();  \t} catch (SpaceException e) {  \t\tInstallException ie = new InstallException(\"설치 중 예외 발행\");  \t\tie.initCause(e); //ie(InstallException)의 원인 예외를 e(SpaceException)으로 지정  \t\tthrow ie; //InstallException 발생  \t}catch (MemoryException me) {  \t\t//......  \t}   }                        — 이유 1 : 여러 예외를 하나로 묶어서 다루기 위해              void install() throws InstallException{ //실제로는 SpaceException이 발생했으나 InstallException안에 포함시켜서 예외 처리됨  \ttry {  \t\tstartInstall(); //SpaceException 발생, 저장공간 부족  \t\tcopyFiles();  \t} catch (SpaceException e) {  \t\tInstallException ie = new InstallException(\"설치 중 예외 발행\");  \t\tie.initCause(e); //ie(InstallException)의 원인 예외를 e(SpaceException)으로 지정  \t\tthrow ie; //InstallException 발생  \t}catch (MemoryException me) {  \t\t//......  \t}   }  public class Main {              \tpublic static void main(String[] args) {  //\t\ttry {  //\t\t\tinstall();  //\t\t} catch (SpaceException e) {  //\t\t\te.printStackTrace();  //\t\t} catch (MemoryException e) {  //\t\t\te.printStackTrace();  //\t\t} catch (Exception e) {  //\t\t\te.printStackTrace();  \t\ttry {  \t\t\tinstall();  \t\t} catch (InstallException e) {  \t\t\te.printStackTrace();  \t\t} catch (Exception e) {  \t\t\te.printStackTrace();  \t\t}  \t}  }                        — 이유 2 : checked예외를 unchecked예외로 변경할때              static void startInstall() throws SpaceException, MemoryException{  \tif(!enoughSpace())  \t\tthrow new SpaceException(\"설치할 공간이 부족합니다.\");  \tif(!enoughMemory())  \t\tthrow new RuntimeException(new MemoryException(\"메모리가 부족합니다.\"));\t\t  }//MemoryException을 RuntimeException으로 위장해 try-catch문은 사용하지않아도됨  //class SpaceException extends Exception{  //\tSpaceException(String msg){  //\t\tsuper(msg);  \t}  }                                          "
  },
  
  {
    "title": "상속 (ingeritance)",
    "url": "/posts/%EC%83%81%EC%86%8D-(Ingeritance)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 상속",
    "date": "2022-08-05 00:00:00 +0900",
    





    
    "snippet": "상속~는 ~이다 (is - a) - ex.원(circle)은 점(point)다. (x)class 자식클래스 extends 부모클래스  기존의 클래스로 새로운 클래스를 작성(코드 재사용)  두 클래스를 부모와 자식 관계로 이어줌  자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화 블럭 제외 (자식클래스에 멤버가 안적혀있어도 있는거임)  자손의 멤버...",
    "content": "상속~는 ~이다 (is - a) - ex.원(circle)은 점(point)다. (x)class 자식클래스 extends 부모클래스  기존의 클래스로 새로운 클래스를 작성(코드 재사용)  두 클래스를 부모와 자식 관계로 이어줌  자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화 블럭 제외 (자식클래스에 멤버가 안적혀있어도 있는거임)  자손의 멤버 개수가 조상보다 적을 수는 없음.(같거나 많다.)  자손의 변경은 조상에게 영향을 미치지 않음.  부모 클래스의 변경은 자식 클래스에 영향을 미침.class point {\tint x, y;}class point3D extends point {\tint z;}  상속을 받지않고 중복으로 멤버들을 지정해줘도 결과는 똑같음.class Tvclass {\tboolean power;//전원상태(on/off)\tint channel;\t\tvoid power() {power = !power;}\t\tvoid channelUp() {++channel;}\t\tvoid channelDown() {--channel;}}\tclass SmartTv extends Tvclass{ //SmartTv는 Tv에 캡션(자막)을 보여주는 기능을 지원\tboolean caption; //캡션상태 (on/off)\tvoid displayCapion(String text) {\t\tif(caption) { \t\t\t//캡션의 상태가 on(true)일때만 text를 보여줌\t\t\tSystem.out.println(text);\t\t}\t}}public class Ex7_1 {\tpublic static void main(String[] args) {\t\tSmartTv stv = new SmartTv();\t\tstv.channel=10; //조상에게 상속받은 멤버\t\tstv.channelUp(); //조상에게 상속받은 멤버\t\tSystem.out.println(stv.channel);\t\tstv.displayCapion(\"ssssssssssss\"); //자막 off상태\t\tstv.caption = true;\t\tSystem.out.println(\"ssssssssssssssssssssssss\");\t\t\t\t\t}}포함(composite)~은 ~을 가지고 있다. (has - a) - ex. 원(circle)은 점(point)를 가지고 있다.(o)  — 90%가 포함이라고 보면 됨      클래스의 멤버로 참조변수를 선언함  class Point {\tint x; //원점의 x좌표\tint y; //원점의 y좌표}class circle {\tPoint c =new Point(); //c가 또 객체를 만들어서 Point를 가르킴\tint r; //반지름}//class circle { int x; int y; int r;}과 같은 거임.public class Ex7_1 {\tpublic static void main(String[] args) {\t\tcircle c = new circle();\t\tc.c.x = 5;\t\tc.c.y = 10;\t\tc.r = 15;\t\t//x,y는 circle c의 point c를 불러야 사용가능class Point{\tint x, y;}class Circle extends Point{\tint r;}class Circle2{\tPoint p = new Point();\tint r;}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\tc.x=1;\t\tc.y=2;\t\tc.r=3;\t\tSystem.out.println(\"c.x = \"+c.x);\t\tSystem.out.println(\"c.y = \"+c.y);\t\tSystem.out.println(\"c.r = \"+c.r);\t\t\t\tSystem.out.println();\t\t\t\tCircle2 c2 = new Circle2();\t\tc2.p.x = 10;\t\tc2.p.y = 15;\t\tc2.r=20;\t\tSystem.out.println(\"c2.p.x = \"+c2.p.x);\t\tSystem.out.println(\"c2.p.y = \"+c2.p.y);\t\tSystem.out.println(\"c2.p.r = \"+c2.r);\t\t\t}}단일상속(Single Inheritance)자바는 단일 상속만을 허용함. (c++은 다중상속 허용) → 인터페이스를 이용하면 비슷한 기능을 쓸 수 있음  비중이 높은 클래스 하나만 상속으로 나머지는 포함으로 작성 가능Object class - 모든 클래스의 조상  부모가 없는 클래스는 자동적으로 object 클래스를 상속받게 됨.      모든 클래스는 object클래스에 정의된 11개의 메소드를 상속받음  toString(), equals(Object obj), hashCode() ……..등등(9장)    상속계층도를 따라올라가면 맨 위에 Object가 있음class Point{\tint x, y;}class Circle extends Point{\tint r;}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\tSystem.out.println(c.toString()); //Circle@5ca881b5 클래스이름@객체주소값\t\tSystem.out.println(c); //Circle@5ca881b5 클래스이름@객체주소값\t\tCircle c2 = new Circle();\t\tSystem.out.println(c2.toString()); //Circle@24d46ca6 클래스이름@객체주소값\t\tSystem.out.println(c2); //Circle@24d46ca6 클래스이름@객체주소값\t}}println이 참조변수가 들어오면 내부적으로 toString을 호출오버라이딩 (overriding)상속받은 조상의 메소드를 자신에 맞게 변경하는 것.  조건          선언부가 조상클래스의 메소드와 일치해야함      접근 제어자(public, protect, defalt, private) 를 조상클래스의 메소드보다 좁은 범위로 변경불가      예외는 조성 클래스의 메소드보다 많이 선언할 수 없다. (8장)      class Point{\tint x, y;String getLocation(){\treturn \"x : \"+x+\", y : \"+y;\t}}class Point3D extends Point{\tint z;\tString getLocation() { //오버라이딩 (선언부 변경 불가 내용[ {} 구현부 ]만 변경가능)\t\treturn \"x : \"+x+\", y: \"+y+\", z : \"+z;\t\t}\t}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tPoint3D p = new Point3D();\t\tp.x = 3;\t\tp.y=5;\t\tp.z=7;\t\tSystem.out.println(p.getLocation()); //x : 3, y: 5, z : 7\t}}class Point{\tint x, y;\t\tPoint(int x, int y){\t\tthis.x= x;\t\tthis.y=y;\t}\t\t//object클래스의 toString()을 오버라이딩\tpublic String toString(){\treturn \"x : \"+x+\", y : \"+y;\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tPoint p = new Point(3,5);\t\tSystem.out.println(p.toString()); //x : 3, y : 5\t\tSystem.out.println(p); //x : 3, y : 5\t}}오버로딩 (overloading)기존에 없는 새로운 (이름이 같은)메소드를 정의하는 것. 오버라이딩이랑은 관계없음.class Parent{\tvoid parentMethod() {\t\t\t}\tclass child extends Parent{\t\tvoid parentMethod() {}\t\tvoid parentMethod(int i) {}\t\t\t\tvoid childMethod() {}\t\tvoid childMethod(int i) {}\t\tvoid childMethod() {}\t\t\t}}참조변수 superthis와 비슷함  객체 자신을 가르치는 참조변수. 인스턴스 메소드(생성자)내에서만 존재  조상의 멤버를 자신의 멤버와 구분할 떄 사용class Parent{\tint x=10;}class child extends Parent{ //구성멤버 3개\tint x = 20;\t\tvoid method() { \t\tSystem.out.println(\"x = \"+x);  //가까이있는 x(20)\t\tSystem.out.println(\"this.x = \"+this.x);//20\t\tSystem.out.println(\"super.x = \"+super.x); //부모클래스의 x (10)\t\t\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tchild c = new child();\t\tc.method();\t}}class Parent{\tint x=10;}class child extends Parent{ //구성멤버 2개\tvoid method() { \t\tSystem.out.println(\"x = \"+x);  //가까이있는 x\t\tSystem.out.println(\"this.x = \"+this.x);\t\tSystem.out.println(\"super.x = \"+super.x); //부모클래스의 x\t\t//중복이 없으면 !! 조상멤버기도하지만 내꺼기도해서 this, super 모두 같은 x를 가르킴\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tchild c = new child();\t\tc.method();\t}}super() - 조상의 생성자참조변수 super와 상관없음  조상의 생성자를 호출할 때  조상의 멤버는 조상의 생성자를 호출해서 초기화  생자와 초기화 블럭은 상속이 xclass Point {\tint x,y;\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y; //초기화\t}}class Point3D extends Point {\tint z;\t\tPoint3D(int x, int y, int z) {\t\tsuper(x, y); //조상class에서 초기화\t\tthis.z=z; //초기화\t}}  생성자의 첫 줄에는 반드시 생성자(super(); or this();)를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입함.class Point {\tint x,y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tsuper();  //object(); 안넣어주면 컴파일러가 자동으로 넣어줌\t\tthis.x=x;\t\tthis.y=y;에러 예시 중요!!class Point {\tint x, y;\tPoint(int x, int y){\t\tsuper(); //컴파일러 자동 추가\t\tthis.x=x;\t\tthis.y=y;\t}\tString getLocation() {\t\treturn \"x : \"+x+\", y : \"+y;\t}}class MyPoint3D extends Point{\tint z;\t//\tMyPoint3D(int x, int y, int z){//\tsuper();  //컴파일러 자동 추가 Point()를 호출 -&gt; Point에 Point();가 없어서 에러남//\tthis.x=x;//\tthis.y=y;//\tthis.z=z;//\t}\t\tMyPoint3D(int x, int y, int z){\t\tsuper(x,y);\t\tthis.z=z;  \t}  //에러 없애는 방법 다른방법은 Pointclass에 Point();추가하기\t\tString getLocation() { //오버라이딩\t\treturn \"x : \"+x+\", y : \"+y+\", z : \"+z;\t}\t}public class Ex_test {\tpublic static void main(String[] args) {\t\tMyPoint3D p3 = new MyPoint3D(1,2,3);\t\t\t}}패키지(package)  서로 연관된 class의 묶음  클래스는 클래스파일(*.class), 패키지는 폴더. 하위 패키지는 하위폴더      클래스의 실제 이름 (full name)은 패키지를 포함.(java.lang.String)    rt.jar는 클래스들을 압축한 파일.(JDK설치경로\\jre\\lib에 위치) - 자바9부터 rt.jar는 없어짐    패키지 선언          패키지는 소스파일의 첫 번째 문장으로 단 한번 선언      같은 소스파일의 클래스들은 모두 같은 패키지에 속하게 된다.      패키지 선언이 없으면 이름없는(unnamed)에 속하게 된다. - defaultpackage        클래스 패스(classpath)          클래스 파일(*.class)의 위치를 알려주는 경로(path)      환경변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용      classpath(환경변수)에 패키지의 루트를 등록해줘야 함      import문클래스를 사용할 때 패키지 이름을 생략할 수 있다.  컴파일러에게 클래스가 속한 패키지를 알려줌  ctrl + shift + o ⇒ 자동으로 import문을 추가해줌.(import java.lang.*[모든클래스];) -  java.lang 패키지(String, Object, System, Thread…)의 클래스는 import하지않고도 사용 가능함.  패키지문과 클래스선언 사이에 선언함.  이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.  static import문          static멤버를 사용할 떄 클래스 이름을 생략가능              import static java.lang.Math.random;  import static java.lang.System.  out;        ⇒ out.println(random()); 가능함.            코드가 길어져서 class이름도 거추장스러운순간이 옴. 코드를 짧게하려고 쓰는 방법. 꼭 필요할때만 사용할것. 헷갈릴수도      제어자(modifier)클래스와 클래스의 멤버(멤버 변수, 메소드)에 부가적인 의미 부여 - 형용사                                             접근 제어자      public, protecred, (default)[아무것도안붙임], private      1개만 사용가능              그외      static, final, abstract, transient, synchronized, volatile, strictfp               하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만). 순서는 상관없으나 보통 접근제어자를 맨 왼쪽에 씀      static - 클래스의, 공통적인                            대상          의미                                      멤버변수          모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다  클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.  클래스가 메모리에 로드될 때 생성된다.                          메소드          인스턴스를 생성하지 않고도 호출이 가능한 static메소드가 된다.  static메소드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다                      final - 마지막의, 변경될 수 없는                                      클래스      변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.  그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다              메소드      변경될 수 없는 메소드. final로 지정된 메소드는 오버라이딩을 통해 재정의 될 수 없다.              멤버변수  지역변수      변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.      final class Finaltest{ //조상이 될 수 없는 클래스\tfinal int MAX_SIZE=10; //값을 변경할 수 없는 멤버변수(상수)\t\tfinal void getMaxsize() {  //오버라이딩 할 수 없는 메소드(변경불가)\t\tfinal int LV = MAX_SIZE; //값을 변경할 수 없는 지역변수(상수)\t\treturn MAX_SIZE;\t}}  abstract - 추상의, 미완성의                                      클래스      클래스 내에서 추상 메소드가 선언되어 있음을 의미한다              메소드      선언부만 작성하고 구현부는 작성하지 않은 추상 메소드임을 알린다.      abstract class abstracttest{ //추상 클래스(추상 메소드를 포함한 클래스\tabstract void move(); //추상 메소드(구현부가 없는 메소드)}//미완성상태 - 미완성 설계도. 제품제작불가 = 인스턴스 생성 불가public class Ex_test {\tpublic static void main(String[] args) {\t\tabstracttest a = new abstracttest();  //에러. 추상클래스의 인스턴스 생성 불가\t}}추상 클래스를 상속받아서 완전한 클래스를 만든 후에 객체생성가능접근 제어자(access modifier) - 1개만 사용 가능  private : 같은 클래스 내에서만 접근이 가능하다.  (default) : 같은 패키지 내에서만 접근이 가능하다.  protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.  public : 접근 제한이 전혀 없다.            제어자      같은 클래스      같은 패키지      자손 클래스      전체                  public      o      o      o      o              protected      o      o      o                     (default)      o      o                            private      o                           ❗클래스 앞에는 public or (default)만 붙일 수 있다. (아무것도 안붙이면 default)클래스 멤버들에게는 4가지 모두 붙일 수 있다.package pkg1;class MyParent{\t\tprivate \tint prv; //같은 클래스\t\t\t\t\t\t\tint dft; //같은 패키지\tprotected \tint prt; //같은 패키지, 자손(다른패키지)\t\tpublic \t\tint pub; //접근제한 없음\t\tpublic void printMembers(){\t\tSystem.out.println(prv);\t\tSystem.out.println(dft);\t\tSystem.out.println(prt);\t\tSystem.out.println(pub);\t}}public class MyParentTest {\tpublic static void main(String[] args) {\t\t\tMyParent p = new MyParent();\t\t\tSystem.out.println(p.prv); //에러. 다른 클래스라서\t\t\tSystem.out.println(p.dft);\t\t\tSystem.out.println(p.prt);\t\t\tSystem.out.println(p.pub);\t}}package pkg1;public class MyParentTest{  //접근 제어자 public\t\tprivate \tint prv; //같은 클래스\t\t\t\t\t\t\tint dft; //같은 패키지\tprotected \tint prt; //같은 패키지, 자손(다른패키지)\t\tpublic \t\tint pub; //접근제한 없음\t\tpublic void printMembers(){\t\tSystem.out.println(prv);\t\tSystem.out.println(dft);\t\tSystem.out.println(prt);\t\tSystem.out.println(pub);\t}}class MyParent {  //접근 제어자 default\tpublic static void main(String[] args) {\t\t\tMyParentTest p = new MyParentTest();//\t\t\tSystem.out.println(p.prv); //에러. 다른 클래스라서\t\t\tSystem.out.println(p.dft);\t\t\tSystem.out.println(p.prt);\t\t\tSystem.out.println(p.pub);\t}}package pkg2;import pkg1.MyParentTest; //ctrl +shift + oclass MyChild extends MyParentTest{\tpublic void printMembers(){//\tSystem.out.println(prv); //에러. 다른 클래서//\tSystem.out.println(dft); //에러. 다른 패키지\t\tSystem.out.println(prt); //자손클래스라서 가능\t\tSystem.out.println(pub);\t}}public class MyParentTest2 {\tpublic static void main(String[] args) {\t\tMyParentTest p = new MyParentTest();//\tSystem.out.println(p.prv); //에러. 다른 클래스라서//\tSystem.out.println(p.dft); //에러. 다른 패키지//\tSystem.out.println(p.prt); //에러. 다른 패키지, 자손관계 없음\t\tSystem.out.println(p.pub);\t}}캡슐화와 접근 제어자  접근 제어자를 사용하는 이유                  외부로부터 데이터를 보호하기 위해(캡슐화)          public class Ex_test{  \tprivate int hour;  //접근 제어자를 private로 하여 외부에서 접근 못하도록 막음  \tprivate int minute;  \tprivate int second;        \t  \tpublic int gethour() {  \t\treturn hour;  \t}  \tpublic void sethour(int hour) {  \t\tif(hour&lt;0 || hour &gt;23) return;  \t\tthis.hour=hour;  //메소드를 통해서 지역변수에 간접접근하도록 만들어 놓음  \t}  }  class test {  \tpublic static void main(String[] args) {  \t\tEx_test T=new Ex_test();  \t\tT.sethour(25);  //조건에 안맞아서 값이 바뀌지 않음. = 값이 보호됨  \t\tT.sethour(21);  \t}  }                    다형성(polymorphism)여러가지 형태를 가질 수 있는 능력  조상 타입 참조변수로 자손 타입 객체를 다루는 것. - 타입 불일치.  Tv t = new SmartTv();                  객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?  조상클래스의 참조변수는 자식 클래스의 멤버를 사용할 수 없다.                    자손타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.        SmartTv s = new Tv 불가능 - 없는 멤버를 호출해서 에러날 가능성 있음              참조변수의 형변환                  사용할 수 있는 멤버의 갯수를 조절하는 것. 멤버 갯수 외 요소는 바뀌지 않음  기본형 형변환 - (double)3.5 → (int)3                    조상 자손 관계의 참조변수는 서로 형변환 가능          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFireEngine f = new FireEngine();  \t\tCar c = (Car)f; //조상인 Car타입으로 형변환  \t\tFireEngine f2 = (FireEngine)c; //자손인 FireEngine타입으로 형변환(생략불가)  \t//Ambulance a = (FireEngine)f; //에러. 상속관계가 아닌 클래스간의 형변환 불가  \t}  }                Car c= (Car)f;경우 자손 클래스의 멤버를 조상클래스의 멤버가 사용할 수 없으니 c는 FireEngine의 모든 멤버를 사용할 수 없음(예시의 경우 c.water사용 불가능)        FireEngine f2 = (FireEngine)c는 f→c→f로 변환되었으니 FireEngine의 모든 멤버를 사용할 수 있음.                  class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tCar car = null;  \t\tFireEngine fe = new FireEngine();  \t\tFireEngine fe2 = null;        \t\t  \t\tfe.water();  \t\tcar = fe; //car = (car)fe; 에서 형변환이 생략됨.  //\t\tcar.water(); //에러  \t\tfe2=(FireEngine)car;  //자손타입&lt;-조상타입. 생략불가  \t\tfe2.water();  \t}  }                ❗fe2=(FireEngine)car;의 경우 사용할 수 있는 멤버의 수가 증가해서 불안정함. 그래서 꼭! 형변환을 써줘야함. 생략불가능        ]          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tCar car = null;  \t\tFireEngine fe = new FireEngine();        \t\t  \t\tFireEngine fe2= (FireEngine)car; //조상 -&gt; 자손  \t\tCar car2 = (Car)fe2; // 자손 -&gt; 조상  \t\t//객체가 없어도 형변환에는 문제없음.  \t\t//car2.drive(); //에러  NullPointerException발생. 객체가 없다는 뜻  \t\t//실제 인스턴스가 뭔지가 중요함.        \t\t  \t\tCar c2 = new Car();  \t\tFireEngine fe3 = (FireEngine)c2; // 형변환 실행 에러. java.lang.ClassCastException  \t\tfe3.water(); //컴파일 ok. 리모컨에는 water가 있음.  \t\t//객체를 Car로 만들어서 객체안에 water자체가 없음!! 그래서 에러나는거임!!  \t}  }                      instanceof 연산자          참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환      형변환 전에 반드시 instanceof로 확인해야 함              인스턴스의 원래 기능을 모두 사용하려고 형변환을 함.          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFireEngine fe = new FireEngine();        \t\t  \t\tSystem.out.println(fe instanceof Object); //true. FireEngine의 조상  \t\tSystem.out.println(fe instanceof Car); //true. FireEngine의 조상  \t\tSystem.out.println(fe instanceof FireEngine); //true  \t\tObject obg = (Object)fe;  \t\tCar c2 = (Car)fe;  \t\tFireEngine fe2 = (FireEngine)fe;  \t\t}  \tCar c = new Car();  \tvoid doWork(Car c) {  \t\tif(c instanceof FireEngine) {//형변환이 가능한지 확인  \t\t\tFireEngine fe = (FireEngine)c; //형변환  \t\t\tfe.water();  \t\t}  \t\telse if (c instanceof Ambulance) {  \t\t\tAmbulance a = (Ambulance)c;  \t\t}  \t}        \t  }                      다형성의 장점                  다형적 매개변수 - 매개변수의 다형성                              참조형 매개변수는 메소드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.              class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  }  class Tvvv extends Product{}  class Computer extends Product{}  class Audio extends Product{}              class Buyer { //물건사는사람  \tint money = 10000; //소지금  \tint bonusPoint = 0; //누적 적립금            \t  //\tvoid buy(Tv t1) {  //\t\tmoney -= t1.price;  //\t\tbonusPoint += t1.bonusPoint;  //\t}  //\tvoid buy(Computer c) {  //\t\tmoney -= c.price;  //\t\tbonusPoint += c.bonusPoint;  //\t}  //\tvoid buy(Audio a) {  //\t\tmoney -= a.price;  //\t\tbonusPoint += a.bonusPoint;  //\t}  \tvoid buy(Product p){  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();            \t\t  //\t\tTvvv tv = new Tvvv();  //\t\ttv.price=5000;  //\t\ttv.bonusPoint= (int) (tv.price*0.01);  //\t\tb.buy(tv);  //\t\tComputer com = new Computer();  //\t\tcom.price=3000;  //\t\tcom.bonusPoint= (int) (com.price*0.01);  //\t\t  //\t\tb.buy(com);            \t\t  \t\tProduct p1= new Tvvv();  \t\tProduct p2= new Computer();  \t\tProduct p3= new Audio();  \t\tp1.price=5000;  \t\tp1.bonusPoint=(int) (5000*0.01);  \t\tb.buy(p1);  \t\tp2.price=3000;  \t\tp2.bonusPoint=(int)(p2.price*0.01);  \t\tb.buy(p2);  \t\tSystem.out.println(b.money);  \t\tSystem.out.println(b.bonusPoint);            \t\t  \t}            \t  }                          class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  \tProduct(int price){  \t\tthis.price=price;  \t\tbonusPoint = (int) (price/10.0);  \t}  }  class Tv extends Product{  \tTv() {  \t\t//조상 클래스의 product(int price)를 호출  \t\tsuper(100); //100만원  \t}  \t//Object 클래스의 toString()을 오버라이딩  \tpublic String toString() {return \"tv\";}  }  class Computer extends Product{              \tComputer() {  \t\tsuper(200);  \t}  \tpublic String toString() {return \"computer\";}  }  class Audio extends Product{              \tAudio() {  \t\tsuper(50);  \t}  \tpublic String toString() {return \"audio\";}  }              class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금            \t  \tvoid buy(Product p){   \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}            \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();            \t\t  \t\tb.buy(new Tv()); //Product tv1 = new Product; b.buy(tv1)  \t\t//짧게 쓸 수 있으나 참조변수가 없어서 리모컨을 사용할 수 없음. b.buy에서 임시로 쓰는 것.  \t\tb.buy(new Computer()); //Product com1 = new Product; b.buy(com1)            \t\t  \t\tSystem.out.println(\"현재 남은 돈은 \"+b.money+\"만원입니다\");  \t\tSystem.out.println(\"현재 보너스 점수는 \"+b.bonusPoint+\"점 입니다.\");  \t}  }                                      ⇒장점 1.하나의 메소드로 여러타입의 객체를 받을 수 있음                    하나의 배열로 여러 종류의 객체를 다루기        : 조상 타입의 배열에 자손들의 객체를 담을 수 있다. =        장점2. 하나의 배열에 여러종류의 객체를 저장할 수 있음          // product p1 = new tv();  // product p2 = new computer();  // product p3 = new audio();          Product p[] = new Product();  p[0] = new tv();  p[1] = new computer();  p[2] = new audio();                ]          class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금        \t  \tProduct cart[] = new Product[10]; //구매한 물건을 담을 배열 (장바구니)        \t  \tint i = 0;        \t  \tvoid buy(Product p){  \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}        \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tcart[i++] = p; //cart에 담고 배열+1해서 새 장바구니칸에 담고..  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  }                  public class Vector extends AbstractList //Vector = 가변배열기능. object배열을 멤버로 가지고 있음.  \t\timplements List, Cloneable, java.io.serializable{  \tprotected Object elementDate[];  }                  class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  \tProduct(int price){  \t\tthis.price=price;  \t\tbonusPoint = (int) (price/10.0);  \t}  }  class Tvvv extends Product{  \tTvvv() {  \t\tsuper(100); //100만원  \t}  \tpublic String toString() {return \"tv\";}  }  class Computer extends Product{          \tComputer() {  \t\tsuper(200);  \t}  \tpublic String toString() {return \"computer\";}  }  class Audio extends Product{          \tAudio() {  \t\tsuper(50);  \t}  \tpublic String toString() {return \"audio\";}  }          class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금        \t  \tProduct cart[] = new Product[10]; //구매한 물건을 담을 배열 (장바구니)        \t  \tint i = 0;        \t  \tvoid buy(Product p){  \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}        \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tcart[i++] = p; //cart에 담고 배열+1해서 새 장바구니칸에 담고..  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  \tvoid summary() { //구매 물품 정보 요약표시  \t\tint sum = 0; //구입한 물품의 가격 합계  \t\tString itemList = \"\"; //구입한 물품 목록        \t\t  \t\t//반복문을 사용해 구입한 물품의 총 가격과 목록을 만든다.  \t\tfor(int i=0; i&lt;cart.length;i++) {  \t\t\tif(cart[i]==null) break;  \t\t\tsum+=cart[i].price;  \t\t\titemList += cart[i]+\", \";  \t\t}  \t\tSystem.out.println(\"구입하신 물건의 총 금액은 \"+sum+\"만원입니다.\");  \t\tSystem.out.println(\"구입하신 제품은 \"+itemList+\"입니다.\");  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();        \t\t  \t\tb.buy(new Tvvv(  ));  \t\tb.buy(new Computer());  \t\tb.buy(new Audio());        \t\t  \t\tSystem.out.println(\"현재 남은 돈은 \"+b.money+\"만원입니다\");  \t\tSystem.out.println(\"현재 보너스 점수는 \"+b.bonusPoint+\"점 입니다.\");  \t\tb.summary();  \t}  }                    추상클래스(abstract calss): 미완성 설계도. 미완성 메소드 -구현부(몸통{})이 없는 메소드- 를 갖고 있는 클래스. 객체 생성 불가능. 일반클래스인데 미완성 메소드를 가지고 있는 것abstract 리턴타입 메소드 이름();abstract class Player { //추상클래스(미완성 클래스)\t\tabstract void play(int pos); //몸통{}이 없는 추상메소드\tabstract void stop(); //몸톰{}이 없는 추상메소드}\t//추상클래스가 다른 클래스를 작성하는데 도움이 됨.//추상클래스는 상속을 통해 완성해야 객체 생성가능class AudioPlayer extends Player{\tvoid play(int pos) {\t\tSystem.out.println(pos+\"위치부터 play합니다.\");\t\t}//추상메소드 구현 = 몸통만들어줌.\tvoid stop() {\t\tSystem.out.println(\"재생을 멈춥니다.\");\t}//추상메소드 구현=몸통 만들어줌}public class PlayerTest {\tpublic static void main(String[] args) {//\t\tPlayer p = new Player();  //에러. 추상클래스의 인스턴스화 불가\t\tAudioPlayer ap = new AudioPlayer(); //인스턴스 생성 가능.\t\tap.play(100);\t\tap.stop();\t\tPlayer p2 = new AudioPlayer(); //Player가 조상타입이라 가능함. 다형성\t\tp2.play(500);\t\tp2.stop();\t\t}\t}abstract class Player{\tboolean pause; //일시정지상태를 저장하기위한 변수\tint currentPos;//현재 play되고 있는 위치를 저장하기 위한 변수\t//플레이어의 종류마다 플레이 방식이나 멈추는 방식이 다르니 미리 만들어봤자 의미가 없음.\t//중요한건데 후에 상속을 만들 때 빠질까봐 강제하는 것임.\tPlayer(){  //추상클래스라도 생성자가 있어야함.\t\tpause = false;  \t\tcurrentPos = 0;\t}\t//지정된 위치(pos)에서 재생을 시작하는 기능이 수행하도록 작성되어야 한다.\tabstract void play(int pos); //추상메소드\t//재생을 즉시 멈추는 기능을 수행하도록 작성되어야한다.\tabstract void stop(); //추상메소드\t\tvoid play() { //인스턴스메소드\t\tplay(currentPos); //추상메소드를 사용할 수 있다.. 메소드는 선언부만 알면 호출가능하므로 추상메소드도 호출가능함.\t//상속을 통해 자손이 완성될 예정이라 사용할 수 있다. (지금 호출은 안됨. 상속을 통해 완성된 다음 호출 가능)\t}}public class ex {\tpublic static void main(String[] args) {\t\t}\t}  꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우      여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.      abstract class Unit{  \tint x,y;  \tabstract void move(int x, int y);  \tvoid stop() {  \t\t//현재 위치에 정지  \t\t};  \t}  class Marine extends Unit { //보병  \tvoid move(int x, int y) {  \t\t//지정된 위치로 이동  \t\tSystem.out.println(\"marine [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid stimPack() {  \t\t//스팀팩 사용  \t}  }  class Tank extends Unit{  \tvoid move(int x, int y) {  \tSystem.out.println(\"Tank [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid changeMode() {}; //공격모드로 변경  }  class Dropship extends Unit {  \tvoid move(int x, int y) {  \tSystem.out.println(\"Dropship [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid load() {}// 선택된 대상 태우기  \tvoid unload() {}//선택대상 내리기  }  public class ex {      \tpublic static void main(String[] args) {  //\t\tUnit[] group = new Unit[3];  //\t\tgroup[0]=new Marine();  //\t\tgroup[1]=new Tank();  //\t\tgroup[2]=new Dropship();  \t\tUnit group[] = {new Marine(), new Tank(), new Dropship()};    \t\t  \t\tfor(int i=0;i&lt;group.length;i++) {  \t\t\tgroup[i].move(100, 200);  \t\t\t//group의 타입은 Unit[], group[0], group[1], group[2]  \t\t}  \t\tObject group2[] = {new Marine(), new Tank(), new Dropship()};  \t\tfor(int i=0;i&lt;group2.length;i++) {  //\t\t\tgroup2[i].move(100, 200);  \t\t\t//Object는 최상위 객체라서 구현은 가능하나 move를 멤버로 가지고있지 않아서 에러남  \t\t}  \t}  }            추상화(불명확)←→구체화(명확)          추상화된 코드는 구체화된 코드보다 유연함. 변경에 유리  구체적인 코드 - GregorianCalendar cal = new GregorianCalendar();  추상적인 코드 = Calendar cal = Calendar.getInstance : Calendar 자손 객체를 반환해 cal에 대입. ⇒ Calendar객체가 무엇을 반환할 지 불명확함.          import java.util.Calendar;      private static Calendar createCalendar(TimeZone. Locale aLocale) {  \tif(caltype != null) {  \t\tswitch(caltype) {  \t\tcase \"buddhist\": //불교력  \t\t\tcal = new BuddhistCalendar(zone, aLocale);  \t\t\tbreak;  \t\tcase \"japanese\" : //일본력  \t\t\tcal = new JapanesImperialCalendar(zone, aLocale);  \t\t\tbreak;  \t\tcase \"gregory\" : //서양력  \t\t\tcal = new GregorianCalendar(zone, aLocale);  \t\t\tbreak;  \t\t}  \t}  }  public class ex {      \tpublic static void main(String[] args) {  //\t\tGregorianCalendar cal = new GregorianCalender(); 구체적  \t\tCalendar cal = Calendar.getInstance();//추상적  \t}  }      인터페이스(interface)추상메소드의 집합(프로그래밍관점)      구현된 것이 하나도 없는 설계도. 껍데기(모든 멤버가 public)    interface 인터페이스이름{    public static final 타입 상수이름 = 값;    public abstract 메소드이름(매개변수목록); }      interface PlayingCard{  \t//상수  \tpublic static final int SPADE =4;  \tfinal int DIAMOND = 3; //public static 생략됨  \tstatic int HAEART = 2; //public final 생략됨  \tint CLOVER = 1; //public static final      \t//추상메소드  \tpublic abstract String getCardNumber();  \tString getCaedKind(); //public abstract생략됨.  \t//public static final은 예외없이 모두 적용이기때문에 적지않아도 자동으로 붙여줌  \t}  public class ex {      \tpublic static void main(String[] args) {  \t}  }        [!important]추상클래스와 인터페이스의 차이점인터페이스는 인스턴스변수를 가질 수 없음!  인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상이 아님)  다중 상속 가능. (추상메소드는 구현부{}가 없어서 충돌해도 문제 없음) - 조상이 여러개여도 가능.  인터페이스는 지역변수를 가지지 못함(추상클래스는 가능)      인터페이스의 구현 : 인터페이스에 정의된 추상메소드를 완성하는 것.  class 클래스 이름 implements 인터페이스 이름{ 인터페이스에 정의된 모든 추상메소드를 구현해야 함. } - 일부만 구현하는 경우, 클래스앞에 abstract를 붙여야함.  = 추상클래스 완성과 동일      interface Fightable{ //인터페이스  \tvoid move(int x, int y);  \tvoid attack(Unit u);  }  class Fighter implements Fightable{ //인터페이스 구현  \tpublic void move(int x, int y) {  \t\tSystem.out.println(\"x = \"+x+\", y = \"+y);  \t}  \tpublic void\tattack(Unit u) {  \t\tSystem.out.println(\"Unit = \"+u);  \t}  }  abstract class Player{ //추상클래스  \tabstract void play(int pos);  \tabstract void stop();  }  class AudioPlayer extends Player{ //추상클래스 구현  \tvoid play(int pos) {  \t\tSystem.out.println(pos);  \t}  \tvoid stop() {  \t\t//내용  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {    \t\t  \t}  }            인터페이스를 이용한 다형성          인터페이스도 구현 클래스의 부모임      인터페이스 타입 매개변수는 인터페이스 구현한 클래스의 객체만 가능      인터페이스를 메소드의 리턴타입으로 지정가능.          import java.io.ObjectInputStream.GetField;      abstract class Unit{  \tint x,y;  \tabstract void move(int x, int y);  \tvoid stop() {  \t\tSystem.out.println(\"멈춤\");  \t};  }  interface Fightable{ //인터페이스  \tvoid move(int x, int y); //public abstract가 생략됨  \tvoid attack(Fightable f); //public abstract가 생략됨  }  class Fighter extends Unit implements Fightable {   \tpublic void move(int x, int y) { //오버라이딩 규칙: 조상(public)보다 접근제어자가 좁으면 안됨.  \t\tSystem.out.println(\"[\"+x+\", \"+y+\"]로 이동\");  \t}  \tpublic void attack(Fightable f) //매개변수 타입이 인터페이스.= 이 인스턴스를 구현한 class의 객체만 가능  \t//attack메소드는 매개변수로 Fightable인터페이스를 구현한 class의 객체만 받음  \t{   \t\tSystem.out.println(f+\"를 공격\");  \t}   \t//싸울 수 있는 상대 소환  \tFightable getFightable(){  \t\tFighter f = new Fighter();   \t\treturn f;  //Fighter가 Fightable을 상속받고있어서 형변환이 가능하기때문에 f는 Fighter지만 사용 가능  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFighter f = new Fighter();  \t\tFightable ff = f.getFightable();    \t\t  \t\tf.move(100, 200);  \t\tf.attack(new Fighter()); //toString이 나옴  \t\tf.stop();    \t\t  \t\tSystem.out.println(\"-----------------\");  \t\tUnit u = new Fighter();  \t\tu.move(100, 200);  \t\tu.stop();  //\t\tu.attack(new Fighter()); //에러, Unit에 attack이 없음    \t\t  \t\tSystem.out.println(\"-----------------\");  \t\tFightable f2 = new Fighter();  \t\tf2.move(100, 200);  \t\tf2.attack(new Fighter()); //toString이 나옴  //\t\tf2.stop(); //Fightable에 stop이 없음  \t}  }            장점          두 대상(객체)간의 ‘연결, 대화, 소통’을 돕는 ‘중간역할’을 한다      선언과 구현을 분리시킬수 있게됨.(변경에 유리)      개발시간 단축      변경에 유리한 설계      표준화 가능 (데이터베이스회사들이 JDBC에 맞춰 데이터베이스를 개발함. 자바개발자는 JDBC를 기준으로 개발 )      서로 관계없는 클래스들의 관계를 맺어줄 수 있다. : 내가 원하는 클래스만 모아서 인터페이스로 묶을 수 있음      인터페이스덕분에 한 클래스를 변경해도 다른 클래스는 안바꿔도 동작함(느슨한 결함)        직접적 관계      class A {  \tpublic void method(C c){  \t\tc.methodC();  \t}  }  class B {  \tpublic void methodB(){  \t\tSystem.out.println(\"methodB()\");  \t}  }  class C{  \tpublic void methodC(){  \t\tSystem.out.println(\"method() in C\");  \t}  }  public class InterfaceTest {      \tpublic static void main(String[] args) {  \t\tA a = new A();  \t\ta.method(new C()); //A가 B에 의존  \t}      }        간접적 관계      class A {  \tpublic void method(I i){  \t\ti.method();  \t}  }  interface I { void method();}       class B implements I{  \tpublic void method(){  \t\tSystem.out.println(\"methodB()\");  \t}  }  class C implements I{  \tpublic void method(){  \t\tSystem.out.println(\"method() in C\");  \t}  }  public class InterfaceTest {      \tpublic static void main(String[] args) {  \t\tA a = new A();  \t\ta.method(new B()); //A가 B에   \t}  }        디폴트 메소드                  인터페이스에 새로운 메소드(추상메소드)를 추가하기 어려움 - 한 인터페이스에 추상메소드가 추가되면 연관된 모든 클래스에 추가된 추상메소드 구현을 해주어야함 ⇒ 해결책:디폴트메소드(default method)        interface MyInterface {        void method();        default void newMethod();{ } }            디폴트메소드 = 인스턴스메소드 (인터페이스 원칙 위반 = 예외)      디폴트메소드가 기존의 메소드와 충돌할때?                              여러 인터페이스의 디폴트 메소드간의 충돌 — 인터페이스를 구현한 클래스에서 디폴트메소드를 오버라이딩한다                                디폴트메소드와 조상클래스의 메소드간의 충돌 — 조상클래스의 메소드가 우선되어 먼저 상속되고, 디폴트메소드는 무시된다.                                static 메소드      내부클래스(inner class) : 클래스 안에 클래스          객체생성없이도 상위클래스의 멤버에 접근가능      코드의 복잡성을 줄일 수 있음. (캡슐화)          class AAA{ //BBB의 외부클래스  \tint i=100;  \tBBB b = new BBB();  \tclass BBB{///AAA의 내부클래스  \t\tvoid method() {  //\t\t\tAAA a = new AAA();  //AAA의 내부클래스라 해줄필요없음  \t\t\tSystem.out.println(i); //객체생성없이 접근가능  \t\t}  \t}  }  class CCC{  }  public class ex {      \tpublic static void main(String[] args) {  \t\tAAA a = new AAA();  \t\ta.b.method();  \t}  }                      내부클래스의 종류와 유효범위(scope)는 변수와 동일                                            내부클래스              특징                                                          인스턴스 클래스  (instance class)              외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.                                      스태택 클래스  (static class)              외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메소드에서 사용될 목적으로 선언된다.                                      지역 클래스  (local class)              외부클래스의 메소드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.                                      익명 클래스  (anonymosus class)              클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)                                                내부클래스의 제어자는 public, private, (default), protected 4가지 사용가능.                  public class ex {          \tclass InterfaceInner{  \t\tint iv = 100;  //\t\tstatic int cv = 100; //에러, static변수 선언불가  \t\t//static은 객체없이 생성할 수 있어야하는데 인스턴스안에 들어가있어서 객체를 만들어야 사용할 수 있게됨. 모순이라 에러표시  \t\tfinal static int CONST = 100; //final static은 상수이므로 허용  \t}        \t  \tstatic class staticInner{  \t\tint iv = 200;  \t\tstatic int cv = 200; //static클래스만 static멤버를 정의할 수 있다.  \t}  \tvoid mymethod() {  \t\tclass LocalInner{  \t\t\tint iv = 300;  //\t\t\tstatic int cv = 300; //에러, static변수를 선언할 수 없다  \t\t\tfinal static int CONST = 300; //final static은 상수이므로 허용  \t\t\t//final뒤에 static이 오는 경우는 어떤 조건에서도 같은 값일 경우.   \t\t\t//객체마다 값이 다를수도 있으면 final만 쓰면됨(ex.카드의 숫자와 무늬)  \t\t}  \t\tint i = LocalInner.CONST; //지역내부클래스의 static상수는 메소드 내에서만 사용가능  \t}  \tpublic static void main(String[] args) {  \t\tSystem.out.println(InterfaceInner.CONST);  \t\tSystem.out.println(staticInner.cv);  //\t\tSystem.out.println(LocalInner.CONST); //지역내부클래스의 static상수는 메소드 외에서는 사용 불가능  \t}  }                  public class ex {          \tclass InstanceInner{}  \tstatic class StaticInner{}        \t  \tInstanceInner iv = new InstanceInner(); //인스턴스 멤버끼리는 직접 접근가능  \tstatic StaticInner cv = new StaticInner(); //static멤버끼리는 직접 접근가능  //\tstatic StaticInner cv2 = new InstanceInner(); //static멤버가 instance멤버 접근 불가능. 반대는 가능          \tstatic void staticmethod() { //static멤버는 인스턴스에 직접접근불가  //\tInstanceInner obj1 = new InstanceInner();  \t\tStaticInner obj2 = new StaticInner();        \t\t  \t\t//이렇게까지 쓰지는 않는데 일단 예시로  \t\tex outer = new ex(); //인스턴스 클래스는 외부클래스를 먼저 생성해야 생성가능  \t\tInstanceInner obj1 = outer.new InstanceInner();  \t}  \tvoid instanceMethod() {//인스턴스메소드에서는 인스턴스멤버와 static멤버 모두 접근가능  \t\tInstanceInner obj1 = new InstanceInner();  \t\tStaticInner obj2 = new StaticInner();  //\t\tLocalInner lv = new LocalInner(); //지역 내부클래스는 외부에서 접근 불가  \t}  \tvoid myMethod() {  \t\tclass LocalInner{}  \t\tLocalInner lv = new LocalInner();  \t}  \tpublic static void main(String[] args) {  \t}  }                  class Outer{  \tprivate int outerIv= 0;  \tprivate static \tint outerCv=0;        \t  \tclass InstanceInner{  \t\tint iiv = outerIv;//외부클래스의 private멤버도 접근가능  \t\tint iiv2 = outerCv;   \t}  \tstatic class StaticInner{  //\t\tint siv = outerIv; //static클래스는 외부클래스의 인스턴스멤버에 접근 불가  \t\tstatic int scv = outerCv;  \t}  \tvoid mymethod() {  \t\tint lv = 0;  \t\tfinal int LV = 0;  //final생략 가능        \t\t  //\t\tlv=3;//밑에 int liv3 = lv;에러내려고 적음. 값이 바뀌었으니 변수로 처리해서 에러남  \t\tclass LocalInner{ //지역내부클래스를 감싸고있는 메소드의 상수만 사용가능  \t\t\tint liv = outerIv;  \t\t\tint liv2 = outerCv;  \t\t\t//내부클래스의 객체가 지역변수보다 더 오래 존재가능   \t\t\t//외부클래스의 지역변수는 final이 붙은 변수(상수)만 접근 가능  \t\t\t//JDK1.8부터는 변수인데 값이 안바뀌는 것도 상수로 간주. (에러x)  \t\t\tint liv3 = lv;  \t\t\tint liv4 = LV;         \t\t\t  \t\t\tvoid method() {  \t\t\t\tSystem.out.println(lv);  \t\t\t}        \t\t\t  \t\t}  \t}  }  public class ex {  \tpublic static void main(String[] args) {  \t}  }                          인스턴스 내부클래스를 사용하려면 외부클래스의 객체를 먼저 만들고 인스턴스내부클래스의 객체를 만들어야 함      class Outer {  \tclass instanceInner {  \t\tint iv =100;  \t}  \tstatic class StaticInner {  \t\tint iv = 200;  \t\tstatic int cv = 300;  \t}  \tvoid myMethod() {  \t\tclass LocalInner{  \t\t\tint iv = 400;  \t\t}  \t}  }  public class ex {  \tpublic static void main(String[] args) {  \t\tOuter oc  = new Outer(); //외부클래스의 인스턴스를 먼저 생성해야 인스턴스클래스의  \t\tOuter.instanceInner ii = oc.new instanceInner(); //인스턴스를 생성가능    \t\t  \t\tSystem.out.println(\"ii.iv : \"+ii.iv);  \t\tSystem.out.println(\"Outer.StaticInner.cv : \"+Outer.StaticInner.cv);    \t\t  \t\t//스태틱 내부클래스의 인스턴스는 외부클래스를 먼저 생성하지않아도 된다  \t\tOuter.StaticInner si = new Outer.StaticInner();  \t\tSystem.out.println(\"ii.iv : \"+si.iv);    \t\t  \t}  }          class Outer {  \tint value = 10; //Outer.this.value 외부클래스의 iv    \t  \tclass Inner{  \t\tint value = 20; //this.value 내부클래스의 iv    \t\t  \t\tvoid method() {  \t\t\tint value = 30;  \t\t\tSystem.out.println(\"           value : \"+value);  \t\t\tSystem.out.println(\"      this.value : \"+this.value);  \t\t\tSystem.out.println(\"Outer.this.value : \"+Outer.this.value);    \t\t\t  \t\t}  \t}    \t  }  public class ex {  \tpublic static void main(String[] args) {  \t\tOuter outer = new Outer();  \t\tOuter.Inner inner = outer.new Inner();  \t\tinner.method();    \t\t  \t}  }            익명클래스(anonymous class)    : 이름이 없는 일회용 클래스. 정의와 생성을 동시에 함(조상이름을 대신 씀)  new 조상클래스 이름(){ 멤버선언 } / new 구현인터페이스이름() { 멤버선언 }      public class ex {  \tObject iv = new Object() {void method2(){}}; //익명클래스  \tstatic Object cv = new Object() {void method2(){}}; //익명클래스    \t  \tvoid Mymethod() {  \t\tObject lv = new Object() { void method2() {}}; //익명클래스  \t}      \tpublic static void main(String[] args) {  \t}  }          import java.awt.*;  import java.awt.event.*;  //awt : 자바의 윈도우 프로그래밍 도구.       public class ex {  \tpublic static void main(String[] args) {  \t\tButton b = new Button(\"start\");  //\t\tb.addActionListener(new EventHandler()); //객체생성  \t\tb.addActionListener(new AcionListener/*조상 OR 인스턴스 이름*/() { //클래스의 정의와 객체생성을 동시에  \t\t\tpublic void actionPerformed(ActionEvent e) {  \t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");  \t\t\t}  \t\t}); //객체생성    \t\t  \t\t//위랑 같아보이지만 다른 클래스임. 일회용클래스이기때문.  \t\tb.addActionListener(new AcionListener/*조상 OR 인스턴스 이름*/() { //클래스의 정의와 객체생성을 동시에  \t\t\tpublic void actionPerformed(ActionEvent e) {  \t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");  \t\t\t}  \t\t}); //객체생성    \t\t  \t\t}  \t}  //class EventHandler implements AcionListener{ //클래스 정의.   //\tpublic void actionPerformed(ActionEvent e) {  //\t\tSystem.out.println(\"ActionEvent occurred!!!\");  //\t}  //}      "
  },
  
  {
    "title": "객체지향(oop)",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5(OOP)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 객체",
    "date": "2022-08-01 00:00:00 +0900",
    





    
    "snippet": "객체지향 언어 = 프로그래밍 언어 + 객체지향개점(규칙)  캡슐화  상속  추상화      다형성    class : 객체를 정의해 놓은 것, 객체를 생성하는데 사용함. (설계도)  = 데이터 + 함수(method) (서로 관련있는 것 끼리 묶음. 데이터만 묶으면  구조체)  기본적으로 하나의 소스파일에 하나의 class를 작성하는것이 바람직하나, 여...",
    "content": "객체지향 언어 = 프로그래밍 언어 + 객체지향개점(규칙)  캡슐화  상속  추상화      다형성    class : 객체를 정의해 놓은 것, 객체를 생성하는데 사용함. (설계도)  = 데이터 + 함수(method) (서로 관련있는 것 끼리 묶음. 데이터만 묶으면  구조체)  기본적으로 하나의 소스파일에 하나의 class를 작성하는것이 바람직하나, 여러 class를 작성할수도 있음.          public class가 있는 경우, 소스파일의 이름은 반드시 public class(한소스파일에서 한번만 사용 가능)의 이름과 일치해야함      public class가 없는 경우, 소스파일의 이름은 class 중 어느 것을 사용해도 무방함. (main method가 있는부분은 동일해야함. 아니면 수동으로 지정가능)            객체(인스턴스와 거의 같은 말임) : 실제로 존재하는 사물 또는 개념. 객체가 가진 기능과 속성에따라 용도가 다름. 모든 인스턴스를 대표하는 일반적 용어. 클래스를 인스턴스화하면 객체(인스턴스)가 됨.  (제품) - 속성(변수) + 기능(메소드)                  class 생성        class Tv { String color ………. (6개의 멤버 = 구성 6개) }                    객체 생성 : 변수명 = new 클래스명();        Tv t = new Tv();                    사용        t.channel1 = 7; t.channelDown(); sout(”현재 “+t.channel1+번입니다”)         class Tv { \t//tv의 속성 \tString color; \tboolean power; \tint channer1;        \t \t//tv의 기능 \tvoid power(){ \t\tpower !=power; //티비 온오프 \t} \tvoid channer1Up() { \t\t++channer1; \t} \tvoid channer1Down() { \t\t--channer1; \t} } public class Ex6_1 {         \tpublic static void main(String[] args) { \t\tTv t = new Tv(); \t\tt.channer1=7; \t\tt.channer1Down(); \t\tSystem.out.println(\"현재 \"+t.channer1+\"번 입니다.\");        \t\t //\t\tTv t2 = new Tv(); //\t\tSystem.out.println(\"현재 \"+t2.channer1+\"번 입니다.\"); //0번        \t\t \t\tTv t2 = t; \t\tSystem.out.println(\"현재 \"+t2.channer1+\"번 입니다.\"); //6번 \t}         }                                    객체 배열 == 참조변수 배열  tv tvarr[] = new tv[3]; == tv tvarr[] = {new tv(), new tv(), new tv()};        tvatrr[0] = new tv(); tvatrr[1] = new tv(); tvatrr[2] = new tv();              인스턴스(객체와 거의 같은 말임) : 특정 class로부터 생성된 객체      선언위치에 따른 변수의 종류      class variable {  \tint iv;  \tstatic int cv;      \tvoid method() {  \tint lv = 0;  \t}  } //이 전체가 class 영역                      변수                  클래스 영역(선언문만 가능, 순서 상관x)                          iv (intance variable), cv(static 있어서 class)                                메소드 영역 - lv(Local variable)                                                    변수의 종류              선언 위치              생성 시기                                                          class 변수              class 영역              클래스가 메모리에 올라갈 때(import할때)                                      instance 변수              class 영역              인스턴스가 생성되었을 때                                      지역변수              class영역 이외의 영역  (메소드, 생성자, 초기화 블럭 내부)              변수 선언문이 수행되었을 때                                      객체 - instance 변수를 묶어놓은 것.                  [!important]CPU ←RAM ←SSD or HDD - ssd, hdd에서 바로 cpu못가니까 ram을 둠. 파일을 읽는다고 하면(loading) 메모리(ram)에 얹는다고 표현함. = 작업을 하려면 class가 메모리에 올라간다고 표현함.ram은 컴퓨터를 끄면 데이터가 날아가니까 저장(save)하려면 다시 디스크로 옮겨야함즉, class변수는 아무때나 사용이 가능하고 instance는 객체생성을 해야 사용 가능함. 그래서!! class는 객체생성이 필요없고 instance는 객체생성이 필요함.                          class 변수 : 공통 속성(객체 모두 같은 값) ??변경하면 까다로워지니까          instance 변수 : 개별 속성(객체마다 다른 값도 가능) ??복사개념이라 수정쉬워서                  class Card{  \tString kind; //무늬  \tint number; //숫자          \tstatic int width = 100; //폭  \tstatic int height = 250;  }          public static main void(String[] args){  \tCard c = new Card();  \tc.kind = \"heart\";  \tc.number = 5;          \t// c.width = 200;  오류는 안나는데 이렇게하면 안됨!! 객체별로 값이 달라짐  \t// c.height = 300; 오류는 안나는데 이렇게하면 안됨!! 객체별로 값이 달라짐  \tCard.width = 200;  \tCard.height = 300; //class값이 전부 변경돼서 객체별로 값이 같아짐  }                  class Card{  \tString kind; //무늬  \tint number; //숫자          \tstatic int width = 100; //폭  \tstatic int height = 250;  }  public class Ex6_3 {          \tpublic static void main(String[] args) {  \t\tSystem.out.println(\"Card.width = \"+Card.width);  \t\tSystem.out.println(\"Card.height = \"+Card.height); //객체 생성없이 사용 가능        \t\t  \t\tCard c1 = new Card();  \t\tc1.kind = \"Heart\";  \t\tc1.number = 7;        \t\t  \t\tCard c2 = new Card();  \t\tc2.kind = \"Spade\";  \t\tc2.number = 4;        \t\t  \t\tSystem.out.println(\"c1은 \"+c1.kind+\", \"+c1.number+\"이며, 이 카드의 크기는 (\"+c1.width+\", \"+c1.height+\")\");  \t\tSystem.out.println(\"c2은 \"+c2.kind+\", \"+c2.number+\"이며, 이 카드의 크기는 (\"+c2.width+\", \"+c2.height+\")\");  \t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경합니다\");        \t\t  //\t\tc1.width=50;  //\t\tc1.height=80; //c1이 인스턴스지만 width와 height가 class기 때문에 모두 바뀜  \t\t//오해하기 쉬운 코드니까 권장하지 않는 코드임.        \t\t  \t\tCard.width=50;  \t\tCard.height=80;  \t\tSystem.out.println(\"c1은 \"+c1.kind+\", \"+c1.number+\"이며, 이 카드의 크기는 (\"+c1.width+\", \"+c1.height+\")\");  \t\tSystem.out.println(\"c2은 \"+c2.kind+\", \"+c2.number+\"이며, 이 카드의 크기는 (\"+c2.width+\", \"+c2.height+\")\");  \t}          }                                      메소드(=블랙박스) : 문장들을 묶어놓은 것. (class안에 있어야함)  선언부 { 구현부 }                                          값(입력)을 받아서 처리하고, 결과를 반환(출력) - 함수랑 똑같다고 보면됨(함수는 독립적이라 class안에 없어도됨.  int add(int x, int y){  int result = x+y;  return result; }                                                      반드시 return으로 마무리 지어야하는데 값이 void일경우 return 생략 가능                                                        메소드 = 블랙박스??                    별 이유없고 걍..별로 알고싶지않아서 println이 어떻게 동작하는지 궁금함? ㄴㄴㅋㅋ                                                              실행흐름                                  인스턴스 생성                  main메소드안에서 메소드 호출                  메소드 {}안의 문장 수행                  호출 메소드로 돌아와서 main메소드안의 메소드로 돌아와서 이후 문장 수행                                            하나의 메소드에 하나의 기능만 수행하도록 작성할 것.              장점                                  코드 중복 줄이기                  코드 관리 용이                  코드 재사용 용이                  코드가 간결해서 이해하기 쉬워진다                                            지역 변수 : 메소드 안에 선언된 변수 (매소드가 끝나면 없어지기때문에 다른 메소드에 이름을 같게해도 상관없음.)              메소드 호출 : 메소드 이름(값1,값2,…[값 안써도 됨]);  int result = add(3,5); ⇒ int add값을 저장할 공간이 필요해서 int result를 씀 (class영역에만 정의 가능)                          int add(int x, int y){  \tint result = x+y;  \treturn result;  }              public static void main(String [] args) {  \tint result = add(3,5);  }                        매개변수 : 메소드를 호출한쪽에서 준 값을 메소드에게 전달하는 역할              class MyMath {  \tlong add(long a, long b) {  \t\treturn a+b;  \t}  \tlong subtract(long a, long b) {  \t\treturn a-b;  \t}  \tlong multiply(long a, long b) {  \t\treturn a*b;  \t}  \tlong divide(long a, long b) {  \t\treturn a/b;  \t}            \t  \t// 두 값을 받아서 더 큰 값을 반환하는 메소드  \tlong max (long a, long b) {  //\t\treturn a&gt;b? a:b;  \t\tif(a&gt;b) return a;  \t\telse return b; //참, 거짓 둘다 return해줘야함  \t}  \tlong min (long l, long m) {  \t\treturn l&lt;m?l:m;  \t}            \t  \tvoid printgugudan(int dan) {  \t\tif(!(dan&gt;=2 &amp;&amp; dan&lt;=9)) {  \t\t\treturn;  \t\t}            \t\t  \t\tfor (int i=1;i&lt;=9;i++) {  \t\t\tSystem.out.printf(\"%d * %d = %d%n\",dan,i,dan*i);  \t\t}  \t}  }  public class Ex6_4 {              \tpublic static void main(String[] args) {  \t\tMyMath mm = new MyMath();            \t\t  \t\tlong result1 = mm.add(5L,3L);  \t\tlong result2 = mm.subtract(5L,3L);  \t\tlong result3 = mm.multiply(5L,3L);  \t\tlong result4 = mm.divide(5L,3L);            \t\t  \t\tSystem.out.println(\"add = \"+result1);  \t\tSystem.out.println(\"subtract = \"+result2);  \t\tSystem.out.println(\"multiply = \"+result3);  \t\tSystem.out.println(\"divide = \"+result4);            \t  \t\tSystem.out.println(mm.max(mm.add(5, 3),mm.add(4, 3)));  \t\tSystem.out.println(mm.max(5, 4));  \t\tSystem.out.println(mm.min(mm.add(5, 3),mm.add(4, 3)));  \t\tSystem.out.println(mm.min(5, 4));            \t\t  \t\tmm.printgugudan(5);  \t}              }                                      반환값 - return : 실행중인 메소드를 종료하고 호출한 곳으로 되돌아간다. (타입이 일치해야하나 자동형변환된는 것은 가능 ex. char → int                                            호출스택 (call srack) : 메소드 수행에 필요한 메모리가 제공되는 공간. 메소드가 호출되면 호출스택에 메모리 할당, 종료되면 해제          stack : 밑이 꽉막힌 상자. 위에 차곡차곡 쌓인다. - 후입선출      main 메소드가 println 메소드를 호출했으면 println 메소드가 실행되는동안 main 메소드는 대기상대임.println메소드가 종료되면 스택에서 사라지고 남은 main메소드가 작업을 계속함  = 맨 위에 있는 메소드 하나만 실행중, 나머지는 대기            기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.      class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tchange(d.x);     \t\t  \t\tSystem.out.println(\"After change(d.x)\");  \t\tSystem.out.println(\"main() : x = \"+d.x); //change의 int x와는 다른 주소를 가지고있기때문에 main안에서는 여전히 10의 값을 가짐  \t}  \tstatic void change(int x) { //int x로 새로운 저장공간은 만들었기때문에 class date의 int x와는 가른 주소를 가짐  \t\tx=1000;  \t\tSystem.out.println(\"chanhe() : x = \"+x);  \t}//change문이 끝났으니 change문 시작할때 새로 지정해준 int x의 값도 종료됨!  }            참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.      class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tchange(d);     \t\t  \t\tSystem.out.println(\"After change(d)\");  \t\tSystem.out.println(\"main() : x = \"+d.x); //1000  \t}  \tstatic void change(Date d) { //main에서도 공유중인 date의 d값을 복사해옴. = main의 x와 같은 동일한 공간을 가짐  \t\td.x=1000;  \t\tSystem.out.println(\"chanhe() : x = \"+d.x);  \t}  }          class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tDate d2 = copy(d);  \t\tSystem.out.println(\"d.x = \"+d.x);  \t\tSystem.out.println(\"dx.x = \"+d2.x);  \t}  \tstatic Date copy(Date d) {  \t\tDate tmp = new Date();    \t\t  \t\ttmp.x=d.x;    \t\t  \t\treturn tmp; //객체의 주소를 반환함    \t\t  \t}  }            일단 이렇게 이해함.            좀 더 확실히 이해하려고 다시 그려봄    static method(class method) - ex)Math.random();          객체생성 없이 ‘클래스이름.메소드이름()’으로 호출      인스턴스 멤버(iv, im)과 관련없는 작업을 하는 메소드      메소드 내에서 인스턴스 변수(iv), 인스턴스 메소드(im) 사용불가 (객체가 있다는 보장이 없음)            instance method          인스턴스 생성 후 ‘참조변수.메소드이름()’으로 호출      인스턴스 멤버와 관련된 작업(iv, im)을 하는 메소드      메소드 내에서 인스턴스 변수(iv) 사용가능      class 메소드 사용 가능함. (class는 언제나 사용가능함)          class MyMath3{  \tlong a,b;  //인스턴스 변수(iv)    \t  \tlong add() { //instance method  \t\treturn a+b; //인스턴스 변수  \t}  \tstatic long add(long a, long b )  { //class method. long a,b는 지역변수이자 매개변수(iv필요없음)  \t\treturn a+b; //지역변수  \t}  }  public class array {  \tpublic static void main(String[] args) {  \t\t\tSystem.out.println(MyMath3.add(200L,100L)); //class method 호출  \t\t\tMyMath3 mm = new MyMath3(); //객체 만들기  \t\t\tmm.a = 200L;  \t\t\tmm.b = 300L;  \t\t\tSystem.out.println(mm.add()); //instance method 호출  \t}  }        static은 iv를 사용하지않을때 붙일 것.    이걸 구분할줄알아야 코더가 아니고 프로그래머가된다…………………………………    그래도 한번더 정리하자면          static - 공통속성에 붙이는 것. (변하지 않는 값 - ex.카드 크기 등)        오버로딩(overloaing : 과적하다) : 한 class안에 같은 이름의 메소드 여러개를 정의하는 것. (대표적으로 println이 있다)                  성립조건                  메소드 이름이 같음          매개변수의 개수 또는 타입이 달라야함.                      반환 타입은 영향이 없음            ex )                        int add(int a, int b) {return a+b}            int add(int x, int y) {return a+b}            ⇒ 오버로딩 아님. 1번만 충족. 그냥 중복처리돼서 에러                        int add(int a, int b) {return a+b}            long add(int a, int b) {return (long)(a+b)}            ⇒ 1번 충족, 2번 불충족, 3번은 상관없음. 결론, 중복정의로 에러                        long add(int a, long b) {return a+b}            long add(long a, int b) {return a+b}            ⇒ 1번 2번 모두 충족, 오버로딩            💡 add(3,3);은 두 add 전부 해당돼서 명확하지않다고 에러남                            class MyMath3{  \tint add(int a, int b) {  \t\tSystem.out.println(\"int add (int a, int b) - \");  \t\treturn a+b;  \t}  \tlong add(long a, int b) {  \t\tSystem.out.println(\"long add (long a, int b) - \");  \t\treturn a+b;  \t}  \tlong add(int a, long b) {  \t\tSystem.out.println(\"long add (int a, long b) - \");  \t\treturn a+b;  \t}  \tlong add(long a, long b) {  \t\tSystem.out.println(\"long add (long a, long b) - \");  \t\treturn a+b;  \t}  \tint add(int[] a) { //배열의 모든 요소의 합을 결과로  \t\tSystem.out.print(\"int add(int[] a) - \");  \t\tint result = 0;  \t\tfor(int i=0; i &lt; a.length;i++)   \t\t\tresult += a[i];  \t\t\treturn result;  \t\t}  }          public class array {  \tpublic static void main(String[] args) {  \t\tMyMath3 mm = new MyMath3();  \t\tSystem.out.println(\"mm.add(3,3) 결과 : \"+mm.add(3,3));  \t\tSystem.out.println(\"mm.add(3L,3) 결과 : \"+mm.add(3L,3));  \t\tSystem.out.println(\"mm.add(3,3L) 결과 : \"+mm.add(3,3L));  \t\tSystem.out.println(\"mm.add(3L,3L) 결과 : \"+mm.add(3L,3L));        \t\t  \t\tint a[] = {100, 200,300};  \t\tSystem.out.println(\"mm.add(a) 결과 : \"+mm.add(a));        \t\t  \t}  }                      생성자(constructor) :                  인스턴스가 생성될 때마다 호출되는 ‘인스턴스 초기화 메소드’        Time t = new Time(); //객체생성  //인스턴스 초기화  t.hour = 12;  t.minute = 34;  t.second = 56;  == Time t = new  Time(12,34,56); //생성자            인스턴스 생성시 수행할 작업(iv 초기화)에 사용              class와 이름이 같아야 함. (구성다른 생성자를 여러개 쓰면 오버로딩임)        class Card {        Card() { //매개변수 없는 생성자        //인스턴스 초기화 작업        }        Card (String kind, int number) { //매개변수 있는 생성자        //인스턴스 초기화 작업        }        Card 클래스가 두개인건 생성자 오버로딩            리턴값이 없음 (void도 안붙임)      모든 class는 한개이상의 생성자가 있어야한다.            기본생성자 (default constructor) : 직접 작성해줘야하나 자동으로 생기는 생성자          매개변수가 없는 생성자              생성자가 하나도 없을 때만, 컴파일러가 자동 추가        Point() {} //Point 클래스의 기본 생성자                class Data_1 {  \tint value;  \t//Date_1(){} 가 자동으로 생김  }  class Data_2{  \tint value;  \t//Data_2() {} //기본생성자 (에러내려고 주석처리함)  \tData_2(int x){ //매개변수가있는 생산자  \t\tvalue = x;  \t}      }  public class array {  \tpublic static void main(String[] args) {  \t\tData_1 d1 = new Data_1(); //Date_1 클래스안에 생성자가 없어서(1개) 기본 생성자가 자동으로 생김  \t\tData_2 d2 = new Data_2(); //compile error 생성자를 호출했는데 Date_2안에 생성자가 없음  \t}  }        어지간하면 그냥 넣어줄것. 나중에가면 헷갈림          매개변수가 있는 생성자 : 생성자 호출할때 바로 값을 받음.          class Car {  \tString color; //색상  \tString gearType; //변속기 종류 - auto(자동), manual(수종)  \tint door; //문 개수    \t  \tCar(){}  \tCar(String c, String g, int d){  \t\tcolor = c;  \t\tgearType = g;  \t\tdoor = d;  \t}  }  public class array {   \tpublic static void main(String[] args) {  \t\tCar c = new Car(\"white\",\"auto\",4);   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t\tSystem.out.println();  \t\tCar c2 = new Car(\"red\",\"manual\",3);   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t}  }            생성자 this()          같은 클래스에서 다른 생성자를 호출할 때 사용      다른 생성자 호출시 첫 줄에서만 가능          class Car {  \tString color; //색상  \tString gearType; //변속기 종류 - auto(자동), manual(수종)  \tint door; //문 개수    \t  \tCar(){  \t\tthis(\"white\",\"auto\",4); // == Car{String color, String gearType, int door)  \t\t//color = \"white\";  \t\t//gearType = \"auto\"  \t\t//door = 4;   이거랑 같은거임. 코드 중복 줄이려고 한 문장으로 만든 것.  \t}  \tCar(String color) {  \t\tthis(color, \"manual\",3);  \t}  \tCar(String color, String gearType, int door){  \t\tthis.color = color;  \t\tthis.door = door;  \t\tthis.gearType= gearType;  \t}  }  public class array {   \tpublic static void main(String[] args) {  \t\tCar c = new Car();   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t\tSystem.out.println();  \t\tCar c2 = new Car(\"red\");   \t\tSystem.out.println(\"색 : \"+c2.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c2.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c2.door);  \t\tSystem.out.println();  \t\tCar c3 = new Car(\"blue\",\"auto\",5);   \t\tSystem.out.println(\"색 : \"+c3.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c3.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c3.door);  \t}  }        코드 중복을 제거하기 위해 생성자끼리 서로 호출하는 것  class Car {\tString color;\tString gearType; \tint door; }Car(){ //값이 주어지지않는다면 밑의 값으로 초기화\tcolor = \"white\";\tgearType = \"auto\";\tdoor = 4;} Car(String c, String g, int d){color = c;gearType = g;door = d;}↓class Car {\tString color;\tString gearType; \tint door; }Car(){\tthis(\"white\",\"auto\",4)}Car(String c, String g, int d){color = c;gearType = g;door = d;}  참조변수 this -괄호 없음 : 생성자 this랑 아예 관련없음. 연관짓지말것.          인스턴스 자신을 가리키는 참조변수 - 인스턴스 주소가 저장되어있다      인스턴스 메소드에서만 사용가능      모든 인스턴스 메소드에 지역변수로 숨겨진 채로 존재      지역변수와 인스턴스 변수를 구분할 때 사용      Car(String c, String g, int d){\t//color는 iv, c는 lv\tcolor = c;\tgearType = g;\tdoor = d;} //같은 클래스안에서는 생략이 가능하나 이름이 같으면 생략이 안됨//this가 자동으로 생략됨Car(String color, String gearType, int door){\t\tthis.color = color;\t\tthis.door = door;\t\tthis.gearType= gearType;} //this가 붙은건 iv, =뒤에있는건 lv//this가 없다면 iv처리가 됨//이름이 같아서 this 생략이 불가능왼쪽으로 많이 쓰는데, 정석은 오른쪽. 지역변수와 인스턴스 구분할때 정석으로 써주면됨class MyMath3{\tlong a,b;  //this a, this b iv의 진짜 이름\tMyMath(int a, int b){\t\tthis.a = a;\t\tthis.b = b;  //this 생락 불가능. 에러는 안나는데 지역변수가 됨\t}\tlong add(){ //인스턴스 메소드\t\treturn a+b; //return this.a + this.b    this는 생략 가능\t} \tstatic long add(long a, long b){ \t\treturn a+b;  //인스턴스 변수 사용 불가능. static이 있어서. 그래서 this. 사용불가\t}}this는 클래스 메소드나 인스턴스 매소드에서만 사용가능  변수의 초기화                  지역변수는 수동 초기화 해주어야함          class a{  \tint x;  \tint y = x;  //인스턴스 변수          \tvoid Method1(){ //메소드 안이니까 지역변수  \t\tint i;   \t\tint j = i; //에러남. i의 값이 없기때문. 지역변수는 자동으로 0으로 초기화해주지 않음.   \t}  \tvoid Method2(){  \t\tint i=0; //지역변수.   \t\tint j = i;  }                            멤버 변수는 자동 초기화된다                  멤버변수(iv, cv) 초기화          명시적 초기화 - 간단 초기화                  기본형 변수의 초기화 - int a= 0;          참조형 변수의 초기화 - Print p = new Print();)                    초기화 블럭 - 복잡한 초기화                  인스턴스 초기화 : {} (잘안씀)          클래스 초기화 블럭 : static{}                    생성자 - 인스턴스 변수 초기화. 복잡한 초기화에 사용        cv초기화가 먼저되고 iv초기화가 이루어짐. 자동→간단→복잡 초기화      class a {  \tstatic int[] arr = new int[10]  //명시적 초기화    \t  \tstatic { //클래스 초기화 블럭 - 배열 arr을 난수로 채운다  \t\tfor (...............  .....        — 클래스 변수 초기화 시점          클래스 변수 초기화 시점 - 클래스가 처음 로딩될 때 단 한번      인스턴스 변수 초기화 시점 - 객체가 만들어질때      "
  },
  
  {
    "title": "배열",
    "url": "/posts/%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 배열",
    "date": "2022-07-31 00:00:00 +0900",
    





    
    "snippet": "배열 : 같은 타입의 변수를 하나의 묶음으로 다루는 것.      선언 : 배열을 다루기 위한 참조변수의 선언    int[] score; / String[] name; - 자바스타일    int score[]; / String name[]; - c언어 스타일    둘다 가능은 함. 편한걸로 쓸것.    int[] score; score = new i...",
    "content": "배열 : 같은 타입의 변수를 하나의 묶음으로 다루는 것.      선언 : 배열을 다루기 위한 참조변수의 선언    int[] score; / String[] name; - 자바스타일    int score[]; / String name[]; - c언어 스타일    둘다 가능은 함. 편한걸로 쓸것.    int[] score; score = new int [5];    배열은 한번 생성하면 실행하는 동안 그 길이를 바꿀 수 없다. 배열의 길이 - int형 상수      char배열인 경우에만    char charr[] = {’a’,’b’,’c’,’d’}    system.out.println(charr)    으로 출력이 가능함. 다른 경우는 for문 또는 Arrays.toString(배열)을 써야 전체출력할 수 있음.  import java.util.*;public class array {\tpublic static void main(String[] args) {\t\t\t\tint iarr1[] = new int[10];\t\tint iarr2[] = new int[10];\t\tint iarr3[] = {100,95,80,70,60};\t\tchar charr[] = {'a','b','c','d'};\t\t\t\tfor(int i=0;i&lt;iarr1.length;i++) {\t\t\tiarr1[i] = i+1;\t\t}\t\t\t\tfor(int i=0;i&lt;iarr2.length;i++) {\t\t\tiarr2[i] = (int)(Math.random()*10)+1;\t\t}\t\tSystem.out.println(Arrays.toString(iarr1));\t\tSystem.out.println(Arrays.toString(iarr2));\t\tSystem.out.println(Arrays.toString(iarr3));\t\tSystem.out.println(charr);\t}}public class array {\tpublic static void main(String[] args) {\t\tint sum = 0;\t\tfloat avg = 0f;\t\t\t\tint score[] = {100,88,100,100,90};\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tsum += score[i];\t\t}\t\t\t\tavg = (float)sum / score.length;\t\t//\t\tSystem.out.printf(\"총점 : %d%n\", sum);//\t\tSystem.out.printf(\"평균 : %.1f%n\", avg);\t\t\t\tSystem.out.println(\"총점 : \"+sum);\t\tSystem.out.println(\"평균 : \"+avg);\t}}public class array {\tpublic static void main(String[] args) {\t\tint score[] = {79,88,91,33,100,55,95};\t\t\t\tint max = score[0];\t\tint min = score[0];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tif(score[i]&gt;max)\t\t\t\tmax=score[i];\t\t\telse if(score[i]&lt;min)\t\t\t\tmin=score[i];\t\t}\t\t\tSystem.out.println(\"최대값 : \"+max);\t\t\tSystem.out.println(\"최소값 : \"+min);\t\t\t\t}}배열 섞기import java.util.Arrays;public class array {\tpublic static void main(String[] args) {\t\t//배열 섞기\t\tint numarr[]= {0,1,2,3,4,5,6,7,8,9};\t\tSystem.out.println(Arrays.toString(numarr));\t\t\t\tfor(int i=0;i&lt;numarr.length;i++) {\t\t\tint n = (int)(Math.random()*10); //이건 [i]값을 랜덤으로 받는거고 실질적으로 배열값만 섞으니까 중복이 안나옴\t\t\tint tmp = numarr[i];\t\t\tnumarr[i] = numarr[n];\t\t\tnumarr[n]=tmp;\t\t}\t\tSystem.out.println(Arrays.toString(numarr));\t}}import java.util.Arrays;public class array {\tpublic static void main(String[] args) {\t\t\tint numarr[] = new int[45];\t\t\t\tfor(int i=0;i&lt;numarr.length;i++) {\t\t\tnumarr[i] = i+1;\t\t}\t\t\t\tint tmp = 0, n = 0;\t\tfor(int j=0;j&lt;numarr.length;j++) {\t\t\tn = (int)(Math.random()*45); //그냥 랜덤으로 numarr[n]을 구하면 중복값이 나옴\t\t\ttmp = numarr[0];\t\t\tnumarr[0]=numarr[n];\t\t\tnumarr[n]=tmp;\t\t}\t\tfor(int k = 0;k&lt;6;k++) {\t\tSystem.out.println(numarr[k]);\t\t}\t}}      String 배열                  선언  String[] name = new String[3];        String name[] = {”aa”,”bb”,”cc”}                import java.util.Arrays;      public class array {      \tpublic static void main(String[] args) {    \t  \t\tString strarr[]= {\"가위\",\"바위\",\"보\"};  \t\tSystem.out.println(Arrays.toString(strarr));    \t\t    \t\t  \t\tfor(int i = 0; i&lt;10;i++) {  \t\tint tmp = (int)(Math.random()*3);  \t\tSystem.out.println(strarr[tmp]);  \t\t}  \t}  }            커맨드라인을 통해 입력받기    args[]를 통해 입력받기임. cmd통해 입력받기 가능        n차원 배열 : n-1차원 배열이 여러개 모인것 보통 3차원부터는 잘 안쓰임, 표현하기 위해서 n중for문 필요함.                  2차원배열        int score [] [] = new int [4] [3]; = 4행 3열                                                           score[0][0]              score[0][1]              score[0][2]                                                          score[0]              score[0][0]              score[0][1]              score[0][2]                                      score[1]              score[1][0]              score[1][1]              score[1][2]                                      score[2]              score[2][0]              score[2][1]              score[2][2]                                      score[3]              score[3][0]              score[3][1]              score[3][2]                                      int arr[] [] ={ {1,2,3}, {4,5,6}}                    public class array {                \tpublic static void main(String[] args) {        \t        \t\tint score[][] = {        \t\t\t\t{100,100,100},        \t\t\t\t{20,20,20,20,20},        \t\t\t\t{30,30,30},        \t\t\t\t{40,40}        \t\t};        \t\tint sum = 0;        \t\t        \t\tfor(int i = 0; i&lt;score.length;i++) {        \t\t\tfor(int j=0;j&lt;score[i].length;j++) {        \t\t\t\tSystem.out.printf(\"score[%d][%d] = %d%n\",i,j,score[i][j]);        \t\t\t\t        \t\t\t\tsum +=score[i][j];        \t\t\t}        \t\t}        \t\tSystem.out.println(\"sum = \"+sum);        \t}        }        public class array {                \tpublic static void main(String[] args) {        \t        \t\tint score[][] = {        \t\t\t\t{100,100,100},        \t\t\t\t{20,20,20},        \t\t\t\t{30,30,30},        \t\t\t\t{40,40,40},        \t\t\t\t{50,50,50}        \t\t};        \t\tint kortotal = 0, engtotal = 0, mathtotal = 0;        \t\t        \t\tSystem.out.println(\"번호  국어   영어   수학   총점  평균\");        \t\tSystem.out.println(\"=============================\");        \t\t        \t\tfor(int i = 0; i&lt;score.length;i++) {        \t\t\tint sum = 0;        \t\t\tfloat avg = 0.0f;        \t\t\t        \t\t\tkortotal += score[i][0];        \t\t\tengtotal += score[i][1];        \t\t\tmathtotal += score[i][2];        \t\t\tSystem.out.printf(\"%3d\", i+1);        \t\t\tfor(int j=0;j&lt;score[i].length;j++) {        \t\t\t\tsum += score[i][j];        \t\t\t\tSystem.out.printf(\"%5d\",score[i][j]);        \t\t\t}        \t\t\tavg = sum/ (float)score[i].length;        \t\t\tSystem.out.printf(\"   %d %2.1f%n\",sum,avg);        \t\t\t}        \t\t}        \t}        import java.util.*;                public class array {                \tpublic static void main(String[] args) {        \t        \t\tString[][] words = {        \t\t\t{\"chair\", \"의자\"},        \t\t\t{\"computer\",\"컴퓨터\"},        \t\t\t{\"integer\",\"정수\"}        \t\t};        \t\t        \t\tScanner scanner = new Scanner(System.in);        \t\t        \t\tfor(int i =0; i&lt;words.length;i++) {        \t\t\tSystem.out.printf(\"Q%d. %s의 뜻은??\",i+1,words[i][0]);        \t\t\t        \t\t\tString tmp = scanner.nextLine();        \t\t\t        \t\t\tif(tmp.equals(words[i][0])) {        \t\t\t\tSystem.out.printf(\"정답입니다!!%n%n\");        \t\t\t}        \t\t\telse {        \t\t\t\tSystem.out.println(\"틀렸습니다! 정답은 \"+words[i][1]+\"입니다.\");        \t\t\t}        \t\t}        \t}        }  String class = char[] + method : 내용을 변경할 수 없다.(read only)  String a =”a”; String b = “b”; a=a+b; 하면 String a와 a값이 따로 저장됨. 덮어쓰기안됨. 연결은 a랑만 돼서 String a는 못씀    charAt - 원하는 위치의 문자를 가져옴.  substring - 원하는 부분의 문자열을 가져옴(마지막글자 안들고오니까 조심)public class array {\tpublic static void main(String[] args) {\t\t\tString str = \"abcdefg\";\t\tchar ch = str.charAt(2);\t\tSystem.out.println(ch); //c\t\tString str2 = str.substring(1,4);\t\tSystem.out.println(str2); //bcd\t\tString str3 = str.substring(1);\t\tSystem.out.println(str3); //bcdefg\t\t\t}}      arrays(class)로 배열 다루기          equals() : 같은 값 비교      toString()      deepToString : 2차원 이상의 다차원 배열의 출력              deepEquals : 2차원 이상의 배열들끼리 값이 같은지 비교  Arrays.deepEquals(배열1,배열2)                    copyOf() : 배열 복사  Arrays.copyOf(배열,복사할 개수) - 전체복사            copyRange : 배열 원하는부분(from~to)까지 복사. 마지막값(to)복사안됨      sort(배열) : 배열 정렬. 숫자 오름차순 정렬.          import java.util.Arrays;        public class array {        \tpublic static void main(String[] args) {    \t    \t\tint arr[] = {0,1,2,3,4};    \t\tint arr2d[][] = { {11,22}, {21,22} };    \t\t    \t\tSystem.out.println(Arrays.toString(arr));    \t\tSystem.out.println(Arrays.deepToString(arr2d));    \t\t    \t\tString str2d[][] = { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\"} };    \t\tString str2d2[][] = { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\"} };    \t\t    \t\tSystem.out.println(Arrays.deepEquals(str2d, str2d2));    \t\t    \t\tint arr2[] = Arrays.copyOf(arr, arr.length);    \t\tSystem.out.println(Arrays.toString(arr2));    \t\tint arr3[] = Arrays.copyOfRange(arr, 2,4);    \t\tSystem.out.println(Arrays.toString(arr3));    \t\t    \t\tint arr4[] = {0,4,2,1,3};    \t\tSystem.out.println(Arrays.toString(arr4));    \t\tArrays.sort(arr4);    \t\tSystem.out.println(Arrays.toString(arr4));    \t}    }"
  },
  
  {
    "title": "제어문 (flow control statemt)",
    "url": "/posts/%EC%A0%9C%EC%96%B4%EB%AC%B8-(flow-control-statemt)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 제어문",
    "date": "2022-07-30 00:00:00 +0900",
    





    
    "snippet": "  조건문          if문                  switch : 처리해야하는 경우의 수가 많을 때 씀(if-else if문보다 효율적)          switch (조건식) {  \tcase 값1 :   \t\t\t//...  \t\t\tbreak;  \tcase 값2 :   \t\t\t//...  \t\t\tbreak;  \t//...  \tdefault : ...",
    "content": "  조건문          if문                  switch : 처리해야하는 경우의 수가 많을 때 씀(if-else if문보다 효율적)          switch (조건식) {  \tcase 값1 :   \t\t\t//...  \t\t\tbreak;  \tcase 값2 :   \t\t\t//...  \t\t\tbreak;  \t//...  \tdefault :  \t\t//....조건식의 결과와 일치하는 case문이 없을떄  \t\t//....  }                      제약조건\t      - 조건식 결과가 정수 또는 문자열이여야함.      - case문의 값은 정수 상수(문자포함), 문자열만 가능, 중복 금지        import java.util.*;        public class ScanfEx1 {                \tpublic static void main(String[] args) {        \t        \tSystem.out.println(\"현재 월을 입력하세요\");        \t        \tScanner scanner = new Scanner(System.in);        \tint month = scanner.nextInt();        \t        \tswitch (month) {        \t\tcase 3: case 4: case 5:        \t\t\tSystem.out.println(\"현재 계절은 봄입니다.\");        \t\t\tbreak;         \t\tcase 6: case 7:case 8:        \t\t\tSystem.out.println(\"현재 계절은 여름입니다.\");        \t\t\tbreak;        \t\tcase 9: case 10:        \t\t\tSystem.out.println(\"현재 계절은 가을입니다.\");        \t\t\tbreak;        \t\tcase 11: case 12: case 1: case 2:        \t\t\tSystem.out.println(\"현재 계절은 겨울입니다.\");        \t\t\tbreak;        \t\tdefault :        \t\t\tSystem.out.println(\"잘못 입력했습니다.\");        \t\t}        \t}        }— Math.random() : 0.0과 1.0사이의 임의의 double값을 반환0.0 * 3 ≤ Math.random() &lt; 1.0*3  ex)원하는 값 1~3      각변에 3을 곱한다    0.0 * 3 ≤ Math.random() * 3 &lt; 1.0 * 3        각 변을 int형으로 변환한다    (int)0.0 * 3 ≤ (int)(Math.random() * 3) &lt; (int)1.0 * 3    0 ≤ Math.random() * 3 &lt; 3        각 변에 1을 더한다    0 + 1 ≤ (Math.random() * 3) +1 &lt; 3 + 1    1 ≤ (Math.random() * 3) +1 &lt; 4      public class ex4_7 {    \tpublic static void main(String[] args) {    \t\tint num=0;    \t\t//1~10사이의 난수를 20개 출력할 것.    \t\tfor(int i=0;i&lt;=20;i++) {    \t\t\tSystem.out.println((int)(Math.random()*10)+1);    \t\t}    \t\tSystem.out.println(\"===============\");        \t\t\t//-5~5사이의 난수를 20개 출력할 것.    \t\tfor(int j=0;j&lt;=20;j++) {    \t\t\tSystem.out.println((int)(Math.random()*11)-5); //0도 포함이라 값이 11개임    \t\t}    \t}    }  반복문          for          public class ex4_8 {        \tpublic static void main(String[] args) {    \t\tfor(int i=1, j=10;i&lt;=10;i++,j--) {    \t\t\tSystem.out.println(\"i=\"+i+\", j=\"+j);    \t}    \t    \t//구구단    \tfor(int j = 2;j&lt;=9;j++){    \t\tSystem.out.println(j+\"단 시작!!!\");    \t\tfor(int k=1;k&lt;=9;k++) {    \t\t\tSystem.out.println(j+\" * \" +k+\" = \"+j*k);    \t\t\tif(k==9)    \t\t\tSystem.out.println(\"====\"+j+\"단 종료====\\n\");    \t\t}    \t}    \t//별 찍기    \t\tfor(int n=1;n&lt;10;n++) {    \t\t\tfor(int x=1;x&lt;n;x++) {    \t\t\t\tSystem.out.print(\"★\");    \t\t\t}    \t\t\tSystem.out.println();    \t\t}     \t}    }  while - 조건식을 만족시키는 동안 블럭을 반복. do while문을 사용.    public class ex4_13 {        \tpublic static void main(String[] args) {    \t\tint sum=0;    \t\tint i=0;    \t\t    \t\twhile (sum&lt;=100) {    \t\t\tSystem.out.printf(\"%d : %d%n\",i,sum);    \t\t\tsum += ++i;    \t\t}    \t}        }    import java.util.*;        public class Ex4_14 {        \tpublic static void main(String[] args) {    \t\tint num=0, sum = 0;    \t\tSystem.out.println(\"숫자를 입력하세요.\");    \t\t    \t\tScanner scanner = new Scanner(System.in);    \t\tString tmp = scanner.nextLine();    \t\tnum = Integer.parseInt(tmp);    \t\t    \t\twhile (num != 0) {    \t\t\tsum += num%10;    \t\t\tSystem.out.printf(\"sum = %d num = %d%n\",sum,num);    \t\t\t    \t\t\tnum /= 10;    \t\t}    \t\tSystem.out.println(\"각 자리수의 합 : \"+sum);    \t\t    \t\tint sum2 = 0;    \t\tfor(num = Integer.parseInt(tmp);num&gt;0;num = num / 10)    \t\t{    \t\t\tsum2 += num%10;    \t\t\tSystem.out.printf(\"sum = %d num = %d%n\",sum2,num);    \t\t}    \t\tSystem.out.println(\"각 자리수의 합 : \"+sum2);    \t}        }  do while : 반복횟수를 알거나 코드가 중복이면 do while문을 사용  do{조건식이 참일 때 수행 될 문장. 처음 한번든 무조건 실행}  while(조건식);    import java.util.*;        public class ex4_15 {        \tpublic static void main(String[] args) {    \t\tint input = 0 , answer = 0;    \t\t    \t\tanswer = (int)(Math.random()*100)+1;    \t\tScanner scanner = new Scanner(System.in);    \t\t    \t\tdo {    \t\t\tSystem.out.println(\"1과 100사이의 정수를 입력하세요.&gt;&gt;\");    \t\t\tinput = scanner.nextInt();    \t\t\t    \t\t\tif (input &gt; answer) {    \t\t\t\tSystem.out.println(\"더 작은 수로 다시 시도하세요.\");    \t\t\t}    \t\t\telse if (input &lt; answer) {    \t\t\t\tSystem.out.println(\"더 큰 수로 다시 시도하세요.\");    \t\t\t}    \t\t} while (input != answer);    \t\t\tSystem.out.println(\"정답입니다!\");    \t\t}    \t}    public class ex4_16 {        \tpublic static void main(String[] args) {    \t\tint i = 0, sum = 0;    \t\t    \t\tdo {    \t\t\t++i;    \t\t\tsum += i;    \t\t} while(sum&lt;100);    \t\tSystem.out.println(\"i=\"+i);    \t\tSystem.out.println(\"sum=\"+sum);    \t}        }    public class ex4_16 {        \tpublic static void main(String[] args) {    \t\tint i = 0, sum = 0;    \t\t    \t\twhile (true) {    \t\t\tif(sum&gt;100)    \t\t\t\tbreak;    \t\t\t++i;    \t\t\tsum += i;    \t\t}    \t\tSystem.out.println(\"i=\"+i);    \t\tSystem.out.println(\"sum=\"+sum);    \t}        }  continue : 조건이 충족된다면 블록의 끝으로 이동, 다시 반복문 수행.public class ex4_17 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;=10;i++) {\t\t\tif(i%2==0)\t\t\t\tcontinue;\t\t\tSystem.out.println(i);\t\t}\t}}  이름붙은 반복문 : 반복문에 이름을 붙여서 break앞에 적어주면 하나이상의 반복문을 벗어날 수 있다Loop1 : for( ......\tfor( ...........\t\t\t\tbreak Loop1;import java.util.*;public class ex4_18 {\tpublic static void main(String[] args) {\t\tint menu = 0;\t\tint num = 0;\t\t\t\tScanner scanner = new Scanner(System.in);\t\t\t\touter : while (true) {\t\t\tSystem.out.println(\"(1) square\");\t\t\tSystem.out.println(\"(2) square root\");\t\t\tSystem.out.println(\"(3) log\");\t\t\tSystem.out.println(\"원하는 메뉴를 입력하세요. (종료 : 0)\");\t\t\t\t\t\tString tmp = scanner.nextLine();\t\t\tmenu = Integer.parseInt(tmp);\t\t\t\t\t\tif(menu == 0) {\t\t\t\tSystem.out.println(\"프로그램을 종료합니다.\");\t\t\t\tbreak;\t\t\t}\t\t\telse if (!(menu&gt;=1 &amp;&amp; menu&lt;=3)) {\t\t\t\tSystem.out.println(\"메뉴를 잘못 선택하셨습니다. (종료는 0)\");\t\t\t\tcontinue;\t\t\t}\t\t\tSystem.out.println(\"선택하신 메뉴는 \"+menu+\"번입니다.\");\t\t\t\t\t\tfor(;;) {\t\t\t\tSystem.out.println(\"계산할 값을 입력하세요.(계산종료 : 0, 전체종료 : 99)&gt;&gt;\");\t\t\t\ttmp = scanner.nextLine();\t\t\t\tnum = Integer.parseInt(tmp);\t\t\t\t\t\t\t\tif(num==0)\t\t\t\t\tbreak;\t\t\t\tif(num==99)\t\t\t\t\tbreak outer;\t\t\t\t\t\t\t\tswitch(menu) {\t\t\t\t\tcase 1:\t\t\t\t\t\tSystem.out.println(\"result=\"+num*num);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 2:\t\t\t\t\t\tSystem.out.println(\"result=\"+Math.sqrt(num)); //제곱근\t\t\t\t\t\tbreak;\t\t\t\t\tcase 3:\t\t\t\t\t\tSystem.out.println(\"result=\"+Math.log(num)); //로그\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t}}"
  },
  
  {
    "title": "연산자(Operator)",
    "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90(Operator)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 연산자",
    "date": "2022-07-30 00:00:00 +0900",
    





    
    "snippet": "연산자 : 연산을 수행하는 기호 (+,-,*,/)피연산자 : 연산자의 수행 대상(x+3에서 x와 3)                                             종류      연산자      설명              산술 연산자      + - * / % ==« »==      사칙연산과 나머지 연산              비교...",
    "content": "연산자 : 연산을 수행하는 기호 (+,-,*,/)피연산자 : 연산자의 수행 대상(x+3에서 x와 3)                                             종류      연산자      설명              산술 연산자      + - * / % ==« »==      사칙연산과 나머지 연산              비교 연산자      &lt; &gt; ≥ ≤ == !=      크고 작음과 같고 다름을 비교              논리 연산자      &amp;&amp; | !(not)      and와 or으로 조건을 연결              대입 연산자      =      우변의 값을 좌변에 저장              기타      (type) ?: instanceof      형변환 연산자, 삼항 연산자, instanceof 연산자        증감 연산자          j = ++i : 값이 참조 되기 전에 증가시 = 일단 i+1하고 i값으로 할거 함      j = i++ : 값이 참조 된 후에 증가시킴 = i값으로 할거 다하고 +1      i++, ++i처럼 독립적으로 쓰였을때는 차이가 없음            형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것.    double d= 85.5; int score = (int)d; //85    ❗반올림 안됨! 그냥 버림!!실수→정수는 모두 그럼          자동 형변환 : 서로 다른 두 타입을 일치시킬깨 형변환을 생략하면 대부분 컴파일러가 알아서 형변환을 자동적으로 한다.                  생략 가능                          float f = 1234; == float f = (float)1234; //컴파일러가 자동으로 형변환. 두개가 같은거임.              byte - int는 int값이 byte타입의 범위 -128~127사이의 값이라면 값 손실이 없기 때문에 예외적으로 가능.  int i = 100; byte b = i ; 는 에러남. 변수값이라 값손실이 없음을 확신할 수 없기 때문.                                생략 불가능                                          int i = 3.14f; //에러남. float가 int보다 크기때문에 값손실이 발생됨.  int i = (int)3.14f로 써줘야함.                                            short - char끼리 자동 형변환 불가능. short가 부호있는 연산자라서. chat - int변환은 가능                                                              산술 변환 : 연산 전에 피연산자의 자동으로 타입을 일치시키는 것.          두 피연산자의 타입을 큰 타입으로 일치시킴              int보다 작은 타입이면 int로 변환된다.  byte + short = int / char + short = int        ‘2’ - ‘0’ = 2 (문자 2의 코드가 50이고 문자 0의 코드가 48이라서. 문자코드가 순서대로 1씩 증가해서 문자끼리 식은 일반 식과 결과값이 같음 )                public class ScanfEx1 {  \tpublic static void main(String[] args) {  \t\tint a = 1_000_000;  \t\tint b = 2_000_000;    \t\t  \t\tlong c = (long)a*b;  \t\tSystem.out.println(c);  \t}  }            반올림 - Math.round - 실수를 소수 첫째 자리에서 반올림  Math.round(4.52) = 5  —n의 자리까지 반올림을 해주려면?    Math.round(Math.PI*1000.0)/1000.0); → 3.142 이렇게 10의 n제곱을 곱하고 나눠줌    equals();String str1 = \"abc\";String str2 = \"abc\";system.out.println(str1==str삼2); //값의 위치가 같음String str3 = new String(\"abc\");String str4 = new String(\"abc\");system.out.println(str3.equals(str4); //인스턴스라서 값을 복제해와서 값의 위치가 다름!!      조건 연산자 ? : 조건식의 결과에 따라 연산결과를 달리한다.    조건식 ? 식1 : 식2 //조건식이 참이면 식1 거짓이면 식2    result = (x&gt;y) ? x : y ; //괄호 생략가능    if문을 간단하게 쓸 수 있는 장점이 있음!!        대입 연산자          lvalue : 왼쪽 피연산자, 저장공간 3, i+3같은 값이 오거나 final을 붙여 상수가 되면 에러남      rvalue : 오른쪽 피연산자      !(not)은 가독성에 안좋으니 가급적 쓰지말것 쓸거면 처음부터 쓰기. 중간부터 쓰면 알아보기 힘들어짐"
  },
  
  {
    "title": "자바의 정석 강의 - 변수(Variable)",
    "url": "/posts/%EB%B3%80%EC%88%98(Variable)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석, 변수",
    "date": "2022-07-29 06:27:00 +0900",
    





    
    "snippet": "  system.out.println(); 에서 print==ln==이 \\n이거라서 따로 \\n안해줘도 지금까지 줄바꿈이 됐던거임..! 충격! pintf도 있다..!      public class Ex2_1 {      \tpublic static void main(String[] args) {  \t\tSystem.out.printf(\"hello\");  ...",
    "content": "  system.out.println(); 에서 print==ln==이 \\n이거라서 따로 \\n안해줘도 지금까지 줄바꿈이 됐던거임..! 충격! pintf도 있다..!      public class Ex2_1 {      \tpublic static void main(String[] args) {  \t\tSystem.out.printf(\"hello\");  \t\tSystem.out.printf(\"hello\");  \t\tSystem.out.printf(\"hello\");  \t}      }        이거는 줄바꿈 안되고 hellohellohello로 실행됨. print로 바꿔도 마찬가지    변수(variable) : 하나의 값을 저장할 수 있는 메모리 공간(RAM). 변경가능  — 변수 선언 이유 : 값(data)를 저장할 수 있는 공간을 마련하기 위해.      변수타입 변수이름; ex)int age;                  =는 등호가 아니라 대입. 그래서 if문에서는 == 를 썼구나  int x=0; 변수 x를 선언 후 0으로 초기화  int y=5; 변수 y를 선언 후 5로 초기화        ❗지역변수는 읽기전에 꼭 초기화를 해주어야 함            변수 타입                  기본형(Primitive type) - 8개                          정수 :                                  int                  byte : 0~127, 이진데이터를 다루는데 사용                  short : c언어와의 호환을 위해 사용. 잘안쓰임                  long : int에 못넣는 20억이 넘는 값을 넣음                                            문자 : char (한글자) - 빈문자(’’;)불가능              문자열 : String (여러글자) -                                                      빈문자(””;) 가능  ⇒ “”+7 = “7” : 숫자 7이 문자열로 변환됨.  ex) “”+7+7 = “7”+7→”7”+”7”⇒ “77”  7+7+”” = 14+””→”14”+””⇒”14”                                                        class이나 너무 자주 쓰여서 String s1 = “ab”; 로 사용가능                                                              실수 (소수점) : double, float              논리(boolean) : true, false. 조선식과 논리적 계산에 사용                                                                        종류/크기                  1byte                  2byte                  4byte                  8byte                                                                              논리형                  boolean                                                                                                           문자형                                     char                                                                                        정수형                  byte                  short                  int                  long                                                  실수형                                                        float                  double                                                      n비트로 표현할 수 있는 값의 개수 : 2의 n제곱            n비트로 표현할 수 있는 부호없는 정수의 범위 : 0~2의n제곱-1            n비트로 표현할 수 있는 부호있는 정수의 범위 : -2의 n-1제곱 ~2의 n-1제곱-1                          부호비트 (sign bit)                                                      byte = -2의 7제곱~ 2의 7제곱 -1 =                                                                                            0                          7bit                                                                                      부호비트가 0이니까 양수                                                                                            1                          7bit                                                                                      부호비트가 1이니까 음수                                                        short = -2의 15제곱~ 2의 15제곱 -1 =                                                                                            s                          15bit                                                                                                                          char = 0~2의 16제곱 -1 (2진수로 변환)                                                                                            16bit                          160000000001000001                                                                                                                          int = -2의 31제곱~ 2의 31제곱 -1 = -20억~20억                                                                                            s                          31bit                                                                                                                          int = -2의 63제곱~ 2의 63제곱 -1 = -800경 ~ 800경                                                                                            s                          63bit                                                                                      혹시 부족하면 Big integer사용                                                        float = 1+8+23 = 32bit = 4byte = -1.410의 -45제곱~1.410의 -45제곱                                                                                            S                          E(8)                          M(23)                                                                                      정밀도 : 7자리                                                        double = 1+11+52 = 64bit = 8byte = -3.410의 38제곱~3.410의 38제곱                                                                                            S                          E(11)                          M(50)                                                                                      정밀도 : 15자리 (float보다 정확함)                                                                                            참조형(Reference type) : 기본형을 제외한 나머지. 무한개                          메모리주소를 저장. (4byte[40억] or 8 byte[160억])                        ex) today = new Date(); - 참조형 변수 today에 객체의 주소를 저장                              리터럴 (literal) : 그 자체로 값을 의미. 기존의 상수.                              리터럴 타입과 접미사                                                            종류                  리터럴                  접미사                                                                              논리형                  false, true                  없음                                                  정수형                  int - 123, Ob0101, 077, 0xFF,  Long - 100L                  L                                                  실수형                  3.14, 3.0e8, 1.4f, 0x1.0p-1                  f(float),  d(double, 생략가능)                                                  문자형                  ‘A’, ‘1’, ’\\n’                  없음                                                  문자열                  “ABC”, “123”, “A”, “true”                  없음                                                      정수형, 실수형은 접미사로 구분함.                                          int oct = 010;            \t\tint hex = 0x10;            \t\t            \t\tSystem.out.println(oct);            \t\tSystem.out.println(hex);            // println을 쓰면 8진수와 16진수를 표현못해서 8과 16이 나옴.            // printf를 쓰면 가능  10진수 : int i = 100;  8진수 : int i = 0100;  16진수 : int i = 0x100;  long i = 10_000_000_000L ⇒ 100억. int가 20억까지 가능함. 꼭 L붙일것.  1e3 = 여기서 e가 10의 n제곱임. = 1000.0 (접미사 없으니 double형)  int i = ‘A’; ⇒ A의 문자열코드인 65가 출력됨  상수(constant) : 한 번만 값을 저장 가능한 변수. 변경 불가능. 앞에 final을 붙이면 됨.ex) final int MAX = 100;MAX = 200;(에러남)&lt;/mark&gt;\tint score = 100;\tscore = 200;\tfinal int MAX = 100;\tchar ch = 'a';\tString str = \"abc\";— 변수와 리터럴 타입 불일치  범위가 변수&gt;리터럴 인 경우 가능함          int &gt; char / long &gt; int / double &gt; float        범위가 변수 &lt; 리터럴 인 경우 에러남          long i = 3.14f - long&lt;float이라 에러      float f = 3.14 (접미사 생략됐으니 double형) 에러. float &lt; double  double d = 3.14f ⇒ 가능      byte, short변수에 int 리터럴 사용 가능        두 변수 값 교환하는 법      int x = 10, y = 20;  int tmp;//빈공간  x=tmp;  x=y;  y=tmp;      pritnln 단점  출력형식 지정 불가 (ex.소수점 자리지정 불가)  10진수로만 출력됨⇒ printf를 사용하면 가능해짐            지시자      설명                  %b      boolean 형식으로 출력              %d      10진 정수의 형식으로 출력              %o      8진 정수의 형식으로 출력  #을 붙여야 접두사도 출력됨              %x, %X      16진 정수의 형식으로 출력  #을 붙여야 접두사도 출력됨              %f      부동 소수점의 형식으로 출력  %g를 사용하면 간략하게 출력              %e, %E (1.234e+02)      지수 표현식의 형식으로 출력              %c      문자로 출력              %s      문자열로 출력      ❗\\n, %n 둘다 줄바꿈이나 %n을 자주 사용할 것.      지시자    system.out.printf(”[%5d]%n”, 10); // [ 10] - 5자리 출력    system.out.printf(”[%-5d]%n”, 10); // [10 ] - 5자리 출력, 왼쪽정렬    system.out.printf(”[%05d]%n”, 10); // [00010] - 5자리 출력(숫자, 문자열 다 됨)    system.out.printf(”[%5d]%n”, 1234567); // [1234567] - 7자리 출력    system.out.printf(“[%14.10f]%n”, 1.23456789); // [ 1.2345678900]   (전체자리 14자리에서 소수점 10자리 출력)  화면으로 입력받기부터 - Scanner : 화면으로부터 데이터를 입력받는 class  import문 필수 - import java.util.*;  Scanner 객체의 생성 Scanner scanner = new Scanner system.in;  Scanner 객체의 사용          int num = scanner.nextInt(); //화면에서 입력받은 정수를 num에 저장      String input = scanner.nextLine(); //화면에서 입력받은 내용을 input에 저장  int num = Integer.parseInt(input); //문자열(input)을 숫자(num)으로 전환                  숫자 → 문자열 = 숫자 + “”          문자열 → 숫자 = Integer.parseInt(”문자열”)  — 한 문장에 여러 값을 받을경우 필요함                    \timport java.util.*;\t\tpublic class ScanfEx1 {\t\t\tpublic static void main(String[] args) {\t\t\t\t//정수\t\t\tScanner scanner = new Scanner(System.in);\t\t\tint num = scanner.nextInt();\t\t\tSystem.out.println(num);\t\t\t\t\t\t//문자열\t\t\tScanner scanner2 = new Scanner(System.in);\t\t\tString input = scanner2.nextLine();\t\t\tSystem.out.println(input);\t\t\t\t\t\t//문자열 -&gt; 숫자\t\t\tScanner scanner3 = new Scanner(System.in);\t\t\tString input2 = scanner3.nextLine();\t\t\tint num2 = Integer.parseInt(input2);\t\t\tSystem.out.println(input2);\t\t}\t}❗Scanner밑에 밑줄은 입출력 관련 객체들은 원칙적으로 반드시 닫아주어야함. 하지만 화면입력같은경우에는 자바 버추얼머신에서 기본적으로 관리가 되기때문에 닫아주지 않아도 됨. 오류는 무시할 것.오버플로우 : 표현할 수 있는 범위를 넘어섰다.최대값 + 1 = 최소값최소값 - 1 = 최대값10진수 :9999→0000 (칸이 4칸이라서)부호없는 정수 : ex) 4bit (표현범위0~15)15(최대값) + 1 → 0(최소값)2진수 : 1111→0000부호있는 정수 : ex) 4bit (표현범위-8~7)7(최대값)+1 → -8(최소값)부호 없는 정수 : 부호 +나-가 존재하지 않는 숫자 세계를 나타냄.(0이하의 음수를 표현x)부호 있는 정수 : 양수타입간의 변환 방법 - 외우지는 못해도 필요할때 찾아볼 수 있는 정도는 돼야함  문자 → 숫자 = 3 - ’0’  숫자 → 문자 = 3 + ’0’  문자→ 문자열 = ‘3’ + “”  문자열 → 문자 = “3”.charAt(0)  숫자 → 문자열 = 3 + ””  문자열 → 숫자  = Integer.parseInt(”3”)  = Double.parseDouble(”3.4”)\timport java.util.*;\t\tpublic class ScanfEx1 {\t\t\tpublic static void main(String[] args) {\t\t\tString str = \"3\";\t\t\tSystem.out.println(str.charAt(0)); //문자열 -&gt; 문자\t\t\tSystem.out.println('3' - '0' + 1); //문자-&gt;숫자\t\t\tSystem.out.println(Integer.parseInt(\"3\")+1); //문자열 -&gt; 숫자\t\t\tSystem.out.println(\"3\"+1); //문자열+숫자 =&gt; 31\t\t\tSystem.out.println(3+'0'); //문자 0은 숫자로 48 =&gt; 51\t\t\tSystem.out.println((char)(3+'0')); // 문자 '3' 출력\t\t}\t}printf사용시 %#x는 접두사 0x가 붙음"
  },
  
  {
    "title": "자바의 정석 강의 - 자바 시작하기 전",
    "url": "/posts/%EC%9E%90%EB%B0%94-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-07-28 21:27:00 +0900",
    





    
    "snippet": "  자바 : 프로그래밍 언어. 컴퓨터 프로그램(애플리케이션)을 만드는데 사용  실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)                  라이브러리 : 프로그램을 만드는데 필요한 기능들을 미리 만들어놓은 것.        ⇒ 쉽고 빠른 개발 가능            pc애플리케이션, 웹 애플리케이션, 모바일 애플리케이...",
    "content": "  자바 : 프로그래밍 언어. 컴퓨터 프로그램(애플리케이션)을 만드는데 사용  실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)                  라이브러리 : 프로그램을 만드는데 필요한 기능들을 미리 만들어놓은 것.        ⇒ 쉽고 빠른 개발 가능            pc애플리케이션, 웹 애플리케이션, 모바일 애플리케이션(안드로이드), 빅 데이터, 게임(ex.마크), 과학, 소형기기 등 에 활용 가능      모던 프로그래밍 언어(객체지향 + 함수형)      특징                  배우기쉬운 객체지향언어(프로그래밍언어+객체지향개념[c++,java,python])          자동 메모리 관리          멀티 쓰레드 지원 - 하나의 프로그램에서 동시에 여러작업 가능.          풍부한 라이브러리로 쉽게 개발가능.          운영체제에 독립적 - 수정없이 여러 운영체제에서 사용가능                          자바 가상 머신(JVM) : 자바 프로그램이 실행되는 가상 컴퓨터(VM). 한번 작성하면, 어디서든(어떤 운영체제에서도) 실행 가능.                                            java API문서 : java API가 제공하는 기능에 대한 상세한 정보를 제공(html)  https://docs.oracle.com/javase/7/docs/api/index.html      단축키          ctrl + shift + L : 단축키 전체 목록      alt + shift + A : 멀티컬럼 편집 - 커서가 +모양으로 바뀌는데 바꾸고 싶은 부분을 드래그해서 한번에 바꿈      ctrl + i : 자동들여쓰기      ctrl + shift + o : import java.util.~; 자동추가      "
  }
  
]

