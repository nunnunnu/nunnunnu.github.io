[
  
  {
    "title": "날짜와 시간 & 형식화",
    "url": "/posts/%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84-&-%ED%98%95%EC%8B%9D%ED%99%94/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-21 00:00:00 +0900",
    





    
    "snippet": "날짜와 시간      java.util.Date : 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)  date의 메소드는 거의 사용되지 않지만(deprecated), 여전히 쓰이고 잇다.    java.util.Calendar :Date클래스를 개선한 새로운 클래스(JDK1.1), 여전히 단점이 있다 (실무에는 아직 쓰이는 곳이 많음    ...",
    "content": "날짜와 시간      java.util.Date : 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)  date의 메소드는 거의 사용되지 않지만(deprecated), 여전히 쓰이고 잇다.    java.util.Calendar :Date클래스를 개선한 새로운 클래스(JDK1.1), 여전히 단점이 있다 (실무에는 아직 쓰이는 곳이 많음          날짜와 시간을 같이 다루는 것이 단점        java.time 패키지 : Date와 Calendar의 단점을 개선한 새로운 클래스들을 제공(JDK1.8=JDK8)          날짜와 시간의 클래스를 나누어 놓음(LocalDate, LocalTime, LocalDateTime)      Calender클래스추상클래스. getinstace()를 통해 구현된 객체를 얻어야 한다.Calendar cal = new Calendar.getInstance(); //사용자 시스템에 기반해서 서양력, 불교력, 일본력 중 하나를 가져온다. (달력을 지정하는것 보다 애매하게 쓰는게 나중에 달력변경 시 조금만 수정해도 사용할 수 있음 - 추상화 )  get()으로 날짜와 시간 가져오기 - int ger(int field)import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar cal = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tint thisYear = cal.get(Calendar.YEAR); //현재 몇년도인지\t\tint lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);//이달의 마지막 날\t\tSystem.out.println(lastDayOfMonth);\t\t}}            필드명      설명                  YEAR      년              MONTH      월(0부터 시작)              WEEK_OF_MONTH      그 달의 몇 번째 주              WEEK_OF_YEAR      그 해의 몇 번째 주              DATE      일              DAY_OF_MONTH      그 달의 몇 번째 일              DAY_OF_YEAR      그 해의 몇 번째 일              DAY_OF_WEEK      요일              DAY_OF_WEEK_IN_MONTH      그 달의 몇 번째 요일              HOUR      시간(0~11)              HOUR_OF_DAY      시간(0~23)              MINUTE      분              SECOND      초              MILLISECOND      천분의 1초              ZONE_OFFSET      GMT기준 시차(천분의 1초단위)  (한국은 GMT시간보다 9시간빨라서 9로 표시)              AM_PM      오전/오후      import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar cal = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tint thisYear = cal.get(Calendar.YEAR); //현재 몇년도인지\t\tint lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);//이달의 마지막 날\t\tSystem.out.println(lastDayOfMonth);\t\tSystem.out.println(cal.get(Calendar.DAY_OF_WEEK_IN_MONTH));\t\tSystem.out.println(cal.get(Calendar.MONTH)); //0부터시작해서 7나옴 8월임\t\tSystem.out.println(cal.get(Calendar.WEEK_OF_YEAR)); //0부터시작해서 7나옴 8월임\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar today = Calendar.getInstance(); //현재 시간과 날짜로 세팅\t\tSystem.out.println(\"이 해의 연도 : \"+today.get(Calendar.YEAR));\t\tSystem.out.println(\"월(0~11, 0:1월) : \"+today.get(Calendar.MONTH));\t\tSystem.out.println(\"이 해의 몇 째 주 : \"+today.get(Calendar.WEEK_OF_YEAR));\t\tSystem.out.println(\"이 달의 몇 째 주 : \"+today.get(Calendar.WEEK_OF_MONTH));\t\t\t//DATE와 DAY_OF_MONTH는 같다\t\tSystem.out.println(\"이 달의 며칠 : \"+today.get(Calendar.DATE));\t\tSystem.out.println(\"이 달의 며칠 : \"+today.get(Calendar.DAY_OF_MONTH));\t\tSystem.out.println(\"이 해의 며칠 : \"+today.get(Calendar.DAY_OF_YEAR));\t\tSystem.out.println(\"요일(1~7, 1은 일요일) : \"+today.get(Calendar.DAY_OF_WEEK));\t\tSystem.out.println(\"이 달의 몇 째 요일 : \"+today.get(Calendar.DAY_OF_WEEK_IN_MONTH));\t\tSystem.out.println(\"오전/오후(0:오전,1:오후) : \"+today.get(Calendar.AM_PM));\t\tSystem.out.println(\"시간(0~11) : \"+today.get(Calendar.HOUR));\t\tSystem.out.println(\"시간(0~23) : \"+today.get(Calendar.HOUR_OF_DAY));\t\tSystem.out.println(\"분(0~59) : \"+today.get(Calendar.MINUTE));\t\tSystem.out.println(\"초(0~59) : \"+today.get(Calendar.SECOND));\t\tSystem.out.println(\"1000분의 1초(0~999) : \"+today.get(Calendar.MILLISECOND));\t\t//천분의 1초를 시간으로 표시하기 위해 360000으로 나눔(1시간 = 60*60초)\t\tSystem.out.println(\"TimeZone : \"+today.get(Calendar.ZONE_OFFSET/(60*60/1000)));\t\tSystem.out.println(\"이 달의 마지막 날 : \"+today.getActualMaximum(Calendar.DATE));\t}}  set()으로 날짜와 시간 지정하기datel = Calendar.getInstance();//\t\tdatel.set(Calendar.YEAR, 2022);//\t\tdatel.set(Calendar.MONTH, 10); //11월//\t\tdatel.set(Calendar.DATE, 20);\t\tdatel.set(2022,10,20); //2022년 11월 20일\t\t\t\tCalendar timel = Calendar.getInstance();//\t\tdatel.set(Calendar.HOUR_OF_DAY, 10); //10시//\t\tdatel.set(Calendar.MINUTE, 20); //20분 //\t\tdatel.set(Calendar.SECOND, 30); //30초\t\ttimel.set(10,20,30); //10시import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\t//요일 숫자-&gt;문자열로 바꾸어 표시\t\tfinal String[] DAY_OF_WEEK = {\"\",\"일\",\"월\",\"화\",\"수\",\"목\",\"금\",\"토\",\"일\"};\t\tCalendar date1 = Calendar.getInstance();\t\tCalendar date2 = Calendar.getInstance();\t\t\t\t//month의 경우 0부터 시작하기 때문에 4월인경우 3으로 지정\t\tdate1.set(2022, 3,29);//2022년 4월 29일\t\tSystem.out.println(\"date1은 \" +toString(date1)+DAY_OF_WEEK[date1.get(Calendar.DAY_OF_WEEK)]+\"요일이고, \");\t\tSystem.out.println(\"date2는 \" +toString(date2)+DAY_OF_WEEK[date2.get(Calendar.DAY_OF_WEEK)]+\"요일입니다.\");\t\t//두 날짜간의 차이를 얻으려면, gerTimeInMillis()-날짜,시간을 초단위로 바꿔줌[/1000해줘야함]- 천분의 일초단위로 변환\tlong difference = (date2.getTimeInMillis() - date1.getTimeInMillis())/1000;\tSystem.out.println(\"date1부터 date2까지 \"+difference+\"초가 지났습니다.\");\tSystem.out.println(\"일(day)로 계산하면 \"+difference/(24*60*60)+\"일입니다\");\t//1일 = 24*60*60\t}\tpublic static String toString(Calendar date) {\t\treturn date.get(Calendar.YEAR)+\"년 \"+(date.get(Calendar.MONTH)+1)+\"월 \"+date.get(Calendar.DATE)+\"일\";\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tfinal int[] TIME_UNIT = {3600,60,1};\t\tfinal String[] TIME_UNIT_NAME= {\"시간\",\"분\",\"초\"};\t\tCalendar time1 = Calendar.getInstance();\t\tCalendar time2 = Calendar.getInstance();\t\t\t\ttime1.set(Calendar.HOUR_OF_DAY,10);\t\ttime1.set(Calendar.MINUTE,20);\t\ttime1.set(Calendar.SECOND,30);\t\ttime2.set(Calendar.HOUR_OF_DAY,20);\t\ttime2.set(Calendar.MINUTE,30);\t\ttime2.set(Calendar.SECOND,10);\t\t\t\tSystem.out.println(\"time1 : \"+time1.get(Calendar.HOUR_OF_DAY)+\"시 \"+time1.get(Calendar.MINUTE)+\"분 \"+time1.get(Calendar.SECOND)+\"초\");\t\tSystem.out.println(\"time2 : \"+time2.get(Calendar.HOUR_OF_DAY)+\"시 \"+time2.get(Calendar.MINUTE)+\"분 \"+time2.get(Calendar.SECOND)+\"초\");\t\t\t\t//Math.abs:절대값\t\tlong different = Math.abs(time2.getTimeInMillis()-time1.getTimeInMillis())/1000;\t\tSystem.out.println(\"time1과 time2의 차이는 \"+different+\"초 입니다\");\t\t\t\tString tmp=\"\";\t\tfor(int i=0;i&lt;TIME_UNIT.length;i++) {\t\t\ttmp += different/TIME_UNIT[i]+TIME_UNIT_NAME[i];\t\t\tdifferent %= TIME_UNIT[i];\t\t}\t\tSystem.out.println(\"시분초로 변환하면 \"+tmp+\"입니다.\");\t}}  clear()는 Calendar객체의 모든 필드를 초기화 → 1970년 1월 1일 00:00:00으로 초기화  clear(int field)는 Calendar객체의 특정 필드를 초기화 → 0초 or 0분 or …import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tSystem.out.println(getDaydiff(\"20010103\",\"20010101\")); //2\t\tSystem.out.println(getDaydiff(\"20010103\",\"20010103\")); //0\t\tSystem.out.println(getDaydiff(\"20010103\",\"200103\")); //형식안맞음.\t}\tpublic static int getDaydiff(String yyyymmdd1, String yyyymmdd2) {\t\tint diff=0;\t\ttry{\t\tint year1 = Integer.parseInt(yyyymmdd1.substring(0,4));\t\tint month1 = Integer.parseInt(yyyymmdd1.substring(4,6));\t\tint day1 = Integer.parseInt(yyyymmdd1.substring(6,8));\t\tint year2 = Integer.parseInt(yyyymmdd2.substring(0,4));\t\tint month2 = Integer.parseInt(yyyymmdd2.substring(4,6));\t\tint day2 = Integer.parseInt(yyyymmdd2.substring(6,8));\t\t\t\tCalendar date1 = Calendar.getInstance();\t\tCalendar date2 = Calendar.getInstance();\t\t//date1, date2사이의 약간의(0.000...초 정도)차이 발생//\t\tSystem.out.println(\"date1 : \"+date1);//\t\tSystem.out.println(\"date2 : \"+date2);\t\t//time세팅을 clear해줘야함\t\tdate1.clear();\t\tdate2.clear();\t\tdate1.set(year1, month1,day1);\t\tdate2.set(year2, month2,day2);\t\tdiff=(int)((date1.getTimeInMillis()-date2.getTimeInMillis())/(24*60*60*1000));\t\t} catch(Exception e) {\t\t\tdiff = 0;//substring, parseInt에서 예외 발생시\t\t}\t\treturn diff;\t}}            add()는 특정 필드의 값을 증가 또는 감소(다른 필드에 영향o)      8월 31일에서 일에 +1하면 월도 +1됨                  roll()은 특정 필드의 값을 증가 또는 감소(다른 필드에 영향x)      8월 31일에서 일에 +1해도 월은 그대로임      import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {\t\tCalendar date = Calendar.getInstance();\t\tdate.set(2022, 7,31);\t\t\t\tSystem.out.println(toString(date)); //8/31\t\tSystem.out.println(\"1일 후\");\t\tdate.add(Calendar.DATE, 1);\t\tSystem.out.println(toString(date)); //9/1\t\tSystem.out.println();\t\tSystem.out.println(\"6달 전\");\t\tdate.add(Calendar.MONTH, -6);\t\tSystem.out.println(toString(date));//3/1\t\tSystem.out.println();\t\tSystem.out.println(\"31일 후(roll)\"); //다른필드(월)에 영향x\t\tdate.roll(Calendar.DATE,31);\t\tSystem.out.println(toString(date)); //3/1\t\tSystem.out.println();\t\tSystem.out.println(\"31일 후(add)\");\t\tdate.add(Calendar.DATE,31);\t\tSystem.out.println(toString(date)); //4/1\t}\tpublic static String toString(Calendar date) {\t\treturn date.get(Calendar.YEAR)+\"년 \"+(date.get(Calendar.MONTH)+1)+\"월 \"+date.get(Calendar.DATE)+\"일\";\t}}import java.util.Calendar;public class  Main {\tpublic static void main(String[] args) {//달력찍기\t\tif(args.length !=2) {\t\t\tSystem.out.println(\"usage : java Ex10\");\t\t\treturn;\t\t}\t\tint year = Integer.parseInt(args[0]);\t\tint month = Integer.parseInt(args[1]);\t\tint START_DAY_OF_WEEK = 0;\t\tint END_DAY_OF_WEEK = 0;\t\t\t\tCalendar sDay = Calendar.getInstance();//시작일\t\tCalendar eDay = Calendar.getInstance();//끝일\t\t\t\t//월의 경우 -1해줘야함 (0~11)\t\tsDay.set(year,month-1,1);\t\teDay.set(year,month,1);\t\t\t\t//다음 달 첫날에서 하루를 빼면 현재달의 마치막 날이 출력\t\teDay.add(Calendar.DATE, -1);\t\t\t\t//첫번째요일이 무슨 요일인지\t\tSTART_DAY_OF_WEEK = sDay.get(Calendar.DAY_OF_WEEK);\t\t\t\t//eDay의 지정된 날짜\t\tEND_DAY_OF_WEEK=eDay.get(Calendar.DATE);\t\t\t\tSystem.out.println(\"       \"+args[0]+\"년 \"+args[1]+\"일\");\t\tSystem.out.println(\" SU MO TU WE TH FR SA\");\t\t\t\t//해당 월의 1일이 어느 요일인지에 따라서 공백을 출력(일요일부터 시작)\t\tfor(int i=1;i&lt;START_DAY_OF_WEEK;i++) {\t\t\tSystem.out.print(\"   \");\t\t}\t\tfor(int i = 1, n=START_DAY_OF_WEEK;i&lt;=END_DAY_OF_WEEK;i++,n++) {\t\t\tSystem.out.print((i&lt;10)?\"  \"+i:\" \"+i);\t\t\tif(n%7==0) System.out.println();\t\t}\t}}      Date와 Calendar간의 변환          Date의 메소드는 대부분 deprecated되었지만 여전히 사용됨(하위호환성-옛날 기능도 계속 지원해주려고 신경씀)          import java.util.Calendar;      public class  Main {  \tpublic static void main(String[] args) {  \t\t//Calendar-&gt;Date  \t\tCalendar cal = Calendar.getInstance();  \t\tDate d = new Date(cal.getTimeInMillis()); //Date(long date)    \t\t  \t\t//Date -&gt; Calendar  \t\tDate d = new Date();  \t\tCalendar cal = Calendar.getInstance();  \t\tcal.setTime(d);  \t}  }      형식화클래스: java.text 패키지의 DecimalFormat(10진수숫자형식) SimpleDateFormat(날짜형식화)  숫자와 날짜를 원하는 형식으로 쉽게 출력 가능 (숫자, 날짜 → 형식문자열)import java.text.DecimalFormat;public class  Main {\tpublic static void main(String[] args) {\t\tdouble num = 1234567.89;\t\tDecimalFormat df = new DecimalFormat(\"#.\\#E0\"); //지수형식 \t\tSystem.out.println(df); //java.text.DecimalFormat@5c8\t\tString result = df.format(num);\t\tSystem.out.println(result); //1.2E6\t}}  형식 문자열에서 숫자와 날짜를 뽑아내는 기능(형식문자열→숫자, 날짜)import java.text.DecimalFormat;import java.text.ParseException;public class  Main {\tpublic static void main(String[] args) throws ParseException {\t\tDecimalFormat df = new DecimalFormat(\"#,###.##\"); //지수형식 \t\tNumber num = df.parse(\"1,234,567.89\");\t\tdouble d = num.doubleValue();\t\tSystem.out.println(d); //1234567.89\t}}      DecimalFormat                  숫자를 형식화 할때 사용(숫자 → 형식문자열)                            특정 형식의 문자열을 숫자로 변환할 때도 사용(형식 문자열→숫자)          import java.text.DecimalFormat;          public class  Main {  \tpublic static void main(String[] args) {  \t\tdouble num = 1234567.89;  \t\tString[] pattern = {  \t\t\t\t\"0\",  \t\t\t\t\"#\",  \t\t\t\t\"0.0\",  \t\t\t\t\"#.#\",  \t\t\t\t\"0000000000.0000\",  \t\t\t\t\"##########.####\",  \t\t\t\t\"#.\\#-\",  \t\t\t\t\"-#.#\",  \t\t\t\t\"#,###.##\",  \t\t\t\t\"#,####.##\",  \t\t\t\t\"\\#E0\",  \t\t\t\t\"0E0\",  \t\t\t\t\"#\\#E0\",  \t\t\t\t\"00E0\",  \t\t\t\t\"###\\#E0\",  \t\t\t\t\"0000E0\",  \t\t\t\t\"#.\\#E0\",  \t\t\t\t\"0.0E0\",  \t\t\t\t\"0.000000000E0\",  \t\t\t\t\"00.00000000E0\",  \t\t\t\t\"000.0000000E0\",  \t\t\t\t\"#.########\\#E0\",  \t\t\t\t\"##.#######\\#E0\",  \t\t\t\t\"###.######\\#E0\",  \t\t\t\t\"#,###.##+;\\#m###.#\\#-\",  \t\t\t\t\"#.#%\",  \t\t\t\t\"#,#\\u2030\",  \t\t\t\t\"\\u00A4 #,####\",  \t\t\t\t\"'#'#,###\",  \t\t\t\t\"''#,###\",  \t\t};  \t\tfor(int i=0;i&lt;pattern.length;i++) {  \t\t\tDecimalFormat df = new DecimalFormat(pattern[i]);  \t\t\tSystem.out.printf(\"%19s : %s\\n\",pattern[i],df.format(num));  \t\t}  \t}  }  /*  0 : 1234568  # : 1234568  0.0 : 1234567.9  #.# : 1234567.9  0000000000.0000 : 0001234567.8900  ##########.#### : 1234567.89  #.\\#- : 1234567.9-  -#.# : -1234567.9  #,###.## : 1,234,567.89  #,####.## : 123,4567.89  \\#E0 : .1E7  0E0 : 1E6  #\\#E0 : 1.2E6  00E0 : 12E5  ###\\#E0 : 123.5E4  0000E0 : 1235E3  #.\\#E0 : 1.2E6  0.0E0 : 1.2E6  0.000000000E0 : 1.234567890E6  00.00000000E0 : 12.34567890E5  000.0000000E0 : 123.4567890E4  #.########\\#E0 : 1.23456789E6  ##.#######\\#E0 : 1.23456789E6  ###.######\\#E0 : 1.23456789E6  #,###.##+;\\#m###.#\\#- : 1,234,567.89+  #.#% : 123456789%  #,#‰ : 1,2,3,4,5,6,7,8,9,0‰  ¤ #,#### : ? 123,4568  '#'#,### : \\#1,234,568  ''#,### : '1,234,568  */                      ⚠️ Integer,parseInt는 콤마(,)가 포함된 문자열을 숫자로 변환 못함      import java.text.DecimalFormat;      public class  Main {  \tpublic static void main(String[] args) {  \t\tDecimalFormat df = new DecimalFormat(\"#,###.#\");  \t\tDecimalFormat df2 = new DecimalFormat(\"#.##\\#E0\");    \t\t  \t\ttry {  //\t\t\tSystem.out.println(Double.parseDouble(\"1,234,567.89\")); //콤마때매 변환 불가로 에러  \t\t\tSystem.out.println(Double.parseDouble(\"1234567.89\"));   \t\t\tNumber num = df.parse(\"1,2 34,567.89\");  \t\t\tSystem.out.print(\"1,234,567.89\"+\" -&gt; \");    \t\t\t  \t\t\tdouble d = num.doubleValue();  \t\t\tSystem.out.print(d+\" -&gt; \"); //1234567.89    \t\t\t  \t\t\tSystem.out.println(df2.format(num)); //1.235E6  \t\t} catch(Exception e) {  \t\t}  \t}  }            SimpleDateFormat          날짜와 시간을 다양한 형식으로 출력할 수 있게 해줌          import java.text.SimpleDateFormat;  import java.util.Date;      public class  Main {  \tpublic static void main(String[] args) {  \t\tDate today = new Date();  \t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");//소문자 mm은 분이 출력    \t\t  \t\tString result = df.format(today);  \t\tSystem.out.println(result);  \t}  }              특정 형식으로 된 문자열에서 날짜와 시간 뽑아내기          import java.text.DateFormat;  import java.text.ParseException;  import java.text.SimpleDateFormat;  import java.util.Date;      public class  Main {  \tpublic static void main(String[] args) throws ParseException {  \t\tDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");  \t\tDateFormat df2 = new SimpleDateFormat(\"yyyy/MM/dd\");    \t\t  \t\tDate d = df.parse(\"2015년 11월 23일\"); //문자열에서 날짜 뽑기  \t\tString result = df2.format(d); //뽑은 날자 문자열로 바꾸기  \t\tSystem.out.println(result); //2015/11/23    \t\t  \t}  }      월은 MM으로import java.text.SimpleDateFormat;import java.util.Date;public class  Main {\tpublic static void main(String[] args) {\t\tDate today = new Date();\t\t\t\tSimpleDateFormat sdf1, sdf2,sdf3,sdf4;\t\tSimpleDateFormat sdf5, sdf6,sdf7,sdf8,sdf9;\t\t\t\tsdf1=new SimpleDateFormat(\"yyyy-MM-dd\");\t\tsdf2=new SimpleDateFormat(\"''yy년 MMM dd일 E요일\");\t\tsdf3=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\t\tsdf4=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss a\");\t\t\t\tsdf5=new SimpleDateFormat(\"오늘은 올 해의 D번째 날입니다\");\t\tsdf6=new SimpleDateFormat(\"오늘은 이 달의 d번째 날입니다\");\t\tsdf7=new SimpleDateFormat(\"오늘은 올 해의 w번째 주입니다\");\t\tsdf8=new SimpleDateFormat(\"오늘은 이 달의 W번째 날입니다\");\t\tsdf9=new SimpleDateFormat(\"오늘은 이 달의 F번째 E요일입니다\");\t\t\t\tSystem.out.println(sdf1.format(today));\t\tSystem.out.println(sdf2.format(today));\t\tSystem.out.println(sdf3.format(today));\t\tSystem.out.println(sdf4.format(today));\t\tSystem.out.println(sdf5.format(today));\t\tSystem.out.println(sdf6.format(today));\t\tSystem.out.println(sdf7.format(today));\t\tSystem.out.println(sdf8.format(today));\t\tSystem.out.println(sdf9.format(today));\t}}import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;public class  Main {\tpublic static void main(String[] args) {\t\tDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");\t\tDateFormat df2 = new SimpleDateFormat(\"yyyy-MM-dd\");\t\t\t\ttry {\t\t\tDate d = df.parse(\"2022년 9월 30일\");\t\t\tSystem.out.println(df2.format(d));\t\t}catch(Exception e) {}\t}}"
  },
  
  {
    "title": "java.lang 패키지와 유용한 클래스",
    "url": "/posts/java.lang%ED%8C%A8%ED%82%A4%EC%A7%80%EC%99%80_%EC%9C%A0%EC%9A%A9%ED%95%9C_%ED%81%B4%EB%9E%98%EC%8A%A4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-15 00:00:00 +0900",
    





    
    "snippet": "Object 클래스: 모든 클래스의 최고 조상. 오직 11개의 메소드만을 가지고 있다.nitity(), wait() 등은 쓰레드(13장)와 관련된 메소드이다            Object클래스의 메소드      설명                  protected Object clone()      객체 자신의 복사본을 반환              ...",
    "content": "Object 클래스: 모든 클래스의 최고 조상. 오직 11개의 메소드만을 가지고 있다.nitity(), wait() 등은 쓰레드(13장)와 관련된 메소드이다            Object클래스의 메소드      설명                  protected Object clone()      객체 자신의 복사본을 반환              public boolean equals(Object obj)      객체 자신과 객체 obj가 같은 객체인지 알려준다(같으면 true)              protected public void finalize()      객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출. 이 때 수행되어야하는 코드가 있을 때 오버라이딩(거의 사용안함)              public Class getClass()      객체 자신의 클래스 정보를 담고있는 Class 인스턴스를 반환              public int hashCode      객체 자신의 해시코드를 반환              public String toString()      객체 자신의 정보를 문자열로 반환              public void notify()      객체 자신을 사용하려고 기다리는 쓰레드 하나만 깨움              public void notifyAll()      객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨움              public void wait()  public void wait(long time out)  public void wait(long timeout, int nanos)      다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다. (timeout은 천분의 1초, nanos는 10의9제곱분의 1초)        [!important]Class처럼 앞글자가 대문자인 Class는 클래스 정보를 담기위한 클래스이다.자바 파일을 저장할때 class파일이 생성되고, class 객체가 생성됨. Class를 호출하면 이때 생성된 class객체를 가지고옴이것을 가지고 객체 생성도 하고 정보를 얻을 수 있게 하는 것이 ReflectionAPI라고 한다.equals(Object obj): 객체 자신(this)과 주어진 객체(obj)를 비교한다. 같으면 true, 다르면 falseObject클래스의 equal()는 객체의 주소를 비교(참조변수 값 비교)— == 는 각 객체의 주소가 같을 경우에만 true. 서로 다른 두 객체는 항상 주소가 다르다.//Object의 equals()를 오버라이딩 해서 주소가 아닌 value값을 비교하도록 함class Value{\tint value;\t\tValue(int value){\t\tthis.value = value;\t}\tpublic boolean equals(Object obj) { //오버라이딩\t\t//참조변수의 형변환 전에는 반드시 instaceof로 확인해야 함.\t\tif(!(obj instanceof Value)) return false;\t\tValue v = (Value)obj; //obj를 value로 형변환. obj안에 value라는 멤버가 없음\t\t//return this == obj; //주소비교. 서로 다른 객체는 항상 다른 주소를 가져서 거짓이 나옴\t\treturn this.value == v.value;\t}}public class  Main {\tpublic static void main(Strin] args) {\t\tValue v1 = new Value(10);\t\tValue v2 = new Value(10);\t\tSystem.out.println(v1.value);\t\tSystem.out.println(v2.value);\t\tSystem.out.println(v1);\t\tSystem.out.println(v2);\t\tSystem.out.println(\"=====================\");\t\tif(v1 == v2) \t\t\tSystem.out.println(\"v1과 v2의 값이 같습니다\");\t\t\t\telse \t\t\tSystem.out.println(\"v1과 v2의 값이 다릅니다\"); //출력됨\t\tSystem.out.println(\"=================\");\t\tif(v1.equals(v2)) \t\t\tSystem.out.println(\"v1과 v2의 값이 같습니다\"); //출력됨\t\t\t\telse \t\t\tSystem.out.println(\"v1과 v2의 값이 다릅니다\");\t\t\t}}  인스턴스 변수의 값을 비교하도록 equals()를 오버라이딩class person{\tlong id;\t\tpublic boolean equals(Object obj) {\t\tif(obj instanceof person) {\t\t\treturn id == ((person)obj).id; //obj가 Object타입 값이므로 id값을 참조하기 위해서 person타입으로 형변환 필요\t\t}\t\telse \t\t\treturn false; //타입이 person이 아니라면 값을 비교할 필요도 없다.\t}}class Person{\tlong id;\t\tpublic boolean equals(Object obj) {\t\tif(!(obj instanceof Person)) {\t\t\treturn false; //타입이 person이 아니라면 값을 비교할 필요도 없다.\t}//\t\treturn id == ((Person)obj).id;\t\tPerson p = (Person)obj;\t\treturn id == p.id;\t}\tPerson(long id){\t\tthis.id = id;\t}}public class  Main {\tpublic static void main(Strin] args) {\t\tPerson p1 = new Person(8011081111222L);\t\tPerson p2 = new Person(8011081111222L);\t\t\t\tif(p1.equals(p2))\t\t\tSystem.out.println(\"p1과 p2는 같은 사람입니다\"); //출력\t\telse\t\t\tSystem.out.println(\"p1과 p2는 다른 사람입니다.\");\t}}hashCode(): 객체의 해시코드(hash code)를 반환하는 메소드Object클래스의 hashCode()는 객체의 주소를 int로 변환해서 반환⇒ 객체의 지문이라고 부르기도 함.public class Object{\tpublic native int hashcode();}      equals()를 오버라이딩하면, hashCode()도 오버라이딩해야한다.    : 둘다 객체의 주소를 가지고 작업하기 때문에 둘다 주소를 iv를 사용하여 작업하도록 오버라이딩 해야함    equals()의 결과가 true인 두 객체의 해시코드는 같아야 하기 때문      public class  Main {      \tpublic static void main(Strin] args) {  \t\tString str1 = new String(\"abc\");  \t\tString str2 = new String(\"abc\");  \t\tSystem.out.println(str1.equals(str2)); //true  \t\tSystem.out.println(str1.hashCode()); //96354  \t\tSystem.out.println(str2.hashCode()); //96354  \t\t//equals값이 같으면 hashCode값도 같아야 함    \t\t  \t\t//System.identityHashCode(str1) == Object클래스의 hashCode  \t\tSystem.out.println(System.identityHashCode(str1));  \t\tSystem.out.println(System.identityHashCode(str2));  \t\t//오버라이딩 하기 전의 기능이 필요할 때 사용. 객체마다 다른 해시코드를 반환함.  \t}  }      toString(), toString()의 오버라이딩      toString() : 객체를 문자열(string)으로 반환하기 위한 메소드  -&gt; ‘객체 == iv집합’이므로 객체를 문자열로 변환한다는 것은 iv값을 문자열로 변환한다는 것과 같은 의미    public String toString() { //Object클래스의 toString()  return  getClass().getName()+”@”+Integer.toHexString(hashCode());  }      class Card{  \tpublic String toString() {    //Object클래스의 toString()  \t\treturn \"kind : \"+kind+\", number : \"+number;  \t} //toString 오버라이딩  \tString kind;  \tint number;    \t  \tCard(){  \t\tthis(\"SPADE\",1);  \t}    \t  \tCard(String kind, int number){  \t\tthis.kind = kind;  \t\tthis.number = number;  \t}  }  public class  Main {  \tpublic static void main(Strin] args) {  \t\tSystem.out.println(new Card().toString()); //Card@7a81197d, kind : SPADE, number : 1  \t\tSystem.out.println(new Card(\"HEART\",10).toString()); //Card@5ca881b5 , kind : HEART, number : 10  \t}  }          import java.util.Objects;      class Card{  \tString kind;  \tint number;    \t  \tCard(){  \t\tthis(\"SPADE\",1);  \t}    \t  \t//============================  \t////Source탭의 Generate hashCode()and equals()가 자동으로 해준 hashCode와 equals의 오버라이딩  //\t@Override  //\tpublic int hashCode() {  //\t\treturn Objects.hash(kind, number);  //\t}  //  //\t@Override  //\tpublic boolean equals(Object obj) {  //\t\tif (this == obj)  //\t\t\treturn true;  //\t\tif (obj == null)  //\t\t\treturn false;  //\t\tif (getClass() != obj.getClass())  //\t\t\treturn false;  //\t\tCard other = (Card) obj;  //\t\treturn Objects.equals(kind, other.kind) &amp;&amp; number == other.number;  //\t} //별로 안어려워서 직접 만드는게 더 직관적이고 좋을 확률이 큼!!  //================================================  \tpublic boolean equals(Object obj) {  \t\tif(!(obj instanceof Card))  \t\t\treturn false;    \t\t  \t\tCard c = (Card)obj;  \t\treturn this.kind.equals(c.kind) &amp;&amp; this.number==c.number;  \t\t//kind가 문자열이라서 equals 써줌  \t}  \tequals() 오버라이딩 해주면 hashCode도 오버라이딩 해줘야함  \tpublic int hashCode() {  \t\treturn Objects.hash(kind, number /*더 넣어도 됨*/);   \tint hash(Object... value){...} : 매개변수가 가변인자(Object...)라서 호출시 지정하는 값의 개수가 정해져 있지 않다.  \t}//iv가 같으면 같은 값이 나오게 됨    \t    \t  \tCard(String kind, int number){  \t\tthis.kind = kind;  \t\tthis.number = number;  \t}  \tpublic String toString() {    //Object클래스의 toString()  \t\treturn \"kind : \"+kind+\", number : \"+number;  \t} //toString 오버라이딩  }  public class  Main {  \tpublic static void main(Strin] args) {  \t\tCard c1 = new Card();  \t\tCard c2 = new Card();  \t\tSystem.out.println(c1.toString()); //Card@7a81197d, kind : SPADE, number : 1  \t\tSystem.out.println(c2.toString()); //Card@5ca881b5 , kind : HEART, number : 10  \t\tSystem.out.println(\"===================\");  \t\tSystem.out.println(c1.equals(c2));  \t\tSystem.out.println(c1.hashCode()); //-1842861219  \t\tSystem.out.println(c2.hashCode()); //-1842861219  \t\t//equals가 true면 hashCode가 똑같이 나와야 함  \t\tSystem.out.println(\"===================\");  \t\tCard c3 = new Card(\"HEART\",10);  \t\tCard c4 = new Card(\"DIAMON\",5);  \t\tSystem.out.println(c3.toString()); //kind : HEART, number : 10  \t\tSystem.out.println(c4.toString()); //kind : DIAMON, number : 5  \t\tSystem.out.println(c3.equals(c4)); //false  \t\tSystem.out.println(c3.hashCode()); //2127040613  \t\tSystem.out.println(c4.hashCode()); //-1921929034  \t\t//equals가 false라서 hashCode도 다른 값이 출력됨  \t}  }      String클래스: 문자열을 다루기 위한 클래스String클래스 = 데이터(char[]) + 메소드(문자열관련)내용을 변경할 수 없는 불변(immutable) 클래스String a = “a”; String b = “b”; a=a+b;일때 a의 “a”값이 사라지고 “ab”가 들어오는게 아니라 “ab”라는 객체가 새로 생성되어 a에 “ab”객체의 주소가 들어가고 “a” 객체는 사라지지않음.⇒ 덧셈 연산자를 이용한 문자열 결합은 성능이 떨어짐(매번 객체가 새로 생성됨)문자열의 변경이나 결합이 잦다면, 내용을 변경 가능한 StringBuffer(내용변경가능)를 사용      문자열 비교      public class  Main {  \tpublic static void main(Strin] args) {  \t\t//하나의 문자열을 여러 참조변수가 공유  \t\tString str1 = \"abc\"; //문자열 리터럴 \"abc\"의 주소가 str1에 저장됨  \t\tString str2 = \"abc\"; //문자열 리터럴 \"abc\"의 주소가 str1에 저장됨  \t\tSystem.out.println(str1 == str2); //true  \t\tSystem.out.println(\"equals 비교 : \"+str1.equals(str2)); //true    \t\t  \t\t//항상 새로운 객체 생성  \t\tString str3 = new String(\"abc\");//새로운 String인스턴스 생성  \t\tString str4 = new String(\"abc\");//새로운 String인스턴스 생성  \t\tSystem.out.println(str3 == str4); //false  \t\tSystem.out.println(\"equals 비교 : \"+str3.equals(str4)); //true  \t\t//String은 변경 불가라 굳이 이렇게 할 필요는 없음  \t}  }        문자열 리터럴 : 프로그램 실행시 자동으로 생성 (constant pool에 저장”          같은 내용의 문자열 리터럴은 하나만 만들어짐(불변이라)ㅈ            빈 문자열 (””, empty string)    : 내용이 없는 크기가 0인 char형 배열을 저장하는 문자열        크기가 0인 배열을 생성하는 것은 어느 타입이나 가능.      public class  Main {  \tpublic static void main(Strin] args) {  \t\tchar charr[] = new char[0]; //길이가 0인 배열 = 데이터 저장 불가  \t\tint iarr[] = {}; //길이가 0인 배열 = 데이터 저장 불가  \t\t//주로 숫자를 문자로 바꿀때나(\"\"+5=\"5\") 배열초기화시(null보다 빈문자열이 편리) 사용함  \t}  }      CharSequence : 인터페이스. CharBuffer, Segment, String, StringBuffer, StringBuilder 클래스들의 공통 조상이 없어서 CharSequence 인터페이스로 묶어준거임.regex : 정규식join()과 StringJoinner: 여러 문자열 사이에 구분자를 넣어서 결합한다. (static메소드)import java.util.Arrays;public class  Main {\tpublic static void main(Strin] args) {\t\tString animals = \"dog,cat,bear\";\t\tString arr[] = animals.split(\",\"); //위 문자열을 ,별로 나눠서 배열로 저장\t\tSystem.out.println(Arrays.toString(arr));/dog, cat, bear]\t\tString str = String.join(\"-\", arr); //배열의 문자열을 '-'로 구분해서 결합(배열x 문자열o)\t\tSystem.out.println(str); //dog-cat-bear\t}}문자열과 기본형 간의 변환      숫자를 문자열로 바꾸는 법      \t\tint i = 100;  \t\tString str1 = i+\"\";  \t\tString str2 = String.valueOf(i);            문자열을 숫자로 바꾸는 법      \t\tint i2 = Integer.parseInt(\"100\"); //옛날 방법  \t\tint i3 = Integer.valueOf(\"100\"); //새로운 방법. 위 방법이 종류가 많아져서 통합해버림  \t\tInteger i4 = Integer.valueOf(\"100\"); //반환타입이 Integer  \t\tint i5 = new Integer(100).intValue(); //밑에서 자세히              [!important]byte, short을 문자열로 변경할 때는 String valueOf(int)를 사용하면 됨      public class  Main {\tpublic static void main(Strin] args) {\t\tint iVal = 100;//\t\tString strVal = String.valueOf(iVal);\t\tString strVal = iVal+\"\";\t\t\t\tdouble dVal = 200.0;//\t\tString strVal2 = String.valueOf(dVal);\t\tString strVal2 = dVal + \"\";\t\t\t\tdouble sum = Integer.parseInt(\"+\"+strVal) //문자열-&gt;숫자\t\t\t\t\t\t\t\t+Double.parseDouble(strVal2);\t\tdouble sum2 = Integer.valueOf(strVal)+Double.valueOf(strVal2);\t\t\t\t\t\tSystem.out.println(String.join(\"\",strVal,\"+\",strVal2,\"=\")+sum);\t\tSystem.out.println(strVal+\"+\"+strVal2+\"=\"+sum2); //성능 떨어짐\t}}      n진법 문자열을 숫자로      public class  Main {  \tpublic static void main(Strin] args) {  //\t\tint i5 = Integer.parseInt(\"FF\"); //에러. NumberFormatException. 10진수에 ff가 없음  \t\tSystem.out.println(\"i = \" +Integer.parseInt(\"100\")); //100  \t\tSystem.out.println(\"i = \" +Integer.parseInt(\"100\",10)); //100 위랑 같은거임  \t\tSystem.out.println(\"i1 = \"+Integer.parseInt(\"100\",2)); //4  \t\tSystem.out.println(\"i2 = \"+Integer.parseInt(\"100\",8)); //64  \t\tSystem.out.println(\"i3 = \"+Integer.parseInt(\"100\",16)); //256  \t\tSystem.out.println(\"i4 = \"+Integer.parseInt(\"FF\",16)); //255  \t}  }      StringBuffer의 생성자와 메소드StringBuffer sb = new StringBuffer(”Hi”) 는 16+2(”h”, “i”로 총 2칸)=18문자를 저장할 수 있는 StringBuffer인스턴스를 생성버퍼크기 = char[] 크기⚠️ 자바에서는 범위가 주어졌을때 start ≤ x &lt;end 라 끝 값은 언제나 포함안됨import javax.xml.transform.Source;public class  Main {\tpublic static void main(Strin] args) {\t\tStringBuffer sb = new StringBuffer(\"01\");\t\tStringBuffer sb2 = sb.append(23);\t\tsb.append(\"4\").append(56); //56도 문자로 들어감\t\t\t\tStringBuffer sb3 = sb.append(78);\t\tsb3.append(9.0);\t\t\t\tSystem.out.println(\"sb = \"+sb); //0123456789.0\t\tSystem.out.println(\"sb2 = \"+sb2); //0123456789.0\t\tSystem.out.println(\"sb3 = \"+sb3); //0123456789.0\t\t\t\tSystem.out.println(\"sb = \"+sb.deleteCharAt(10)); //01234567890\t\tSystem.out.println(\"sb = \"+sb.delete(3, 6)); //01267890\t\tSystem.out.println(\"sb = \"+sb.insert(3, \"abc\")); //012abc67890\t\tSystem.out.println(\"sb = \"+sb.replace(6, sb.length(), \"END\")); //012abcEND\t\t\t\tSystem.out.println(\"capacity : \"+sb.capacity()); //18. 처음 sb객체 생성시 \"01\"로 생성해서 16+2\t\tSystem.out.println(\"length : \"+sb.length()); //9\t}}StringBuilder      StringBuffer : 동기화 돼있다. 멀티 쓰레드(13장)에 안전(thread-safe)  → 멀티 쓰레드 프로그램이 아닌경우, 동기화는 불필요한 성능저하를 불러옴        StringBuilder : 동기화 안되어있다. 싱글 쓰레드일때는 StringBuilder를 사용하면 성능이 향상됨  Math: 수학관련 static 메소드의 집합  E : 자연로그의 밑  PI : 원주율  round : 반올림  — double d = 90.7552; d = (Math.round(d*100))/100.0; ⇒ 90.76            ![image](/assets/images/java/2022-08-15-javalang/IMG-20240818214102-9.png      ]      public class  Main {\tpublic static void main(Strin] args) {\t\tdouble sum=0;\t\tdouble sum1=0;\t\tdouble sum2=0;\t\tfor(double d = 1.5; d&lt;=10.5; d++) {\t\t\tdouble d1= Math.round(d);\t\t\tdouble d2= Math.rint(d); //반올림하는데 .5는 짝수를 출력\t\t\t\t\t\tSystem.out.printf(\"%4.1f %4.1f, %4.1f%n\",d,d1,d2);\t\t\t\t\t\tsum+=d;\t\t\tsum1+=d1;\t\t\tsum2+=d2;\t\t\tSystem.out.println(\"====================\");\t\t\tSystem.out.printf(\"%4.1f %4.1f, %4.1f%n\",sum,sum1,sum2);\t\t\tSystem.out.println(\"******************\");\t\t/*\t\t 1.5  2.0,  2.0\t\t====================\t\t 1.5  2.0,  2.0\t\t******************\t\t 2.5  3.0,  2.0\t\t====================\t\t 4.0  5.0,  4.0\t\t******************\t\t 3.5  4.0,  4.0\t\t====================\t\t 7.5  9.0,  8.0\t\t******************\t\t 4.5  5.0,  4.0\t\t====================\t\t12.0 14.0, 12.0\t\t******************\t\t 5.5  6.0,  6.0\t\t====================\t\t17.5 20.0, 18.0\t\t******************\t\t 6.5  7.0,  6.0\t\t====================\t\t24.0 27.0, 24.0\t\t******************\t\t 7.5  8.0,  8.0\t\t====================\t\t31.5 35.0, 32.0\t\t******************\t\t 8.5  9.0,  8.0\t\t====================\t\t40.0 44.0, 40.0\t\t******************\t\t 9.5 10.0, 10.0\t\t====================\t\t49.5 54.0, 50.0\t\t******************\t\t10.5 11.0, 10.0\t\t====================\t\t60.0 65.0, 60.0\t\t******************\t\t\t *///rint가 최종 합산이 더 정확함. \t\t}\t}}래퍼(wrapper)클래스: 기본형 값을 감싸는 클래스. 8개의 기본형을 객체로 다뤄야할 때 사용.public class  Main {\tpublic static void main(Strin] args) {\t\tInteger i = new Integer(100);\t\tInteger i2 = new Integer(100);\t\t\t\tSystem.out.println(\"i==i2 ? \"+(i==i2)); //false\t\tSystem.out.println(\"i.equals(i2)? \"+i.equals(i2)); //true\t\tSystem.out.println(\"i.compareTo(i2) \"+i.compareTo(i2)); //0, 같으면 0, 오른쪽이 작으면 양수, 오른쪽이 크면 음수\t\tSystem.out.println(\"i.toString() = \"+i.toString()); //100(문자열)\t\t\t\tSystem.out.println(\"MAX_VALUE = \"+Integer.MAX_VALUE); //2147483647 . 최댓값 (+20억)\t\tSystem.out.println(\"MIN_VALUE = \"+Integer.MIN_VALUE); //-2147483648 . 최솟값(-20억)\t\tSystem.out.println(\"SIZE = \"+Integer.SIZE+\"bits\"); //32bits\t\tSystem.out.println(\"BYTES = \"+Integer.BYTES+\"BYTES\"); //4BYTES\t\tSystem.out.println(\"TYPE = \"+Integer.TYPE); //int\t}}  타입Value - 래퍼객체 → 기본형 (new Integer → int)  래퍼클래스 → 문자열 - toString() 사용Number클래스: 모든 숫자 래퍼 클래스의 조상— byte, short, integer, long, float, double, BigInteger, BigDecimal오토박싱 &amp; 언박싱오토박싱 : 기본형 → 객체 자동변환 (int → Integer)언박싱 : Integer → int  JDK1.5부터는 기본형과 참조형간의 연산이 가능해짐(컴파일러가 바꿔줌)int i = 5; Integer iobj = new Integer(7); int sum = i+iobg;⇒ int i = 5; Integer iobj = new Integer(7); int sum = i+ iobg.intValue();로 자동 컴파일됨import java.util.ArrayList;public class  Main {\tpublic static void main(Strin] args) {\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\t\tlist.add(10); //오토박싱. 10-&gt; new Integer(10);  \t\t//↑ 원래는 list.add(new Integer)처럼 객체를 넣어줘야 함.JDK1.5이후에만 가능.(컴파일러가 자동변환)\t\t\t\t//list에 저장된 객체를 꺼내기. //\t\tint value = list.get(0).intValue();// 원래는 이렇게 써줘야함. intValue()로 Integer를 int로 변환\t\tint value = list.get(0);  //언박싱. new Integer(10) -&gt; 10;\t}}import java.util.ArrayList;public class  Main {\tpublic static void main(Strin] args) {\t\tint i = 10;\t\t\t\t//기본형 -&gt; 참조형\t\t//Integer intg = Integer.Value(i);\t\tInteger intg = (Integer)i;  \t\t//Object obg = (Object)Integer.Value(i);\t\tObject obg = (Object)i;\t\t\t\t//Long lng = new Long(100L);\t\tLong lng = 100L; //원래는 객체를 생성해줘야 하나 기본형을 바로 저장하도록 컴파일러가 바꿔줌\t\t\t\tint i2 = intg + 10; //참조형+기본형 가능\t\tLong l = intg + lng; //참조형+참조형 가능. \t\t\t\tInteger intg2 = new Integer(20);\t\tint i3 = (int)intg2; //참조형 -&gt; 기본형 가능\t\t\t\t/*컴파일 전 코드 \t\t\t\t\t\t컴파일 후 코드\t\t * Integer intg = (Integer)i;\t\tInteger intg = Integer.Value(i);\t\t *Object obg = (Object)i;\t\t\tObject obg = (Object)Integer.Value(i);\t\t *Long lng = 100L;\t\t\t\t\tLong lng =  new Long(100L);\t\t */\t\t\t}}"
  },
  
  {
    "title": "예외처리",
    "url": "/posts/%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-14 00:00:00 +0900",
    





    
    "snippet": "프로그램 오류system.out.println(args[0]); //컴파일 에러System.out.println(args[0]); //런타임 에러 : 실행중 발생하는 에러. 매개변수로 받은 값이 없는데 실행해서 생김  논리적에러(logical error) : 작성 의도와 다르게 동작  컴파일러에러(compile-time error) : 컴파일 할 때 ...",
    "content": "프로그램 오류system.out.println(args[0]); //컴파일 에러System.out.println(args[0]); //런타임 에러 : 실행중 발생하는 에러. 매개변수로 받은 값이 없는데 실행해서 생김  논리적에러(logical error) : 작성 의도와 다르게 동작  컴파일러에러(compile-time error) : 컴파일 할 때 발생하는 에러번호          컴파일러                  구문체크          번역          최적화 (ex. int i = 3+5를 8로 변경)                      런타임에러(runtime error) : 실행할 때 발생하는 에러. 프로그램종료                  에러 (error) : 프로그램코드에 의해 수습될 수 없는 심각한 오류  ex)Out Of Memory Error - OOME : 메모리부족으로 일어나는 오류                    예외 (exception) : 프로그램코드에 의해 수습될 수 있는 다소 미약한 오류  ex)RuntimeException, IOException                              Excepton클래스들 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외            — checked예외 : 컴파일러가 예외처리 여부를 체크(예외처리 필수)                                RuntimeException 클래스들 : 프로그래머의 실수로 발생하는 예외            — unchecked예외 : 컴파일러가 예외처리 여부를 체크 안함.(예외처리 선택)              throw new Exception(\"고의로 발생\");  //try-catch문이 없어 컴파일 조차 안됨  \t\tthrow new RuntimeException(\"고의로 발생\");  //try-catch가 없어도 컴파일은 됐으나 실행중 에러. 비정상 종료                                            예외처리(exception handling) : 프로그램 실행시 발생할 수 있는 예외의 발생에 대비한 코드를 작성.  프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지  — try - catch문 사용 - {}생략불가.            try { /예외가 발생할 가능성이 있는 문장을 넣는다/  } catch (Exception1 e1) { /* Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 넣음/  } catch (Exception2 e2) { / Exception2이 발생했을 경우, 이를 처리하기 위한 문장을 넣음/  catch (ExceptionN eN) { / ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 넣음*/                          try블럭에서 예외가 발생한 경우                                  발생한 예외와 일치하는 catch블럭이 있는지 확인                  일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.                                                            try블럭 내에서 예외가 발생하지 않은 경우                                  catch블럭을 거치지 않고 전체 try-catch문을 빠져나가 수행을 계속한다.                                  public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\ttry {  \t\t\tSystem.out.println(2);  \t\t\tSystem.out.println(3);  \t\t} catch (Exception e) {  \t\t\tSystem.out.println(4); //예외가 발생하지 않아서 출력안됨.   \t\t}//try-catch문의 끝  \t\tSystem.out.println(5);  //1 2 3 5 출력됨  \t\tSystem.out.println(\"=============\");  \t\tSystem.out.println(1);  \t\ttry {  \t\t\tSystem.out.println(0/0); //예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(2);  \t\t} catch (ArithmeticException e) {  \t\t\tSystem.out.println(3);  \t\t}//try-catch문의 끝  \t\tSystem.out.println(4);  //1 3 4 출력됨  \t}//main 메소드의 끝  }                                                              printStackTrace() : 예외발생 당시의 호출스택(Call strack)에 있었던 메소드의 정보와 예외 메시지를 화면에 출력한다.                      getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메세지를 얻을 수 있다.              public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\tSystem.out.println(2);  \t\ttry {  \t\t\tSystem.out.println(3);  \t\t\tSystem.out.println(0/0); //ArithmeticException예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(4); //실행안됨  \t\t} catch (ArithmeticException ae) {  \t\t\tae.printStackTrace();  \t\t\tSystem.out.println(\"예외 메세지 : \"+ae.getMessage());   \t\t} catch (Exception e) {  //Exception : 모든 예외의 최고조상, 모든 예외를 처리함(맨 마지막에 와야함)  \t\t\tSystem.out.println(\"Exception\"); //실행안됨  \t\t}//try-catch문의 끝  \t\tSystem.out.println(6);    \t\t//1 2 3   java.lang.ArithmeticException: / by   zero 예외 메세지 : / by zero   6 출력됨  \t}//main 메소드의 끝  }                                예외 발생시키기                                          연산자 new를 이용해 발생시키려는 예외 클래스의 객체를 만든다 Exception e = new Exception(”고의로 발생시켰음”);                                            키워드 throw를 이용해 예외 발생 throw e;                                              예외 처리방법                                          멀티 catch블럭(try - catch문) : 내용이 같은 catch블럭을 하나로 합친 것 (JDK1.7부터)  try { /…/ } catch (ExceptionA | ExceptionB) { e.printStackTrace (); }                멀티catch블록에 쓰는 두 클래스가 부모자식관계면 에러. 부모만써도 같은 의미라서 에러표시됨                  public class ex {  \tpublic static void main(String[] args) {  \t\tSystem.out.println(1);  \t\tSystem.out.println(2);  \t\ttry {  \t\t\tSystem.out.println(3);  \t\t\tSystem.out.println(0/0); //ArithmeticException예외 발생 0으로 나누기 금지  \t\t\tSystem.out.println(4); //실행안됨  \t\t} catch (ExceptionA | ExceptionB e) {  //Exception : 모든 예외의 최고조상, 모든 예외를 처리함(맨 마지막에 와야함)  //\t\t\te.methodA(); //에러, e에 ExceptionA가 들어올지 ExceptionB가 들어올지 알수 없음. methodA는 ExceptionA의 멤버라서 에러  \t\t\t//ExceptionA,ExceptionB의 공통멤버는 사용 가능  \t\t\tif(e instanceof ExceptionA) {  \t\t\t\tExceptionA e1 = (ExceptionA)e;  \t\t\t\te1.methodA();  \t\t\t}  \t\t\telse {  \t\t\t\tExceptionB e2 = (ExceptionB)e;  \t\t\t\te2.methodB();  \t\t\t}  \t\t}//try-catch문의 끝  \t\tSystem.out.println(6);    \t}//main 메소드의 끝  }                                                            메소드에 예외 선언하기 : 빈catch블럭을 사용함                ❗예외를 발생시키는 키워드 throw와 메소드에 선언할 때 쓰이는 throws를 잘 구분 할 것.                  static void startInstall() throws SpaceException, MemoryException{  \tif(!enoughSpace()) //설치공간이 부족하다면  \t\tthrow new SpaceException(\"설치공간 부족\");  \tif(!enoughMemory()) //메모리가 부족하다면  \t\tthrow new MemoryException(\"메모리 부족\");  } //내가 처리할 수 없는 것들. 사용자에게 해결하고 오라고 떠넘김                                  public class ex {  \tpublic static void main(String[] args) throws Exception{  \tmethod1(); //같은 클래스 내의 static멤버이므로 객체생성없이 직접 호출 가능  \t}  \tstatic void method1()throws Exception {  \t\tmethod2();  \t}  \tstatic void method2() throws Exception{  \t\tthrow new Exception();  \t}  } //method2에서 발생한 Exception이 try-catch문을 만나지 못해 method1-main까지 올라갔다가 JVM까지 올라감 -&gt; 비정상종료  //try-catch문이 하나는 있어야 해결이됨.                                  import java.io.*;                  public class ex {  \tpublic static void main(String[] args) {  \t\t\tFile f = createFile(\"\");  \t\t\tSystem.out.println(f.getName()+\" 파일이 성공적으로 생성되었습니다\");  \t\t}                   static File createFile(String fileName){  \ttry {  \t\tif(fileName == null || fileName.equals(\"\"))  \t {  \t\t throw new Exception(\"파일 이름이 유효하지 않습니다.\");  \t }  \t} catch(Exception e) {  \t\t fileName = \"제목없음.txt\";  \t }  \t File f = new File(fileName); //File클래스의 객체 생성  \t try {  \t\tf.createNewFile();  \t} catch (IOException e) {  \t\te.printStackTrace();  \t}finally{  \t\t//예외 발생 여부와 상관없이 무조건 실행해야함. 코드 중복 박기 위해  \t}  \t return f;  \t}   }                                                            finally블럭 : 예외 발생 여부와 관계없이 수행되어야 하는 코드                ⚠️ try블럭안에 return문이 있어서 try블럭을 벗어나갈 때도 finally블럭이 실행 됨                                                          사용자정의 예외 만들기            : 우리가 직접 예외 클래스를 정의할 수 있다.            조상은 Exception과 RuntimeException중에 선택 (웬만하면 RuntimeException으로 할것. try-catch문 꼭 안써줘도 됨)              class MyException extends Exception{  \tMyException(String msg){ //문자열을 매개변수로 받는 생성자  \t\tsuper(msg); //조상인 Exception의 생성자를 호출  \t}  }                          class MyException extends Exception{  \t//에러코드 값을 저장하기 위한 필드 추가  \tprivate final int ERR_CODE;  \t MyException(String msg, int errCode){ //생성자  \t\t super(msg);  \t\t ERR_CODE = errCode;  \t }  \t MyException(String msg){ //생성자  \t\t this(msg, 100); //ERR_CODE를 100(기본값)으로 초기화  \t }  \t public int getErrCode() { //에러코드를 얻을 수 있는 메소드도 추가  \t\t return ERR_CODE; //주로 getMessage()와 함께 사용될 것.  \t }  \t}                                            예외 되던지기(exception re-throwing)            : 예외를 처리한 후에 다시 예외를 발생시킴              public class Main {  \tpublic static void main(String[] args) {  \t\ttry {  \t\t\tmethod1();  \t\t} catch (Exception e) {  \t\t\tSystem.out.println(\"main메소드에서 예외처리 되었습니다\");  \t\t} //예외 2번처리 = 예외 되던지기 = 예외 양쪽에서 처리  \t}  static void method1() throws Exception{  \t\ttry {  \t\t\tthrow new Exception();  \t\t}catch (Exception e) {  \t\t\tSystem.out.println(\"method1에서 예외가 처리되었습니다\");  \t\t\tthrow e;  \t\t}  \t}  }                                            연결된 예외(chained exception)            : 한 예외가 다른 예외를 발생시킬 수 있다.            예외 A가 예외 B를 발생시키면 A는 B의 원인예외(cause exception)            Throwable initCause(Throwable cause) : 지정된 예외를 원인 예외로 등록            Throwable getCause() : 원인 예외를 반환              public class Throwable implements Serializable{  \t//...  \tprivate Throwable cause = this; //객체 자신(this)을 원인 예외로 등록  \t//...  \tpublic synchronized Throwable initCause(Throwable cause) {  \t\t//...  \t\tthis.cause = cause; //cause를 원인 예외로 등록  \t\treturn this;  \t}  }                          void install() throws InstallException{ //실제로는 SpaceException이 발생했으나 InstallException안에 포함시켜서 예외 처리됨  \ttry {  \t\tstartInstall(); //SpaceException 발생, 저장공간 부족  \t\tcopyFiles();  \t} catch (SpaceException e) {  \t\tInstallException ie = new InstallException(\"설치 중 예외 발행\");  \t\tie.initCause(e); //ie(InstallException)의 원인 예외를 e(SpaceException)으로 지정  \t\tthrow ie; //InstallException 발생  \t}catch (MemoryException me) {  \t\t//......  \t}   }                        — 이유 1 : 여러 예외를 하나로 묶어서 다루기 위해              void install() throws InstallException{ //실제로는 SpaceException이 발생했으나 InstallException안에 포함시켜서 예외 처리됨  \ttry {  \t\tstartInstall(); //SpaceException 발생, 저장공간 부족  \t\tcopyFiles();  \t} catch (SpaceException e) {  \t\tInstallException ie = new InstallException(\"설치 중 예외 발행\");  \t\tie.initCause(e); //ie(InstallException)의 원인 예외를 e(SpaceException)으로 지정  \t\tthrow ie; //InstallException 발생  \t}catch (MemoryException me) {  \t\t//......  \t}   }  public class Main {              \tpublic static void main(String[] args) {  //\t\ttry {  //\t\t\tinstall();  //\t\t} catch (SpaceException e) {  //\t\t\te.printStackTrace();  //\t\t} catch (MemoryException e) {  //\t\t\te.printStackTrace();  //\t\t} catch (Exception e) {  //\t\t\te.printStackTrace();  \t\ttry {  \t\t\tinstall();  \t\t} catch (InstallException e) {  \t\t\te.printStackTrace();  \t\t} catch (Exception e) {  \t\t\te.printStackTrace();  \t\t}  \t}  }                        — 이유 2 : checked예외를 unchecked예외로 변경할때              static void startInstall() throws SpaceException, MemoryException{  \tif(!enoughSpace())  \t\tthrow new SpaceException(\"설치할 공간이 부족합니다.\");  \tif(!enoughMemory())  \t\tthrow new RuntimeException(new MemoryException(\"메모리가 부족합니다.\"));\t\t  }//MemoryException을 RuntimeException으로 위장해 try-catch문은 사용하지않아도됨  //class SpaceException extends Exception{  //\tSpaceException(String msg){  //\t\tsuper(msg);  \t}  }                                          "
  },
  
  {
    "title": "상속 (ingeritance)",
    "url": "/posts/%EC%83%81%EC%86%8D-(Ingeritance)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-05 00:00:00 +0900",
    





    
    "snippet": "상속~는 ~이다 (is - a) - ex.원(circle)은 점(point)다. (x)class 자식클래스 extends 부모클래스  기존의 클래스로 새로운 클래스를 작성(코드 재사용)  두 클래스를 부모와 자식 관계로 이어줌  자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화 블럭 제외 (자식클래스에 멤버가 안적혀있어도 있는거임)  자손의 멤버...",
    "content": "상속~는 ~이다 (is - a) - ex.원(circle)은 점(point)다. (x)class 자식클래스 extends 부모클래스  기존의 클래스로 새로운 클래스를 작성(코드 재사용)  두 클래스를 부모와 자식 관계로 이어줌  자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화 블럭 제외 (자식클래스에 멤버가 안적혀있어도 있는거임)  자손의 멤버 개수가 조상보다 적을 수는 없음.(같거나 많다.)  자손의 변경은 조상에게 영향을 미치지 않음.  부모 클래스의 변경은 자식 클래스에 영향을 미침.class point {\tint x, y;}class point3D extends point {\tint z;}  상속을 받지않고 중복으로 멤버들을 지정해줘도 결과는 똑같음.class Tvclass {\tboolean power;//전원상태(on/off)\tint channel;\t\tvoid power() {power = !power;}\t\tvoid channelUp() {++channel;}\t\tvoid channelDown() {--channel;}}\tclass SmartTv extends Tvclass{ //SmartTv는 Tv에 캡션(자막)을 보여주는 기능을 지원\tboolean caption; //캡션상태 (on/off)\tvoid displayCapion(String text) {\t\tif(caption) { \t\t\t//캡션의 상태가 on(true)일때만 text를 보여줌\t\t\tSystem.out.println(text);\t\t}\t}}public class Ex7_1 {\tpublic static void main(String[] args) {\t\tSmartTv stv = new SmartTv();\t\tstv.channel=10; //조상에게 상속받은 멤버\t\tstv.channelUp(); //조상에게 상속받은 멤버\t\tSystem.out.println(stv.channel);\t\tstv.displayCapion(\"ssssssssssss\"); //자막 off상태\t\tstv.caption = true;\t\tSystem.out.println(\"ssssssssssssssssssssssss\");\t\t\t\t\t}}포함(composite)~은 ~을 가지고 있다. (has - a) - ex. 원(circle)은 점(point)를 가지고 있다.(o)  — 90%가 포함이라고 보면 됨      클래스의 멤버로 참조변수를 선언함  class Point {\tint x; //원점의 x좌표\tint y; //원점의 y좌표}class circle {\tPoint c =new Point(); //c가 또 객체를 만들어서 Point를 가르킴\tint r; //반지름}//class circle { int x; int y; int r;}과 같은 거임.public class Ex7_1 {\tpublic static void main(String[] args) {\t\tcircle c = new circle();\t\tc.c.x = 5;\t\tc.c.y = 10;\t\tc.r = 15;\t\t//x,y는 circle c의 point c를 불러야 사용가능class Point{\tint x, y;}class Circle extends Point{\tint r;}class Circle2{\tPoint p = new Point();\tint r;}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\tc.x=1;\t\tc.y=2;\t\tc.r=3;\t\tSystem.out.println(\"c.x = \"+c.x);\t\tSystem.out.println(\"c.y = \"+c.y);\t\tSystem.out.println(\"c.r = \"+c.r);\t\t\t\tSystem.out.println();\t\t\t\tCircle2 c2 = new Circle2();\t\tc2.p.x = 10;\t\tc2.p.y = 15;\t\tc2.r=20;\t\tSystem.out.println(\"c2.p.x = \"+c2.p.x);\t\tSystem.out.println(\"c2.p.y = \"+c2.p.y);\t\tSystem.out.println(\"c2.p.r = \"+c2.r);\t\t\t}}단일상속(Single Inheritance)자바는 단일 상속만을 허용함. (c++은 다중상속 허용) → 인터페이스를 이용하면 비슷한 기능을 쓸 수 있음  비중이 높은 클래스 하나만 상속으로 나머지는 포함으로 작성 가능Object class - 모든 클래스의 조상  부모가 없는 클래스는 자동적으로 object 클래스를 상속받게 됨.      모든 클래스는 object클래스에 정의된 11개의 메소드를 상속받음  toString(), equals(Object obj), hashCode() ……..등등(9장)    상속계층도를 따라올라가면 맨 위에 Object가 있음class Point{\tint x, y;}class Circle extends Point{\tint r;}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\tSystem.out.println(c.toString()); //Circle@5ca881b5 클래스이름@객체주소값\t\tSystem.out.println(c); //Circle@5ca881b5 클래스이름@객체주소값\t\tCircle c2 = new Circle();\t\tSystem.out.println(c2.toString()); //Circle@24d46ca6 클래스이름@객체주소값\t\tSystem.out.println(c2); //Circle@24d46ca6 클래스이름@객체주소값\t}}println이 참조변수가 들어오면 내부적으로 toString을 호출오버라이딩 (overriding)상속받은 조상의 메소드를 자신에 맞게 변경하는 것.  조건          선언부가 조상클래스의 메소드와 일치해야함      접근 제어자(public, protect, defalt, private) 를 조상클래스의 메소드보다 좁은 범위로 변경불가      예외는 조성 클래스의 메소드보다 많이 선언할 수 없다. (8장)      class Point{\tint x, y;String getLocation(){\treturn \"x : \"+x+\", y : \"+y;\t}}class Point3D extends Point{\tint z;\tString getLocation() { //오버라이딩 (선언부 변경 불가 내용[ {} 구현부 ]만 변경가능)\t\treturn \"x : \"+x+\", y: \"+y+\", z : \"+z;\t\t}\t}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tPoint3D p = new Point3D();\t\tp.x = 3;\t\tp.y=5;\t\tp.z=7;\t\tSystem.out.println(p.getLocation()); //x : 3, y: 5, z : 7\t}}class Point{\tint x, y;\t\tPoint(int x, int y){\t\tthis.x= x;\t\tthis.y=y;\t}\t\t//object클래스의 toString()을 오버라이딩\tpublic String toString(){\treturn \"x : \"+x+\", y : \"+y;\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tPoint p = new Point(3,5);\t\tSystem.out.println(p.toString()); //x : 3, y : 5\t\tSystem.out.println(p); //x : 3, y : 5\t}}오버로딩 (overloading)기존에 없는 새로운 (이름이 같은)메소드를 정의하는 것. 오버라이딩이랑은 관계없음.class Parent{\tvoid parentMethod() {\t\t\t}\tclass child extends Parent{\t\tvoid parentMethod() {}\t\tvoid parentMethod(int i) {}\t\t\t\tvoid childMethod() {}\t\tvoid childMethod(int i) {}\t\tvoid childMethod() {}\t\t\t}}참조변수 superthis와 비슷함  객체 자신을 가르치는 참조변수. 인스턴스 메소드(생성자)내에서만 존재  조상의 멤버를 자신의 멤버와 구분할 떄 사용class Parent{\tint x=10;}class child extends Parent{ //구성멤버 3개\tint x = 20;\t\tvoid method() { \t\tSystem.out.println(\"x = \"+x);  //가까이있는 x(20)\t\tSystem.out.println(\"this.x = \"+this.x);//20\t\tSystem.out.println(\"super.x = \"+super.x); //부모클래스의 x (10)\t\t\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tchild c = new child();\t\tc.method();\t}}class Parent{\tint x=10;}class child extends Parent{ //구성멤버 2개\tvoid method() { \t\tSystem.out.println(\"x = \"+x);  //가까이있는 x\t\tSystem.out.println(\"this.x = \"+this.x);\t\tSystem.out.println(\"super.x = \"+super.x); //부모클래스의 x\t\t//중복이 없으면 !! 조상멤버기도하지만 내꺼기도해서 this, super 모두 같은 x를 가르킴\t}}public class InheritanceTest {\tpublic static void main(String[] args) {\t\tchild c = new child();\t\tc.method();\t}}super() - 조상의 생성자참조변수 super와 상관없음  조상의 생성자를 호출할 때  조상의 멤버는 조상의 생성자를 호출해서 초기화  생자와 초기화 블럭은 상속이 xclass Point {\tint x,y;\tPoint(int x, int y){\t\tthis.x=x;\t\tthis.y=y; //초기화\t}}class Point3D extends Point {\tint z;\t\tPoint3D(int x, int y, int z) {\t\tsuper(x, y); //조상class에서 초기화\t\tthis.z=z; //초기화\t}}  생성자의 첫 줄에는 반드시 생성자(super(); or this();)를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입함.class Point {\tint x,y;\tPoint(){\t\tthis(0,0);\t}\tPoint(int x, int y){\t\tsuper();  //object(); 안넣어주면 컴파일러가 자동으로 넣어줌\t\tthis.x=x;\t\tthis.y=y;에러 예시 중요!!class Point {\tint x, y;\tPoint(int x, int y){\t\tsuper(); //컴파일러 자동 추가\t\tthis.x=x;\t\tthis.y=y;\t}\tString getLocation() {\t\treturn \"x : \"+x+\", y : \"+y;\t}}class MyPoint3D extends Point{\tint z;\t//\tMyPoint3D(int x, int y, int z){//\tsuper();  //컴파일러 자동 추가 Point()를 호출 -&gt; Point에 Point();가 없어서 에러남//\tthis.x=x;//\tthis.y=y;//\tthis.z=z;//\t}\t\tMyPoint3D(int x, int y, int z){\t\tsuper(x,y);\t\tthis.z=z;  \t}  //에러 없애는 방법 다른방법은 Pointclass에 Point();추가하기\t\tString getLocation() { //오버라이딩\t\treturn \"x : \"+x+\", y : \"+y+\", z : \"+z;\t}\t}public class Ex_test {\tpublic static void main(String[] args) {\t\tMyPoint3D p3 = new MyPoint3D(1,2,3);\t\t\t}}패키지(package)  서로 연관된 class의 묶음  클래스는 클래스파일(*.class), 패키지는 폴더. 하위 패키지는 하위폴더      클래스의 실제 이름 (full name)은 패키지를 포함.(java.lang.String)    rt.jar는 클래스들을 압축한 파일.(JDK설치경로\\jre\\lib에 위치) - 자바9부터 rt.jar는 없어짐    패키지 선언          패키지는 소스파일의 첫 번째 문장으로 단 한번 선언      같은 소스파일의 클래스들은 모두 같은 패키지에 속하게 된다.      패키지 선언이 없으면 이름없는(unnamed)에 속하게 된다. - defaultpackage        클래스 패스(classpath)          클래스 파일(*.class)의 위치를 알려주는 경로(path)      환경변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용      classpath(환경변수)에 패키지의 루트를 등록해줘야 함      import문클래스를 사용할 때 패키지 이름을 생략할 수 있다.  컴파일러에게 클래스가 속한 패키지를 알려줌  ctrl + shift + o ⇒ 자동으로 import문을 추가해줌.(import java.lang.*[모든클래스];) -  java.lang 패키지(String, Object, System, Thread…)의 클래스는 import하지않고도 사용 가능함.  패키지문과 클래스선언 사이에 선언함.  이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.  static import문          static멤버를 사용할 떄 클래스 이름을 생략가능              import static java.lang.Math.random;  import static java.lang.System.  out;        ⇒ out.println(random()); 가능함.            코드가 길어져서 class이름도 거추장스러운순간이 옴. 코드를 짧게하려고 쓰는 방법. 꼭 필요할때만 사용할것. 헷갈릴수도      제어자(modifier)클래스와 클래스의 멤버(멤버 변수, 메소드)에 부가적인 의미 부여 - 형용사                                             접근 제어자      public, protecred, (default)[아무것도안붙임], private      1개만 사용가능              그외      static, final, abstract, transient, synchronized, volatile, strictfp               하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만). 순서는 상관없으나 보통 접근제어자를 맨 왼쪽에 씀      static - 클래스의, 공통적인                            대상          의미                                      멤버변수          모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다  클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.  클래스가 메모리에 로드될 때 생성된다.                          메소드          인스턴스를 생성하지 않고도 호출이 가능한 static메소드가 된다.  static메소드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다                      final - 마지막의, 변경될 수 없는                                      클래스      변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.  그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다              메소드      변경될 수 없는 메소드. final로 지정된 메소드는 오버라이딩을 통해 재정의 될 수 없다.              멤버변수  지역변수      변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.      final class Finaltest{ //조상이 될 수 없는 클래스\tfinal int MAX_SIZE=10; //값을 변경할 수 없는 멤버변수(상수)\t\tfinal void getMaxsize() {  //오버라이딩 할 수 없는 메소드(변경불가)\t\tfinal int LV = MAX_SIZE; //값을 변경할 수 없는 지역변수(상수)\t\treturn MAX_SIZE;\t}}  abstract - 추상의, 미완성의                                      클래스      클래스 내에서 추상 메소드가 선언되어 있음을 의미한다              메소드      선언부만 작성하고 구현부는 작성하지 않은 추상 메소드임을 알린다.      abstract class abstracttest{ //추상 클래스(추상 메소드를 포함한 클래스\tabstract void move(); //추상 메소드(구현부가 없는 메소드)}//미완성상태 - 미완성 설계도. 제품제작불가 = 인스턴스 생성 불가public class Ex_test {\tpublic static void main(String[] args) {\t\tabstracttest a = new abstracttest();  //에러. 추상클래스의 인스턴스 생성 불가\t}}추상 클래스를 상속받아서 완전한 클래스를 만든 후에 객체생성가능접근 제어자(access modifier) - 1개만 사용 가능  private : 같은 클래스 내에서만 접근이 가능하다.  (default) : 같은 패키지 내에서만 접근이 가능하다.  protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.  public : 접근 제한이 전혀 없다.            제어자      같은 클래스      같은 패키지      자손 클래스      전체                  public      o      o      o      o              protected      o      o      o                     (default)      o      o                            private      o                           ❗클래스 앞에는 public or (default)만 붙일 수 있다. (아무것도 안붙이면 default)클래스 멤버들에게는 4가지 모두 붙일 수 있다.package pkg1;class MyParent{\t\tprivate \tint prv; //같은 클래스\t\t\t\t\t\t\tint dft; //같은 패키지\tprotected \tint prt; //같은 패키지, 자손(다른패키지)\t\tpublic \t\tint pub; //접근제한 없음\t\tpublic void printMembers(){\t\tSystem.out.println(prv);\t\tSystem.out.println(dft);\t\tSystem.out.println(prt);\t\tSystem.out.println(pub);\t}}public class MyParentTest {\tpublic static void main(String[] args) {\t\t\tMyParent p = new MyParent();\t\t\tSystem.out.println(p.prv); //에러. 다른 클래스라서\t\t\tSystem.out.println(p.dft);\t\t\tSystem.out.println(p.prt);\t\t\tSystem.out.println(p.pub);\t}}package pkg1;public class MyParentTest{  //접근 제어자 public\t\tprivate \tint prv; //같은 클래스\t\t\t\t\t\t\tint dft; //같은 패키지\tprotected \tint prt; //같은 패키지, 자손(다른패키지)\t\tpublic \t\tint pub; //접근제한 없음\t\tpublic void printMembers(){\t\tSystem.out.println(prv);\t\tSystem.out.println(dft);\t\tSystem.out.println(prt);\t\tSystem.out.println(pub);\t}}class MyParent {  //접근 제어자 default\tpublic static void main(String[] args) {\t\t\tMyParentTest p = new MyParentTest();//\t\t\tSystem.out.println(p.prv); //에러. 다른 클래스라서\t\t\tSystem.out.println(p.dft);\t\t\tSystem.out.println(p.prt);\t\t\tSystem.out.println(p.pub);\t}}package pkg2;import pkg1.MyParentTest; //ctrl +shift + oclass MyChild extends MyParentTest{\tpublic void printMembers(){//\tSystem.out.println(prv); //에러. 다른 클래서//\tSystem.out.println(dft); //에러. 다른 패키지\t\tSystem.out.println(prt); //자손클래스라서 가능\t\tSystem.out.println(pub);\t}}public class MyParentTest2 {\tpublic static void main(String[] args) {\t\tMyParentTest p = new MyParentTest();//\tSystem.out.println(p.prv); //에러. 다른 클래스라서//\tSystem.out.println(p.dft); //에러. 다른 패키지//\tSystem.out.println(p.prt); //에러. 다른 패키지, 자손관계 없음\t\tSystem.out.println(p.pub);\t}}캡슐화와 접근 제어자  접근 제어자를 사용하는 이유                  외부로부터 데이터를 보호하기 위해(캡슐화)          public class Ex_test{  \tprivate int hour;  //접근 제어자를 private로 하여 외부에서 접근 못하도록 막음  \tprivate int minute;  \tprivate int second;        \t  \tpublic int gethour() {  \t\treturn hour;  \t}  \tpublic void sethour(int hour) {  \t\tif(hour&lt;0 || hour &gt;23) return;  \t\tthis.hour=hour;  //메소드를 통해서 지역변수에 간접접근하도록 만들어 놓음  \t}  }  class test {  \tpublic static void main(String[] args) {  \t\tEx_test T=new Ex_test();  \t\tT.sethour(25);  //조건에 안맞아서 값이 바뀌지 않음. = 값이 보호됨  \t\tT.sethour(21);  \t}  }                    다형성(polymorphism)여러가지 형태를 가질 수 있는 능력  조상 타입 참조변수로 자손 타입 객체를 다루는 것. - 타입 불일치.  Tv t = new SmartTv();                  객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?  조상클래스의 참조변수는 자식 클래스의 멤버를 사용할 수 없다.                    자손타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.        SmartTv s = new Tv 불가능 - 없는 멤버를 호출해서 에러날 가능성 있음              참조변수의 형변환                  사용할 수 있는 멤버의 갯수를 조절하는 것. 멤버 갯수 외 요소는 바뀌지 않음  기본형 형변환 - (double)3.5 → (int)3                    조상 자손 관계의 참조변수는 서로 형변환 가능          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFireEngine f = new FireEngine();  \t\tCar c = (Car)f; //조상인 Car타입으로 형변환  \t\tFireEngine f2 = (FireEngine)c; //자손인 FireEngine타입으로 형변환(생략불가)  \t//Ambulance a = (FireEngine)f; //에러. 상속관계가 아닌 클래스간의 형변환 불가  \t}  }                Car c= (Car)f;경우 자손 클래스의 멤버를 조상클래스의 멤버가 사용할 수 없으니 c는 FireEngine의 모든 멤버를 사용할 수 없음(예시의 경우 c.water사용 불가능)        FireEngine f2 = (FireEngine)c는 f→c→f로 변환되었으니 FireEngine의 모든 멤버를 사용할 수 있음.                  class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tCar car = null;  \t\tFireEngine fe = new FireEngine();  \t\tFireEngine fe2 = null;        \t\t  \t\tfe.water();  \t\tcar = fe; //car = (car)fe; 에서 형변환이 생략됨.  //\t\tcar.water(); //에러  \t\tfe2=(FireEngine)car;  //자손타입&lt;-조상타입. 생략불가  \t\tfe2.water();  \t}  }                ❗fe2=(FireEngine)car;의 경우 사용할 수 있는 멤버의 수가 증가해서 불안정함. 그래서 꼭! 형변환을 써줘야함. 생략불가능        ]          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tCar car = null;  \t\tFireEngine fe = new FireEngine();        \t\t  \t\tFireEngine fe2= (FireEngine)car; //조상 -&gt; 자손  \t\tCar car2 = (Car)fe2; // 자손 -&gt; 조상  \t\t//객체가 없어도 형변환에는 문제없음.  \t\t//car2.drive(); //에러  NullPointerException발생. 객체가 없다는 뜻  \t\t//실제 인스턴스가 뭔지가 중요함.        \t\t  \t\tCar c2 = new Car();  \t\tFireEngine fe3 = (FireEngine)c2; // 형변환 실행 에러. java.lang.ClassCastException  \t\tfe3.water(); //컴파일 ok. 리모컨에는 water가 있음.  \t\t//객체를 Car로 만들어서 객체안에 water자체가 없음!! 그래서 에러나는거임!!  \t}  }                      instanceof 연산자          참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환      형변환 전에 반드시 instanceof로 확인해야 함              인스턴스의 원래 기능을 모두 사용하려고 형변환을 함.          class Car{  \tString Color;  \tint door;        \t  \tvoid drive() { //운전하는 기능  \t\tSystem.out.println(\"brrrrr...~~\");  \t}  \tvoid stop() {  \t\tSystem.out.println(\"stop!!\");  \t}  }  class FireEngine extends Car{  \tvoid water() {  \t\tSystem.out.println(\"water!!\");  \t}  }  class Ambulance extends Car{        \t  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFireEngine fe = new FireEngine();        \t\t  \t\tSystem.out.println(fe instanceof Object); //true. FireEngine의 조상  \t\tSystem.out.println(fe instanceof Car); //true. FireEngine의 조상  \t\tSystem.out.println(fe instanceof FireEngine); //true  \t\tObject obg = (Object)fe;  \t\tCar c2 = (Car)fe;  \t\tFireEngine fe2 = (FireEngine)fe;  \t\t}  \tCar c = new Car();  \tvoid doWork(Car c) {  \t\tif(c instanceof FireEngine) {//형변환이 가능한지 확인  \t\t\tFireEngine fe = (FireEngine)c; //형변환  \t\t\tfe.water();  \t\t}  \t\telse if (c instanceof Ambulance) {  \t\t\tAmbulance a = (Ambulance)c;  \t\t}  \t}        \t  }                      다형성의 장점                  다형적 매개변수 - 매개변수의 다형성                              참조형 매개변수는 메소드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.              class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  }  class Tvvv extends Product{}  class Computer extends Product{}  class Audio extends Product{}              class Buyer { //물건사는사람  \tint money = 10000; //소지금  \tint bonusPoint = 0; //누적 적립금            \t  //\tvoid buy(Tv t1) {  //\t\tmoney -= t1.price;  //\t\tbonusPoint += t1.bonusPoint;  //\t}  //\tvoid buy(Computer c) {  //\t\tmoney -= c.price;  //\t\tbonusPoint += c.bonusPoint;  //\t}  //\tvoid buy(Audio a) {  //\t\tmoney -= a.price;  //\t\tbonusPoint += a.bonusPoint;  //\t}  \tvoid buy(Product p){  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();            \t\t  //\t\tTvvv tv = new Tvvv();  //\t\ttv.price=5000;  //\t\ttv.bonusPoint= (int) (tv.price*0.01);  //\t\tb.buy(tv);  //\t\tComputer com = new Computer();  //\t\tcom.price=3000;  //\t\tcom.bonusPoint= (int) (com.price*0.01);  //\t\t  //\t\tb.buy(com);            \t\t  \t\tProduct p1= new Tvvv();  \t\tProduct p2= new Computer();  \t\tProduct p3= new Audio();  \t\tp1.price=5000;  \t\tp1.bonusPoint=(int) (5000*0.01);  \t\tb.buy(p1);  \t\tp2.price=3000;  \t\tp2.bonusPoint=(int)(p2.price*0.01);  \t\tb.buy(p2);  \t\tSystem.out.println(b.money);  \t\tSystem.out.println(b.bonusPoint);            \t\t  \t}            \t  }                          class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  \tProduct(int price){  \t\tthis.price=price;  \t\tbonusPoint = (int) (price/10.0);  \t}  }  class Tv extends Product{  \tTv() {  \t\t//조상 클래스의 product(int price)를 호출  \t\tsuper(100); //100만원  \t}  \t//Object 클래스의 toString()을 오버라이딩  \tpublic String toString() {return \"tv\";}  }  class Computer extends Product{              \tComputer() {  \t\tsuper(200);  \t}  \tpublic String toString() {return \"computer\";}  }  class Audio extends Product{              \tAudio() {  \t\tsuper(50);  \t}  \tpublic String toString() {return \"audio\";}  }              class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금            \t  \tvoid buy(Product p){   \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}            \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();            \t\t  \t\tb.buy(new Tv()); //Product tv1 = new Product; b.buy(tv1)  \t\t//짧게 쓸 수 있으나 참조변수가 없어서 리모컨을 사용할 수 없음. b.buy에서 임시로 쓰는 것.  \t\tb.buy(new Computer()); //Product com1 = new Product; b.buy(com1)            \t\t  \t\tSystem.out.println(\"현재 남은 돈은 \"+b.money+\"만원입니다\");  \t\tSystem.out.println(\"현재 보너스 점수는 \"+b.bonusPoint+\"점 입니다.\");  \t}  }                                      ⇒장점 1.하나의 메소드로 여러타입의 객체를 받을 수 있음                    하나의 배열로 여러 종류의 객체를 다루기        : 조상 타입의 배열에 자손들의 객체를 담을 수 있다. =        장점2. 하나의 배열에 여러종류의 객체를 저장할 수 있음          // product p1 = new tv();  // product p2 = new computer();  // product p3 = new audio();          Product p[] = new Product();  p[0] = new tv();  p[1] = new computer();  p[2] = new audio();                ]          class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금        \t  \tProduct cart[] = new Product[10]; //구매한 물건을 담을 배열 (장바구니)        \t  \tint i = 0;        \t  \tvoid buy(Product p){  \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}        \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tcart[i++] = p; //cart에 담고 배열+1해서 새 장바구니칸에 담고..  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  }                  public class Vector extends AbstractList //Vector = 가변배열기능. object배열을 멤버로 가지고 있음.  \t\timplements List, Cloneable, java.io.serializable{  \tprotected Object elementDate[];  }                  class Product{  \tint price; //제품가격  \tint bonusPoint; //포인트  \tProduct(int price){  \t\tthis.price=price;  \t\tbonusPoint = (int) (price/10.0);  \t}  }  class Tvvv extends Product{  \tTvvv() {  \t\tsuper(100); //100만원  \t}  \tpublic String toString() {return \"tv\";}  }  class Computer extends Product{          \tComputer() {  \t\tsuper(200);  \t}  \tpublic String toString() {return \"computer\";}  }  class Audio extends Product{          \tAudio() {  \t\tsuper(50);  \t}  \tpublic String toString() {return \"audio\";}  }          class Buyer { //물건사는사람  \tint money = 1000; //소지금  \tint bonusPoint = 0; //누적 적립금        \t  \tProduct cart[] = new Product[10]; //구매한 물건을 담을 배열 (장바구니)        \t  \tint i = 0;        \t  \tvoid buy(Product p){  \t\tif(money&lt;p.price) {  \t\t\tSystem.out.println(\"잔액이 부족하여 물건을 구매할 수 없습니다.\");  \t\t\treturn;  \t\t}        \t  \t\tmoney -= p.price;  \t\tbonusPoint += p.bonusPoint;  \t\tcart[i++] = p; //cart에 담고 배열+1해서 새 장바구니칸에 담고..  \t\tSystem.out.println(p+\"을/를 구매하셨습니다.\");  //여기서 p는 p.toString과 같음  \t}  \tvoid summary() { //구매 물품 정보 요약표시  \t\tint sum = 0; //구입한 물품의 가격 합계  \t\tString itemList = \"\"; //구입한 물품 목록        \t\t  \t\t//반복문을 사용해 구입한 물품의 총 가격과 목록을 만든다.  \t\tfor(int i=0; i&lt;cart.length;i++) {  \t\t\tif(cart[i]==null) break;  \t\t\tsum+=cart[i].price;  \t\t\titemList += cart[i]+\", \";  \t\t}  \t\tSystem.out.println(\"구입하신 물건의 총 금액은 \"+sum+\"만원입니다.\");  \t\tSystem.out.println(\"구입하신 제품은 \"+itemList+\"입니다.\");  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tBuyer b = new Buyer();        \t\t  \t\tb.buy(new Tvvv(  ));  \t\tb.buy(new Computer());  \t\tb.buy(new Audio());        \t\t  \t\tSystem.out.println(\"현재 남은 돈은 \"+b.money+\"만원입니다\");  \t\tSystem.out.println(\"현재 보너스 점수는 \"+b.bonusPoint+\"점 입니다.\");  \t\tb.summary();  \t}  }                    추상클래스(abstract calss): 미완성 설계도. 미완성 메소드 -구현부(몸통{})이 없는 메소드- 를 갖고 있는 클래스. 객체 생성 불가능. 일반클래스인데 미완성 메소드를 가지고 있는 것abstract 리턴타입 메소드 이름();abstract class Player { //추상클래스(미완성 클래스)\t\tabstract void play(int pos); //몸통{}이 없는 추상메소드\tabstract void stop(); //몸톰{}이 없는 추상메소드}\t//추상클래스가 다른 클래스를 작성하는데 도움이 됨.//추상클래스는 상속을 통해 완성해야 객체 생성가능class AudioPlayer extends Player{\tvoid play(int pos) {\t\tSystem.out.println(pos+\"위치부터 play합니다.\");\t\t}//추상메소드 구현 = 몸통만들어줌.\tvoid stop() {\t\tSystem.out.println(\"재생을 멈춥니다.\");\t}//추상메소드 구현=몸통 만들어줌}public class PlayerTest {\tpublic static void main(String[] args) {//\t\tPlayer p = new Player();  //에러. 추상클래스의 인스턴스화 불가\t\tAudioPlayer ap = new AudioPlayer(); //인스턴스 생성 가능.\t\tap.play(100);\t\tap.stop();\t\tPlayer p2 = new AudioPlayer(); //Player가 조상타입이라 가능함. 다형성\t\tp2.play(500);\t\tp2.stop();\t\t}\t}abstract class Player{\tboolean pause; //일시정지상태를 저장하기위한 변수\tint currentPos;//현재 play되고 있는 위치를 저장하기 위한 변수\t//플레이어의 종류마다 플레이 방식이나 멈추는 방식이 다르니 미리 만들어봤자 의미가 없음.\t//중요한건데 후에 상속을 만들 때 빠질까봐 강제하는 것임.\tPlayer(){  //추상클래스라도 생성자가 있어야함.\t\tpause = false;  \t\tcurrentPos = 0;\t}\t//지정된 위치(pos)에서 재생을 시작하는 기능이 수행하도록 작성되어야 한다.\tabstract void play(int pos); //추상메소드\t//재생을 즉시 멈추는 기능을 수행하도록 작성되어야한다.\tabstract void stop(); //추상메소드\t\tvoid play() { //인스턴스메소드\t\tplay(currentPos); //추상메소드를 사용할 수 있다.. 메소드는 선언부만 알면 호출가능하므로 추상메소드도 호출가능함.\t//상속을 통해 자손이 완성될 예정이라 사용할 수 있다. (지금 호출은 안됨. 상속을 통해 완성된 다음 호출 가능)\t}}public class ex {\tpublic static void main(String[] args) {\t\t}\t}  꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우      여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.      abstract class Unit{  \tint x,y;  \tabstract void move(int x, int y);  \tvoid stop() {  \t\t//현재 위치에 정지  \t\t};  \t}  class Marine extends Unit { //보병  \tvoid move(int x, int y) {  \t\t//지정된 위치로 이동  \t\tSystem.out.println(\"marine [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid stimPack() {  \t\t//스팀팩 사용  \t}  }  class Tank extends Unit{  \tvoid move(int x, int y) {  \tSystem.out.println(\"Tank [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid changeMode() {}; //공격모드로 변경  }  class Dropship extends Unit {  \tvoid move(int x, int y) {  \tSystem.out.println(\"Dropship [x = \"+x+\", y = \"+y+\"]\");  \t}  \tvoid load() {}// 선택된 대상 태우기  \tvoid unload() {}//선택대상 내리기  }  public class ex {      \tpublic static void main(String[] args) {  //\t\tUnit[] group = new Unit[3];  //\t\tgroup[0]=new Marine();  //\t\tgroup[1]=new Tank();  //\t\tgroup[2]=new Dropship();  \t\tUnit group[] = {new Marine(), new Tank(), new Dropship()};    \t\t  \t\tfor(int i=0;i&lt;group.length;i++) {  \t\t\tgroup[i].move(100, 200);  \t\t\t//group의 타입은 Unit[], group[0], group[1], group[2]  \t\t}  \t\tObject group2[] = {new Marine(), new Tank(), new Dropship()};  \t\tfor(int i=0;i&lt;group2.length;i++) {  //\t\t\tgroup2[i].move(100, 200);  \t\t\t//Object는 최상위 객체라서 구현은 가능하나 move를 멤버로 가지고있지 않아서 에러남  \t\t}  \t}  }            추상화(불명확)←→구체화(명확)          추상화된 코드는 구체화된 코드보다 유연함. 변경에 유리  구체적인 코드 - GregorianCalendar cal = new GregorianCalendar();  추상적인 코드 = Calendar cal = Calendar.getInstance : Calendar 자손 객체를 반환해 cal에 대입. ⇒ Calendar객체가 무엇을 반환할 지 불명확함.          import java.util.Calendar;      private static Calendar createCalendar(TimeZone. Locale aLocale) {  \tif(caltype != null) {  \t\tswitch(caltype) {  \t\tcase \"buddhist\": //불교력  \t\t\tcal = new BuddhistCalendar(zone, aLocale);  \t\t\tbreak;  \t\tcase \"japanese\" : //일본력  \t\t\tcal = new JapanesImperialCalendar(zone, aLocale);  \t\t\tbreak;  \t\tcase \"gregory\" : //서양력  \t\t\tcal = new GregorianCalendar(zone, aLocale);  \t\t\tbreak;  \t\t}  \t}  }  public class ex {      \tpublic static void main(String[] args) {  //\t\tGregorianCalendar cal = new GregorianCalender(); 구체적  \t\tCalendar cal = Calendar.getInstance();//추상적  \t}  }      인터페이스(interface)추상메소드의 집합(프로그래밍관점)      구현된 것이 하나도 없는 설계도. 껍데기(모든 멤버가 public)    interface 인터페이스이름{    public static final 타입 상수이름 = 값;    public abstract 메소드이름(매개변수목록); }      interface PlayingCard{  \t//상수  \tpublic static final int SPADE =4;  \tfinal int DIAMOND = 3; //public static 생략됨  \tstatic int HAEART = 2; //public final 생략됨  \tint CLOVER = 1; //public static final      \t//추상메소드  \tpublic abstract String getCardNumber();  \tString getCaedKind(); //public abstract생략됨.  \t//public static final은 예외없이 모두 적용이기때문에 적지않아도 자동으로 붙여줌  \t}  public class ex {      \tpublic static void main(String[] args) {  \t}  }        [!important]추상클래스와 인터페이스의 차이점인터페이스는 인스턴스변수를 가질 수 없음!  인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상이 아님)  다중 상속 가능. (추상메소드는 구현부{}가 없어서 충돌해도 문제 없음) - 조상이 여러개여도 가능.  인터페이스는 지역변수를 가지지 못함(추상클래스는 가능)      인터페이스의 구현 : 인터페이스에 정의된 추상메소드를 완성하는 것.  class 클래스 이름 implements 인터페이스 이름{ 인터페이스에 정의된 모든 추상메소드를 구현해야 함. } - 일부만 구현하는 경우, 클래스앞에 abstract를 붙여야함.  = 추상클래스 완성과 동일      interface Fightable{ //인터페이스  \tvoid move(int x, int y);  \tvoid attack(Unit u);  }  class Fighter implements Fightable{ //인터페이스 구현  \tpublic void move(int x, int y) {  \t\tSystem.out.println(\"x = \"+x+\", y = \"+y);  \t}  \tpublic void\tattack(Unit u) {  \t\tSystem.out.println(\"Unit = \"+u);  \t}  }  abstract class Player{ //추상클래스  \tabstract void play(int pos);  \tabstract void stop();  }  class AudioPlayer extends Player{ //추상클래스 구현  \tvoid play(int pos) {  \t\tSystem.out.println(pos);  \t}  \tvoid stop() {  \t\t//내용  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {    \t\t  \t}  }            인터페이스를 이용한 다형성          인터페이스도 구현 클래스의 부모임      인터페이스 타입 매개변수는 인터페이스 구현한 클래스의 객체만 가능      인터페이스를 메소드의 리턴타입으로 지정가능.          import java.io.ObjectInputStream.GetField;      abstract class Unit{  \tint x,y;  \tabstract void move(int x, int y);  \tvoid stop() {  \t\tSystem.out.println(\"멈춤\");  \t};  }  interface Fightable{ //인터페이스  \tvoid move(int x, int y); //public abstract가 생략됨  \tvoid attack(Fightable f); //public abstract가 생략됨  }  class Fighter extends Unit implements Fightable {   \tpublic void move(int x, int y) { //오버라이딩 규칙: 조상(public)보다 접근제어자가 좁으면 안됨.  \t\tSystem.out.println(\"[\"+x+\", \"+y+\"]로 이동\");  \t}  \tpublic void attack(Fightable f) //매개변수 타입이 인터페이스.= 이 인스턴스를 구현한 class의 객체만 가능  \t//attack메소드는 매개변수로 Fightable인터페이스를 구현한 class의 객체만 받음  \t{   \t\tSystem.out.println(f+\"를 공격\");  \t}   \t//싸울 수 있는 상대 소환  \tFightable getFightable(){  \t\tFighter f = new Fighter();   \t\treturn f;  //Fighter가 Fightable을 상속받고있어서 형변환이 가능하기때문에 f는 Fighter지만 사용 가능  \t}  }  public class Ex_test {  \tpublic static void main(String[] args) {  \t\tFighter f = new Fighter();  \t\tFightable ff = f.getFightable();    \t\t  \t\tf.move(100, 200);  \t\tf.attack(new Fighter()); //toString이 나옴  \t\tf.stop();    \t\t  \t\tSystem.out.println(\"-----------------\");  \t\tUnit u = new Fighter();  \t\tu.move(100, 200);  \t\tu.stop();  //\t\tu.attack(new Fighter()); //에러, Unit에 attack이 없음    \t\t  \t\tSystem.out.println(\"-----------------\");  \t\tFightable f2 = new Fighter();  \t\tf2.move(100, 200);  \t\tf2.attack(new Fighter()); //toString이 나옴  //\t\tf2.stop(); //Fightable에 stop이 없음  \t}  }            장점          두 대상(객체)간의 ‘연결, 대화, 소통’을 돕는 ‘중간역할’을 한다      선언과 구현을 분리시킬수 있게됨.(변경에 유리)      개발시간 단축      변경에 유리한 설계      표준화 가능 (데이터베이스회사들이 JDBC에 맞춰 데이터베이스를 개발함. 자바개발자는 JDBC를 기준으로 개발 )      서로 관계없는 클래스들의 관계를 맺어줄 수 있다. : 내가 원하는 클래스만 모아서 인터페이스로 묶을 수 있음      인터페이스덕분에 한 클래스를 변경해도 다른 클래스는 안바꿔도 동작함(느슨한 결함)        직접적 관계      class A {  \tpublic void method(C c){  \t\tc.methodC();  \t}  }  class B {  \tpublic void methodB(){  \t\tSystem.out.println(\"methodB()\");  \t}  }  class C{  \tpublic void methodC(){  \t\tSystem.out.println(\"method() in C\");  \t}  }  public class InterfaceTest {      \tpublic static void main(String[] args) {  \t\tA a = new A();  \t\ta.method(new C()); //A가 B에 의존  \t}      }        간접적 관계      class A {  \tpublic void method(I i){  \t\ti.method();  \t}  }  interface I { void method();}       class B implements I{  \tpublic void method(){  \t\tSystem.out.println(\"methodB()\");  \t}  }  class C implements I{  \tpublic void method(){  \t\tSystem.out.println(\"method() in C\");  \t}  }  public class InterfaceTest {      \tpublic static void main(String[] args) {  \t\tA a = new A();  \t\ta.method(new B()); //A가 B에   \t}  }        디폴트 메소드                  인터페이스에 새로운 메소드(추상메소드)를 추가하기 어려움 - 한 인터페이스에 추상메소드가 추가되면 연관된 모든 클래스에 추가된 추상메소드 구현을 해주어야함 ⇒ 해결책:디폴트메소드(default method)        interface MyInterface {        void method();        default void newMethod();{ } }            디폴트메소드 = 인스턴스메소드 (인터페이스 원칙 위반 = 예외)      디폴트메소드가 기존의 메소드와 충돌할때?                              여러 인터페이스의 디폴트 메소드간의 충돌 — 인터페이스를 구현한 클래스에서 디폴트메소드를 오버라이딩한다                                디폴트메소드와 조상클래스의 메소드간의 충돌 — 조상클래스의 메소드가 우선되어 먼저 상속되고, 디폴트메소드는 무시된다.                                static 메소드      내부클래스(inner class) : 클래스 안에 클래스          객체생성없이도 상위클래스의 멤버에 접근가능      코드의 복잡성을 줄일 수 있음. (캡슐화)          class AAA{ //BBB의 외부클래스  \tint i=100;  \tBBB b = new BBB();  \tclass BBB{///AAA의 내부클래스  \t\tvoid method() {  //\t\t\tAAA a = new AAA();  //AAA의 내부클래스라 해줄필요없음  \t\t\tSystem.out.println(i); //객체생성없이 접근가능  \t\t}  \t}  }  class CCC{  }  public class ex {      \tpublic static void main(String[] args) {  \t\tAAA a = new AAA();  \t\ta.b.method();  \t}  }                      내부클래스의 종류와 유효범위(scope)는 변수와 동일                                            내부클래스              특징                                                          인스턴스 클래스  (instance class)              외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.                                      스태택 클래스  (static class)              외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메소드에서 사용될 목적으로 선언된다.                                      지역 클래스  (local class)              외부클래스의 메소드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.                                      익명 클래스  (anonymosus class)              클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)                                                내부클래스의 제어자는 public, private, (default), protected 4가지 사용가능.                  public class ex {          \tclass InterfaceInner{  \t\tint iv = 100;  //\t\tstatic int cv = 100; //에러, static변수 선언불가  \t\t//static은 객체없이 생성할 수 있어야하는데 인스턴스안에 들어가있어서 객체를 만들어야 사용할 수 있게됨. 모순이라 에러표시  \t\tfinal static int CONST = 100; //final static은 상수이므로 허용  \t}        \t  \tstatic class staticInner{  \t\tint iv = 200;  \t\tstatic int cv = 200; //static클래스만 static멤버를 정의할 수 있다.  \t}  \tvoid mymethod() {  \t\tclass LocalInner{  \t\t\tint iv = 300;  //\t\t\tstatic int cv = 300; //에러, static변수를 선언할 수 없다  \t\t\tfinal static int CONST = 300; //final static은 상수이므로 허용  \t\t\t//final뒤에 static이 오는 경우는 어떤 조건에서도 같은 값일 경우.   \t\t\t//객체마다 값이 다를수도 있으면 final만 쓰면됨(ex.카드의 숫자와 무늬)  \t\t}  \t\tint i = LocalInner.CONST; //지역내부클래스의 static상수는 메소드 내에서만 사용가능  \t}  \tpublic static void main(String[] args) {  \t\tSystem.out.println(InterfaceInner.CONST);  \t\tSystem.out.println(staticInner.cv);  //\t\tSystem.out.println(LocalInner.CONST); //지역내부클래스의 static상수는 메소드 외에서는 사용 불가능  \t}  }                  public class ex {          \tclass InstanceInner{}  \tstatic class StaticInner{}        \t  \tInstanceInner iv = new InstanceInner(); //인스턴스 멤버끼리는 직접 접근가능  \tstatic StaticInner cv = new StaticInner(); //static멤버끼리는 직접 접근가능  //\tstatic StaticInner cv2 = new InstanceInner(); //static멤버가 instance멤버 접근 불가능. 반대는 가능          \tstatic void staticmethod() { //static멤버는 인스턴스에 직접접근불가  //\tInstanceInner obj1 = new InstanceInner();  \t\tStaticInner obj2 = new StaticInner();        \t\t  \t\t//이렇게까지 쓰지는 않는데 일단 예시로  \t\tex outer = new ex(); //인스턴스 클래스는 외부클래스를 먼저 생성해야 생성가능  \t\tInstanceInner obj1 = outer.new InstanceInner();  \t}  \tvoid instanceMethod() {//인스턴스메소드에서는 인스턴스멤버와 static멤버 모두 접근가능  \t\tInstanceInner obj1 = new InstanceInner();  \t\tStaticInner obj2 = new StaticInner();  //\t\tLocalInner lv = new LocalInner(); //지역 내부클래스는 외부에서 접근 불가  \t}  \tvoid myMethod() {  \t\tclass LocalInner{}  \t\tLocalInner lv = new LocalInner();  \t}  \tpublic static void main(String[] args) {  \t}  }                  class Outer{  \tprivate int outerIv= 0;  \tprivate static \tint outerCv=0;        \t  \tclass InstanceInner{  \t\tint iiv = outerIv;//외부클래스의 private멤버도 접근가능  \t\tint iiv2 = outerCv;   \t}  \tstatic class StaticInner{  //\t\tint siv = outerIv; //static클래스는 외부클래스의 인스턴스멤버에 접근 불가  \t\tstatic int scv = outerCv;  \t}  \tvoid mymethod() {  \t\tint lv = 0;  \t\tfinal int LV = 0;  //final생략 가능        \t\t  //\t\tlv=3;//밑에 int liv3 = lv;에러내려고 적음. 값이 바뀌었으니 변수로 처리해서 에러남  \t\tclass LocalInner{ //지역내부클래스를 감싸고있는 메소드의 상수만 사용가능  \t\t\tint liv = outerIv;  \t\t\tint liv2 = outerCv;  \t\t\t//내부클래스의 객체가 지역변수보다 더 오래 존재가능   \t\t\t//외부클래스의 지역변수는 final이 붙은 변수(상수)만 접근 가능  \t\t\t//JDK1.8부터는 변수인데 값이 안바뀌는 것도 상수로 간주. (에러x)  \t\t\tint liv3 = lv;  \t\t\tint liv4 = LV;         \t\t\t  \t\t\tvoid method() {  \t\t\t\tSystem.out.println(lv);  \t\t\t}        \t\t\t  \t\t}  \t}  }  public class ex {  \tpublic static void main(String[] args) {  \t}  }                          인스턴스 내부클래스를 사용하려면 외부클래스의 객체를 먼저 만들고 인스턴스내부클래스의 객체를 만들어야 함      class Outer {  \tclass instanceInner {  \t\tint iv =100;  \t}  \tstatic class StaticInner {  \t\tint iv = 200;  \t\tstatic int cv = 300;  \t}  \tvoid myMethod() {  \t\tclass LocalInner{  \t\t\tint iv = 400;  \t\t}  \t}  }  public class ex {  \tpublic static void main(String[] args) {  \t\tOuter oc  = new Outer(); //외부클래스의 인스턴스를 먼저 생성해야 인스턴스클래스의  \t\tOuter.instanceInner ii = oc.new instanceInner(); //인스턴스를 생성가능    \t\t  \t\tSystem.out.println(\"ii.iv : \"+ii.iv);  \t\tSystem.out.println(\"Outer.StaticInner.cv : \"+Outer.StaticInner.cv);    \t\t  \t\t//스태틱 내부클래스의 인스턴스는 외부클래스를 먼저 생성하지않아도 된다  \t\tOuter.StaticInner si = new Outer.StaticInner();  \t\tSystem.out.println(\"ii.iv : \"+si.iv);    \t\t  \t}  }          class Outer {  \tint value = 10; //Outer.this.value 외부클래스의 iv    \t  \tclass Inner{  \t\tint value = 20; //this.value 내부클래스의 iv    \t\t  \t\tvoid method() {  \t\t\tint value = 30;  \t\t\tSystem.out.println(\"           value : \"+value);  \t\t\tSystem.out.println(\"      this.value : \"+this.value);  \t\t\tSystem.out.println(\"Outer.this.value : \"+Outer.this.value);    \t\t\t  \t\t}  \t}    \t  }  public class ex {  \tpublic static void main(String[] args) {  \t\tOuter outer = new Outer();  \t\tOuter.Inner inner = outer.new Inner();  \t\tinner.method();    \t\t  \t}  }            익명클래스(anonymous class)    : 이름이 없는 일회용 클래스. 정의와 생성을 동시에 함(조상이름을 대신 씀)  new 조상클래스 이름(){ 멤버선언 } / new 구현인터페이스이름() { 멤버선언 }      public class ex {  \tObject iv = new Object() {void method2(){}}; //익명클래스  \tstatic Object cv = new Object() {void method2(){}}; //익명클래스    \t  \tvoid Mymethod() {  \t\tObject lv = new Object() { void method2() {}}; //익명클래스  \t}      \tpublic static void main(String[] args) {  \t}  }          import java.awt.*;  import java.awt.event.*;  //awt : 자바의 윈도우 프로그래밍 도구.       public class ex {  \tpublic static void main(String[] args) {  \t\tButton b = new Button(\"start\");  //\t\tb.addActionListener(new EventHandler()); //객체생성  \t\tb.addActionListener(new AcionListener/*조상 OR 인스턴스 이름*/() { //클래스의 정의와 객체생성을 동시에  \t\t\tpublic void actionPerformed(ActionEvent e) {  \t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");  \t\t\t}  \t\t}); //객체생성    \t\t  \t\t//위랑 같아보이지만 다른 클래스임. 일회용클래스이기때문.  \t\tb.addActionListener(new AcionListener/*조상 OR 인스턴스 이름*/() { //클래스의 정의와 객체생성을 동시에  \t\t\tpublic void actionPerformed(ActionEvent e) {  \t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");  \t\t\t}  \t\t}); //객체생성    \t\t  \t\t}  \t}  //class EventHandler implements AcionListener{ //클래스 정의.   //\tpublic void actionPerformed(ActionEvent e) {  //\t\tSystem.out.println(\"ActionEvent occurred!!!\");  //\t}  //}      "
  },
  
  {
    "title": "객체지향(oop)",
    "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5(OOP)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-08-01 00:00:00 +0900",
    





    
    "snippet": "객체지향 언어 = 프로그래밍 언어 + 객체지향개점(규칙)  캡슐화  상속  추상화      다형성    class : 객체를 정의해 놓은 것, 객체를 생성하는데 사용함. (설계도)  = 데이터 + 함수(method) (서로 관련있는 것 끼리 묶음. 데이터만 묶으면  구조체)  기본적으로 하나의 소스파일에 하나의 class를 작성하는것이 바람직하나, 여...",
    "content": "객체지향 언어 = 프로그래밍 언어 + 객체지향개점(규칙)  캡슐화  상속  추상화      다형성    class : 객체를 정의해 놓은 것, 객체를 생성하는데 사용함. (설계도)  = 데이터 + 함수(method) (서로 관련있는 것 끼리 묶음. 데이터만 묶으면  구조체)  기본적으로 하나의 소스파일에 하나의 class를 작성하는것이 바람직하나, 여러 class를 작성할수도 있음.          public class가 있는 경우, 소스파일의 이름은 반드시 public class(한소스파일에서 한번만 사용 가능)의 이름과 일치해야함      public class가 없는 경우, 소스파일의 이름은 class 중 어느 것을 사용해도 무방함. (main method가 있는부분은 동일해야함. 아니면 수동으로 지정가능)            객체(인스턴스와 거의 같은 말임) : 실제로 존재하는 사물 또는 개념. 객체가 가진 기능과 속성에따라 용도가 다름. 모든 인스턴스를 대표하는 일반적 용어. 클래스를 인스턴스화하면 객체(인스턴스)가 됨.  (제품) - 속성(변수) + 기능(메소드)                  class 생성        class Tv { String color ………. (6개의 멤버 = 구성 6개) }                    객체 생성 : 변수명 = new 클래스명();        Tv t = new Tv();                    사용        t.channel1 = 7; t.channelDown(); sout(”현재 “+t.channel1+번입니다”)         class Tv { \t//tv의 속성 \tString color; \tboolean power; \tint channer1;        \t \t//tv의 기능 \tvoid power(){ \t\tpower !=power; //티비 온오프 \t} \tvoid channer1Up() { \t\t++channer1; \t} \tvoid channer1Down() { \t\t--channer1; \t} } public class Ex6_1 {         \tpublic static void main(String[] args) { \t\tTv t = new Tv(); \t\tt.channer1=7; \t\tt.channer1Down(); \t\tSystem.out.println(\"현재 \"+t.channer1+\"번 입니다.\");        \t\t //\t\tTv t2 = new Tv(); //\t\tSystem.out.println(\"현재 \"+t2.channer1+\"번 입니다.\"); //0번        \t\t \t\tTv t2 = t; \t\tSystem.out.println(\"현재 \"+t2.channer1+\"번 입니다.\"); //6번 \t}         }                                    객체 배열 == 참조변수 배열  tv tvarr[] = new tv[3]; == tv tvarr[] = {new tv(), new tv(), new tv()};        tvatrr[0] = new tv(); tvatrr[1] = new tv(); tvatrr[2] = new tv();              인스턴스(객체와 거의 같은 말임) : 특정 class로부터 생성된 객체      선언위치에 따른 변수의 종류      class variable {  \tint iv;  \tstatic int cv;      \tvoid method() {  \tint lv = 0;  \t}  } //이 전체가 class 영역                      변수                  클래스 영역(선언문만 가능, 순서 상관x)                          iv (intance variable), cv(static 있어서 class)                                메소드 영역 - lv(Local variable)                                                    변수의 종류              선언 위치              생성 시기                                                          class 변수              class 영역              클래스가 메모리에 올라갈 때(import할때)                                      instance 변수              class 영역              인스턴스가 생성되었을 때                                      지역변수              class영역 이외의 영역  (메소드, 생성자, 초기화 블럭 내부)              변수 선언문이 수행되었을 때                                      객체 - instance 변수를 묶어놓은 것.                  [!important]CPU ←RAM ←SSD or HDD - ssd, hdd에서 바로 cpu못가니까 ram을 둠. 파일을 읽는다고 하면(loading) 메모리(ram)에 얹는다고 표현함. = 작업을 하려면 class가 메모리에 올라간다고 표현함.ram은 컴퓨터를 끄면 데이터가 날아가니까 저장(save)하려면 다시 디스크로 옮겨야함즉, class변수는 아무때나 사용이 가능하고 instance는 객체생성을 해야 사용 가능함. 그래서!! class는 객체생성이 필요없고 instance는 객체생성이 필요함.                          class 변수 : 공통 속성(객체 모두 같은 값) ??변경하면 까다로워지니까          instance 변수 : 개별 속성(객체마다 다른 값도 가능) ??복사개념이라 수정쉬워서                  class Card{  \tString kind; //무늬  \tint number; //숫자          \tstatic int width = 100; //폭  \tstatic int height = 250;  }          public static main void(String[] args){  \tCard c = new Card();  \tc.kind = \"heart\";  \tc.number = 5;          \t// c.width = 200;  오류는 안나는데 이렇게하면 안됨!! 객체별로 값이 달라짐  \t// c.height = 300; 오류는 안나는데 이렇게하면 안됨!! 객체별로 값이 달라짐  \tCard.width = 200;  \tCard.height = 300; //class값이 전부 변경돼서 객체별로 값이 같아짐  }                  class Card{  \tString kind; //무늬  \tint number; //숫자          \tstatic int width = 100; //폭  \tstatic int height = 250;  }  public class Ex6_3 {          \tpublic static void main(String[] args) {  \t\tSystem.out.println(\"Card.width = \"+Card.width);  \t\tSystem.out.println(\"Card.height = \"+Card.height); //객체 생성없이 사용 가능        \t\t  \t\tCard c1 = new Card();  \t\tc1.kind = \"Heart\";  \t\tc1.number = 7;        \t\t  \t\tCard c2 = new Card();  \t\tc2.kind = \"Spade\";  \t\tc2.number = 4;        \t\t  \t\tSystem.out.println(\"c1은 \"+c1.kind+\", \"+c1.number+\"이며, 이 카드의 크기는 (\"+c1.width+\", \"+c1.height+\")\");  \t\tSystem.out.println(\"c2은 \"+c2.kind+\", \"+c2.number+\"이며, 이 카드의 크기는 (\"+c2.width+\", \"+c2.height+\")\");  \t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경합니다\");        \t\t  //\t\tc1.width=50;  //\t\tc1.height=80; //c1이 인스턴스지만 width와 height가 class기 때문에 모두 바뀜  \t\t//오해하기 쉬운 코드니까 권장하지 않는 코드임.        \t\t  \t\tCard.width=50;  \t\tCard.height=80;  \t\tSystem.out.println(\"c1은 \"+c1.kind+\", \"+c1.number+\"이며, 이 카드의 크기는 (\"+c1.width+\", \"+c1.height+\")\");  \t\tSystem.out.println(\"c2은 \"+c2.kind+\", \"+c2.number+\"이며, 이 카드의 크기는 (\"+c2.width+\", \"+c2.height+\")\");  \t}          }                                      메소드(=블랙박스) : 문장들을 묶어놓은 것. (class안에 있어야함)  선언부 { 구현부 }                                          값(입력)을 받아서 처리하고, 결과를 반환(출력) - 함수랑 똑같다고 보면됨(함수는 독립적이라 class안에 없어도됨.  int add(int x, int y){  int result = x+y;  return result; }                                                      반드시 return으로 마무리 지어야하는데 값이 void일경우 return 생략 가능                                                        메소드 = 블랙박스??                    별 이유없고 걍..별로 알고싶지않아서 println이 어떻게 동작하는지 궁금함? ㄴㄴㅋㅋ                                                              실행흐름                                  인스턴스 생성                  main메소드안에서 메소드 호출                  메소드 {}안의 문장 수행                  호출 메소드로 돌아와서 main메소드안의 메소드로 돌아와서 이후 문장 수행                                            하나의 메소드에 하나의 기능만 수행하도록 작성할 것.              장점                                  코드 중복 줄이기                  코드 관리 용이                  코드 재사용 용이                  코드가 간결해서 이해하기 쉬워진다                                            지역 변수 : 메소드 안에 선언된 변수 (매소드가 끝나면 없어지기때문에 다른 메소드에 이름을 같게해도 상관없음.)              메소드 호출 : 메소드 이름(값1,값2,…[값 안써도 됨]);  int result = add(3,5); ⇒ int add값을 저장할 공간이 필요해서 int result를 씀 (class영역에만 정의 가능)                          int add(int x, int y){  \tint result = x+y;  \treturn result;  }              public static void main(String [] args) {  \tint result = add(3,5);  }                        매개변수 : 메소드를 호출한쪽에서 준 값을 메소드에게 전달하는 역할              class MyMath {  \tlong add(long a, long b) {  \t\treturn a+b;  \t}  \tlong subtract(long a, long b) {  \t\treturn a-b;  \t}  \tlong multiply(long a, long b) {  \t\treturn a*b;  \t}  \tlong divide(long a, long b) {  \t\treturn a/b;  \t}            \t  \t// 두 값을 받아서 더 큰 값을 반환하는 메소드  \tlong max (long a, long b) {  //\t\treturn a&gt;b? a:b;  \t\tif(a&gt;b) return a;  \t\telse return b; //참, 거짓 둘다 return해줘야함  \t}  \tlong min (long l, long m) {  \t\treturn l&lt;m?l:m;  \t}            \t  \tvoid printgugudan(int dan) {  \t\tif(!(dan&gt;=2 &amp;&amp; dan&lt;=9)) {  \t\t\treturn;  \t\t}            \t\t  \t\tfor (int i=1;i&lt;=9;i++) {  \t\t\tSystem.out.printf(\"%d * %d = %d%n\",dan,i,dan*i);  \t\t}  \t}  }  public class Ex6_4 {              \tpublic static void main(String[] args) {  \t\tMyMath mm = new MyMath();            \t\t  \t\tlong result1 = mm.add(5L,3L);  \t\tlong result2 = mm.subtract(5L,3L);  \t\tlong result3 = mm.multiply(5L,3L);  \t\tlong result4 = mm.divide(5L,3L);            \t\t  \t\tSystem.out.println(\"add = \"+result1);  \t\tSystem.out.println(\"subtract = \"+result2);  \t\tSystem.out.println(\"multiply = \"+result3);  \t\tSystem.out.println(\"divide = \"+result4);            \t  \t\tSystem.out.println(mm.max(mm.add(5, 3),mm.add(4, 3)));  \t\tSystem.out.println(mm.max(5, 4));  \t\tSystem.out.println(mm.min(mm.add(5, 3),mm.add(4, 3)));  \t\tSystem.out.println(mm.min(5, 4));            \t\t  \t\tmm.printgugudan(5);  \t}              }                                      반환값 - return : 실행중인 메소드를 종료하고 호출한 곳으로 되돌아간다. (타입이 일치해야하나 자동형변환된는 것은 가능 ex. char → int                                            호출스택 (call srack) : 메소드 수행에 필요한 메모리가 제공되는 공간. 메소드가 호출되면 호출스택에 메모리 할당, 종료되면 해제          stack : 밑이 꽉막힌 상자. 위에 차곡차곡 쌓인다. - 후입선출      main 메소드가 println 메소드를 호출했으면 println 메소드가 실행되는동안 main 메소드는 대기상대임.println메소드가 종료되면 스택에서 사라지고 남은 main메소드가 작업을 계속함  = 맨 위에 있는 메소드 하나만 실행중, 나머지는 대기            기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.      class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tchange(d.x);     \t\t  \t\tSystem.out.println(\"After change(d.x)\");  \t\tSystem.out.println(\"main() : x = \"+d.x); //change의 int x와는 다른 주소를 가지고있기때문에 main안에서는 여전히 10의 값을 가짐  \t}  \tstatic void change(int x) { //int x로 새로운 저장공간은 만들었기때문에 class date의 int x와는 가른 주소를 가짐  \t\tx=1000;  \t\tSystem.out.println(\"chanhe() : x = \"+x);  \t}//change문이 끝났으니 change문 시작할때 새로 지정해준 int x의 값도 종료됨!  }            참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.      class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tchange(d);     \t\t  \t\tSystem.out.println(\"After change(d)\");  \t\tSystem.out.println(\"main() : x = \"+d.x); //1000  \t}  \tstatic void change(Date d) { //main에서도 공유중인 date의 d값을 복사해옴. = main의 x와 같은 동일한 공간을 가짐  \t\td.x=1000;  \t\tSystem.out.println(\"chanhe() : x = \"+d.x);  \t}  }          class Date {  \tint x;  }  public class array {      \tpublic static void main(String[] args) {  \t\tDate d = new Date();  \t\td.x=10;  \t\tSystem.out.println(\"main() : x =\" + d.x);    \t\t  \t\tDate d2 = copy(d);  \t\tSystem.out.println(\"d.x = \"+d.x);  \t\tSystem.out.println(\"dx.x = \"+d2.x);  \t}  \tstatic Date copy(Date d) {  \t\tDate tmp = new Date();    \t\t  \t\ttmp.x=d.x;    \t\t  \t\treturn tmp; //객체의 주소를 반환함    \t\t  \t}  }            일단 이렇게 이해함.            좀 더 확실히 이해하려고 다시 그려봄    static method(class method) - ex)Math.random();          객체생성 없이 ‘클래스이름.메소드이름()’으로 호출      인스턴스 멤버(iv, im)과 관련없는 작업을 하는 메소드      메소드 내에서 인스턴스 변수(iv), 인스턴스 메소드(im) 사용불가 (객체가 있다는 보장이 없음)            instance method          인스턴스 생성 후 ‘참조변수.메소드이름()’으로 호출      인스턴스 멤버와 관련된 작업(iv, im)을 하는 메소드      메소드 내에서 인스턴스 변수(iv) 사용가능      class 메소드 사용 가능함. (class는 언제나 사용가능함)          class MyMath3{  \tlong a,b;  //인스턴스 변수(iv)    \t  \tlong add() { //instance method  \t\treturn a+b; //인스턴스 변수  \t}  \tstatic long add(long a, long b )  { //class method. long a,b는 지역변수이자 매개변수(iv필요없음)  \t\treturn a+b; //지역변수  \t}  }  public class array {  \tpublic static void main(String[] args) {  \t\t\tSystem.out.println(MyMath3.add(200L,100L)); //class method 호출  \t\t\tMyMath3 mm = new MyMath3(); //객체 만들기  \t\t\tmm.a = 200L;  \t\t\tmm.b = 300L;  \t\t\tSystem.out.println(mm.add()); //instance method 호출  \t}  }        static은 iv를 사용하지않을때 붙일 것.    이걸 구분할줄알아야 코더가 아니고 프로그래머가된다…………………………………    그래도 한번더 정리하자면          static - 공통속성에 붙이는 것. (변하지 않는 값 - ex.카드 크기 등)        오버로딩(overloaing : 과적하다) : 한 class안에 같은 이름의 메소드 여러개를 정의하는 것. (대표적으로 println이 있다)                  성립조건                  메소드 이름이 같음          매개변수의 개수 또는 타입이 달라야함.                      반환 타입은 영향이 없음            ex )                        int add(int a, int b) {return a+b}            int add(int x, int y) {return a+b}            ⇒ 오버로딩 아님. 1번만 충족. 그냥 중복처리돼서 에러                        int add(int a, int b) {return a+b}            long add(int a, int b) {return (long)(a+b)}            ⇒ 1번 충족, 2번 불충족, 3번은 상관없음. 결론, 중복정의로 에러                        long add(int a, long b) {return a+b}            long add(long a, int b) {return a+b}            ⇒ 1번 2번 모두 충족, 오버로딩            💡 add(3,3);은 두 add 전부 해당돼서 명확하지않다고 에러남                            class MyMath3{  \tint add(int a, int b) {  \t\tSystem.out.println(\"int add (int a, int b) - \");  \t\treturn a+b;  \t}  \tlong add(long a, int b) {  \t\tSystem.out.println(\"long add (long a, int b) - \");  \t\treturn a+b;  \t}  \tlong add(int a, long b) {  \t\tSystem.out.println(\"long add (int a, long b) - \");  \t\treturn a+b;  \t}  \tlong add(long a, long b) {  \t\tSystem.out.println(\"long add (long a, long b) - \");  \t\treturn a+b;  \t}  \tint add(int[] a) { //배열의 모든 요소의 합을 결과로  \t\tSystem.out.print(\"int add(int[] a) - \");  \t\tint result = 0;  \t\tfor(int i=0; i &lt; a.length;i++)   \t\t\tresult += a[i];  \t\t\treturn result;  \t\t}  }          public class array {  \tpublic static void main(String[] args) {  \t\tMyMath3 mm = new MyMath3();  \t\tSystem.out.println(\"mm.add(3,3) 결과 : \"+mm.add(3,3));  \t\tSystem.out.println(\"mm.add(3L,3) 결과 : \"+mm.add(3L,3));  \t\tSystem.out.println(\"mm.add(3,3L) 결과 : \"+mm.add(3,3L));  \t\tSystem.out.println(\"mm.add(3L,3L) 결과 : \"+mm.add(3L,3L));        \t\t  \t\tint a[] = {100, 200,300};  \t\tSystem.out.println(\"mm.add(a) 결과 : \"+mm.add(a));        \t\t  \t}  }                      생성자(constructor) :                  인스턴스가 생성될 때마다 호출되는 ‘인스턴스 초기화 메소드’        Time t = new Time(); //객체생성  //인스턴스 초기화  t.hour = 12;  t.minute = 34;  t.second = 56;  == Time t = new  Time(12,34,56); //생성자            인스턴스 생성시 수행할 작업(iv 초기화)에 사용              class와 이름이 같아야 함. (구성다른 생성자를 여러개 쓰면 오버로딩임)        class Card {        Card() { //매개변수 없는 생성자        //인스턴스 초기화 작업        }        Card (String kind, int number) { //매개변수 있는 생성자        //인스턴스 초기화 작업        }        Card 클래스가 두개인건 생성자 오버로딩            리턴값이 없음 (void도 안붙임)      모든 class는 한개이상의 생성자가 있어야한다.            기본생성자 (default constructor) : 직접 작성해줘야하나 자동으로 생기는 생성자          매개변수가 없는 생성자              생성자가 하나도 없을 때만, 컴파일러가 자동 추가        Point() {} //Point 클래스의 기본 생성자                class Data_1 {  \tint value;  \t//Date_1(){} 가 자동으로 생김  }  class Data_2{  \tint value;  \t//Data_2() {} //기본생성자 (에러내려고 주석처리함)  \tData_2(int x){ //매개변수가있는 생산자  \t\tvalue = x;  \t}      }  public class array {  \tpublic static void main(String[] args) {  \t\tData_1 d1 = new Data_1(); //Date_1 클래스안에 생성자가 없어서(1개) 기본 생성자가 자동으로 생김  \t\tData_2 d2 = new Data_2(); //compile error 생성자를 호출했는데 Date_2안에 생성자가 없음  \t}  }        어지간하면 그냥 넣어줄것. 나중에가면 헷갈림          매개변수가 있는 생성자 : 생성자 호출할때 바로 값을 받음.          class Car {  \tString color; //색상  \tString gearType; //변속기 종류 - auto(자동), manual(수종)  \tint door; //문 개수    \t  \tCar(){}  \tCar(String c, String g, int d){  \t\tcolor = c;  \t\tgearType = g;  \t\tdoor = d;  \t}  }  public class array {   \tpublic static void main(String[] args) {  \t\tCar c = new Car(\"white\",\"auto\",4);   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t\tSystem.out.println();  \t\tCar c2 = new Car(\"red\",\"manual\",3);   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t}  }            생성자 this()          같은 클래스에서 다른 생성자를 호출할 때 사용      다른 생성자 호출시 첫 줄에서만 가능          class Car {  \tString color; //색상  \tString gearType; //변속기 종류 - auto(자동), manual(수종)  \tint door; //문 개수    \t  \tCar(){  \t\tthis(\"white\",\"auto\",4); // == Car{String color, String gearType, int door)  \t\t//color = \"white\";  \t\t//gearType = \"auto\"  \t\t//door = 4;   이거랑 같은거임. 코드 중복 줄이려고 한 문장으로 만든 것.  \t}  \tCar(String color) {  \t\tthis(color, \"manual\",3);  \t}  \tCar(String color, String gearType, int door){  \t\tthis.color = color;  \t\tthis.door = door;  \t\tthis.gearType= gearType;  \t}  }  public class array {   \tpublic static void main(String[] args) {  \t\tCar c = new Car();   \t\tSystem.out.println(\"색 : \"+c.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c.door);  \t\tSystem.out.println();  \t\tCar c2 = new Car(\"red\");   \t\tSystem.out.println(\"색 : \"+c2.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c2.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c2.door);  \t\tSystem.out.println();  \t\tCar c3 = new Car(\"blue\",\"auto\",5);   \t\tSystem.out.println(\"색 : \"+c3.color);  \t\tSystem.out.println(\"변속기 종류 : \"+c3.gearType);  \t\tSystem.out.println(\"문 개수 : \"+c3.door);  \t}  }        코드 중복을 제거하기 위해 생성자끼리 서로 호출하는 것  class Car {\tString color;\tString gearType; \tint door; }Car(){ //값이 주어지지않는다면 밑의 값으로 초기화\tcolor = \"white\";\tgearType = \"auto\";\tdoor = 4;} Car(String c, String g, int d){color = c;gearType = g;door = d;}↓class Car {\tString color;\tString gearType; \tint door; }Car(){\tthis(\"white\",\"auto\",4)}Car(String c, String g, int d){color = c;gearType = g;door = d;}  참조변수 this -괄호 없음 : 생성자 this랑 아예 관련없음. 연관짓지말것.          인스턴스 자신을 가리키는 참조변수 - 인스턴스 주소가 저장되어있다      인스턴스 메소드에서만 사용가능      모든 인스턴스 메소드에 지역변수로 숨겨진 채로 존재      지역변수와 인스턴스 변수를 구분할 때 사용      Car(String c, String g, int d){\t//color는 iv, c는 lv\tcolor = c;\tgearType = g;\tdoor = d;} //같은 클래스안에서는 생략이 가능하나 이름이 같으면 생략이 안됨//this가 자동으로 생략됨Car(String color, String gearType, int door){\t\tthis.color = color;\t\tthis.door = door;\t\tthis.gearType= gearType;} //this가 붙은건 iv, =뒤에있는건 lv//this가 없다면 iv처리가 됨//이름이 같아서 this 생략이 불가능왼쪽으로 많이 쓰는데, 정석은 오른쪽. 지역변수와 인스턴스 구분할때 정석으로 써주면됨class MyMath3{\tlong a,b;  //this a, this b iv의 진짜 이름\tMyMath(int a, int b){\t\tthis.a = a;\t\tthis.b = b;  //this 생락 불가능. 에러는 안나는데 지역변수가 됨\t}\tlong add(){ //인스턴스 메소드\t\treturn a+b; //return this.a + this.b    this는 생략 가능\t} \tstatic long add(long a, long b){ \t\treturn a+b;  //인스턴스 변수 사용 불가능. static이 있어서. 그래서 this. 사용불가\t}}this는 클래스 메소드나 인스턴스 매소드에서만 사용가능  변수의 초기화                  지역변수는 수동 초기화 해주어야함          class a{  \tint x;  \tint y = x;  //인스턴스 변수          \tvoid Method1(){ //메소드 안이니까 지역변수  \t\tint i;   \t\tint j = i; //에러남. i의 값이 없기때문. 지역변수는 자동으로 0으로 초기화해주지 않음.   \t}  \tvoid Method2(){  \t\tint i=0; //지역변수.   \t\tint j = i;  }                            멤버 변수는 자동 초기화된다                  멤버변수(iv, cv) 초기화          명시적 초기화 - 간단 초기화                  기본형 변수의 초기화 - int a= 0;          참조형 변수의 초기화 - Print p = new Print();)                    초기화 블럭 - 복잡한 초기화                  인스턴스 초기화 : {} (잘안씀)          클래스 초기화 블럭 : static{}                    생성자 - 인스턴스 변수 초기화. 복잡한 초기화에 사용        cv초기화가 먼저되고 iv초기화가 이루어짐. 자동→간단→복잡 초기화      class a {  \tstatic int[] arr = new int[10]  //명시적 초기화    \t  \tstatic { //클래스 초기화 블럭 - 배열 arr을 난수로 채운다  \t\tfor (...............  .....        — 클래스 변수 초기화 시점          클래스 변수 초기화 시점 - 클래스가 처음 로딩될 때 단 한번      인스턴스 변수 초기화 시점 - 객체가 만들어질때      "
  },
  
  {
    "title": "배열",
    "url": "/posts/%EB%B0%B0%EC%97%B4/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-07-31 00:00:00 +0900",
    





    
    "snippet": "배열 : 같은 타입의 변수를 하나의 묶음으로 다루는 것.      선언 : 배열을 다루기 위한 참조변수의 선언    int[] score; / String[] name; - 자바스타일    int score[]; / String name[]; - c언어 스타일    둘다 가능은 함. 편한걸로 쓸것.    int[] score; score = new i...",
    "content": "배열 : 같은 타입의 변수를 하나의 묶음으로 다루는 것.      선언 : 배열을 다루기 위한 참조변수의 선언    int[] score; / String[] name; - 자바스타일    int score[]; / String name[]; - c언어 스타일    둘다 가능은 함. 편한걸로 쓸것.    int[] score; score = new int [5];    배열은 한번 생성하면 실행하는 동안 그 길이를 바꿀 수 없다. 배열의 길이 - int형 상수      char배열인 경우에만    char charr[] = {’a’,’b’,’c’,’d’}    system.out.println(charr)    으로 출력이 가능함. 다른 경우는 for문 또는 Arrays.toString(배열)을 써야 전체출력할 수 있음.  import java.util.*;public class array {\tpublic static void main(String[] args) {\t\t\t\tint iarr1[] = new int[10];\t\tint iarr2[] = new int[10];\t\tint iarr3[] = {100,95,80,70,60};\t\tchar charr[] = {'a','b','c','d'};\t\t\t\tfor(int i=0;i&lt;iarr1.length;i++) {\t\t\tiarr1[i] = i+1;\t\t}\t\t\t\tfor(int i=0;i&lt;iarr2.length;i++) {\t\t\tiarr2[i] = (int)(Math.random()*10)+1;\t\t}\t\tSystem.out.println(Arrays.toString(iarr1));\t\tSystem.out.println(Arrays.toString(iarr2));\t\tSystem.out.println(Arrays.toString(iarr3));\t\tSystem.out.println(charr);\t}}public class array {\tpublic static void main(String[] args) {\t\tint sum = 0;\t\tfloat avg = 0f;\t\t\t\tint score[] = {100,88,100,100,90};\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tsum += score[i];\t\t}\t\t\t\tavg = (float)sum / score.length;\t\t//\t\tSystem.out.printf(\"총점 : %d%n\", sum);//\t\tSystem.out.printf(\"평균 : %.1f%n\", avg);\t\t\t\tSystem.out.println(\"총점 : \"+sum);\t\tSystem.out.println(\"평균 : \"+avg);\t}}public class array {\tpublic static void main(String[] args) {\t\tint score[] = {79,88,91,33,100,55,95};\t\t\t\tint max = score[0];\t\tint min = score[0];\t\t\t\tfor(int i=0;i&lt;score.length;i++) {\t\t\tif(score[i]&gt;max)\t\t\t\tmax=score[i];\t\t\telse if(score[i]&lt;min)\t\t\t\tmin=score[i];\t\t}\t\t\tSystem.out.println(\"최대값 : \"+max);\t\t\tSystem.out.println(\"최소값 : \"+min);\t\t\t\t}}배열 섞기import java.util.Arrays;public class array {\tpublic static void main(String[] args) {\t\t//배열 섞기\t\tint numarr[]= {0,1,2,3,4,5,6,7,8,9};\t\tSystem.out.println(Arrays.toString(numarr));\t\t\t\tfor(int i=0;i&lt;numarr.length;i++) {\t\t\tint n = (int)(Math.random()*10); //이건 [i]값을 랜덤으로 받는거고 실질적으로 배열값만 섞으니까 중복이 안나옴\t\t\tint tmp = numarr[i];\t\t\tnumarr[i] = numarr[n];\t\t\tnumarr[n]=tmp;\t\t}\t\tSystem.out.println(Arrays.toString(numarr));\t}}import java.util.Arrays;public class array {\tpublic static void main(String[] args) {\t\t\tint numarr[] = new int[45];\t\t\t\tfor(int i=0;i&lt;numarr.length;i++) {\t\t\tnumarr[i] = i+1;\t\t}\t\t\t\tint tmp = 0, n = 0;\t\tfor(int j=0;j&lt;numarr.length;j++) {\t\t\tn = (int)(Math.random()*45); //그냥 랜덤으로 numarr[n]을 구하면 중복값이 나옴\t\t\ttmp = numarr[0];\t\t\tnumarr[0]=numarr[n];\t\t\tnumarr[n]=tmp;\t\t}\t\tfor(int k = 0;k&lt;6;k++) {\t\tSystem.out.println(numarr[k]);\t\t}\t}}      String 배열                  선언  String[] name = new String[3];        String name[] = {”aa”,”bb”,”cc”}                import java.util.Arrays;      public class array {      \tpublic static void main(String[] args) {    \t  \t\tString strarr[]= {\"가위\",\"바위\",\"보\"};  \t\tSystem.out.println(Arrays.toString(strarr));    \t\t    \t\t  \t\tfor(int i = 0; i&lt;10;i++) {  \t\tint tmp = (int)(Math.random()*3);  \t\tSystem.out.println(strarr[tmp]);  \t\t}  \t}  }            커맨드라인을 통해 입력받기    args[]를 통해 입력받기임. cmd통해 입력받기 가능        n차원 배열 : n-1차원 배열이 여러개 모인것 보통 3차원부터는 잘 안쓰임, 표현하기 위해서 n중for문 필요함.                  2차원배열        int score [] [] = new int [4] [3]; = 4행 3열                                                           score[0][0]              score[0][1]              score[0][2]                                                          score[0]              score[0][0]              score[0][1]              score[0][2]                                      score[1]              score[1][0]              score[1][1]              score[1][2]                                      score[2]              score[2][0]              score[2][1]              score[2][2]                                      score[3]              score[3][0]              score[3][1]              score[3][2]                                      int arr[] [] ={ {1,2,3}, {4,5,6}}                    public class array {                \tpublic static void main(String[] args) {        \t        \t\tint score[][] = {        \t\t\t\t{100,100,100},        \t\t\t\t{20,20,20,20,20},        \t\t\t\t{30,30,30},        \t\t\t\t{40,40}        \t\t};        \t\tint sum = 0;        \t\t        \t\tfor(int i = 0; i&lt;score.length;i++) {        \t\t\tfor(int j=0;j&lt;score[i].length;j++) {        \t\t\t\tSystem.out.printf(\"score[%d][%d] = %d%n\",i,j,score[i][j]);        \t\t\t\t        \t\t\t\tsum +=score[i][j];        \t\t\t}        \t\t}        \t\tSystem.out.println(\"sum = \"+sum);        \t}        }        public class array {                \tpublic static void main(String[] args) {        \t        \t\tint score[][] = {        \t\t\t\t{100,100,100},        \t\t\t\t{20,20,20},        \t\t\t\t{30,30,30},        \t\t\t\t{40,40,40},        \t\t\t\t{50,50,50}        \t\t};        \t\tint kortotal = 0, engtotal = 0, mathtotal = 0;        \t\t        \t\tSystem.out.println(\"번호  국어   영어   수학   총점  평균\");        \t\tSystem.out.println(\"=============================\");        \t\t        \t\tfor(int i = 0; i&lt;score.length;i++) {        \t\t\tint sum = 0;        \t\t\tfloat avg = 0.0f;        \t\t\t        \t\t\tkortotal += score[i][0];        \t\t\tengtotal += score[i][1];        \t\t\tmathtotal += score[i][2];        \t\t\tSystem.out.printf(\"%3d\", i+1);        \t\t\tfor(int j=0;j&lt;score[i].length;j++) {        \t\t\t\tsum += score[i][j];        \t\t\t\tSystem.out.printf(\"%5d\",score[i][j]);        \t\t\t}        \t\t\tavg = sum/ (float)score[i].length;        \t\t\tSystem.out.printf(\"   %d %2.1f%n\",sum,avg);        \t\t\t}        \t\t}        \t}        import java.util.*;                public class array {                \tpublic static void main(String[] args) {        \t        \t\tString[][] words = {        \t\t\t{\"chair\", \"의자\"},        \t\t\t{\"computer\",\"컴퓨터\"},        \t\t\t{\"integer\",\"정수\"}        \t\t};        \t\t        \t\tScanner scanner = new Scanner(System.in);        \t\t        \t\tfor(int i =0; i&lt;words.length;i++) {        \t\t\tSystem.out.printf(\"Q%d. %s의 뜻은??\",i+1,words[i][0]);        \t\t\t        \t\t\tString tmp = scanner.nextLine();        \t\t\t        \t\t\tif(tmp.equals(words[i][0])) {        \t\t\t\tSystem.out.printf(\"정답입니다!!%n%n\");        \t\t\t}        \t\t\telse {        \t\t\t\tSystem.out.println(\"틀렸습니다! 정답은 \"+words[i][1]+\"입니다.\");        \t\t\t}        \t\t}        \t}        }  String class = char[] + method : 내용을 변경할 수 없다.(read only)  String a =”a”; String b = “b”; a=a+b; 하면 String a와 a값이 따로 저장됨. 덮어쓰기안됨. 연결은 a랑만 돼서 String a는 못씀    charAt - 원하는 위치의 문자를 가져옴.  substring - 원하는 부분의 문자열을 가져옴(마지막글자 안들고오니까 조심)public class array {\tpublic static void main(String[] args) {\t\t\tString str = \"abcdefg\";\t\tchar ch = str.charAt(2);\t\tSystem.out.println(ch); //c\t\tString str2 = str.substring(1,4);\t\tSystem.out.println(str2); //bcd\t\tString str3 = str.substring(1);\t\tSystem.out.println(str3); //bcdefg\t\t\t}}      arrays(class)로 배열 다루기          equals() : 같은 값 비교      toString()      deepToString : 2차원 이상의 다차원 배열의 출력              deepEquals : 2차원 이상의 배열들끼리 값이 같은지 비교  Arrays.deepEquals(배열1,배열2)                    copyOf() : 배열 복사  Arrays.copyOf(배열,복사할 개수) - 전체복사            copyRange : 배열 원하는부분(from~to)까지 복사. 마지막값(to)복사안됨      sort(배열) : 배열 정렬. 숫자 오름차순 정렬.          import java.util.Arrays;        public class array {        \tpublic static void main(String[] args) {    \t    \t\tint arr[] = {0,1,2,3,4};    \t\tint arr2d[][] = { {11,22}, {21,22} };    \t\t    \t\tSystem.out.println(Arrays.toString(arr));    \t\tSystem.out.println(Arrays.deepToString(arr2d));    \t\t    \t\tString str2d[][] = { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\"} };    \t\tString str2d2[][] = { {\"aaa\",\"bbb\"},{\"AAA\",\"BBB\"} };    \t\t    \t\tSystem.out.println(Arrays.deepEquals(str2d, str2d2));    \t\t    \t\tint arr2[] = Arrays.copyOf(arr, arr.length);    \t\tSystem.out.println(Arrays.toString(arr2));    \t\tint arr3[] = Arrays.copyOfRange(arr, 2,4);    \t\tSystem.out.println(Arrays.toString(arr3));    \t\t    \t\tint arr4[] = {0,4,2,1,3};    \t\tSystem.out.println(Arrays.toString(arr4));    \t\tArrays.sort(arr4);    \t\tSystem.out.println(Arrays.toString(arr4));    \t}    }"
  },
  
  {
    "title": "제어문 (flow control statemt)",
    "url": "/posts/%EC%A0%9C%EC%96%B4%EB%AC%B8-(flow-control-statemt)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-07-30 00:00:00 +0900",
    





    
    "snippet": "  조건문          if문                  switch : 처리해야하는 경우의 수가 많을 때 씀(if-else if문보다 효율적)          switch (조건식) {  \tcase 값1 :   \t\t\t//...  \t\t\tbreak;  \tcase 값2 :   \t\t\t//...  \t\t\tbreak;  \t//...  \tdefault : ...",
    "content": "  조건문          if문                  switch : 처리해야하는 경우의 수가 많을 때 씀(if-else if문보다 효율적)          switch (조건식) {  \tcase 값1 :   \t\t\t//...  \t\t\tbreak;  \tcase 값2 :   \t\t\t//...  \t\t\tbreak;  \t//...  \tdefault :  \t\t//....조건식의 결과와 일치하는 case문이 없을떄  \t\t//....  }                      제약조건\t      - 조건식 결과가 정수 또는 문자열이여야함.      - case문의 값은 정수 상수(문자포함), 문자열만 가능, 중복 금지        import java.util.*;        public class ScanfEx1 {                \tpublic static void main(String[] args) {        \t        \tSystem.out.println(\"현재 월을 입력하세요\");        \t        \tScanner scanner = new Scanner(System.in);        \tint month = scanner.nextInt();        \t        \tswitch (month) {        \t\tcase 3: case 4: case 5:        \t\t\tSystem.out.println(\"현재 계절은 봄입니다.\");        \t\t\tbreak;         \t\tcase 6: case 7:case 8:        \t\t\tSystem.out.println(\"현재 계절은 여름입니다.\");        \t\t\tbreak;        \t\tcase 9: case 10:        \t\t\tSystem.out.println(\"현재 계절은 가을입니다.\");        \t\t\tbreak;        \t\tcase 11: case 12: case 1: case 2:        \t\t\tSystem.out.println(\"현재 계절은 겨울입니다.\");        \t\t\tbreak;        \t\tdefault :        \t\t\tSystem.out.println(\"잘못 입력했습니다.\");        \t\t}        \t}        }— Math.random() : 0.0과 1.0사이의 임의의 double값을 반환0.0 * 3 ≤ Math.random() &lt; 1.0*3  ex)원하는 값 1~3      각변에 3을 곱한다    0.0 * 3 ≤ Math.random() * 3 &lt; 1.0 * 3        각 변을 int형으로 변환한다    (int)0.0 * 3 ≤ (int)(Math.random() * 3) &lt; (int)1.0 * 3    0 ≤ Math.random() * 3 &lt; 3        각 변에 1을 더한다    0 + 1 ≤ (Math.random() * 3) +1 &lt; 3 + 1    1 ≤ (Math.random() * 3) +1 &lt; 4      public class ex4_7 {    \tpublic static void main(String[] args) {    \t\tint num=0;    \t\t//1~10사이의 난수를 20개 출력할 것.    \t\tfor(int i=0;i&lt;=20;i++) {    \t\t\tSystem.out.println((int)(Math.random()*10)+1);    \t\t}    \t\tSystem.out.println(\"===============\");        \t\t\t//-5~5사이의 난수를 20개 출력할 것.    \t\tfor(int j=0;j&lt;=20;j++) {    \t\t\tSystem.out.println((int)(Math.random()*11)-5); //0도 포함이라 값이 11개임    \t\t}    \t}    }  반복문          for          public class ex4_8 {        \tpublic static void main(String[] args) {    \t\tfor(int i=1, j=10;i&lt;=10;i++,j--) {    \t\t\tSystem.out.println(\"i=\"+i+\", j=\"+j);    \t}    \t    \t//구구단    \tfor(int j = 2;j&lt;=9;j++){    \t\tSystem.out.println(j+\"단 시작!!!\");    \t\tfor(int k=1;k&lt;=9;k++) {    \t\t\tSystem.out.println(j+\" * \" +k+\" = \"+j*k);    \t\t\tif(k==9)    \t\t\tSystem.out.println(\"====\"+j+\"단 종료====\\n\");    \t\t}    \t}    \t//별 찍기    \t\tfor(int n=1;n&lt;10;n++) {    \t\t\tfor(int x=1;x&lt;n;x++) {    \t\t\t\tSystem.out.print(\"★\");    \t\t\t}    \t\t\tSystem.out.println();    \t\t}     \t}    }  while - 조건식을 만족시키는 동안 블럭을 반복. do while문을 사용.    public class ex4_13 {        \tpublic static void main(String[] args) {    \t\tint sum=0;    \t\tint i=0;    \t\t    \t\twhile (sum&lt;=100) {    \t\t\tSystem.out.printf(\"%d : %d%n\",i,sum);    \t\t\tsum += ++i;    \t\t}    \t}        }    import java.util.*;        public class Ex4_14 {        \tpublic static void main(String[] args) {    \t\tint num=0, sum = 0;    \t\tSystem.out.println(\"숫자를 입력하세요.\");    \t\t    \t\tScanner scanner = new Scanner(System.in);    \t\tString tmp = scanner.nextLine();    \t\tnum = Integer.parseInt(tmp);    \t\t    \t\twhile (num != 0) {    \t\t\tsum += num%10;    \t\t\tSystem.out.printf(\"sum = %d num = %d%n\",sum,num);    \t\t\t    \t\t\tnum /= 10;    \t\t}    \t\tSystem.out.println(\"각 자리수의 합 : \"+sum);    \t\t    \t\tint sum2 = 0;    \t\tfor(num = Integer.parseInt(tmp);num&gt;0;num = num / 10)    \t\t{    \t\t\tsum2 += num%10;    \t\t\tSystem.out.printf(\"sum = %d num = %d%n\",sum2,num);    \t\t}    \t\tSystem.out.println(\"각 자리수의 합 : \"+sum2);    \t}        }  do while : 반복횟수를 알거나 코드가 중복이면 do while문을 사용  do{조건식이 참일 때 수행 될 문장. 처음 한번든 무조건 실행}  while(조건식);    import java.util.*;        public class ex4_15 {        \tpublic static void main(String[] args) {    \t\tint input = 0 , answer = 0;    \t\t    \t\tanswer = (int)(Math.random()*100)+1;    \t\tScanner scanner = new Scanner(System.in);    \t\t    \t\tdo {    \t\t\tSystem.out.println(\"1과 100사이의 정수를 입력하세요.&gt;&gt;\");    \t\t\tinput = scanner.nextInt();    \t\t\t    \t\t\tif (input &gt; answer) {    \t\t\t\tSystem.out.println(\"더 작은 수로 다시 시도하세요.\");    \t\t\t}    \t\t\telse if (input &lt; answer) {    \t\t\t\tSystem.out.println(\"더 큰 수로 다시 시도하세요.\");    \t\t\t}    \t\t} while (input != answer);    \t\t\tSystem.out.println(\"정답입니다!\");    \t\t}    \t}    public class ex4_16 {        \tpublic static void main(String[] args) {    \t\tint i = 0, sum = 0;    \t\t    \t\tdo {    \t\t\t++i;    \t\t\tsum += i;    \t\t} while(sum&lt;100);    \t\tSystem.out.println(\"i=\"+i);    \t\tSystem.out.println(\"sum=\"+sum);    \t}        }    public class ex4_16 {        \tpublic static void main(String[] args) {    \t\tint i = 0, sum = 0;    \t\t    \t\twhile (true) {    \t\t\tif(sum&gt;100)    \t\t\t\tbreak;    \t\t\t++i;    \t\t\tsum += i;    \t\t}    \t\tSystem.out.println(\"i=\"+i);    \t\tSystem.out.println(\"sum=\"+sum);    \t}        }  continue : 조건이 충족된다면 블록의 끝으로 이동, 다시 반복문 수행.public class ex4_17 {\tpublic static void main(String[] args) {\t\tfor(int i=0;i&lt;=10;i++) {\t\t\tif(i%2==0)\t\t\t\tcontinue;\t\t\tSystem.out.println(i);\t\t}\t}}  이름붙은 반복문 : 반복문에 이름을 붙여서 break앞에 적어주면 하나이상의 반복문을 벗어날 수 있다Loop1 : for( ......\tfor( ...........\t\t\t\tbreak Loop1;import java.util.*;public class ex4_18 {\tpublic static void main(String[] args) {\t\tint menu = 0;\t\tint num = 0;\t\t\t\tScanner scanner = new Scanner(System.in);\t\t\t\touter : while (true) {\t\t\tSystem.out.println(\"(1) square\");\t\t\tSystem.out.println(\"(2) square root\");\t\t\tSystem.out.println(\"(3) log\");\t\t\tSystem.out.println(\"원하는 메뉴를 입력하세요. (종료 : 0)\");\t\t\t\t\t\tString tmp = scanner.nextLine();\t\t\tmenu = Integer.parseInt(tmp);\t\t\t\t\t\tif(menu == 0) {\t\t\t\tSystem.out.println(\"프로그램을 종료합니다.\");\t\t\t\tbreak;\t\t\t}\t\t\telse if (!(menu&gt;=1 &amp;&amp; menu&lt;=3)) {\t\t\t\tSystem.out.println(\"메뉴를 잘못 선택하셨습니다. (종료는 0)\");\t\t\t\tcontinue;\t\t\t}\t\t\tSystem.out.println(\"선택하신 메뉴는 \"+menu+\"번입니다.\");\t\t\t\t\t\tfor(;;) {\t\t\t\tSystem.out.println(\"계산할 값을 입력하세요.(계산종료 : 0, 전체종료 : 99)&gt;&gt;\");\t\t\t\ttmp = scanner.nextLine();\t\t\t\tnum = Integer.parseInt(tmp);\t\t\t\t\t\t\t\tif(num==0)\t\t\t\t\tbreak;\t\t\t\tif(num==99)\t\t\t\t\tbreak outer;\t\t\t\t\t\t\t\tswitch(menu) {\t\t\t\t\tcase 1:\t\t\t\t\t\tSystem.out.println(\"result=\"+num*num);\t\t\t\t\t\tbreak;\t\t\t\t\tcase 2:\t\t\t\t\t\tSystem.out.println(\"result=\"+Math.sqrt(num)); //제곱근\t\t\t\t\t\tbreak;\t\t\t\t\tcase 3:\t\t\t\t\t\tSystem.out.println(\"result=\"+Math.log(num)); //로그\t\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t}}"
  },
  
  {
    "title": "연산자(Operator)",
    "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90(Operator)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-07-30 00:00:00 +0900",
    





    
    "snippet": "연산자 : 연산을 수행하는 기호 (+,-,*,/)피연산자 : 연산자의 수행 대상(x+3에서 x와 3)                                             종류      연산자      설명              산술 연산자      + - * / % ==« »==      사칙연산과 나머지 연산              비교...",
    "content": "연산자 : 연산을 수행하는 기호 (+,-,*,/)피연산자 : 연산자의 수행 대상(x+3에서 x와 3)                                             종류      연산자      설명              산술 연산자      + - * / % ==« »==      사칙연산과 나머지 연산              비교 연산자      &lt; &gt; ≥ ≤ == !=      크고 작음과 같고 다름을 비교              논리 연산자      &amp;&amp; | !(not)      and와 or으로 조건을 연결              대입 연산자      =      우변의 값을 좌변에 저장              기타      (type) ?: instanceof      형변환 연산자, 삼항 연산자, instanceof 연산자        증감 연산자          j = ++i : 값이 참조 되기 전에 증가시 = 일단 i+1하고 i값으로 할거 함      j = i++ : 값이 참조 된 후에 증가시킴 = i값으로 할거 다하고 +1      i++, ++i처럼 독립적으로 쓰였을때는 차이가 없음            형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것.    double d= 85.5; int score = (int)d; //85    ❗반올림 안됨! 그냥 버림!!실수→정수는 모두 그럼          자동 형변환 : 서로 다른 두 타입을 일치시킬깨 형변환을 생략하면 대부분 컴파일러가 알아서 형변환을 자동적으로 한다.                  생략 가능                          float f = 1234; == float f = (float)1234; //컴파일러가 자동으로 형변환. 두개가 같은거임.              byte - int는 int값이 byte타입의 범위 -128~127사이의 값이라면 값 손실이 없기 때문에 예외적으로 가능.  int i = 100; byte b = i ; 는 에러남. 변수값이라 값손실이 없음을 확신할 수 없기 때문.                                생략 불가능                                          int i = 3.14f; //에러남. float가 int보다 크기때문에 값손실이 발생됨.  int i = (int)3.14f로 써줘야함.                                            short - char끼리 자동 형변환 불가능. short가 부호있는 연산자라서. chat - int변환은 가능                                                              산술 변환 : 연산 전에 피연산자의 자동으로 타입을 일치시키는 것.          두 피연산자의 타입을 큰 타입으로 일치시킴              int보다 작은 타입이면 int로 변환된다.  byte + short = int / char + short = int        ‘2’ - ‘0’ = 2 (문자 2의 코드가 50이고 문자 0의 코드가 48이라서. 문자코드가 순서대로 1씩 증가해서 문자끼리 식은 일반 식과 결과값이 같음 )                public class ScanfEx1 {  \tpublic static void main(String[] args) {  \t\tint a = 1_000_000;  \t\tint b = 2_000_000;    \t\t  \t\tlong c = (long)a*b;  \t\tSystem.out.println(c);  \t}  }            반올림 - Math.round - 실수를 소수 첫째 자리에서 반올림  Math.round(4.52) = 5  —n의 자리까지 반올림을 해주려면?    Math.round(Math.PI*1000.0)/1000.0); → 3.142 이렇게 10의 n제곱을 곱하고 나눠줌    equals();String str1 = \"abc\";String str2 = \"abc\";system.out.println(str1==str삼2); //값의 위치가 같음String str3 = new String(\"abc\");String str4 = new String(\"abc\");system.out.println(str3.equals(str4); //인스턴스라서 값을 복제해와서 값의 위치가 다름!!      조건 연산자 ? : 조건식의 결과에 따라 연산결과를 달리한다.    조건식 ? 식1 : 식2 //조건식이 참이면 식1 거짓이면 식2    result = (x&gt;y) ? x : y ; //괄호 생략가능    if문을 간단하게 쓸 수 있는 장점이 있음!!        대입 연산자          lvalue : 왼쪽 피연산자, 저장공간 3, i+3같은 값이 오거나 final을 붙여 상수가 되면 에러남      rvalue : 오른쪽 피연산자      !(not)은 가독성에 안좋으니 가급적 쓰지말것 쓸거면 처음부터 쓰기. 중간부터 쓰면 알아보기 힘들어짐"
  },
  
  {
    "title": "자바의 정석 강의 - 변수(Variable)",
    "url": "/posts/%EB%B3%80%EC%88%98(Variable)/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-07-29 06:27:00 +0900",
    





    
    "snippet": "  system.out.println(); 에서 print==ln==이 \\n이거라서 따로 \\n안해줘도 지금까지 줄바꿈이 됐던거임..! 충격! pintf도 있다..!      public class Ex2_1 {      \tpublic static void main(String[] args) {  \t\tSystem.out.printf(\"hello\");  ...",
    "content": "  system.out.println(); 에서 print==ln==이 \\n이거라서 따로 \\n안해줘도 지금까지 줄바꿈이 됐던거임..! 충격! pintf도 있다..!      public class Ex2_1 {      \tpublic static void main(String[] args) {  \t\tSystem.out.printf(\"hello\");  \t\tSystem.out.printf(\"hello\");  \t\tSystem.out.printf(\"hello\");  \t}      }        이거는 줄바꿈 안되고 hellohellohello로 실행됨. print로 바꿔도 마찬가지    변수(variable) : 하나의 값을 저장할 수 있는 메모리 공간(RAM). 변경가능  — 변수 선언 이유 : 값(data)를 저장할 수 있는 공간을 마련하기 위해.      변수타입 변수이름; ex)int age;                  =는 등호가 아니라 대입. 그래서 if문에서는 == 를 썼구나  int x=0; 변수 x를 선언 후 0으로 초기화  int y=5; 변수 y를 선언 후 5로 초기화        ❗지역변수는 읽기전에 꼭 초기화를 해주어야 함            변수 타입                  기본형(Primitive type) - 8개                          정수 :                                  int                  byte : 0~127, 이진데이터를 다루는데 사용                  short : c언어와의 호환을 위해 사용. 잘안쓰임                  long : int에 못넣는 20억이 넘는 값을 넣음                                            문자 : char (한글자) - 빈문자(’’;)불가능              문자열 : String (여러글자) -                                                      빈문자(””;) 가능  ⇒ “”+7 = “7” : 숫자 7이 문자열로 변환됨.  ex) “”+7+7 = “7”+7→”7”+”7”⇒ “77”  7+7+”” = 14+””→”14”+””⇒”14”                                                        class이나 너무 자주 쓰여서 String s1 = “ab”; 로 사용가능                                                              실수 (소수점) : double, float              논리(boolean) : true, false. 조선식과 논리적 계산에 사용                                                                        종류/크기                  1byte                  2byte                  4byte                  8byte                                                                              논리형                  boolean                                                                                                           문자형                                     char                                                                                        정수형                  byte                  short                  int                  long                                                  실수형                                                        float                  double                                                      n비트로 표현할 수 있는 값의 개수 : 2의 n제곱            n비트로 표현할 수 있는 부호없는 정수의 범위 : 0~2의n제곱-1            n비트로 표현할 수 있는 부호있는 정수의 범위 : -2의 n-1제곱 ~2의 n-1제곱-1                          부호비트 (sign bit)                                                      byte = -2의 7제곱~ 2의 7제곱 -1 =                                                                                            0                          7bit                                                                                      부호비트가 0이니까 양수                                                                                            1                          7bit                                                                                      부호비트가 1이니까 음수                                                        short = -2의 15제곱~ 2의 15제곱 -1 =                                                                                            s                          15bit                                                                                                                          char = 0~2의 16제곱 -1 (2진수로 변환)                                                                                            16bit                          160000000001000001                                                                                                                          int = -2의 31제곱~ 2의 31제곱 -1 = -20억~20억                                                                                            s                          31bit                                                                                                                          int = -2의 63제곱~ 2의 63제곱 -1 = -800경 ~ 800경                                                                                            s                          63bit                                                                                      혹시 부족하면 Big integer사용                                                        float = 1+8+23 = 32bit = 4byte = -1.410의 -45제곱~1.410의 -45제곱                                                                                            S                          E(8)                          M(23)                                                                                      정밀도 : 7자리                                                        double = 1+11+52 = 64bit = 8byte = -3.410의 38제곱~3.410의 38제곱                                                                                            S                          E(11)                          M(50)                                                                                      정밀도 : 15자리 (float보다 정확함)                                                                                            참조형(Reference type) : 기본형을 제외한 나머지. 무한개                          메모리주소를 저장. (4byte[40억] or 8 byte[160억])                        ex) today = new Date(); - 참조형 변수 today에 객체의 주소를 저장                              리터럴 (literal) : 그 자체로 값을 의미. 기존의 상수.                              리터럴 타입과 접미사                                                            종류                  리터럴                  접미사                                                                              논리형                  false, true                  없음                                                  정수형                  int - 123, Ob0101, 077, 0xFF,  Long - 100L                  L                                                  실수형                  3.14, 3.0e8, 1.4f, 0x1.0p-1                  f(float),  d(double, 생략가능)                                                  문자형                  ‘A’, ‘1’, ’\\n’                  없음                                                  문자열                  “ABC”, “123”, “A”, “true”                  없음                                                      정수형, 실수형은 접미사로 구분함.                                          int oct = 010;            \t\tint hex = 0x10;            \t\t            \t\tSystem.out.println(oct);            \t\tSystem.out.println(hex);            // println을 쓰면 8진수와 16진수를 표현못해서 8과 16이 나옴.            // printf를 쓰면 가능  10진수 : int i = 100;  8진수 : int i = 0100;  16진수 : int i = 0x100;  long i = 10_000_000_000L ⇒ 100억. int가 20억까지 가능함. 꼭 L붙일것.  1e3 = 여기서 e가 10의 n제곱임. = 1000.0 (접미사 없으니 double형)  int i = ‘A’; ⇒ A의 문자열코드인 65가 출력됨  상수(constant) : 한 번만 값을 저장 가능한 변수. 변경 불가능. 앞에 final을 붙이면 됨.ex) final int MAX = 100;MAX = 200;(에러남)&lt;/mark&gt;\tint score = 100;\tscore = 200;\tfinal int MAX = 100;\tchar ch = 'a';\tString str = \"abc\";— 변수와 리터럴 타입 불일치  범위가 변수&gt;리터럴 인 경우 가능함          int &gt; char / long &gt; int / double &gt; float        범위가 변수 &lt; 리터럴 인 경우 에러남          long i = 3.14f - long&lt;float이라 에러      float f = 3.14 (접미사 생략됐으니 double형) 에러. float &lt; double  double d = 3.14f ⇒ 가능      byte, short변수에 int 리터럴 사용 가능        두 변수 값 교환하는 법      int x = 10, y = 20;  int tmp;//빈공간  x=tmp;  x=y;  y=tmp;      pritnln 단점  출력형식 지정 불가 (ex.소수점 자리지정 불가)  10진수로만 출력됨⇒ printf를 사용하면 가능해짐            지시자      설명                  %b      boolean 형식으로 출력              %d      10진 정수의 형식으로 출력              %o      8진 정수의 형식으로 출력  #을 붙여야 접두사도 출력됨              %x, %X      16진 정수의 형식으로 출력  #을 붙여야 접두사도 출력됨              %f      부동 소수점의 형식으로 출력  %g를 사용하면 간략하게 출력              %e, %E (1.234e+02)      지수 표현식의 형식으로 출력              %c      문자로 출력              %s      문자열로 출력      ❗\\n, %n 둘다 줄바꿈이나 %n을 자주 사용할 것.      지시자    system.out.printf(”[%5d]%n”, 10); // [ 10] - 5자리 출력    system.out.printf(”[%-5d]%n”, 10); // [10 ] - 5자리 출력, 왼쪽정렬    system.out.printf(”[%05d]%n”, 10); // [00010] - 5자리 출력(숫자, 문자열 다 됨)    system.out.printf(”[%5d]%n”, 1234567); // [1234567] - 7자리 출력    system.out.printf(“[%14.10f]%n”, 1.23456789); // [ 1.2345678900]   (전체자리 14자리에서 소수점 10자리 출력)  화면으로 입력받기부터 - Scanner : 화면으로부터 데이터를 입력받는 class  import문 필수 - import java.util.*;  Scanner 객체의 생성 Scanner scanner = new Scanner system.in;  Scanner 객체의 사용          int num = scanner.nextInt(); //화면에서 입력받은 정수를 num에 저장      String input = scanner.nextLine(); //화면에서 입력받은 내용을 input에 저장  int num = Integer.parseInt(input); //문자열(input)을 숫자(num)으로 전환                  숫자 → 문자열 = 숫자 + “”          문자열 → 숫자 = Integer.parseInt(”문자열”)  — 한 문장에 여러 값을 받을경우 필요함                    \timport java.util.*;\t\tpublic class ScanfEx1 {\t\t\tpublic static void main(String[] args) {\t\t\t\t//정수\t\t\tScanner scanner = new Scanner(System.in);\t\t\tint num = scanner.nextInt();\t\t\tSystem.out.println(num);\t\t\t\t\t\t//문자열\t\t\tScanner scanner2 = new Scanner(System.in);\t\t\tString input = scanner2.nextLine();\t\t\tSystem.out.println(input);\t\t\t\t\t\t//문자열 -&gt; 숫자\t\t\tScanner scanner3 = new Scanner(System.in);\t\t\tString input2 = scanner3.nextLine();\t\t\tint num2 = Integer.parseInt(input2);\t\t\tSystem.out.println(input2);\t\t}\t}❗Scanner밑에 밑줄은 입출력 관련 객체들은 원칙적으로 반드시 닫아주어야함. 하지만 화면입력같은경우에는 자바 버추얼머신에서 기본적으로 관리가 되기때문에 닫아주지 않아도 됨. 오류는 무시할 것.오버플로우 : 표현할 수 있는 범위를 넘어섰다.최대값 + 1 = 최소값최소값 - 1 = 최대값10진수 :9999→0000 (칸이 4칸이라서)부호없는 정수 : ex) 4bit (표현범위0~15)15(최대값) + 1 → 0(최소값)2진수 : 1111→0000부호있는 정수 : ex) 4bit (표현범위-8~7)7(최대값)+1 → -8(최소값)부호 없는 정수 : 부호 +나-가 존재하지 않는 숫자 세계를 나타냄.(0이하의 음수를 표현x)부호 있는 정수 : 양수타입간의 변환 방법 - 외우지는 못해도 필요할때 찾아볼 수 있는 정도는 돼야함  문자 → 숫자 = 3 - ’0’  숫자 → 문자 = 3 + ’0’  문자→ 문자열 = ‘3’ + “”  문자열 → 문자 = “3”.charAt(0)  숫자 → 문자열 = 3 + ””  문자열 → 숫자  = Integer.parseInt(”3”)  = Double.parseDouble(”3.4”)\timport java.util.*;\t\tpublic class ScanfEx1 {\t\t\tpublic static void main(String[] args) {\t\t\tString str = \"3\";\t\t\tSystem.out.println(str.charAt(0)); //문자열 -&gt; 문자\t\t\tSystem.out.println('3' - '0' + 1); //문자-&gt;숫자\t\t\tSystem.out.println(Integer.parseInt(\"3\")+1); //문자열 -&gt; 숫자\t\t\tSystem.out.println(\"3\"+1); //문자열+숫자 =&gt; 31\t\t\tSystem.out.println(3+'0'); //문자 0은 숫자로 48 =&gt; 51\t\t\tSystem.out.println((char)(3+'0')); // 문자 '3' 출력\t\t}\t}printf사용시 %#x는 접두사 0x가 붙음"
  },
  
  {
    "title": "자바의 정석 강의 - 자바 시작하기 전",
    "url": "/posts/%EC%9E%90%EB%B0%94-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84/",
    "categories": "JAVA",
    "tags": "java, 자바의정석",
    "date": "2022-07-28 21:27:00 +0900",
    





    
    "snippet": "  자바 : 프로그래밍 언어. 컴퓨터 프로그램(애플리케이션)을 만드는데 사용  실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)                  라이브러리 : 프로그램을 만드는데 필요한 기능들을 미리 만들어놓은 것.        ⇒ 쉽고 빠른 개발 가능            pc애플리케이션, 웹 애플리케이션, 모바일 애플리케이...",
    "content": "  자바 : 프로그래밍 언어. 컴퓨터 프로그램(애플리케이션)을 만드는데 사용  실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)                  라이브러리 : 프로그램을 만드는데 필요한 기능들을 미리 만들어놓은 것.        ⇒ 쉽고 빠른 개발 가능            pc애플리케이션, 웹 애플리케이션, 모바일 애플리케이션(안드로이드), 빅 데이터, 게임(ex.마크), 과학, 소형기기 등 에 활용 가능      모던 프로그래밍 언어(객체지향 + 함수형)      특징                  배우기쉬운 객체지향언어(프로그래밍언어+객체지향개념[c++,java,python])          자동 메모리 관리          멀티 쓰레드 지원 - 하나의 프로그램에서 동시에 여러작업 가능.          풍부한 라이브러리로 쉽게 개발가능.          운영체제에 독립적 - 수정없이 여러 운영체제에서 사용가능                          자바 가상 머신(JVM) : 자바 프로그램이 실행되는 가상 컴퓨터(VM). 한번 작성하면, 어디서든(어떤 운영체제에서도) 실행 가능.                                            java API문서 : java API가 제공하는 기능에 대한 상세한 정보를 제공(html)  https://docs.oracle.com/javase/7/docs/api/index.html      단축키          ctrl + shift + L : 단축키 전체 목록      alt + shift + A : 멀티컬럼 편집 - 커서가 +모양으로 바뀌는데 바꾸고 싶은 부분을 드래그해서 한번에 바꿈      ctrl + i : 자동들여쓰기      ctrl + shift + o : import java.util.~; 자동추가      "
  }
  
]

