

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>히히</title>
  <subtitle>-</subtitle>
  <updated>2024-09-08T21:36:45+09:00</updated>
  <author>
    <name>jinny</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="ko-KR"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <rights> © 2024 jinny </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>[국비교육학원-수업내용정리] 스프링 시큐리티</title>
    <link href="http://localhost:4000/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/" rel="alternate" type="text/html" title="[국비교육학원-수업내용정리] 스프링 시큐리티" />
    <published>2023-02-24T00:00:00+09:00</published>
  
    <updated>2023-02-27T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/</id>
    <content src="http://localhost:4000/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>로그아웃은 프론트일임!!!!

마찬가지로 sns로그인은 프론트일임

세션, 모델을 사용할거면 안쓰는게 맞음

토큰은 임의로 만료불가

로그아웃은 프론트에서 브라우저 메모리에서 삭제

아니면 백에서 레디스 이용



찾아보면 테이블을 분리하는경우가 많은데 회원 권한이 하나라면 하나로 통합해도됨



이거임

plugins {
	id &amp;#39;java&amp;#39;
	id &amp;#39;war&amp;#39;
	id &amp;#39;org.springframework.boot&amp;#39; version &amp;#39;3.0.2&amp;#39;
	id &amp;#39;io.spring.dependency-management&amp;#39; version &amp;#39;1.1.0&amp;#39;
}

group = &amp;#39;com.example&amp;#39;
version = &amp;#39;0.0.1-SNAPSHOT&amp;#39;
sourceCompatibility = &amp;#39;17&amp;#39;

configuration...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 기본편] 스프링 컨테이너와 빈</title>
    <link href="http://localhost:4000/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80_%EB%B9%88/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 기본편] 스프링 컨테이너와 빈" />
    <published>2023-01-29T00:00:00+09:00</published>
  
    <updated>2023-01-29T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80_%EB%B9%88/</id>
    <content src="http://localhost:4000/posts/%EC%8A%A4%ED%94%84%EB%A7%81_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80_%EB%B9%88/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>스프링 컨테이너 생성

ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Appconfig.class);

ApplicationContext(인터페이스임)를 스프링 컨테이너라고 부름 - 정확히는 BeanFactory, ApplicationContext로 구분해서 부르는데 BeanFactory를 사용하는 경우가 거의 없음

XML기반이나 어노테이션 기반의 자바 설정 클래스로 만들 수 있음. 직전 강의에서 사용한 AppConfig가 어노테이션기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것.

new AnnotationConfigApplicationContext(Appconfig.class); 이게 Applica...</summary>

  </entry>

  
  <entry>
    <title>[국비교육학원-수업내용정리] JSP</title>
    <link href="http://localhost:4000/posts/jsp/" rel="alternate" type="text/html" title="[국비교육학원-수업내용정리] JSP" />
    <published>2023-01-04T00:00:00+09:00</published>
  
    <updated>2023-01-17T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/jsp/</id>
    <content src="http://localhost:4000/posts/jsp/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>jar : java application runtime

war : web archive runtime

프로젝트 생성시 빼먹은 패키지가있다면 메이븐에서 추가해도됨


  [!info]

  https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper/10.1.4


이거 추가. 버전에 숫자말고 다른게있으면 테스트버전임 jasper가 jsp view resolver임

server.port=80으로하면 localhost로 들어가도 접속됨. 포트기본번호라서. 원격배포할때 80으로 내보냄

dependencies {
	implementation &amp;#39;org.springframework.boot:spring-boot-starter-...</summary>

  </entry>

  
  <entry>
    <title>[김영한 자바 ORM 표준 JPA] 쿼리언어 - 중급 문법</title>
    <link href="http://localhost:4000/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EC%A4%91%EA%B8%89-%EB%AC%B8%EB%B2%95/" rel="alternate" type="text/html" title="[김영한 자바 ORM 표준 JPA] 쿼리언어 - 중급 문법" />
    <published>2022-12-31T00:00:00+09:00</published>
  
    <updated>2023-09-03T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EC%A4%91%EA%B8%89-%EB%AC%B8%EB%B2%95/</id>
    <content src="http://localhost:4000/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EC%A4%91%EA%B8%89-%EB%AC%B8%EB%B2%95/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="JPA" />
    
  

  <summary>경로 표현식

.(점)을 찍어서 객체 그래프를 탐색함


  [!important]
select m.username -&amp;amp;gt; 상태 필드from Member mjoin m.team t -&amp;amp;gt; 단일 값 연관 필드(엔티티로 넘어감. ManyToOne or OneToOne)join m.orders o -&amp;amp;gt; 컬렉션 값 연관 필드(양방향 관계. 컬렉션으로 넘어감)where t.name = ‘팀A’



  상태 필드(state field): 단순히 값을 저장하기 위한 필드(ex: m.username). 경로 탐색의 끝(.찍어서 어디 못간다는 소리). 탐색x
  
    연관 필드(association field): 연관관계를 위한 필드

    
      단일 값 연관 필드 : @ManyToOne, ...</summary>

  </entry>

  
  <entry>
    <title>[김영한 자바 ORM 표준 JPA] 쿼리언어 기본문법</title>
    <link href="http://localhost:4000/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/" rel="alternate" type="text/html" title="[김영한 자바 ORM 표준 JPA] 쿼리언어 기본문법" />
    <published>2022-12-31T00:00:00+09:00</published>
  
    <updated>2023-09-03T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/</id>
    <content src="http://localhost:4000/posts/%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4_%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="JPA" />
    
  

  <summary>JPAFactoryQuery query = new JPAQueryFactory(em);
QMember m = QMember.member;

JPA를 사용하면 엔티티 객체를 중심으로 개발을 함. 문제는 검색쿼리. 검색을 할때도 테이블이 아닌 객체를 대상으로 검색을 함. 모든 DB데이터를 객체로 변환해서 검색을 하는 것은 불가능함
에플리케이션이 필요한 데이터만 DB에 불러오려면 결국 검색조건이 포함된 SQL이 필요함.

JPQL(Java Persistence Query Language)

가장 단순한 조회 방법 - entityManager.find(), 객체 그래프 탐색(a.getB().getC())

JPA는 SQL을 추상화 한 JPQL이라는 객체 지향 쿼리 언어를 제공함

SQL과 문법이 유사함. se...</summary>

  </entry>

</feed>


