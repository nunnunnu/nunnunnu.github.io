

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>히히</title>
  <subtitle>-</subtitle>
  <updated>2024-09-10T11:42:22+09:00</updated>
  <author>
    <name>jinny</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="ko-KR"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <rights> © 2024 jinny </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 프록시 기술과 한계</title>
    <link href="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EA%B8%B0%EC%88%A0%EA%B3%BC%ED%95%9C%EA%B3%84/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 프록시 기술과 한계" />
    <published>2024-03-02T00:00:00+09:00</published>
  
    <updated>2024-03-02T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EA%B8%B0%EC%88%A0%EA%B3%BC%ED%95%9C%EA%B3%84/</id>
    <content src="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EA%B8%B0%EC%88%A0%EA%B3%BC%ED%95%9C%EA%B3%84/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>JDK 동적 프록시의 한계


  
    타입캐스팅

    인터페이스 기반으로 프록시를 생성하기때문에 구체클래스로 타입캐스팅이 불가능하다는 한계가 있음

      package hello.aop.proxys;
    
  import org.junit.jupiter.api.Assertions;
  import org.junit.jupiter.api.Test;
  import org.springframework.aop.framework.ProxyFactory;
    
  import hello.aop.member.MemberService;
  import hello.aop.member.MemberServiceImpl;
  import lombok.extern.slf4j.Slf4j;
    
  @...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 프록시 내부 호출</title>
    <link href="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EB%82%B4%EB%B6%80%ED%98%B8%EC%B6%9C/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 프록시 내부 호출" />
    <published>2024-02-26T00:00:00+09:00</published>
  
    <updated>2024-03-02T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EB%82%B4%EB%B6%80%ED%98%B8%EC%B6%9C/</id>
    <content src="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C%EB%82%B4%EB%B6%80%ED%98%B8%EC%B6%9C/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>문제

package hello.aop.internalcall;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
 
@Slf4j
@Component
public class CallServiceV0 {
    public void external() {
        log.info(&amp;quot;call external&amp;quot;);

        internal(); //내부 메소드 호출(this.internal())
    }

    public void internal() {
        log.info(&amp;quot;call internal&amp;quot;);
    }
}



package hello.aop.internalcall.a...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 포인트 컷 지시자</title>
    <link href="http://localhost:4000/posts/%ED%8F%AC%EC%9D%B8%ED%8A%B8%EC%BB%B7%EC%A7%80%EC%8B%9C%EC%9E%90/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 포인트 컷 지시자" />
    <published>2024-02-25T00:00:00+09:00</published>
  
    <updated>2024-02-25T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%ED%8F%AC%EC%9D%B8%ED%8A%B8%EC%BB%B7%EC%A7%80%EC%8B%9C%EC%9E%90/</id>
    <content src="http://localhost:4000/posts/%ED%8F%AC%EC%9D%B8%ED%8A%B8%EC%BB%B7%EC%A7%80%EC%8B%9C%EC%9E%90/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>에스팩트J가 제공하는 포인트컷 표현식(pointcut expression)을 포인트컷 표현식이라고 부른다.

포인트컷 표현식은 execution같은 포인트컷 지시자(pointcut Designator)로 시작 해 PCD라 부른다


  포인트컷 지시자(pointcut Designator)
    
      execution : 메소드 실행 조인 포인트 매칭, 스프링 AOP에서 가장 많이 사용하고 기능도 복잡
      within : 특정 타입내 조인포인트를 매칭
      args : 인자가 주어진 타입의 인스턴스인 조인포인트
      this : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인포인트)
      target : Target객체(스프링AOP가 가르키는 실제대상)를 대상...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 프록시- 프록시 패턴, 데코레이터 패턴</title>
    <link href="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4,-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 프록시- 프록시 패턴, 데코레이터 패턴" />
    <published>2024-02-17T00:00:00+09:00</published>
  
    <updated>2024-02-17T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4,-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</id>
    <content src="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4,-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>구조1. 인터페이스 + 구현클래스 - 수동등록

      package com.example.proxy.app.v1;
    
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  import org.springframework.web.bind.annotation.ResponseBody;
    
  @RequestMapping //@Controller or RequestMapping 이 있어야 스프링 컨트롤러로 인식...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 프록시 팩토리(스프링이 지원하는 프록시)</title>
    <link href="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A9%ED%86%A0%EB%A6%AC/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 프록시 팩토리(스프링이 지원하는 프록시)" />
    <published>2024-02-17T00:00:00+09:00</published>
  
    <updated>2024-02-17T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A9%ED%86%A0%EB%A6%AC/</id>
    <content src="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A9%ED%86%A0%EB%A6%AC/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>JDK 동적프록시와 CGLIB를 동적으로 사용하려면(인터페이스가있는경우에는 JDK동적프록시, 아니면 CGLIB를 사용) 스프링이 제공하는 프록시 팩토리를 사용해야함



사용할때 InvocationHandler(JDK 동적프록시가 제공), MethodInterceptor(CGLIB가 제공)을 각각 중복으로 만들지않고 Advice를 사용하면된다.

Advice는 InvocationHandler와 MethodInterceptor를 신경쓰지않기위해 스프링이 만들어 낸 개념임

결과적으로 InvocationHandler와 MethodInterceptor는 Advice를 호출하게됨. 프록시 팩토리가 Advice를 호출하는 전용 InvocationHandler와 MethodInterceptor를 내부에서 사용함
...</summary>

  </entry>

</feed>


