

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>히히</title>
  <subtitle>-</subtitle>
  <updated>2024-09-09T15:44:01+09:00</updated>
  <author>
    <name>jinny</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="ko-KR"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <rights> © 2024 jinny </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 프록시- 프록시 패턴, 데코레이터 패턴</title>
    <link href="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4,-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 프록시- 프록시 패턴, 데코레이터 패턴" />
    <published>2024-02-17T00:00:00+09:00</published>
  
    <updated>2024-02-17T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4,-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</id>
    <content src="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4,-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>구조1. 인터페이스 + 구현클래스 - 수동등록

      package com.example.proxy.app.v1;
    
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  import org.springframework.web.bind.annotation.ResponseBody;
    
  @RequestMapping //@Controller or RequestMapping 이 있어야 스프링 컨트롤러로 인식...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 프록시 팩토리(스프링이 지원하는 프록시)</title>
    <link href="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A9%ED%86%A0%EB%A6%AC/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 프록시 팩토리(스프링이 지원하는 프록시)" />
    <published>2024-02-17T00:00:00+09:00</published>
  
    <updated>2024-02-17T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A9%ED%86%A0%EB%A6%AC/</id>
    <content src="http://localhost:4000/posts/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A9%ED%86%A0%EB%A6%AC/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>JDK 동적프록시와 CGLIB를 동적으로 사용하려면(인터페이스가있는경우에는 JDK동적프록시, 아니면 CGLIB를 사용) 스프링이 제공하는 프록시 팩토리를 사용해야함



사용할때 InvocationHandler(JDK 동적프록시가 제공), MethodInterceptor(CGLIB가 제공)을 각각 중복으로 만들지않고 Advice를 사용하면된다.

Advice는 InvocationHandler와 MethodInterceptor를 신경쓰지않기위해 스프링이 만들어 낸 개념임

결과적으로 InvocationHandler와 MethodInterceptor는 Advice를 호출하게됨. 프록시 팩토리가 Advice를 호출하는 전용 InvocationHandler와 MethodInterceptor를 내부에서 사용함
...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 동적 프록시</title>
    <link href="http://localhost:4000/posts/%EB%8F%99%EC%A0%81%ED%94%84%EB%A1%9D%EC%8B%9C/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 동적 프록시" />
    <published>2024-02-17T00:00:00+09:00</published>
  
    <updated>2024-03-02T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EB%8F%99%EC%A0%81%ED%94%84%EB%A1%9D%EC%8B%9C/</id>
    <content src="http://localhost:4000/posts/%EB%8F%99%EC%A0%81%ED%94%84%EB%A1%9D%EC%8B%9C/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>프록시를 적용하여 프록시패턴, 데코레이터패턴을 적용해보니 클래스가 너무 많이생긴다는 단점이있었음

게다가 많은 프록시 클래스들의 코드는 거의 중복코드였음

자바가 기본으로 제공하는 JDK 동적프록시 기술이나 CGLIB같은 프록시 생성 오픈기술을 활용하면 프록시 객체를 동적으로 만들 수 있음
JDK 동적 프록시
구조
    package com.example.proxy.jdkdynamic;
    
    import lombok.extern.slf4j.Slf4j;
    import org.junit.jupiter.api.Test;
    
    import java.lang.reflect.InvocationTargetException;
    import java.lang.reflect.Method...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 디자인 패턴 - template call back</title>
    <link href="http://localhost:4000/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_template_call_back/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 디자인 패턴 - template call back" />
    <published>2024-01-07T00:00:00+09:00</published>
  
    <updated>2024-01-07T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_template_call_back/</id>
    <content src="http://localhost:4000/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_template_call_back/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>-전략패턴에서 구현한

package com.hello.high.trace.strategy.code;

import com.hello.high.trace.strategy.code.strategy.Strategy;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ContextV2 {
	public void execute(Strategy strategy) {
		long startTime = System.currentTimeMillis();
		//비지니스로직 실행
		strategy.call(); //위임
		long endTime = System.currentTimeMillis();
		long resultTime = endTime - startTim...</summary>

  </entry>

  
  <entry>
    <title>[김영한 스프링 핵심원리 - 고급] 디자인 패턴 - templateMethod</title>
    <link href="http://localhost:4000/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_templateMethod/" rel="alternate" type="text/html" title="[김영한 스프링 핵심원리 - 고급] 디자인 패턴 - templateMethod" />
    <published>2024-01-01T00:00:00+09:00</published>
  
    <updated>2024-01-01T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_templateMethod/</id>
    <content src="http://localhost:4000/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4_templateMethod/" />
    <author>
      <name>jinny</name>
    </author>

  
    
    <category term="Spring" />
    
  

  <summary>그전 강의 챕터에서 비지니스로직을 구현할때마다 로그를 찍을때

@GetMapping(&amp;quot;/v2/request&amp;quot;)
	public String request(String itemId) {
		TraceStatus status = null;
		try {
			 status = trace.begin(&amp;quot;OrderController.requset()&amp;quot;);
			orderService.orderItem(status.getTraceId(), itemId);
			trace.end(status);
			return &amp;quot;ok&amp;quot;;
		} catch (Exception e) {
			trace.exception(status, e);
			throw e; //예외를 꼭 다시 던져줘야함
		}
	}


위처럼 중복 코드를 작성해...</summary>

  </entry>

</feed>


